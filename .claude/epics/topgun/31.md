---
name: Implement WebSocket broadcasting for real-time dashboard updates
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:49Z
github: https://github.com/johnproblems/topgun/issues/141
depends_on: [25]
parallel: true
conflicts_with: []
---

# Task: Implement WebSocket broadcasting for real-time dashboard updates

## Description

Implement a comprehensive WebSocket broadcasting system using Laravel Reverb to deliver real-time resource monitoring updates to Vue.js dashboard components. This system transforms static resource dashboards into dynamic, live-updating interfaces that instantly reflect server health, capacity changes, and deployment events without requiring manual page refreshes.

**The Real-Time Problem:**

Traditional monitoring dashboards rely on client-side polling—sending HTTP requests every few seconds to check for updates. This approach has critical drawbacks:

1. **Network Overhead**: Thousands of polling requests per hour waste bandwidth and server resources
2. **Delayed Updates**: 5-10 second polling intervals mean users see stale data up to 10 seconds old
3. **Battery Drain**: Mobile devices exhaust battery running constant background timers
4. **Scalability Issues**: 100 concurrent users × 12 polls/minute = 1,200 req/min just for dashboard updates
5. **Race Conditions**: Multiple tabs polling simultaneously create inconsistent UI states

**The WebSocket Solution:**

WebSockets establish persistent, bidirectional connections between client and server, enabling the server to push updates to clients immediately when events occur. This architecture delivers:

- **Instant Updates**: Metrics appear on dashboards within 100ms of collection
- **Zero Polling**: Clients passively listen for events, eliminating wasteful requests
- **Scalability**: Single Redis pub/sub message broadcasts to unlimited concurrent users
- **Consistent State**: All connected clients receive identical updates simultaneously
- **Efficient Protocol**: Binary WebSocket frames reduce network traffic by 60-80% vs. HTTP polling

**Laravel Reverb Architecture:**

Laravel Reverb is a first-party WebSocket server built specifically for Laravel applications. It provides:

- **Native Laravel Integration**: Broadcasting events automatically translates to WebSocket messages
- **Redis Pub/Sub**: Horizontal scaling across multiple Reverb instances
- **Channel Authentication**: Laravel's native authentication protects private channels
- **Presence Channels**: Track which users are viewing dashboards in real-time
- **Automatic Reconnection**: Client libraries handle connection failures transparently

**Implementation Scope:**

This task implements the complete broadcasting infrastructure:

1. **Server-Side Broadcasting**: Jobs and services dispatch events to Redis pub/sub
2. **Channel Authorization**: Private channels scoped to organization membership
3. **Event Payload Design**: Optimized JSON payloads for metrics, deployments, capacity
4. **Client-Side Listeners**: Vue.js composables for subscribing to WebSocket channels
5. **Connection Management**: Automatic reconnection, error handling, offline detection
6. **Performance Optimization**: Event batching, delta updates, compression

**Integration Points:**

**Data Sources (Event Publishers):**
- **Task 24 (ResourceMonitoringJob)**: Publishes server metrics every 30 seconds
- **Task 25 (SystemResourceMonitor)**: Broadcasts capacity threshold warnings
- **Task 26 (CapacityManager)**: Announces server scoring updates
- **Task 18 (TerraformDeploymentJob)**: Streams infrastructure provisioning status
- **Existing ApplicationDeploymentJob**: Sends deployment progress updates

**Data Consumers (Event Subscribers):**
- **Task 29 (ResourceDashboard.vue)**: Real-time server metrics charts
- **Task 30 (CapacityPlanner.vue)**: Live server capacity visualization
- **Task 21 (DeploymentMonitoring.vue)**: Terraform provisioning progress
- **Existing Livewire Components**: Server status updates, deployment logs

**Why This Task is Critical:**

Real-time updates are the difference between a professional monitoring dashboard and a frustrating, outdated interface. Users managing production infrastructure need instant visibility into system health—delayed metrics can mean missed deployment failures, undetected resource exhaustion, or slow incident response. WebSocket broadcasting ensures administrators see critical events the moment they occur, enabling proactive management instead of reactive firefighting.

This infrastructure also enables future features like collaborative editing (seeing other admins' changes live), notification systems (toasts for deployment completions), and audit logs (real-time activity feeds). The investment in WebSocket infrastructure pays dividends across the entire enterprise platform.

## Acceptance Criteria

- [ ] Laravel Reverb configured and running on dedicated port (default: 8080)
- [ ] Broadcasting configuration uses Redis driver for pub/sub
- [ ] Private channels implemented with organization-scoped authorization
- [ ] Presence channels implemented for tracking active dashboard viewers
- [ ] Server metric broadcast events created (CPU, memory, disk, network)
- [ ] Deployment status broadcast events created (Terraform, application deployments)
- [ ] Capacity change broadcast events created (server scoring updates)
- [ ] Laravel Echo client configured in Vue.js application
- [ ] Vue.js composables created for channel subscription management
- [ ] Automatic reconnection logic implemented with exponential backoff
- [ ] Connection status indicators in UI (online, offline, reconnecting)
- [ ] Event batching implemented to reduce message frequency
- [ ] Delta updates implemented (only changed metrics sent, not full snapshots)
- [ ] Integration tests written for all broadcast events
- [ ] Browser tests written for real-time UI updates
- [ ] Performance tested: 100 concurrent connections with < 50ms latency
- [ ] Memory leak tests: no leaks after 1000+ message broadcasts

## Technical Details

### File Paths

**Reverb Configuration:**
- `/home/topgun/topgun/config/reverb.php` (new - if not exists, use broadcasting.php)
- `/home/topgun/topgun/config/broadcasting.php` (existing - configure reverb driver)

**Broadcast Events:**
- `/home/topgun/topgun/app/Events/Enterprise/ResourceMetricsUpdated.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/ServerCapacityChanged.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/DeploymentStatusUpdated.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/OrganizationQuotaExceeded.php` (new)

**Channel Authorization:**
- `/home/topgun/topgun/routes/channels.php` (existing - add organization-scoped channels)

**Frontend:**
- `/home/topgun/topgun/resources/js/echo.js` (new - Laravel Echo configuration)
- `/home/topgun/topgun/resources/js/composables/useWebSocket.js` (new)
- `/home/topgun/topgun/resources/js/composables/useResourceMetrics.js` (new)
- `/home/topgun/topgun/resources/js/composables/useDeploymentStatus.js` (new)

**Environment:**
- `/home/topgun/topgun/.env` (modify - add Reverb configuration)

### Broadcasting Configuration

**File:** `config/broadcasting.php`

```php
<?php

return [
    'default' => env('BROADCAST_DRIVER', 'reverb'),

    'connections' => [
        'reverb' => [
            'driver' => 'reverb',
            'key' => env('REVERB_APP_KEY'),
            'secret' => env('REVERB_APP_SECRET'),
            'app_id' => env('REVERB_APP_ID'),
            'options' => [
                'host' => env('REVERB_HOST', '0.0.0.0'),
                'port' => env('REVERB_PORT', 8080),
                'scheme' => env('REVERB_SCHEME', 'http'),
                'useTLS' => env('REVERB_SCHEME', 'http') === 'https',
            ],
            'client_options' => [
                // Guzzle client options for API calls
            ],
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => 'default',
        ],

        // Log driver for testing without Reverb running
        'log' => [
            'driver' => 'log',
        ],

        'null' => [
            'driver' => 'null',
        ],
    ],
];
```

**Environment Variables:**

```bash
# .env additions
BROADCAST_DRIVER=reverb

REVERB_APP_ID=your-app-id
REVERB_APP_KEY=your-app-key
REVERB_APP_SECRET=your-app-secret
REVERB_HOST=0.0.0.0
REVERB_PORT=8080
REVERB_SCHEME=http

# For production with SSL
# REVERB_SCHEME=https
# REVERB_PORT=443
```

### Broadcast Event: Resource Metrics

**File:** `app/Events/Enterprise/ResourceMetricsUpdated.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Organization;
use App\Models\Server;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

/**
 * Broadcast real-time server resource metrics to organization dashboards
 *
 * Dispatched by: ResourceMonitoringJob (Task 24)
 * Consumed by: ResourceDashboard.vue (Task 29)
 */
class ResourceMetricsUpdated implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public string $queue = 'broadcasting';

    /**
     * Create a new event instance
     *
     * @param Organization $organization
     * @param Server $server
     * @param array $metrics Current metrics snapshot
     * @param array|null $previousMetrics Previous metrics for delta calculation
     */
    public function __construct(
        public Organization $organization,
        public Server $server,
        public array $metrics,
        public ?array $previousMetrics = null
    ) {
    }

    /**
     * Get the channels the event should broadcast on
     *
     * @return Channel
     */
    public function broadcastOn(): Channel
    {
        // Private channel scoped to organization
        return new Channel("organization.{$this->organization->id}.servers.{$this->server->id}.metrics");
    }

    /**
     * Get the data to broadcast
     *
     * Optimized payload: only send changed metrics (delta updates)
     *
     * @return array
     */
    public function broadcastWith(): array
    {
        // Calculate delta if previous metrics available
        if ($this->previousMetrics) {
            $changed = [];

            foreach ($this->metrics as $key => $value) {
                if (!isset($this->previousMetrics[$key]) || $this->previousMetrics[$key] !== $value) {
                    $changed[$key] = $value;
                }
            }

            // If no changes, don't broadcast (save bandwidth)
            if (empty($changed)) {
                return [];
            }

            return [
                'server_id' => $this->server->id,
                'server_name' => $this->server->name,
                'metrics' => $changed, // Only changed metrics
                'timestamp' => now()->toIso8601String(),
                'delta' => true,
            ];
        }

        // Full snapshot if no previous metrics
        return [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'metrics' => $this->metrics,
            'timestamp' => now()->toIso8601String(),
            'delta' => false,
        ];
    }

    /**
     * Determine if this event should broadcast
     *
     * Skip broadcasting if no meaningful changes
     *
     * @return bool
     */
    public function broadcastWhen(): bool
    {
        // Don't broadcast if delta is empty
        if ($this->previousMetrics && empty($this->broadcastWith())) {
            return false;
        }

        return true;
    }

    /**
     * Get the name for the broadcast event
     *
     * @return string
     */
    public function broadcastAs(): string
    {
        return 'metrics.updated';
    }
}
```

### Broadcast Event: Server Capacity Changed

**File:** `app/Events/Enterprise/ServerCapacityChanged.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Organization;
use App\Models\Server;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

/**
 * Broadcast server capacity scoring updates
 *
 * Dispatched by: CapacityManager (Task 26)
 * Consumed by: CapacityPlanner.vue (Task 30)
 */
class ServerCapacityChanged implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public string $queue = 'broadcasting';

    public function __construct(
        public Organization $organization,
        public Server $server,
        public float $capacityScore,
        public float $previousScore,
        public array $capacityBreakdown
    ) {
    }

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->organization->id}.capacity");
    }

    public function broadcastWith(): array
    {
        return [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'capacity_score' => round($this->capacityScore, 2),
            'previous_score' => round($this->previousScore, 2),
            'score_change' => round($this->capacityScore - $this->previousScore, 2),
            'breakdown' => $this->capacityBreakdown,
            'timestamp' => now()->toIso8601String(),
        ];
    }

    public function broadcastAs(): string
    {
        return 'capacity.changed';
    }

    /**
     * Only broadcast if score changed significantly (> 5%)
     */
    public function broadcastWhen(): bool
    {
        $percentageChange = abs(($this->capacityScore - $this->previousScore) / $this->previousScore * 100);

        return $percentageChange > 5;
    }
}
```

### Broadcast Event: Deployment Status

**File:** `app/Events/Enterprise/DeploymentStatusUpdated.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Organization;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

/**
 * Broadcast deployment progress updates (Terraform, application deployments)
 *
 * Dispatched by: TerraformDeploymentJob (Task 18), ApplicationDeploymentJob
 * Consumed by: DeploymentMonitoring.vue (Task 21)
 */
class DeploymentStatusUpdated implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public string $queue = 'broadcasting';

    public function __construct(
        public Organization $organization,
        public string $deploymentId,
        public string $deploymentType, // 'terraform', 'application', 'database'
        public string $status, // 'pending', 'running', 'completed', 'failed'
        public int $progress, // 0-100
        public ?string $currentStep = null,
        public ?string $message = null,
        public ?array $metadata = null
    ) {
    }

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->organization->id}.deployments.{$this->deploymentId}");
    }

    public function broadcastWith(): array
    {
        return [
            'deployment_id' => $this->deploymentId,
            'deployment_type' => $this->deploymentType,
            'status' => $this->status,
            'progress' => $this->progress,
            'current_step' => $this->currentStep,
            'message' => $this->message,
            'metadata' => $this->metadata,
            'timestamp' => now()->toIso8601String(),
        ];
    }

    public function broadcastAs(): string
    {
        return 'deployment.status';
    }
}
```

### Channel Authorization

**File:** `routes/channels.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use Illuminate\Support\Facades\Broadcast;

/*
|--------------------------------------------------------------------------
| Broadcast Channels
|--------------------------------------------------------------------------
|
| Organization-scoped channels for real-time updates
|
*/

/**
 * Organization server metrics channel
 *
 * Authorization: User must be member of organization
 */
Broadcast::channel('organization.{organizationId}.servers.{serverId}.metrics', function ($user, $organizationId, $serverId) {
    $organization = Organization::find($organizationId);

    if (!$organization) {
        return false;
    }

    // Check user is member of organization
    if (!$user->organizations->contains($organization)) {
        return false;
    }

    // Verify server belongs to organization
    $server = Server::find($serverId);

    if (!$server || $server->team_id !== $organization->id) {
        return false;
    }

    return [
        'id' => $user->id,
        'name' => $user->name,
        'email' => $user->email,
    ];
});

/**
 * Organization capacity channel
 */
Broadcast::channel('organization.{organizationId}.capacity', function ($user, $organizationId) {
    $organization = Organization::find($organizationId);

    if (!$organization || !$user->organizations->contains($organization)) {
        return false;
    }

    return [
        'id' => $user->id,
        'name' => $user->name,
    ];
});

/**
 * Deployment status channel
 */
Broadcast::channel('organization.{organizationId}.deployments.{deploymentId}', function ($user, $organizationId, $deploymentId) {
    $organization = Organization::find($organizationId);

    if (!$organization || !$user->organizations->contains($organization)) {
        return false;
    }

    // Additional authorization: verify deployment belongs to organization
    // Implementation depends on deployment model structure

    return [
        'id' => $user->id,
        'name' => $user->name,
    ];
});

/**
 * Organization-wide events channel (quota exceeded, system notifications)
 */
Broadcast::channel('organization.{organizationId}.notifications', function ($user, $organizationId) {
    $organization = Organization::find($organizationId);

    if (!$organization || !$user->organizations->contains($organization)) {
        return false;
    }

    return [
        'id' => $user->id,
        'name' => $user->name,
        'role' => $user->pivot->role ?? 'member',
    ];
});

/**
 * Presence channel: Show who's viewing the dashboard
 */
Broadcast::channel('organization.{organizationId}.dashboard', function ($user, $organizationId) {
    $organization = Organization::find($organizationId);

    if (!$organization || !$user->organizations->contains($organization)) {
        return false;
    }

    return [
        'id' => $user->id,
        'name' => $user->name,
        'avatar' => $user->avatar_url ?? null,
        'role' => $user->pivot->role ?? 'member',
    ];
});
```

### Frontend: Laravel Echo Configuration

**File:** `resources/js/echo.js`

```javascript
import Echo from 'laravel-echo'
import Pusher from 'pusher-js'

window.Pusher = Pusher

/**
 * Configure Laravel Echo for WebSocket broadcasting
 *
 * Uses Reverb driver for real-time communication
 */
window.Echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST || window.location.hostname,
    wsPort: import.meta.env.VITE_REVERB_PORT || 8080,
    wssPort: import.meta.env.VITE_REVERB_PORT || 8080,
    forceTLS: (import.meta.env.VITE_REVERB_SCHEME || 'http') === 'https',
    enabledTransports: ['ws', 'wss'],

    // Authentication for private channels
    authEndpoint: '/broadcasting/auth',
    auth: {
        headers: {
            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.content,
            'Accept': 'application/json',
        },
    },

    // Connection options
    enableStats: false,
    enableLogging: import.meta.env.DEV,
})

/**
 * Connection event handlers
 */
window.Echo.connector.pusher.connection.bind('connected', () => {
    console.log('[Echo] Connected to WebSocket server')
})

window.Echo.connector.pusher.connection.bind('disconnected', () => {
    console.log('[Echo] Disconnected from WebSocket server')
})

window.Echo.connector.pusher.connection.bind('error', (error) => {
    console.error('[Echo] Connection error:', error)
})

window.Echo.connector.pusher.connection.bind('unavailable', () => {
    console.warn('[Echo] WebSocket server unavailable, will retry...')
})

export default window.Echo
```

### Frontend: WebSocket Composable

**File:** `resources/js/composables/useWebSocket.js`

```javascript
import { ref, onMounted, onUnmounted } from 'vue'
import Echo from '@/echo'

/**
 * Vue composable for WebSocket connection management
 *
 * Provides reactive connection status and automatic cleanup
 */
export function useWebSocket() {
    const isConnected = ref(false)
    const isConnecting = ref(false)
    const error = ref(null)

    const updateConnectionStatus = () => {
        const state = Echo.connector.pusher.connection.state

        isConnected.value = state === 'connected'
        isConnecting.value = state === 'connecting' || state === 'unavailable'
    }

    onMounted(() => {
        // Bind connection state listeners
        Echo.connector.pusher.connection.bind('state_change', updateConnectionStatus)

        // Initial state
        updateConnectionStatus()
    })

    onUnmounted(() => {
        // Cleanup listeners
        Echo.connector.pusher.connection.unbind('state_change', updateConnectionStatus)
    })

    /**
     * Manually disconnect from WebSocket server
     */
    const disconnect = () => {
        Echo.disconnect()
    }

    /**
     * Manually reconnect to WebSocket server
     */
    const reconnect = () => {
        Echo.connector.pusher.connect()
    }

    return {
        isConnected,
        isConnecting,
        error,
        disconnect,
        reconnect,
    }
}
```

### Frontend: Resource Metrics Composable

**File:** `resources/js/composables/useResourceMetrics.js`

```javascript
import { ref, onMounted, onUnmounted } from 'vue'
import Echo from '@/echo'

/**
 * Vue composable for subscribing to real-time resource metrics
 *
 * Usage:
 *   const { metrics, isListening } = useResourceMetrics(organizationId, serverId)
 */
export function useResourceMetrics(organizationId, serverId) {
    const metrics = ref({
        cpu_usage: 0,
        memory_usage: 0,
        disk_usage: 0,
        network_rx: 0,
        network_tx: 0,
    })

    const isListening = ref(false)
    const lastUpdate = ref(null)

    let channel = null

    const startListening = () => {
        if (!organizationId || !serverId) {
            console.warn('[useResourceMetrics] Missing organizationId or serverId')
            return
        }

        const channelName = `organization.${organizationId}.servers.${serverId}.metrics`

        channel = Echo.private(channelName)
            .listen('.metrics.updated', (event) => {
                console.log('[useResourceMetrics] Received metrics update:', event)

                // Handle delta updates
                if (event.delta) {
                    // Merge changed metrics with existing
                    metrics.value = {
                        ...metrics.value,
                        ...event.metrics,
                    }
                } else {
                    // Full snapshot
                    metrics.value = event.metrics
                }

                lastUpdate.value = event.timestamp
            })
            .error((error) => {
                console.error('[useResourceMetrics] Channel error:', error)
            })

        isListening.value = true
        console.log(`[useResourceMetrics] Listening on ${channelName}`)
    }

    const stopListening = () => {
        if (channel) {
            Echo.leave(`organization.${organizationId}.servers.${serverId}.metrics`)
            channel = null
            isListening.value = false
            console.log('[useResourceMetrics] Stopped listening')
        }
    }

    onMounted(() => {
        startListening()
    })

    onUnmounted(() => {
        stopListening()
    })

    return {
        metrics,
        isListening,
        lastUpdate,
        startListening,
        stopListening,
    }
}
```

### Frontend: Deployment Status Composable

**File:** `resources/js/composables/useDeploymentStatus.js`

```javascript
import { ref, onMounted, onUnmounted } from 'vue'
import Echo from '@/echo'

/**
 * Vue composable for real-time deployment status updates
 */
export function useDeploymentStatus(organizationId, deploymentId) {
    const status = ref('pending')
    const progress = ref(0)
    const currentStep = ref(null)
    const message = ref(null)
    const metadata = ref({})
    const isListening = ref(false)

    let channel = null

    const startListening = () => {
        if (!organizationId || !deploymentId) {
            console.warn('[useDeploymentStatus] Missing organizationId or deploymentId')
            return
        }

        const channelName = `organization.${organizationId}.deployments.${deploymentId}`

        channel = Echo.private(channelName)
            .listen('.deployment.status', (event) => {
                console.log('[useDeploymentStatus] Status update:', event)

                status.value = event.status
                progress.value = event.progress
                currentStep.value = event.current_step
                message.value = event.message
                metadata.value = event.metadata || {}
            })

        isListening.value = true
        console.log(`[useDeploymentStatus] Listening on ${channelName}`)
    }

    const stopListening = () => {
        if (channel) {
            Echo.leave(`organization.${organizationId}.deployments.${deploymentId}`)
            channel = null
            isListening.value = false
        }
    }

    onMounted(() => {
        startListening()
    })

    onUnmounted(() => {
        stopListening()
    })

    return {
        status,
        progress,
        currentStep,
        message,
        metadata,
        isListening,
        startListening,
        stopListening,
    }
}
```

### Integration: Dispatching Events from Jobs

**Example:** `app/Jobs/Enterprise/ResourceMonitoringJob.php` (Task 24)

```php
use App\Events\Enterprise\ResourceMetricsUpdated;

public function handle(SystemResourceMonitor $monitor): void
{
    $servers = Server::where('organization_id', $this->organizationId)->get();

    foreach ($servers as $server) {
        // Collect current metrics
        $currentMetrics = $monitor->collectServerMetrics($server);

        // Get previous metrics from cache
        $previousMetrics = Cache::get("metrics:{$server->id}:previous");

        // Store metrics in database
        $monitor->storeMetrics($server, $currentMetrics);

        // Broadcast to WebSocket
        broadcast(new ResourceMetricsUpdated(
            organization: $server->organization,
            server: $server,
            metrics: $currentMetrics,
            previousMetrics: $previousMetrics
        ))->toOthers();

        // Update cache with current metrics for next delta
        Cache::put("metrics:{$server->id}:previous", $currentMetrics, 300);
    }
}
```

### Vue.js Component Integration Example

**File:** `resources/js/Components/Enterprise/Monitoring/ResourceDashboard.vue` (Task 29)

```vue
<script setup>
import { computed } from 'vue'
import { useResourceMetrics } from '@/composables/useResourceMetrics'
import { useWebSocket } from '@/composables/useWebSocket'

const props = defineProps({
    organizationId: Number,
    serverId: Number,
})

// WebSocket connection status
const { isConnected, isConnecting } = useWebSocket()

// Real-time metrics
const { metrics, lastUpdate } = useResourceMetrics(props.organizationId, props.serverId)

// Format metrics for display
const cpuUsage = computed(() => metrics.value.cpu_usage?.toFixed(1) || 0)
const memoryUsage = computed(() => metrics.value.memory_usage?.toFixed(1) || 0)
const diskUsage = computed(() => metrics.value.disk_usage?.toFixed(1) || 0)
</script>

<template>
  <div class="resource-dashboard">
    <!-- Connection Status Indicator -->
    <div class="connection-status">
      <span v-if="isConnected" class="status-indicator online">
        <span class="pulse"></span>
        Live
      </span>
      <span v-else-if="isConnecting" class="status-indicator connecting">
        Connecting...
      </span>
      <span v-else class="status-indicator offline">
        Offline
      </span>
    </div>

    <!-- Metrics Display -->
    <div class="metrics-grid">
      <div class="metric-card">
        <h3>CPU Usage</h3>
        <p class="metric-value">{{ cpuUsage }}%</p>
        <div class="metric-bar" :style="{ width: `${cpuUsage}%` }"></div>
      </div>

      <div class="metric-card">
        <h3>Memory Usage</h3>
        <p class="metric-value">{{ memoryUsage }}%</p>
        <div class="metric-bar" :style="{ width: `${memoryUsage}%` }"></div>
      </div>

      <div class="metric-card">
        <h3>Disk Usage</h3>
        <p class="metric-value">{{ diskUsage }}%</p>
        <div class="metric-bar" :style="{ width: `${diskUsage}%` }"></div>
      </div>
    </div>

    <!-- Last Update Timestamp -->
    <p v-if="lastUpdate" class="last-update">
      Last update: {{ new Date(lastUpdate).toLocaleTimeString() }}
    </p>
  </div>
</template>

<style scoped>
.connection-status {
    position: absolute;
    top: 1rem;
    right: 1rem;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
    font-weight: 500;
}

.status-indicator.online {
    color: #10b981;
}

.status-indicator.connecting {
    color: #f59e0b;
}

.status-indicator.offline {
    color: #ef4444;
}

.pulse {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: currentColor;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 2rem;
}

.metric-card {
    padding: 1rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
}

.metric-value {
    font-size: 2rem;
    font-weight: 700;
    margin: 0.5rem 0;
}

.metric-bar {
    height: 8px;
    background-color: #3b82f6;
    border-radius: 4px;
    transition: width 0.3s ease;
}

.last-update {
    margin-top: 1rem;
    font-size: 0.875rem;
    color: #6b7280;
}
</style>
```

## Implementation Approach

### Step 1: Install and Configure Laravel Reverb

1. Install Reverb package:
   ```bash
   composer require laravel/reverb
   php artisan reverb:install
   ```

2. Configure `.env` with Reverb credentials:
   ```bash
   BROADCAST_DRIVER=reverb
   REVERB_APP_ID=...
   REVERB_APP_KEY=...
   REVERB_APP_SECRET=...
   ```

3. Start Reverb server:
   ```bash
   php artisan reverb:start
   ```

### Step 2: Create Broadcast Events

1. Create `ResourceMetricsUpdated` event with delta update logic
2. Create `ServerCapacityChanged` event with threshold filtering
3. Create `DeploymentStatusUpdated` event for progress tracking
4. Implement `broadcastWith()` for optimized payloads
5. Implement `broadcastWhen()` to prevent unnecessary broadcasts

### Step 3: Configure Channel Authorization

1. Add organization-scoped channel authorization in `routes/channels.php`
2. Verify user membership before authorizing channel access
3. Implement presence channels for dashboard viewer tracking
4. Test authorization with different user roles

### Step 4: Frontend Setup

1. Install Laravel Echo and Pusher JS:
   ```bash
   npm install --save laravel-echo pusher-js
   ```

2. Create `resources/js/echo.js` with Reverb configuration
3. Import Echo in main application entry point
4. Test connection in browser console

### Step 5: Create Vue Composables

1. Create `useWebSocket.js` for connection status management
2. Create `useResourceMetrics.js` for server metric subscriptions
3. Create `useDeploymentStatus.js` for deployment tracking
4. Implement automatic cleanup in `onUnmounted` hooks

### Step 6: Integrate with Existing Jobs

1. Modify `ResourceMonitoringJob` to dispatch `ResourceMetricsUpdated`
2. Modify `CapacityManager` to dispatch `ServerCapacityChanged`
3. Modify `TerraformDeploymentJob` to dispatch `DeploymentStatusUpdated`
4. Add delta update logic using cached previous metrics

### Step 7: Update Vue Components

1. Integrate composables into `ResourceDashboard.vue`
2. Add connection status indicators
3. Add real-time metric updates with animations
4. Add deployment progress bars with WebSocket updates

### Step 8: Performance Optimization

1. Implement event batching for high-frequency updates
2. Add delta update logic to reduce payload sizes
3. Configure Redis pub/sub for horizontal scaling
4. Add compression for large event payloads

### Step 9: Testing

1. Unit test broadcast events with payload structure validation
2. Integration test channel authorization
3. Browser test real-time UI updates
4. Load test with 100+ concurrent connections

### Step 10: Production Deployment

1. Configure Reverb behind reverse proxy (Nginx, Caddy)
2. Enable SSL/TLS for secure WebSocket connections
3. Set up process manager (Supervisor) for Reverb
4. Configure monitoring and alerting for WebSocket health

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Events/ResourceMetricsUpdatedTest.php`

```php
<?php

use App\Events\Enterprise\ResourceMetricsUpdated;
use App\Models\Organization;
use App\Models\Server;

it('broadcasts on correct channel', function () {
    $organization = Organization::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);

    $event = new ResourceMetricsUpdated(
        organization: $organization,
        server: $server,
        metrics: ['cpu_usage' => 50.5],
    );

    $channel = $event->broadcastOn();

    expect($channel->name)->toBe("organization.{$organization->id}.servers.{$server->id}.metrics");
});

it('broadcasts delta updates when previous metrics provided', function () {
    $organization = Organization::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);

    $event = new ResourceMetricsUpdated(
        organization: $organization,
        server: $server,
        metrics: ['cpu_usage' => 60, 'memory_usage' => 70],
        previousMetrics: ['cpu_usage' => 50, 'memory_usage' => 70],
    );

    $data = $event->broadcastWith();

    expect($data['delta'])->toBeTrue();
    expect($data['metrics'])->toHaveKey('cpu_usage');
    expect($data['metrics'])->not->toHaveKey('memory_usage'); // Unchanged
});

it('does not broadcast when no metrics changed', function () {
    $organization = Organization::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);

    $metrics = ['cpu_usage' => 50, 'memory_usage' => 70];

    $event = new ResourceMetricsUpdated(
        organization: $organization,
        server: $server,
        metrics: $metrics,
        previousMetrics: $metrics,
    );

    expect($event->broadcastWhen())->toBeFalse();
});
```

### Integration Tests

**File:** `tests/Feature/Broadcasting/ChannelAuthorizationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use App\Models\User;
use Illuminate\Support\Facades\Broadcast;

it('authorizes user for organization server metrics channel', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);

    $organization->users()->attach($user, ['role' => 'admin']);

    $result = Broadcast::channel(
        "organization.{$organization->id}.servers.{$server->id}.metrics",
        $user
    );

    expect($result)->not->toBeFalse();
    expect($result['id'])->toBe($user->id);
});

it('denies user for different organization channel', function () {
    $organization1 = Organization::factory()->create();
    $organization2 = Organization::factory()->create();
    $user = User::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization1->id]);

    $organization2->users()->attach($user, ['role' => 'admin']);

    $result = Broadcast::channel(
        "organization.{$organization1->id}.servers.{$server->id}.metrics",
        $user
    );

    expect($result)->toBeFalse();
});
```

### Browser Tests

**File:** `tests/Browser/RealTimeMetricsTest.php`

```php
<?php

use App\Events\Enterprise\ResourceMetricsUpdated;
use App\Models\Organization;
use App\Models\Server;
use App\Models\User;
use Laravel\Dusk\Browser;

it('displays real-time metric updates', function () {
    $organization = Organization::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);
    $user = User::factory()->create();

    $organization->users()->attach($user, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($user, $organization, $server) {
        $browser->loginAs($user)
            ->visit("/organizations/{$organization->id}/dashboard")
            ->waitFor('.resource-dashboard')
            ->assertSee('0%'); // Initial CPU usage

        // Broadcast metric update
        broadcast(new ResourceMetricsUpdated(
            organization: $organization,
            server: $server,
            metrics: ['cpu_usage' => 75.5],
        ));

        // Wait for WebSocket update
        $browser->waitUntilMissing('.status-indicator.connecting')
            ->waitForText('75.5%')
            ->assertSee('Live');
    });
});
```

### Performance Tests

**File:** `tests/Performance/WebSocketLoadTest.php`

```php
<?php

it('handles 100 concurrent WebSocket connections', function () {
    $organization = Organization::factory()->create();
    $server = Server::factory()->create(['team_id' => $organization->id]);

    $startTime = microtime(true);

    // Simulate 100 concurrent clients
    $promises = [];

    for ($i = 0; $i < 100; $i++) {
        $promises[] = async(function () use ($organization, $server) {
            broadcast(new ResourceMetricsUpdated(
                organization: $organization,
                server: $server,
                metrics: ['cpu_usage' => rand(0, 100)],
            ));
        });
    }

    await($promises);

    $duration = (microtime(true) - $startTime) * 1000;

    expect($duration)->toBeLessThan(100); // < 100ms for 100 broadcasts
});
```

## Definition of Done

- [ ] Laravel Reverb installed and configured
- [ ] Broadcasting driver set to 'reverb' in config
- [ ] ResourceMetricsUpdated event created with delta updates
- [ ] ServerCapacityChanged event created with threshold filtering
- [ ] DeploymentStatusUpdated event created
- [ ] OrganizationQuotaExceeded event created
- [ ] Channel authorization implemented for all channels
- [ ] Presence channel implemented for dashboard viewers
- [ ] Laravel Echo configured in frontend
- [ ] useWebSocket composable created
- [ ] useResourceMetrics composable created
- [ ] useDeploymentStatus composable created
- [ ] ResourceMonitoringJob dispatches broadcast events
- [ ] CapacityManager dispatches capacity change events
- [ ] TerraformDeploymentJob dispatches deployment events
- [ ] ResourceDashboard.vue integrates WebSocket updates
- [ ] CapacityPlanner.vue integrates capacity updates
- [ ] DeploymentMonitoring.vue integrates deployment updates
- [ ] Connection status indicators added to UI
- [ ] Automatic reconnection logic implemented
- [ ] Delta updates implemented (only changed metrics sent)
- [ ] Event batching implemented for high-frequency updates
- [ ] Unit tests written (10+ tests, >90% coverage)
- [ ] Integration tests written (channel authorization)
- [ ] Browser tests written (real-time UI updates)
- [ ] Performance tests written (100+ concurrent connections)
- [ ] Load tested: < 50ms latency for 100 concurrent users
- [ ] Memory leak tested: no leaks after 1000+ broadcasts
- [ ] Documentation updated with WebSocket architecture
- [ ] Reverb configured behind reverse proxy for production
- [ ] SSL/TLS enabled for secure WebSocket connections
- [ ] Process manager configured (Supervisor)
- [ ] Monitoring and alerting configured
- [ ] Code follows Laravel broadcasting best practices
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 25 (SystemResourceMonitor - provides metrics to broadcast)
- **Integrates with:** Task 24 (ResourceMonitoringJob - dispatches metric events)
- **Integrates with:** Task 26 (CapacityManager - dispatches capacity events)
- **Integrates with:** Task 18 (TerraformDeploymentJob - dispatches deployment events)
- **Used by:** Task 29 (ResourceDashboard.vue - consumes metric broadcasts)
- **Used by:** Task 30 (CapacityPlanner.vue - consumes capacity broadcasts)
- **Used by:** Task 21 (DeploymentMonitoring.vue - consumes deployment broadcasts)
