---
name: Create database schema for server_resource_metrics and organization_resource_usage tables
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:41Z
github: https://github.com/johnproblems/topgun/issues/132
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Create database schema for server_resource_metrics and organization_resource_usage tables

## Description
Design and implement time-series optimized database tables for storing high-frequency server resource metrics (30-second intervals) and organization-level resource quota tracking. This foundation enables real-time monitoring, capacity planning, and intelligent server selection for deployments.

## Technical Approach

### Time-Series Table Design Principles
- **High Write Throughput**: Expect ~2 writes/minute per server (every 30 seconds)
- **Efficient Historical Queries**: Support dashboards querying last 24h, 7d, 30d of data
- **Data Retention**: 90 days detailed + 1 year aggregated (implement cleanup job)
- **Partitioning Strategy**: Partition by month for efficient data pruning

### Database Schema

#### 1. `server_resource_metrics` Table (Time-Series)

```php
Schema::create('server_resource_metrics', function (Blueprint $table) {
    $table->id();
    $table->foreignId('server_id')->constrained()->cascadeOnDelete();

    // CPU metrics (percentage values 0-100)
    $table->decimal('cpu_usage_percent', 5, 2); // Total CPU usage
    $table->decimal('cpu_load_1min', 8, 2);     // 1-min load average
    $table->decimal('cpu_load_5min', 8, 2);     // 5-min load average
    $table->decimal('cpu_load_15min', 8, 2);    // 15-min load average
    $table->smallInteger('cpu_cores')->default(1); // Available cores

    // Memory metrics (bytes)
    $table->unsignedBigInteger('memory_total_bytes');
    $table->unsignedBigInteger('memory_used_bytes');
    $table->unsignedBigInteger('memory_available_bytes');
    $table->decimal('memory_usage_percent', 5, 2);

    // Disk metrics (bytes)
    $table->unsignedBigInteger('disk_total_bytes');
    $table->unsignedBigInteger('disk_used_bytes');
    $table->unsignedBigInteger('disk_available_bytes');
    $table->decimal('disk_usage_percent', 5, 2);
    $table->unsignedBigInteger('disk_read_bytes')->nullable();  // Delta since last reading
    $table->unsignedBigInteger('disk_write_bytes')->nullable(); // Delta since last reading

    // Network metrics (bytes - deltas)
    $table->unsignedBigInteger('network_rx_bytes')->nullable(); // Received since last reading
    $table->unsignedBigInteger('network_tx_bytes')->nullable(); // Transmitted since last reading

    // Container statistics
    $table->unsignedInteger('running_containers')->default(0);
    $table->unsignedInteger('total_containers')->default(0);

    // Metadata
    $table->timestamp('collected_at')->index(); // When metric was collected
    $table->timestamps();

    // Indexes for time-series queries
    $table->index(['server_id', 'collected_at']); // Primary query pattern
    $table->index('collected_at'); // For data retention cleanup
});

// Add comment for PostgreSQL
DB::statement("COMMENT ON TABLE server_resource_metrics IS 'Time-series metrics collected every 30 seconds per server'");
```

**Indexing Strategy:**
- Composite index `(server_id, collected_at)` for per-server time-range queries
- Single index `collected_at` for global cleanup operations
- Consider BRIN index for `collected_at` column in PostgreSQL (reduces index size)

**Partitioning (PostgreSQL 15):**
```sql
-- Enable partitioning by month for efficient pruning
CREATE TABLE server_resource_metrics_template (LIKE server_resource_metrics INCLUDING ALL);
ALTER TABLE server_resource_metrics_template ADD CONSTRAINT partition_check
    CHECK (collected_at >= DATE '2025-01-01' AND collected_at < DATE '2025-02-01');
```

#### 2. `organization_resource_usage` Table

```php
Schema::create('organization_resource_usage', function (Blueprint $table) {
    $table->id();
    $table->foreignId('organization_id')->constrained()->cascadeOnDelete();

    // Current resource usage (updated in real-time)
    $table->unsignedInteger('servers_count')->default(0);
    $table->unsignedInteger('applications_count')->default(0);
    $table->unsignedInteger('databases_count')->default(0);
    $table->unsignedInteger('deployments_this_month')->default(0);

    // Aggregated capacity across all organization servers
    $table->unsignedBigInteger('total_memory_bytes')->default(0);
    $table->unsignedBigInteger('used_memory_bytes')->default(0);
    $table->unsignedBigInteger('total_disk_bytes')->default(0);
    $table->unsignedBigInteger('used_disk_bytes')->default(0);
    $table->unsignedInteger('total_cpu_cores')->default(0);

    // Quota limits (from enterprise_licenses.resource_limits JSON)
    $table->unsignedInteger('max_servers')->nullable();
    $table->unsignedInteger('max_applications')->nullable();
    $table->unsignedInteger('max_databases')->nullable();
    $table->unsignedInteger('max_deployments_per_month')->nullable();

    // Billing period tracking
    $table->date('current_period_start');
    $table->date('current_period_end');

    // Metadata
    $table->timestamp('last_calculated_at')->nullable(); // When aggregation was last computed
    $table->timestamps();

    // Unique constraint - one row per organization
    $table->unique('organization_id');

    // Indexes
    $table->index('last_calculated_at'); // For background job to find stale records
});

DB::statement("COMMENT ON TABLE organization_resource_usage IS 'Aggregated resource usage and quota tracking per organization'");
```

#### 3. Supporting Migration: Add `server_id` to `servers` Table (if not exists)

```php
// Extend servers table with enterprise fields
Schema::table('servers', function (Blueprint $table) {
    // Link to organization hierarchy
    $table->foreignId('organization_id')->nullable()->after('team_id')->constrained()->nullOnDelete();

    // Current snapshot (for quick access without querying metrics table)
    $table->decimal('current_cpu_usage', 5, 2)->nullable();
    $table->decimal('current_memory_usage', 5, 2)->nullable();
    $table->decimal('current_disk_usage', 5, 2)->nullable();
    $table->timestamp('last_metrics_at')->nullable();

    // Capacity score (computed by CapacityManager)
    $table->decimal('capacity_score', 5, 2)->default(0)->comment('0-100 score, higher = more available');
    $table->timestamp('capacity_score_updated_at')->nullable();

    $table->index('organization_id');
    $table->index('capacity_score'); // For finding optimal servers
});
```

### Data Aggregation Strategy

**Raw Metrics Retention:**
- Keep 90 days of 30-second interval data (~259,200 records per server)
- Use background job to aggregate older data into hourly/daily summaries

**Aggregation Tables (Future Enhancement):**
```php
// server_resource_metrics_hourly (1 year retention)
// server_resource_metrics_daily (5 year retention)
```

### Redis Caching Strategy

**Cache Keys:**
```php
// Latest metrics for dashboard (60 second TTL)
"server:{server_id}:metrics:latest"

// Organization aggregates (5 minute TTL)
"organization:{org_id}:usage:current"

// Historical data (1 hour TTL with tag-based invalidation)
"server:{server_id}:metrics:24h"
"server:{server_id}:metrics:7d"
```

## Implementation Steps

### Step 1: Create Migrations
```bash
php artisan make:migration create_server_resource_metrics_table
php artisan make:migration create_organization_resource_usage_table
php artisan make:migration add_enterprise_fields_to_servers_table
```

### Step 2: Implement Model Classes

**ServerResourceMetric.php:**
```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class ServerResourceMetric extends Model
{
    protected $fillable = [
        'server_id', 'cpu_usage_percent', 'cpu_load_1min', 'cpu_load_5min',
        'cpu_load_15min', 'cpu_cores', 'memory_total_bytes', 'memory_used_bytes',
        'memory_available_bytes', 'memory_usage_percent', 'disk_total_bytes',
        'disk_used_bytes', 'disk_available_bytes', 'disk_usage_percent',
        'disk_read_bytes', 'disk_write_bytes', 'network_rx_bytes',
        'network_tx_bytes', 'running_containers', 'total_containers', 'collected_at'
    ];

    protected function casts(): array
    {
        return [
            'collected_at' => 'datetime',
            'cpu_usage_percent' => 'decimal:2',
            'memory_usage_percent' => 'decimal:2',
            'disk_usage_percent' => 'decimal:2',
        ];
    }

    public function server(): BelongsTo
    {
        return $this->belongsTo(Server::class);
    }

    // Scopes for time-range queries
    public function scopeLastHours($query, int $hours = 24)
    {
        return $query->where('collected_at', '>=', now()->subHours($hours));
    }

    public function scopeLastDays($query, int $days = 7)
    {
        return $query->where('collected_at', '>=', now()->subDays($days));
    }
}
```

**OrganizationResourceUsage.php:**
```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class OrganizationResourceUsage extends Model
{
    protected $fillable = [
        'organization_id', 'servers_count', 'applications_count',
        'databases_count', 'deployments_this_month', 'total_memory_bytes',
        'used_memory_bytes', 'total_disk_bytes', 'used_disk_bytes',
        'total_cpu_cores', 'max_servers', 'max_applications',
        'max_databases', 'max_deployments_per_month',
        'current_period_start', 'current_period_end', 'last_calculated_at'
    ];

    protected function casts(): array
    {
        return [
            'current_period_start' => 'date',
            'current_period_end' => 'date',
            'last_calculated_at' => 'datetime',
        ];
    }

    public function organization(): BelongsTo
    {
        return $this->belongsTo(Organization::class);
    }

    // Check if quota exceeded
    public function isServerQuotaExceeded(): bool
    {
        return $this->max_servers && $this->servers_count >= $this->max_servers;
    }

    public function isDeploymentQuotaExceeded(): bool
    {
        return $this->max_deployments_per_month &&
               $this->deployments_this_month >= $this->max_deployments_per_month;
    }

    public function getRemainingServerQuota(): ?int
    {
        return $this->max_servers ? max(0, $this->max_servers - $this->servers_count) : null;
    }
}
```

### Step 3: Database Seeder

```php
namespace Database\Seeders;

use App\Models\Organization;
use App\Models\OrganizationResourceUsage;
use Illuminate\Database\Seeder;

class OrganizationResourceUsageSeeder extends Seeder
{
    public function run(): void
    {
        Organization::all()->each(function ($org) {
            OrganizationResourceUsage::create([
                'organization_id' => $org->id,
                'current_period_start' => now()->startOfMonth(),
                'current_period_end' => now()->endOfMonth(),
                'max_servers' => $org->license?->resource_limits['max_servers'] ?? null,
                'max_applications' => $org->license?->resource_limits['max_applications'] ?? null,
                'max_databases' => $org->license?->resource_limits['max_databases'] ?? null,
                'max_deployments_per_month' => $org->license?->resource_limits['max_deployments_per_month'] ?? null,
            ]);
        });
    }
}
```

### Step 4: Data Retention Job

```php
namespace App\Jobs;

use App\Models\ServerResourceMetric;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class CleanupOldMetricsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function handle(): void
    {
        $retentionDays = config('monitoring.metrics_retention_days', 90);

        ServerResourceMetric::where('collected_at', '<', now()->subDays($retentionDays))
            ->chunkById(1000, function ($metrics) {
                $metrics->each->delete();
            });
    }
}

// Schedule in app/Console/Kernel.php:
$schedule->job(new CleanupOldMetricsJob)->daily()->at('02:00');
```

## Acceptance Criteria
- [ ] Migration files create tables with correct schema
- [ ] Indexes optimize time-series queries (server_id, collected_at composite)
- [ ] Models include relationships and helper methods
- [ ] Seeder initializes organization_resource_usage for existing organizations
- [ ] Data retention job configured for 90-day cleanup
- [ ] PostgreSQL partitioning documented for production optimization
- [ ] Redis caching strategy documented
- [ ] Migration rollback works correctly

## Testing Strategy

### Unit Tests
```php
// tests/Unit/Models/ServerResourceMetricTest.php
it('casts metric values correctly', function () {
    $metric = ServerResourceMetric::factory()->create([
        'cpu_usage_percent' => 75.456,
        'collected_at' => '2025-10-06 12:00:00',
    ]);

    expect($metric->cpu_usage_percent)->toBe(75.46);
    expect($metric->collected_at)->toBeInstanceOf(Carbon::class);
});

it('filters last 24 hours correctly', function () {
    ServerResourceMetric::factory()->create(['collected_at' => now()->subHours(25)]);
    ServerResourceMetric::factory()->create(['collected_at' => now()->subHours(12)]);

    $recent = ServerResourceMetric::lastHours(24)->get();
    expect($recent)->toHaveCount(1);
});

// tests/Unit/Models/OrganizationResourceUsageTest.php
it('detects quota exceeded', function () {
    $usage = OrganizationResourceUsage::factory()->create([
        'servers_count' => 10,
        'max_servers' => 10,
    ]);

    expect($usage->isServerQuotaExceeded())->toBeTrue();
});

it('calculates remaining quota', function () {
    $usage = OrganizationResourceUsage::factory()->create([
        'servers_count' => 7,
        'max_servers' => 10,
    ]);

    expect($usage->getRemainingServerQuota())->toBe(3);
});
```

### Feature Tests
```php
// tests/Feature/Metrics/MetricStorageTest.php
it('stores server metrics with correct indexes', function () {
    $server = Server::factory()->create();

    ServerResourceMetric::create([
        'server_id' => $server->id,
        'cpu_usage_percent' => 45.5,
        'memory_usage_percent' => 60.2,
        'disk_usage_percent' => 30.1,
        'collected_at' => now(),
        // ... other fields
    ]);

    $this->assertDatabaseHas('server_resource_metrics', [
        'server_id' => $server->id,
    ]);
});

it('enforces unique organization_resource_usage per organization', function () {
    $org = Organization::factory()->create();

    OrganizationResourceUsage::factory()->create(['organization_id' => $org->id]);

    expect(fn() => OrganizationResourceUsage::factory()->create(['organization_id' => $org->id]))
        ->toThrow(\Illuminate\Database\QueryException::class);
});
```

### Performance Tests
```php
// tests/Performance/MetricQueryPerformanceTest.php
it('queries 24h metrics efficiently', function () {
    $server = Server::factory()->create();
    ServerResourceMetric::factory()->count(2880)->create(['server_id' => $server->id]); // 2 days

    $start = microtime(true);
    $metrics = ServerResourceMetric::where('server_id', $server->id)
        ->lastHours(24)
        ->get();
    $duration = microtime(true) - $start;

    expect($metrics)->toHaveCount(2880);
    expect($duration)->toBeLessThan(0.5); // Should complete in < 500ms
});
```

## Technical Details
- Size: M
- Estimated hours: 8-12
- PostgreSQL 15 time-series optimization
- BRIN indexing for efficient time-range queries
- Monthly partitioning for data retention

## Dependencies
- [ ] PostgreSQL 15+ with partitioning support
- [ ] Redis for metric caching
- [ ] Organizations and EnterpriseLicense models (already exist)

## Database Performance Considerations

### Query Patterns to Optimize
1. **Dashboard queries**: Last 24h metrics for specific server
2. **Capacity planning**: Current usage across all organization servers
3. **Historical analysis**: Aggregate metrics over 7d/30d
4. **Cleanup operations**: Delete metrics older than retention period

### Expected Data Volume
- **Per server**: 2 writes/minute Ã— 1440 min/day = 2,880 rows/day
- **100 servers**: 288,000 rows/day, 25.9M rows/90 days
- **With proper indexing**: Queries remain <100ms even at scale

## Configuration File

```php
// config/monitoring.php
return [
    'metrics_collection_interval' => env('METRICS_COLLECTION_INTERVAL', 30), // seconds
    'metrics_retention_days' => env('METRICS_RETENTION_DAYS', 90),
    'cache_ttl' => [
        'latest_metrics' => 60, // 1 minute
        'historical_24h' => 300, // 5 minutes
        'historical_7d' => 3600, // 1 hour
        'organization_usage' => 300, // 5 minutes
    ],
];
```

## Definition of Done
- [ ] Migrations create all required tables with indexes
- [ ] Models implement relationships and helper methods
- [ ] Unit tests cover model logic (quota checks, scopes)
- [ ] Feature tests verify database constraints
- [ ] Performance tests validate query speed
- [ ] Seeder populates organization_resource_usage
- [ ] Cleanup job scheduled in Kernel.php
- [ ] Configuration file created
- [ ] Database comments added for documentation
- [ ] Code passes PHPStan level 5
- [ ] Code formatted with Laravel Pint
