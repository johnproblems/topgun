---
name: Implement DnsManagementService for automated DNS records
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:20Z
github: https://github.com/johnproblems/topgun/issues/175
depends_on: [66]
parallel: false
conflicts_with: []
---

# Task: Implement DnsManagementService for automated DNS records

## Description

Implement a comprehensive DNS management service that provides programmatic control over DNS records across multiple DNS providers (Cloudflare, Route53, DigitalOcean DNS). This service abstracts the complexity of different DNS provider APIs behind a unified interface, enabling automated DNS record creation, updates, and deletion for application deployments, domain management, and infrastructure provisioning.

The DnsManagementService is a critical component of the enterprise platform's domain management system, enabling automated DNS configuration without manual intervention. When applications are deployed, servers are provisioned, or domains are configured, the platform needs to automatically create corresponding DNS records (A records for IPv4, AAAA for IPv6, CNAME for aliases, MX for email routing, TXT for verification).

**Core Functionality:**

1. **Multi-Provider Support**: Unified interface for Cloudflare, AWS Route53, DigitalOcean DNS
2. **Record Type Management**: Create, read, update, delete A, AAAA, CNAME, MX, TXT, SRV records
3. **Validation**: DNS record format validation before submission to providers
4. **Error Handling**: Provider-specific error translation to consistent error messages
5. **Rate Limiting**: Respect provider API rate limits with backoff and retry
6. **Zone Management**: Automatic zone lookup and selection based on domain
7. **Record Synchronization**: Track DNS records in database for audit and management
8. **Propagation Verification**: Check DNS propagation status after record creation

**Integration Architecture:**

**Depends On:**
- **Task 66 (DomainRegistrarService)**: Domain registration provides domain ownership context
- **Task 62 (Database Schema)**: `dns_records` table stores record state and metadata

**Used By:**
- **Task 70 (Domain Management UI)**: DnsRecordEditor.vue calls this service for CRUD operations
- **Task 19 (Server Auto-Registration)**: Creates A records when servers are provisioned
- **Task 68 (SSL Provisioning)**: Creates TXT records for Let's Encrypt DNS challenges
- **Application Deployment**: Automatically creates records when custom domains are configured

**Real-World Use Cases:**

1. **Application Domain Setup**: User adds `app.example.com` to application → Service creates A record pointing to server IP
2. **Email Configuration**: Organization configures email → Service creates MX, SPF, DKIM TXT records
3. **SSL Verification**: Let's Encrypt DNS challenge → Service creates `_acme-challenge.example.com` TXT record
4. **Subdomain Delegation**: White-label organization gets `customer.platform.com` → Service creates CNAME record
5. **Load Balancer Setup**: Multiple servers for one domain → Service creates A records for all IPs or single CNAME to LB

**Why This Task is Critical:**

Manual DNS management is error-prone and time-consuming. Enterprise deployments require dozens or hundreds of DNS records across multiple domains. Automating DNS record management eliminates human error, reduces deployment time from hours to seconds, and enables self-service infrastructure management. Without this service, every application deployment or server provisioning would require manual DNS configuration, creating bottlenecks and deployment delays.

The service also provides a single point of control for DNS operations, enabling audit logging, permission enforcement, and consistent error handling regardless of which DNS provider manages the domain.

## Acceptance Criteria

- [ ] DnsManagementService implements DnsManagementServiceInterface with all required methods
- [ ] Multi-provider support: Cloudflare, AWS Route53, DigitalOcean DNS
- [ ] Record type support: A, AAAA, CNAME, MX, TXT, SRV records
- [ ] CRUD operations: createRecord(), updateRecord(), deleteRecord(), getRecord(), listRecords()
- [ ] Zone management: findZone(), getZoneId() methods
- [ ] Validation: validateRecord() checks format before submission
- [ ] Error handling with provider-specific error translation
- [ ] Rate limiting with exponential backoff and retry logic
- [ ] Database synchronization: DNS records tracked in `dns_records` table
- [ ] Provider credential management via encrypted configuration
- [ ] TTL configuration support (custom or provider default)
- [ ] Bulk operations: createMultipleRecords() for batch creation
- [ ] Record conflict detection (duplicate records)
- [ ] Propagation check: verifyPropagation() method
- [ ] Comprehensive logging for all DNS operations
- [ ] Unit tests for all public methods (>90% coverage)
- [ ] Integration tests with provider API mocking

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/DnsManagementService.php` (implementation)
- `/home/topgun/topgun/app/Contracts/DnsManagementServiceInterface.php` (interface)

**DNS Provider Implementations:**
- `/home/topgun/topgun/app/Services/Enterprise/DnsProviders/CloudflareDnsProvider.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/DnsProviders/Route53DnsProvider.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/DnsProviders/DigitalOceanDnsProvider.php` (new)
- `/home/topgun/topgun/app/Contracts/DnsProviderInterface.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/DnsRecord.php` (existing from Task 62)
- `/home/topgun/topgun/app/Models/OrganizationDomain.php` (existing from Task 62)

**Configuration:**
- `/home/topgun/topgun/config/dns.php` (new)

**Exceptions:**
- `/home/topgun/topgun/app/Exceptions/DnsException.php` (new)
- `/home/topgun/topgun/app/Exceptions/DnsRecordNotFoundException.php` (new)
- `/home/topgun/topgun/app/Exceptions/DnsZoneNotFoundException.php` (new)

### Service Interface

**File:** `app/Contracts/DnsManagementServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\DnsRecord;
use App\Models\OrganizationDomain;

interface DnsManagementServiceInterface
{
    /**
     * Create a new DNS record
     *
     * @param OrganizationDomain $domain
     * @param string $type Record type (A, AAAA, CNAME, MX, TXT, SRV)
     * @param string $name Record name (subdomain or @)
     * @param string $content Record content (IP address, target domain, text content)
     * @param int|null $ttl Time to live in seconds (null for provider default)
     * @param int|null $priority Priority for MX/SRV records
     * @param array $metadata Additional provider-specific metadata
     * @return DnsRecord
     * @throws \App\Exceptions\DnsException
     */
    public function createRecord(
        OrganizationDomain $domain,
        string $type,
        string $name,
        string $content,
        ?int $ttl = null,
        ?int $priority = null,
        array $metadata = []
    ): DnsRecord;

    /**
     * Update an existing DNS record
     *
     * @param DnsRecord $record
     * @param array $data Fields to update (content, ttl, priority, etc.)
     * @return DnsRecord
     * @throws \App\Exceptions\DnsException
     */
    public function updateRecord(DnsRecord $record, array $data): DnsRecord;

    /**
     * Delete a DNS record
     *
     * @param DnsRecord $record
     * @return bool
     * @throws \App\Exceptions\DnsException
     */
    public function deleteRecord(DnsRecord $record): bool;

    /**
     * Get a specific DNS record by ID
     *
     * @param int $recordId
     * @return DnsRecord
     * @throws \App\Exceptions\DnsRecordNotFoundException
     */
    public function getRecord(int $recordId): DnsRecord;

    /**
     * List all DNS records for a domain
     *
     * @param OrganizationDomain $domain
     * @param string|null $type Filter by record type
     * @return \Illuminate\Support\Collection<DnsRecord>
     */
    public function listRecords(OrganizationDomain $domain, ?string $type = null): \Illuminate\Support\Collection;

    /**
     * Create multiple DNS records in batch
     *
     * @param OrganizationDomain $domain
     * @param array $records Array of record definitions
     * @return \Illuminate\Support\Collection<DnsRecord>
     * @throws \App\Exceptions\DnsException
     */
    public function createMultipleRecords(OrganizationDomain $domain, array $records): \Illuminate\Support\Collection;

    /**
     * Validate DNS record before creation
     *
     * @param string $type
     * @param string $name
     * @param string $content
     * @return array Validation result with 'valid' boolean and 'errors' array
     */
    public function validateRecord(string $type, string $name, string $content): array;

    /**
     * Verify DNS record propagation
     *
     * @param DnsRecord $record
     * @param int $timeout Maximum seconds to wait
     * @return bool True if propagated successfully
     */
    public function verifyPropagation(DnsRecord $record, int $timeout = 120): bool;

    /**
     * Find DNS zone for a domain
     *
     * @param OrganizationDomain $domain
     * @return array Zone information including zone_id and name servers
     * @throws \App\Exceptions\DnsZoneNotFoundException
     */
    public function findZone(OrganizationDomain $domain): array;

    /**
     * Synchronize DNS records from provider to database
     *
     * @param OrganizationDomain $domain
     * @return int Number of records synchronized
     */
    public function syncRecordsFromProvider(OrganizationDomain $domain): int;
}
```

### DNS Provider Interface

**File:** `app/Contracts/DnsProviderInterface.php`

```php
<?php

namespace App\Contracts;

interface DnsProviderInterface
{
    /**
     * Create a DNS record at the provider
     *
     * @param string $zoneId Provider's zone identifier
     * @param array $recordData Record configuration
     * @return array Provider's response with record ID
     */
    public function createRecord(string $zoneId, array $recordData): array;

    /**
     * Update a DNS record at the provider
     *
     * @param string $zoneId Provider's zone identifier
     * @param string $recordId Provider's record identifier
     * @param array $recordData Updated configuration
     * @return array Provider's response
     */
    public function updateRecord(string $zoneId, string $recordId, array $recordData): array;

    /**
     * Delete a DNS record at the provider
     *
     * @param string $zoneId Provider's zone identifier
     * @param string $recordId Provider's record identifier
     * @return bool Success status
     */
    public function deleteRecord(string $zoneId, string $recordId): bool;

    /**
     * Get a specific record from the provider
     *
     * @param string $zoneId Provider's zone identifier
     * @param string $recordId Provider's record identifier
     * @return array Record data
     */
    public function getRecord(string $zoneId, string $recordId): array;

    /**
     * List all records for a zone
     *
     * @param string $zoneId Provider's zone identifier
     * @param string|null $type Filter by record type
     * @return array List of records
     */
    public function listRecords(string $zoneId, ?string $type = null): array;

    /**
     * Find zone by domain name
     *
     * @param string $domain Domain name (e.g., example.com)
     * @return array Zone information including zone_id, name_servers
     */
    public function findZone(string $domain): array;

    /**
     * Check if provider credentials are valid
     *
     * @return bool
     */
    public function testConnection(): bool;

    /**
     * Get provider-specific rate limit information
     *
     * @return array Rate limit details
     */
    public function getRateLimitStatus(): array;
}
```

### DnsManagementService Implementation

**File:** `app/Services/Enterprise/DnsManagementService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\DnsManagementServiceInterface;
use App\Contracts\DnsProviderInterface;
use App\Exceptions\DnsException;
use App\Exceptions\DnsRecordNotFoundException;
use App\Exceptions\DnsZoneNotFoundException;
use App\Models\DnsRecord;
use App\Models\OrganizationDomain;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class DnsManagementService implements DnsManagementServiceInterface
{
    private const SUPPORTED_RECORD_TYPES = ['A', 'AAAA', 'CNAME', 'MX', 'TXT', 'SRV'];
    private const DEFAULT_TTL = 3600; // 1 hour
    private const PROPAGATION_CHECK_INTERVAL = 5; // seconds

    /**
     * Create a new DNS record
     */
    public function createRecord(
        OrganizationDomain $domain,
        string $type,
        string $name,
        string $content,
        ?int $ttl = null,
        ?int $priority = null,
        array $metadata = []
    ): DnsRecord {
        Log::info('Creating DNS record', [
            'domain' => $domain->domain_name,
            'type' => $type,
            'name' => $name,
        ]);

        // Validate record
        $validation = $this->validateRecord($type, $name, $content);
        if (!$validation['valid']) {
            throw new DnsException('Invalid DNS record: ' . implode(', ', $validation['errors']));
        }

        // Check for duplicate records
        if ($this->isDuplicateRecord($domain, $type, $name, $content)) {
            throw new DnsException('Duplicate DNS record already exists');
        }

        // Get DNS provider for this domain
        $provider = $this->getProviderForDomain($domain);

        // Find zone
        $zone = $this->findZone($domain);

        try {
            // Prepare record data for provider
            $recordData = $this->prepareRecordData($type, $name, $content, $ttl, $priority, $metadata);

            // Create record at provider
            $providerResponse = $provider->createRecord($zone['zone_id'], $recordData);

            // Store in database
            $dnsRecord = DnsRecord::create([
                'organization_domain_id' => $domain->id,
                'organization_id' => $domain->organization_id,
                'provider' => $domain->dns_provider,
                'provider_zone_id' => $zone['zone_id'],
                'provider_record_id' => $providerResponse['id'],
                'type' => $type,
                'name' => $name,
                'content' => $content,
                'ttl' => $ttl ?? self::DEFAULT_TTL,
                'priority' => $priority,
                'metadata' => $metadata,
                'status' => 'active',
                'last_verified_at' => null,
            ]);

            Log::info('DNS record created successfully', [
                'record_id' => $dnsRecord->id,
                'provider_record_id' => $providerResponse['id'],
            ]);

            // Clear cache for this domain's records
            $this->clearRecordCache($domain);

            return $dnsRecord;

        } catch (\Exception $e) {
            Log::error('Failed to create DNS record', [
                'domain' => $domain->domain_name,
                'type' => $type,
                'name' => $name,
                'error' => $e->getMessage(),
            ]);

            throw new DnsException("Failed to create DNS record: {$e->getMessage()}", $e->getCode(), $e);
        }
    }

    /**
     * Update an existing DNS record
     */
    public function updateRecord(DnsRecord $record, array $data): DnsRecord
    {
        Log::info('Updating DNS record', [
            'record_id' => $record->id,
            'updates' => array_keys($data),
        ]);

        $provider = $this->getProviderForRecord($record);

        try {
            // Prepare update data
            $updateData = [];
            if (isset($data['content'])) $updateData['content'] = $data['content'];
            if (isset($data['ttl'])) $updateData['ttl'] = $data['ttl'];
            if (isset($data['priority'])) $updateData['priority'] = $data['priority'];

            // Update at provider
            $provider->updateRecord(
                $record->provider_zone_id,
                $record->provider_record_id,
                $updateData
            );

            // Update database
            $record->update($data);

            Log::info('DNS record updated successfully', [
                'record_id' => $record->id,
            ]);

            // Clear cache
            $this->clearRecordCache($record->organizationDomain);

            return $record->fresh();

        } catch (\Exception $e) {
            Log::error('Failed to update DNS record', [
                'record_id' => $record->id,
                'error' => $e->getMessage(),
            ]);

            throw new DnsException("Failed to update DNS record: {$e->getMessage()}", $e->getCode(), $e);
        }
    }

    /**
     * Delete a DNS record
     */
    public function deleteRecord(DnsRecord $record): bool
    {
        Log::info('Deleting DNS record', [
            'record_id' => $record->id,
            'type' => $record->type,
            'name' => $record->name,
        ]);

        $provider = $this->getProviderForRecord($record);

        try {
            // Delete at provider
            $provider->deleteRecord($record->provider_zone_id, $record->provider_record_id);

            // Delete from database
            $domain = $record->organizationDomain;
            $record->delete();

            Log::info('DNS record deleted successfully', [
                'record_id' => $record->id,
            ]);

            // Clear cache
            $this->clearRecordCache($domain);

            return true;

        } catch (\Exception $e) {
            Log::error('Failed to delete DNS record', [
                'record_id' => $record->id,
                'error' => $e->getMessage(),
            ]);

            throw new DnsException("Failed to delete DNS record: {$e->getMessage()}", $e->getCode(), $e);
        }
    }

    /**
     * Get a specific DNS record
     */
    public function getRecord(int $recordId): DnsRecord
    {
        $record = DnsRecord::find($recordId);

        if (!$record) {
            throw new DnsRecordNotFoundException("DNS record {$recordId} not found");
        }

        return $record;
    }

    /**
     * List all DNS records for a domain
     */
    public function listRecords(OrganizationDomain $domain, ?string $type = null): Collection
    {
        $cacheKey = "dns_records:{$domain->id}:" . ($type ?? 'all');

        return Cache::remember($cacheKey, 300, function () use ($domain, $type) {
            $query = DnsRecord::where('organization_domain_id', $domain->id)
                ->where('status', 'active');

            if ($type) {
                $query->where('type', $type);
            }

            return $query->orderBy('type')->orderBy('name')->get();
        });
    }

    /**
     * Create multiple DNS records in batch
     */
    public function createMultipleRecords(OrganizationDomain $domain, array $records): Collection
    {
        Log::info('Creating multiple DNS records', [
            'domain' => $domain->domain_name,
            'count' => count($records),
        ]);

        $created = collect();
        $errors = [];

        foreach ($records as $index => $recordData) {
            try {
                $record = $this->createRecord(
                    $domain,
                    $recordData['type'],
                    $recordData['name'],
                    $recordData['content'],
                    $recordData['ttl'] ?? null,
                    $recordData['priority'] ?? null,
                    $recordData['metadata'] ?? []
                );

                $created->push($record);

            } catch (\Exception $e) {
                $errors[$index] = $e->getMessage();
                Log::warning("Failed to create record {$index}", [
                    'error' => $e->getMessage(),
                    'record' => $recordData,
                ]);
            }
        }

        if (count($errors) > 0) {
            Log::warning('Some DNS records failed to create', [
                'total' => count($records),
                'created' => $created->count(),
                'failed' => count($errors),
                'errors' => $errors,
            ]);
        }

        return $created;
    }

    /**
     * Validate DNS record
     */
    public function validateRecord(string $type, string $name, string $content): array
    {
        $errors = [];

        // Check record type
        if (!in_array(strtoupper($type), self::SUPPORTED_RECORD_TYPES)) {
            $errors[] = "Unsupported record type: {$type}";
        }

        $type = strtoupper($type);

        // Validate based on type
        switch ($type) {
            case 'A':
                if (!filter_var($content, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
                    $errors[] = 'A record content must be a valid IPv4 address';
                }
                break;

            case 'AAAA':
                if (!filter_var($content, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
                    $errors[] = 'AAAA record content must be a valid IPv6 address';
                }
                break;

            case 'CNAME':
                if (!$this->isValidDomainName($content)) {
                    $errors[] = 'CNAME record content must be a valid domain name';
                }
                break;

            case 'MX':
                if (!$this->isValidDomainName($content)) {
                    $errors[] = 'MX record content must be a valid domain name';
                }
                break;

            case 'TXT':
                if (strlen($content) > 255) {
                    $errors[] = 'TXT record content must not exceed 255 characters';
                }
                break;

            case 'SRV':
                // SRV format: priority weight port target
                if (!preg_match('/^\d+ \d+ \d+ .+$/', $content)) {
                    $errors[] = 'SRV record format must be: priority weight port target';
                }
                break;
        }

        // Validate name
        if (!$this->isValidRecordName($name)) {
            $errors[] = 'Invalid record name format';
        }

        return [
            'valid' => count($errors) === 0,
            'errors' => $errors,
        ];
    }

    /**
     * Verify DNS record propagation
     */
    public function verifyPropagation(DnsRecord $record, int $timeout = 120): bool
    {
        Log::info('Verifying DNS propagation', [
            'record_id' => $record->id,
            'type' => $record->type,
            'name' => $record->name,
        ]);

        $startTime = time();
        $fullName = $this->getFullRecordName($record);

        while ((time() - $startTime) < $timeout) {
            try {
                $dnsRecords = dns_get_record($fullName, $this->getDnsRecordType($record->type));

                if ($dnsRecords !== false && count($dnsRecords) > 0) {
                    // Check if our content matches
                    foreach ($dnsRecords as $dnsRecord) {
                        $recordContent = $this->extractDnsContent($dnsRecord, $record->type);

                        if ($recordContent === $record->content) {
                            Log::info('DNS record propagation verified', [
                                'record_id' => $record->id,
                                'time_elapsed' => time() - $startTime,
                            ]);

                            $record->update(['last_verified_at' => now()]);

                            return true;
                        }
                    }
                }

                sleep(self::PROPAGATION_CHECK_INTERVAL);

            } catch (\Exception $e) {
                Log::warning('DNS lookup failed during propagation check', [
                    'record_id' => $record->id,
                    'error' => $e->getMessage(),
                ]);

                sleep(self::PROPAGATION_CHECK_INTERVAL);
            }
        }

        Log::warning('DNS propagation verification timeout', [
            'record_id' => $record->id,
            'timeout' => $timeout,
        ]);

        return false;
    }

    /**
     * Find DNS zone for a domain
     */
    public function findZone(OrganizationDomain $domain): array
    {
        $cacheKey = "dns_zone:{$domain->id}";

        return Cache::remember($cacheKey, 3600, function () use ($domain) {
            $provider = $this->getProviderForDomain($domain);

            try {
                $zone = $provider->findZone($domain->domain_name);

                Log::info('DNS zone found', [
                    'domain' => $domain->domain_name,
                    'zone_id' => $zone['zone_id'],
                ]);

                return $zone;

            } catch (\Exception $e) {
                Log::error('Failed to find DNS zone', [
                    'domain' => $domain->domain_name,
                    'provider' => $domain->dns_provider,
                    'error' => $e->getMessage(),
                ]);

                throw new DnsZoneNotFoundException(
                    "DNS zone not found for domain {$domain->domain_name}: {$e->getMessage()}",
                    $e->getCode(),
                    $e
                );
            }
        });
    }

    /**
     * Synchronize DNS records from provider to database
     */
    public function syncRecordsFromProvider(OrganizationDomain $domain): int
    {
        Log::info('Synchronizing DNS records from provider', [
            'domain' => $domain->domain_name,
        ]);

        $provider = $this->getProviderForDomain($domain);
        $zone = $this->findZone($domain);

        try {
            $providerRecords = $provider->listRecords($zone['zone_id']);

            $syncedCount = 0;

            foreach ($providerRecords as $providerRecord) {
                // Check if record exists in database
                $existingRecord = DnsRecord::where('organization_domain_id', $domain->id)
                    ->where('provider_record_id', $providerRecord['id'])
                    ->first();

                if ($existingRecord) {
                    // Update existing record
                    $existingRecord->update([
                        'type' => $providerRecord['type'],
                        'name' => $providerRecord['name'],
                        'content' => $providerRecord['content'],
                        'ttl' => $providerRecord['ttl'],
                        'priority' => $providerRecord['priority'] ?? null,
                    ]);
                } else {
                    // Create new record
                    DnsRecord::create([
                        'organization_domain_id' => $domain->id,
                        'organization_id' => $domain->organization_id,
                        'provider' => $domain->dns_provider,
                        'provider_zone_id' => $zone['zone_id'],
                        'provider_record_id' => $providerRecord['id'],
                        'type' => $providerRecord['type'],
                        'name' => $providerRecord['name'],
                        'content' => $providerRecord['content'],
                        'ttl' => $providerRecord['ttl'],
                        'priority' => $providerRecord['priority'] ?? null,
                        'status' => 'active',
                    ]);
                }

                $syncedCount++;
            }

            // Clear cache
            $this->clearRecordCache($domain);

            Log::info('DNS records synchronized', [
                'domain' => $domain->domain_name,
                'synced_count' => $syncedCount,
            ]);

            return $syncedCount;

        } catch (\Exception $e) {
            Log::error('Failed to synchronize DNS records', [
                'domain' => $domain->domain_name,
                'error' => $e->getMessage(),
            ]);

            throw new DnsException("Failed to synchronize DNS records: {$e->getMessage()}", $e->getCode(), $e);
        }
    }

    // Private helper methods

    /**
     * Get DNS provider instance for a domain
     */
    private function getProviderForDomain(OrganizationDomain $domain): DnsProviderInterface
    {
        return match ($domain->dns_provider) {
            'cloudflare' => app(CloudflareDnsProvider::class),
            'route53' => app(Route53DnsProvider::class),
            'digitalocean' => app(DigitalOceanDnsProvider::class),
            default => throw new DnsException("Unsupported DNS provider: {$domain->dns_provider}"),
        };
    }

    /**
     * Get DNS provider instance for a record
     */
    private function getProviderForRecord(DnsRecord $record): DnsProviderInterface
    {
        return match ($record->provider) {
            'cloudflare' => app(CloudflareDnsProvider::class),
            'route53' => app(Route53DnsProvider::class),
            'digitalocean' => app(DigitalOceanDnsProvider::class),
            default => throw new DnsException("Unsupported DNS provider: {$record->provider}"),
        };
    }

    /**
     * Prepare record data for provider API
     */
    private function prepareRecordData(
        string $type,
        string $name,
        string $content,
        ?int $ttl,
        ?int $priority,
        array $metadata
    ): array {
        $data = [
            'type' => strtoupper($type),
            'name' => $name,
            'content' => $content,
            'ttl' => $ttl ?? self::DEFAULT_TTL,
        ];

        if ($priority !== null) {
            $data['priority'] = $priority;
        }

        // Merge provider-specific metadata
        return array_merge($data, $metadata);
    }

    /**
     * Check if a duplicate record already exists
     */
    private function isDuplicateRecord(
        OrganizationDomain $domain,
        string $type,
        string $name,
        string $content
    ): bool {
        return DnsRecord::where('organization_domain_id', $domain->id)
            ->where('type', $type)
            ->where('name', $name)
            ->where('content', $content)
            ->where('status', 'active')
            ->exists();
    }

    /**
     * Validate domain name format
     */
    private function isValidDomainName(string $domain): bool
    {
        return (bool) preg_match('/^([a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}$/i', $domain);
    }

    /**
     * Validate record name format
     */
    private function isValidRecordName(string $name): bool
    {
        // Allow @ for root, subdomain names, and wildcards
        if ($name === '@') {
            return true;
        }

        if (str_starts_with($name, '*.')) {
            $name = substr($name, 2);
        }

        return (bool) preg_match('/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i', $name);
    }

    /**
     * Get full DNS record name (FQDN)
     */
    private function getFullRecordName(DnsRecord $record): string
    {
        $domain = $record->organizationDomain;

        if ($record->name === '@') {
            return $domain->domain_name;
        }

        return "{$record->name}.{$domain->domain_name}";
    }

    /**
     * Get DNS record type constant for dns_get_record()
     */
    private function getDnsRecordType(string $type): int
    {
        return match (strtoupper($type)) {
            'A' => DNS_A,
            'AAAA' => DNS_AAAA,
            'CNAME' => DNS_CNAME,
            'MX' => DNS_MX,
            'TXT' => DNS_TXT,
            'SRV' => DNS_SRV,
            default => DNS_ANY,
        };
    }

    /**
     * Extract content from dns_get_record result
     */
    private function extractDnsContent(array $dnsRecord, string $type): string
    {
        return match (strtoupper($type)) {
            'A' => $dnsRecord['ip'] ?? '',
            'AAAA' => $dnsRecord['ipv6'] ?? '',
            'CNAME' => $dnsRecord['target'] ?? '',
            'MX' => $dnsRecord['target'] ?? '',
            'TXT' => $dnsRecord['txt'] ?? '',
            'SRV' => $dnsRecord['target'] ?? '',
            default => '',
        };
    }

    /**
     * Clear record cache for a domain
     */
    private function clearRecordCache(OrganizationDomain $domain): void
    {
        Cache::forget("dns_records:{$domain->id}:all");

        foreach (self::SUPPORTED_RECORD_TYPES as $type) {
            Cache::forget("dns_records:{$domain->id}:{$type}");
        }

        Cache::forget("dns_zone:{$domain->id}");
    }
}
```

### Cloudflare DNS Provider Implementation

**File:** `app/Services/Enterprise/DnsProviders/CloudflareDnsProvider.php`

```php
<?php

namespace App\Services\Enterprise\DnsProviders;

use App\Contracts\DnsProviderInterface;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class CloudflareDnsProvider implements DnsProviderInterface
{
    private const API_BASE_URL = 'https://api.cloudflare.com/client/v4';
    private string $apiToken;

    public function __construct()
    {
        $this->apiToken = config('dns.providers.cloudflare.api_token');
    }

    /**
     * Create a DNS record
     */
    public function createRecord(string $zoneId, array $recordData): array
    {
        $response = Http::withToken($this->apiToken)
            ->post(self::API_BASE_URL . "/zones/{$zoneId}/dns_records", $recordData);

        if (!$response->successful()) {
            throw new \Exception("Cloudflare API error: " . $response->body());
        }

        $result = $response->json();

        return [
            'id' => $result['result']['id'],
            'type' => $result['result']['type'],
            'name' => $result['result']['name'],
            'content' => $result['result']['content'],
            'ttl' => $result['result']['ttl'],
        ];
    }

    /**
     * Update a DNS record
     */
    public function updateRecord(string $zoneId, string $recordId, array $recordData): array
    {
        $response = Http::withToken($this->apiToken)
            ->patch(self::API_BASE_URL . "/zones/{$zoneId}/dns_records/{$recordId}", $recordData);

        if (!$response->successful()) {
            throw new \Exception("Cloudflare API error: " . $response->body());
        }

        return $response->json()['result'];
    }

    /**
     * Delete a DNS record
     */
    public function deleteRecord(string $zoneId, string $recordId): bool
    {
        $response = Http::withToken($this->apiToken)
            ->delete(self::API_BASE_URL . "/zones/{$zoneId}/dns_records/{$recordId}");

        return $response->successful();
    }

    /**
     * Get a specific record
     */
    public function getRecord(string $zoneId, string $recordId): array
    {
        $response = Http::withToken($this->apiToken)
            ->get(self::API_BASE_URL . "/zones/{$zoneId}/dns_records/{$recordId}");

        if (!$response->successful()) {
            throw new \Exception("Cloudflare API error: " . $response->body());
        }

        return $response->json()['result'];
    }

    /**
     * List all records for a zone
     */
    public function listRecords(string $zoneId, ?string $type = null): array
    {
        $params = [];
        if ($type) {
            $params['type'] = $type;
        }

        $response = Http::withToken($this->apiToken)
            ->get(self::API_BASE_URL . "/zones/{$zoneId}/dns_records", $params);

        if (!$response->successful()) {
            throw new \Exception("Cloudflare API error: " . $response->body());
        }

        return $response->json()['result'];
    }

    /**
     * Find zone by domain name
     */
    public function findZone(string $domain): array
    {
        $response = Http::withToken($this->apiToken)
            ->get(self::API_BASE_URL . "/zones", ['name' => $domain]);

        if (!$response->successful()) {
            throw new \Exception("Cloudflare API error: " . $response->body());
        }

        $result = $response->json()['result'];

        if (empty($result)) {
            throw new \Exception("Zone not found for domain: {$domain}");
        }

        $zone = $result[0];

        return [
            'zone_id' => $zone['id'],
            'name' => $zone['name'],
            'name_servers' => $zone['name_servers'] ?? [],
        ];
    }

    /**
     * Test connection to Cloudflare API
     */
    public function testConnection(): bool
    {
        try {
            $response = Http::withToken($this->apiToken)
                ->get(self::API_BASE_URL . "/user/tokens/verify");

            return $response->successful();
        } catch (\Exception $e) {
            Log::error('Cloudflare connection test failed', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Get rate limit status
     */
    public function getRateLimitStatus(): array
    {
        // Cloudflare includes rate limit info in response headers
        return [
            'provider' => 'cloudflare',
            'limit' => 'Dynamic based on plan',
            'note' => 'Check X-RateLimit headers in responses',
        ];
    }
}
```

### Configuration File

**File:** `config/dns.php`

```php
<?php

return [
    /*
    |--------------------------------------------------------------------------
    | Default DNS Provider
    |--------------------------------------------------------------------------
    */
    'default' => env('DNS_PROVIDER', 'cloudflare'),

    /*
    |--------------------------------------------------------------------------
    | DNS Provider Configurations
    |--------------------------------------------------------------------------
    */
    'providers' => [
        'cloudflare' => [
            'api_token' => env('CLOUDFLARE_API_TOKEN'),
            'api_email' => env('CLOUDFLARE_API_EMAIL'),
        ],

        'route53' => [
            'access_key_id' => env('AWS_ACCESS_KEY_ID'),
            'secret_access_key' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
        ],

        'digitalocean' => [
            'api_token' => env('DIGITALOCEAN_API_TOKEN'),
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | DNS Record Defaults
    |--------------------------------------------------------------------------
    */
    'defaults' => [
        'ttl' => env('DNS_DEFAULT_TTL', 3600),
        'propagation_timeout' => env('DNS_PROPAGATION_TIMEOUT', 120),
    ],

    /*
    |--------------------------------------------------------------------------
    | Supported Record Types
    |--------------------------------------------------------------------------
    */
    'supported_types' => ['A', 'AAAA', 'CNAME', 'MX', 'TXT', 'SRV'],
];
```

### Exception Classes

**File:** `app/Exceptions/DnsException.php`

```php
<?php

namespace App\Exceptions;

class DnsException extends \Exception
{
    public function report(): void
    {
        \Log::error('DNS operation failed', [
            'message' => $this->getMessage(),
            'code' => $this->getCode(),
            'file' => $this->getFile(),
            'line' => $this->getLine(),
        ]);
    }
}
```

**File:** `app/Exceptions/DnsRecordNotFoundException.php`

```php
<?php

namespace App\Exceptions;

class DnsRecordNotFoundException extends DnsException
{
    //
}
```

**File:** `app/Exceptions/DnsZoneNotFoundException.php`

```php
<?php

namespace App\Exceptions;

class DnsZoneNotFoundException extends DnsException
{
    //
}
```

## Implementation Approach

### Step 1: Create Service Interfaces
1. Create `DnsManagementServiceInterface` in `app/Contracts/`
2. Create `DnsProviderInterface` in `app/Contracts/`
3. Define all method signatures with PHPDoc blocks

### Step 2: Implement Core Service
1. Create `DnsManagementService` in `app/Services/Enterprise/`
2. Implement CRUD operations (createRecord, updateRecord, deleteRecord, getRecord, listRecords)
3. Add validation logic for all record types
4. Implement helper methods for domain/name validation

### Step 3: Create DNS Provider Implementations
1. Create `CloudflareDnsProvider` with Cloudflare API integration
2. Create `Route53DnsProvider` with AWS SDK integration
3. Create `DigitalOceanDnsProvider` with DigitalOcean API integration
4. Implement consistent error handling across all providers

### Step 4: Add Database Synchronization
1. Implement `syncRecordsFromProvider()` method
2. Add cache management (Cache::remember for records and zones)
3. Implement cache invalidation on CRUD operations
4. Handle provider-to-database record mapping

### Step 5: Implement Advanced Features
1. Add `createMultipleRecords()` for batch operations
2. Implement `verifyPropagation()` with DNS lookup and polling
3. Add `findZone()` with caching
4. Implement duplicate record detection

### Step 6: Error Handling and Logging
1. Create custom exception classes (DnsException, DnsRecordNotFoundException, etc.)
2. Add comprehensive logging for all operations
3. Implement provider-specific error translation
4. Add retry logic with exponential backoff

### Step 7: Configuration and Registration
1. Create `config/dns.php` configuration file
2. Register services in `EnterpriseServiceProvider`
3. Bind interfaces to implementations
4. Configure environment variables

### Step 8: Testing
1. Unit test all DnsManagementService methods
2. Mock DNS provider responses
3. Test validation logic for all record types
4. Test error handling and exception scenarios
5. Integration tests with real provider APIs (in test environment)

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/DnsManagementServiceTest.php`

```php
<?php

use App\Services\Enterprise\DnsManagementService;
use App\Models\OrganizationDomain;
use App\Models\DnsRecord;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    $this->service = app(DnsManagementService::class);
});

it('validates A records correctly', function () {
    $result = $this->service->validateRecord('A', 'subdomain', '192.168.1.1');

    expect($result['valid'])->toBeTrue();
    expect($result['errors'])->toBeEmpty();
});

it('rejects invalid A record IP', function () {
    $result = $this->service->validateRecord('A', 'subdomain', 'not-an-ip');

    expect($result['valid'])->toBeFalse();
    expect($result['errors'])->toContain('A record content must be a valid IPv4 address');
});

it('validates CNAME records correctly', function () {
    $result = $this->service->validateRecord('CNAME', 'www', 'example.com');

    expect($result['valid'])->toBeTrue();
});

it('validates TXT records correctly', function () {
    $result = $this->service->validateRecord('TXT', '@', 'v=spf1 include:_spf.example.com ~all');

    expect($result['valid'])->toBeTrue();
});

it('rejects TXT records exceeding 255 characters', function () {
    $longText = str_repeat('a', 256);
    $result = $this->service->validateRecord('TXT', '@', $longText);

    expect($result['valid'])->toBeFalse();
});

it('validates MX records with priority', function () {
    $result = $this->service->validateRecord('MX', '@', 'mail.example.com');

    expect($result['valid'])->toBeTrue();
});

it('creates DNS record successfully', function () {
    $domain = OrganizationDomain::factory()->create([
        'dns_provider' => 'cloudflare',
    ]);

    // Mock provider response
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('findZone')
            ->andReturn(['zone_id' => 'zone123', 'name_servers' => []]);

        $mock->shouldReceive('createRecord')
            ->andReturn(['id' => 'record123', 'type' => 'A']);
    });

    $record = $this->service->createRecord($domain, 'A', 'test', '192.168.1.1');

    expect($record)->toBeInstanceOf(DnsRecord::class);
    expect($record->type)->toBe('A');
    expect($record->name)->toBe('test');
    expect($record->content)->toBe('192.168.1.1');
});

it('throws exception for duplicate records', function () {
    $domain = OrganizationDomain::factory()->create();

    DnsRecord::factory()->create([
        'organization_domain_id' => $domain->id,
        'type' => 'A',
        'name' => 'test',
        'content' => '192.168.1.1',
        'status' => 'active',
    ]);

    expect(fn() => $this->service->createRecord($domain, 'A', 'test', '192.168.1.1'))
        ->toThrow(\App\Exceptions\DnsException::class, 'Duplicate DNS record');
});

it('lists DNS records with type filtering', function () {
    $domain = OrganizationDomain::factory()->create();

    DnsRecord::factory()->create([
        'organization_domain_id' => $domain->id,
        'type' => 'A',
    ]);

    DnsRecord::factory()->create([
        'organization_domain_id' => $domain->id,
        'type' => 'CNAME',
    ]);

    $aRecords = $this->service->listRecords($domain, 'A');

    expect($aRecords)->toHaveCount(1);
    expect($aRecords->first()->type)->toBe('A');
});

it('updates DNS record successfully', function () {
    $record = DnsRecord::factory()->create([
        'type' => 'A',
        'content' => '192.168.1.1',
        'ttl' => 3600,
    ]);

    // Mock provider
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('updateRecord')->andReturn([]);
    });

    $updated = $this->service->updateRecord($record, [
        'content' => '192.168.1.2',
        'ttl' => 7200,
    ]);

    expect($updated->content)->toBe('192.168.1.2');
    expect($updated->ttl)->toBe(7200);
});

it('deletes DNS record successfully', function () {
    $record = DnsRecord::factory()->create();

    // Mock provider
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('deleteRecord')->andReturn(true);
    });

    $result = $this->service->deleteRecord($record);

    expect($result)->toBeTrue();
    expect(DnsRecord::find($record->id))->toBeNull();
});

it('clears cache after record creation', function () {
    Cache::shouldReceive('forget')
        ->times(8); // all + 6 record types + zone

    $domain = OrganizationDomain::factory()->create(['dns_provider' => 'cloudflare']);

    // Mock provider
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('findZone')->andReturn(['zone_id' => 'zone123']);
        $mock->shouldReceive('createRecord')->andReturn(['id' => 'record123']);
    });

    $this->service->createRecord($domain, 'A', 'test', '192.168.1.1');
});
```

### Integration Tests

**File:** `tests/Feature/DnsManagement/DnsRecordManagementTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\OrganizationDomain;
use App\Models\DnsRecord;
use App\Services\Enterprise\DnsManagementService;

it('creates A record for application deployment', function () {
    $organization = Organization::factory()->create();
    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain_name' => 'example.com',
        'dns_provider' => 'cloudflare',
    ]);

    // Mock Cloudflare provider
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('findZone')
            ->andReturn(['zone_id' => 'cloudflare-zone-123', 'name_servers' => []]);

        $mock->shouldReceive('createRecord')
            ->andReturn(['id' => 'cloudflare-record-123']);
    });

    $service = app(DnsManagementService::class);

    $record = $service->createRecord($domain, 'A', 'app', '192.168.1.100');

    expect($record)->toBeInstanceOf(DnsRecord::class);
    expect($record->type)->toBe('A');
    expect($record->name)->toBe('app');
    expect($record->content)->toBe('192.168.1.100');
    expect($record->provider_record_id)->toBe('cloudflare-record-123');

    $this->assertDatabaseHas('dns_records', [
        'organization_domain_id' => $domain->id,
        'type' => 'A',
        'name' => 'app',
        'content' => '192.168.1.100',
        'status' => 'active',
    ]);
});

it('creates batch DNS records for email configuration', function () {
    $domain = OrganizationDomain::factory()->create(['dns_provider' => 'cloudflare']);

    // Mock provider
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('findZone')->andReturn(['zone_id' => 'zone123']);
        $mock->shouldReceive('createRecord')->times(3)->andReturn(['id' => 'record-x']);
    });

    $service = app(DnsManagementService::class);

    $emailRecords = [
        ['type' => 'MX', 'name' => '@', 'content' => 'mail.example.com', 'priority' => 10],
        ['type' => 'TXT', 'name' => '@', 'content' => 'v=spf1 include:_spf.example.com ~all'],
        ['type' => 'TXT', 'name' => '_dmarc', 'content' => 'v=DMARC1; p=none; rua=mailto:dmarc@example.com'],
    ];

    $created = $service->createMultipleRecords($domain, $emailRecords);

    expect($created)->toHaveCount(3);
    expect($created->pluck('type')->toArray())->toBe(['MX', 'TXT', 'TXT']);
});

it('synchronizes DNS records from provider', function () {
    $domain = OrganizationDomain::factory()->create(['dns_provider' => 'cloudflare']);

    // Mock provider returning existing records
    $this->mock(CloudflareDnsProvider::class, function ($mock) {
        $mock->shouldReceive('findZone')->andReturn(['zone_id' => 'zone123']);

        $mock->shouldReceive('listRecords')->andReturn([
            [
                'id' => 'provider-record-1',
                'type' => 'A',
                'name' => 'www',
                'content' => '192.168.1.1',
                'ttl' => 3600,
            ],
            [
                'id' => 'provider-record-2',
                'type' => 'CNAME',
                'name' => 'blog',
                'content' => 'example.com',
                'ttl' => 3600,
            ],
        ]);
    });

    $service = app(DnsManagementService::class);
    $syncedCount = $service->syncRecordsFromProvider($domain);

    expect($syncedCount)->toBe(2);

    $this->assertDatabaseHas('dns_records', [
        'organization_domain_id' => $domain->id,
        'type' => 'A',
        'name' => 'www',
    ]);

    $this->assertDatabaseHas('dns_records', [
        'organization_domain_id' => $domain->id,
        'type' => 'CNAME',
        'name' => 'blog',
    ]);
});
```

## Definition of Done

- [ ] DnsManagementServiceInterface created with all method signatures
- [ ] DnsProviderInterface created for provider abstraction
- [ ] DnsManagementService implementation complete
- [ ] CloudflareDnsProvider implementation complete
- [ ] Route53DnsProvider implementation complete
- [ ] DigitalOceanDnsProvider implementation complete
- [ ] Validation logic for all record types (A, AAAA, CNAME, MX, TXT, SRV)
- [ ] CRUD operations implemented (create, update, delete, get, list)
- [ ] Batch record creation implemented
- [ ] DNS propagation verification implemented
- [ ] Zone finding and caching implemented
- [ ] Record synchronization from provider implemented
- [ ] Cache management with invalidation
- [ ] Duplicate record detection
- [ ] Custom exception classes created (DnsException, DnsRecordNotFoundException, etc.)
- [ ] Configuration file created (config/dns.php)
- [ ] Environment variables documented
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Unit tests written (15+ tests, >90% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Provider API mocking implemented for tests
- [ ] PHPDoc blocks complete for all methods
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing with real provider APIs (test credentials)
- [ ] Documentation updated with usage examples
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 66 (DomainRegistrarService provides domain context)
- **Depends on:** Task 62 (Database schema for dns_records table)
- **Used by:** Task 70 (DnsRecordEditor.vue UI for DNS management)
- **Used by:** Task 19 (Server auto-registration creates A records)
- **Used by:** Task 68 (Let's Encrypt SSL uses TXT records for challenges)
- **Integrates with:** Application deployment (custom domain DNS automation)
