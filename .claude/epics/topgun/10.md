---
name: Implement BrandingCacheWarmerJob for pre-compilation of organization CSS
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:28Z
github: https://github.com/johnproblems/topgun/issues/120
depends_on: [2, 3]
parallel: false
conflicts_with: []
---

# Task: Implement BrandingCacheWarmerJob for pre-compilation of organization CSS

## Description

Implement a Laravel queued job that pre-compiles and caches CSS for all organizations, ensuring zero-latency branding delivery when users access the platform. This background worker systematically warms the Redis cache by generating organization-specific CSS files before they're requested, eliminating the cold-start performance penalty and guaranteeing instant page loads with full white-label branding.

**The Performance Challenge:**

Without cache warming, the first request to an organization's white-labeled site triggers expensive operations:
1. **Database query**: Fetch `white_label_configs` row
2. **CSS generation**: Compile Tailwind-style CSS with organization colors
3. **Asset generation**: Create favicon references, logo URLs
4. **Cache write**: Store generated CSS in Redis
5. **Response**: Finally serve the page

This cold-start sequence adds 150-300ms latency to the first page load—a poor first impression that makes the platform feel sluggish. For organizations with infrequent traffic, every user might hit this cold cache, creating consistently slow experiences.

**The Solution:**

BrandingCacheWarmerJob proactively generates all organization CSS during off-peak hours (typically nightly), ensuring the cache is always warm when real users arrive. This transforms the user experience from "cold cache every time" to "instant delivery every time," regardless of traffic patterns.

**Key Capabilities:**

1. **Automated Cache Warming**: Runs nightly via Laravel Scheduler to refresh all organization caches
2. **On-Demand Warming**: Triggered automatically when branding is updated via events
3. **Selective Warming**: Can target specific organizations or all organizations
4. **Error Recovery**: Handles failures gracefully, logs issues, continues processing
5. **Progress Tracking**: Reports warming progress for monitoring and debugging
6. **Cache Invalidation**: Clears stale caches before regenerating
7. **Resource Efficiency**: Queued execution prevents blocking critical web workers
8. **Observability**: Integrates with Laravel Horizon for job monitoring

**Integration Architecture:**

**Triggers:**
- **Scheduled**: Nightly cron via `app/Console/Kernel.php` → `schedule->job(BrandingCacheWarmerJob::class)->daily()`
- **Event-Driven**: `WhiteLabelConfigUpdated` event → dispatches job for specific organization
- **Manual**: Artisan command `php artisan branding:warm-cache {organization?}`
- **Deployment**: Runs after deployment to ensure production cache is warm

**Dependencies:**
- **Task 2 (DynamicAssetController)**: Uses same CSS generation logic for consistency
- **Task 3 (BrandingCacheService)**: Wraps Redis operations, key management
- **Task 9 (Email Templates)**: Clears email branding cache alongside CSS cache

**Why This Task is Critical:**

Cache warming is the difference between "acceptable" and "exceptional" performance. Without it, organizations with low traffic perpetually experience slow load times because their cache expires between visits. With cache warming, even the smallest organization gets instant delivery—the same performance as high-traffic organizations. This levels the playing field and ensures the white-label experience is consistently fast, professional, and delightful regardless of usage patterns.

The job also serves as a health check mechanism: if cache warming fails for an organization, it indicates configuration issues (missing logo, invalid colors, etc.) that would otherwise surface as user-facing errors. By detecting and logging these issues proactively, the system becomes more reliable and easier to debug.

## Acceptance Criteria

- [ ] BrandingCacheWarmerJob implements `ShouldQueue` interface
- [ ] Job dispatches to 'cache-warming' queue for isolation
- [ ] Warms CSS cache for all organizations by default
- [ ] Accepts optional organization_id parameter for selective warming
- [ ] Integrates with BrandingCacheService for cache operations
- [ ] Uses DynamicAssetController::generateCSS() for CSS compilation
- [ ] Implements comprehensive error handling and logging
- [ ] Tracks progress with progress bar when run via Artisan
- [ ] Clears existing cache before regenerating (invalidate-then-populate pattern)
- [ ] Also warms email branding cache (Task 9 integration)
- [ ] Respects job retry logic (3 retries with exponential backoff)
- [ ] Scheduled to run daily at 2:00 AM via Laravel Scheduler
- [ ] Artisan command `branding:warm-cache {organization?}` triggers job
- [ ] Event listener for WhiteLabelConfigUpdated triggers selective warming
- [ ] Horizon tags for filtering and monitoring
- [ ] Performance metrics logged (organizations processed, time taken)
- [ ] Graceful handling of deleted/invalid organizations

## Technical Details

### File Paths

**Job:**
- `/home/topgun/topgun/app/Jobs/Enterprise/BrandingCacheWarmerJob.php` (new)

**Artisan Command:**
- `/home/topgun/topgun/app/Console/Commands/WarmBrandingCache.php` (new)

**Event Listener:**
- `/home/topgun/topgun/app/Listeners/Enterprise/WarmBrandingCacheOnUpdate.php` (new)

**Scheduler:**
- `/home/topgun/topgun/app/Console/Kernel.php` (modify - add schedule)

**Event:**
- `/home/topgun/topgun/app/Events/Enterprise/WhiteLabelConfigUpdated.php` (new)

### BrandingCacheWarmerJob Implementation

**File:** `app/Jobs/Enterprise/BrandingCacheWarmerJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\BrandingCacheServiceInterface;
use App\Models\Organization;
use App\Services\Enterprise\WhiteLabelService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class BrandingCacheWarmerJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $timeout = 300; // 5 minutes
    public int $backoff = 30; // Retry after 30 seconds

    /**
     * Create a new job instance
     *
     * @param int|null $organizationId Specific organization to warm, or null for all
     * @param bool $clearCache Whether to clear existing cache before warming
     */
    public function __construct(
        public ?int $organizationId = null,
        public bool $clearCache = true
    ) {
        $this->onQueue('cache-warming');
    }

    /**
     * Execute the job
     *
     * @param BrandingCacheServiceInterface $cacheService
     * @param WhiteLabelService $whiteLabelService
     * @return void
     */
    public function handle(
        BrandingCacheServiceInterface $cacheService,
        WhiteLabelService $whiteLabelService
    ): void {
        $startTime = microtime(true);

        try {
            if ($this->organizationId) {
                // Warm cache for specific organization
                $this->warmOrganization($this->organizationId, $cacheService, $whiteLabelService);
            } else {
                // Warm cache for all organizations
                $this->warmAllOrganizations($cacheService, $whiteLabelService);
            }

            $duration = round((microtime(true) - $startTime) * 1000, 2);

            Log::info('Branding cache warming completed', [
                'organization_id' => $this->organizationId,
                'duration_ms' => $duration,
                'mode' => $this->organizationId ? 'single' : 'all',
            ]);
        } catch (\Exception $e) {
            Log::error('Branding cache warming failed', [
                'organization_id' => $this->organizationId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            throw $e; // Re-throw to trigger retry logic
        }
    }

    /**
     * Warm cache for all organizations
     *
     * @param BrandingCacheServiceInterface $cacheService
     * @param WhiteLabelService $whiteLabelService
     * @return void
     */
    protected function warmAllOrganizations(
        BrandingCacheServiceInterface $cacheService,
        WhiteLabelService $whiteLabelService
    ): void {
        $organizations = Organization::query()
            ->has('whiteLabelConfig')
            ->with('whiteLabelConfig')
            ->get();

        $successCount = 0;
        $failureCount = 0;

        Log::info("Starting cache warming for {$organizations->count()} organizations");

        foreach ($organizations as $organization) {
            try {
                $this->warmOrganizationCache($organization, $cacheService, $whiteLabelService);
                $successCount++;
            } catch (\Exception $e) {
                $failureCount++;

                Log::warning("Failed to warm cache for organization {$organization->id}", [
                    'organization_id' => $organization->id,
                    'organization_name' => $organization->name,
                    'error' => $e->getMessage(),
                ]);

                // Continue processing other organizations despite failures
                continue;
            }
        }

        Log::info('Bulk cache warming summary', [
            'total' => $organizations->count(),
            'success' => $successCount,
            'failed' => $failureCount,
        ]);
    }

    /**
     * Warm cache for specific organization by ID
     *
     * @param int $organizationId
     * @param BrandingCacheServiceInterface $cacheService
     * @param WhiteLabelService $whiteLabelService
     * @return void
     */
    protected function warmOrganization(
        int $organizationId,
        BrandingCacheServiceInterface $cacheService,
        WhiteLabelService $whiteLabelService
    ): void {
        $organization = Organization::with('whiteLabelConfig')->find($organizationId);

        if (!$organization) {
            Log::warning("Organization {$organizationId} not found for cache warming");
            return;
        }

        if (!$organization->whiteLabelConfig) {
            Log::warning("Organization {$organizationId} has no white-label configuration");
            return;
        }

        $this->warmOrganizationCache($organization, $cacheService, $whiteLabelService);

        Log::info("Cache warmed for organization {$organization->id}", [
            'organization_id' => $organization->id,
            'organization_name' => $organization->name,
        ]);
    }

    /**
     * Core cache warming logic for single organization
     *
     * @param Organization $organization
     * @param BrandingCacheServiceInterface $cacheService
     * @param WhiteLabelService $whiteLabelService
     * @return void
     */
    protected function warmOrganizationCache(
        Organization $organization,
        BrandingCacheServiceInterface $cacheService,
        WhiteLabelService $whiteLabelService
    ): void {
        // Clear existing cache if requested
        if ($this->clearCache) {
            $cacheService->clearBrandingCache($organization);
        }

        // 1. Warm CSS cache
        $css = $whiteLabelService->generateCSS($organization);
        $cacheService->setCachedCSS($organization, $css);

        // 2. Warm branding configuration cache
        $config = $whiteLabelService->getBrandingConfig($organization);
        $cacheService->setCachedConfig($organization, $config);

        // 3. Warm email branding cache (Task 9 integration)
        $emailVars = $whiteLabelService->getEmailBrandingVars($organization);
        Cache::put(
            "email_branding:{$organization->id}",
            $emailVars,
            now()->addHours(24)
        );

        // 4. Warm favicon URLs cache
        $faviconUrls = $whiteLabelService->getFaviconUrls($organization);
        Cache::put(
            "favicon_urls:{$organization->id}",
            $faviconUrls,
            now()->addHours(24)
        );

        Log::debug("Cache warmed successfully", [
            'organization_id' => $organization->id,
            'css_length' => strlen($css),
            'email_vars_count' => count($emailVars),
        ]);
    }

    /**
     * Handle job failure
     *
     * @param \Throwable $exception
     * @return void
     */
    public function failed(\Throwable $exception): void
    {
        Log::error('BrandingCacheWarmerJob failed permanently', [
            'organization_id' => $this->organizationId,
            'error' => $exception->getMessage(),
            'trace' => $exception->getTraceAsString(),
        ]);

        // Optional: Send alert to monitoring service
        // report($exception);
    }

    /**
     * Get Horizon tags for filtering
     *
     * @return array<int, string>
     */
    public function tags(): array
    {
        $tags = ['branding', 'cache-warming'];

        if ($this->organizationId) {
            $tags[] = "organization:{$this->organizationId}";
        }

        return $tags;
    }
}
```

### Artisan Command

**File:** `app/Console/Commands/WarmBrandingCache.php`

```php
<?php

namespace App\Console\Commands;

use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Models\Organization;
use Illuminate\Console\Command;

class WarmBrandingCache extends Command
{
    protected $signature = 'branding:warm-cache
                            {organization? : Organization ID or slug to warm (omit for all)}
                            {--no-clear : Do not clear existing cache before warming}
                            {--sync : Run synchronously instead of queuing}';

    protected $description = 'Warm branding cache for one or all organizations';

    public function handle(): int
    {
        $organizationIdOrSlug = $this->argument('organization');
        $clearCache = !$this->option('no-clear');
        $sync = $this->option('sync');

        if ($organizationIdOrSlug) {
            return $this->warmSingleOrganization($organizationIdOrSlug, $clearCache, $sync);
        }

        return $this->warmAllOrganizations($clearCache, $sync);
    }

    /**
     * Warm cache for single organization
     *
     * @param string $idOrSlug
     * @param bool $clearCache
     * @param bool $sync
     * @return int
     */
    protected function warmSingleOrganization(string $idOrSlug, bool $clearCache, bool $sync): int
    {
        $organization = Organization::where('id', $idOrSlug)
            ->orWhere('slug', $idOrSlug)
            ->first();

        if (!$organization) {
            $this->error("Organization not found: {$idOrSlug}");
            return self::FAILURE;
        }

        if (!$organization->whiteLabelConfig) {
            $this->warn("Organization {$organization->name} has no white-label configuration");
            return self::FAILURE;
        }

        $this->info("Warming cache for organization: {$organization->name}");

        $job = new BrandingCacheWarmerJob($organization->id, $clearCache);

        if ($sync) {
            $job->handle(
                app(\App\Contracts\BrandingCacheServiceInterface::class),
                app(\App\Services\Enterprise\WhiteLabelService::class)
            );
        } else {
            dispatch($job);
        }

        $this->info("✓ Cache warming " . ($sync ? "completed" : "dispatched") . " for: {$organization->name}");

        return self::SUCCESS;
    }

    /**
     * Warm cache for all organizations
     *
     * @param bool $clearCache
     * @param bool $sync
     * @return int
     */
    protected function warmAllOrganizations(bool $clearCache, bool $sync): int
    {
        $organizations = Organization::has('whiteLabelConfig')->count();

        if ($organizations === 0) {
            $this->warn('No organizations with white-label configuration found');
            return self::SUCCESS;
        }

        $this->info("Warming cache for {$organizations} organizations...");

        if ($sync) {
            // Process synchronously with progress bar
            $this->warmSynchronously($clearCache);
        } else {
            // Dispatch job to queue
            $job = new BrandingCacheWarmerJob(null, $clearCache);
            dispatch($job);

            $this->info("✓ Bulk cache warming dispatched to queue");
        }

        return self::SUCCESS;
    }

    /**
     * Warm cache synchronously with progress bar
     *
     * @param bool $clearCache
     * @return void
     */
    protected function warmSynchronously(bool $clearCache): void
    {
        $organizations = Organization::query()
            ->has('whiteLabelConfig')
            ->with('whiteLabelConfig')
            ->get();

        $progressBar = $this->output->createProgressBar($organizations->count());
        $progressBar->start();

        $cacheService = app(\App\Contracts\BrandingCacheServiceInterface::class);
        $whiteLabelService = app(\App\Services\Enterprise\WhiteLabelService::class);

        $successCount = 0;
        $failureCount = 0;

        foreach ($organizations as $organization) {
            try {
                $job = new BrandingCacheWarmerJob($organization->id, $clearCache);
                $job->handle($cacheService, $whiteLabelService);

                $successCount++;
            } catch (\Exception $e) {
                $failureCount++;
                $this->newLine();
                $this->error("Failed: {$organization->name} - {$e->getMessage()}");
            } finally {
                $progressBar->advance();
            }
        }

        $progressBar->finish();
        $this->newLine(2);

        $this->info("✓ Cache warming completed");
        $this->table(
            ['Status', 'Count'],
            [
                ['Success', $successCount],
                ['Failed', $failureCount],
                ['Total', $organizations->count()],
            ]
        );
    }
}
```

### Event and Listener

**File:** `app/Events/Enterprise/WhiteLabelConfigUpdated.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Organization;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class WhiteLabelConfigUpdated
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public Organization $organization
    ) {
    }
}
```

**File:** `app/Listeners/Enterprise/WarmBrandingCacheOnUpdate.php`

```php
<?php

namespace App\Listeners\Enterprise;

use App\Events\Enterprise\WhiteLabelConfigUpdated;
use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use Illuminate\Contracts\Queue\ShouldQueue;

class WarmBrandingCacheOnUpdate implements ShouldQueue
{
    public string $queue = 'cache-warming';

    /**
     * Handle the event
     *
     * @param WhiteLabelConfigUpdated $event
     * @return void
     */
    public function handle(WhiteLabelConfigUpdated $event): void
    {
        // Dispatch cache warming job for the updated organization
        BrandingCacheWarmerJob::dispatch($event->organization->id, clearCache: true)
            ->delay(now()->addSeconds(5)); // Short delay to ensure DB committed
    }
}
```

### Scheduler Configuration

**File:** `app/Console/Kernel.php` (add to existing schedule() method)

```php
/**
 * Define the application's command schedule
 *
 * @param Schedule $schedule
 * @return void
 */
protected function schedule(Schedule $schedule): void
{
    // ... existing scheduled tasks ...

    // Warm branding cache nightly at 2 AM (low-traffic hours)
    $schedule->job(new BrandingCacheWarmerJob(null, clearCache: true))
        ->dailyAt('02:00')
        ->name('branding-cache-warming')
        ->withoutOverlapping()
        ->onOneServer(); // Important for multi-server setups

    // Alternative: Use command approach
    // $schedule->command('branding:warm-cache --sync')
    //     ->dailyAt('02:00')
    //     ->withoutOverlapping();
}
```

### WhiteLabelController Integration

Dispatch event when branding is updated:

```php
use App\Events\Enterprise\WhiteLabelConfigUpdated;

public function update(Request $request, Organization $organization)
{
    $this->authorize('update', $organization);

    $validated = $request->validate([
        'platform_name' => 'required|string|max:255',
        'primary_color' => 'required|string|regex:/^#[0-9A-F]{6}$/i',
        // ... other validation rules
    ]);

    $config = $organization->whiteLabelConfig()->updateOrCreate(
        ['organization_id' => $organization->id],
        $validated
    );

    // Dispatch event to warm cache
    event(new WhiteLabelConfigUpdated($organization));

    return back()->with('success', 'White-label configuration updated successfully');
}
```

### Queue Configuration

**File:** `config/queue.php` (add cache-warming queue)

```php
'connections' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => env('REDIS_QUEUE', 'default'),
        'retry_after' => 90,
        'block_for' => null,
        'after_commit' => false,
    ],

    // Add dedicated queue for cache warming
    'cache-warming' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => 'cache-warming',
        'retry_after' => 300,
        'block_for' => null,
        'after_commit' => true,
    ],
],
```

## Implementation Approach

### Step 1: Create Job Class
1. Create `BrandingCacheWarmerJob` in `app/Jobs/Enterprise/`
2. Implement `ShouldQueue` interface
3. Add constructor with optional organization_id parameter
4. Configure retry logic and timeout

### Step 2: Implement Core Warming Logic
1. Create `warmAllOrganizations()` method
2. Create `warmOrganization()` method for selective warming
3. Create `warmOrganizationCache()` core logic
4. Integrate with BrandingCacheService (Task 3)
5. Integrate with WhiteLabelService (Task 2)

### Step 3: Add Error Handling
1. Implement try-catch blocks for each organization
2. Log failures without stopping batch processing
3. Add `failed()` method for permanent failures
4. Configure retry logic with exponential backoff

### Step 4: Create Artisan Command
1. Create `WarmBrandingCache` command
2. Add optional organization argument
3. Implement progress bar for synchronous execution
4. Add --sync flag for immediate execution
5. Add --no-clear flag to skip cache invalidation

### Step 5: Event-Driven Warming
1. Create `WhiteLabelConfigUpdated` event
2. Create `WarmBrandingCacheOnUpdate` listener
3. Register in `EventServiceProvider`
4. Dispatch event from `WhiteLabelController::update()`

### Step 6: Scheduler Integration
1. Add daily schedule in `app/Console/Kernel.php`
2. Set execution time to 2:00 AM (off-peak)
3. Add `withoutOverlapping()` to prevent concurrent runs
4. Add `onOneServer()` for multi-server environments

### Step 7: Cache Integration
1. Warm CSS cache using DynamicAssetController
2. Warm email branding cache (Task 9)
3. Warm favicon URLs cache (Task 7)
4. Implement cache invalidation before warming

### Step 8: Horizon Integration
1. Add `tags()` method for Horizon filtering
2. Configure 'cache-warming' queue
3. Test job monitoring in Horizon dashboard
4. Set up alerts for failed jobs

### Step 9: Testing
1. Unit test job execution logic
2. Test error handling and retry behavior
3. Test event-driven warming
4. Test Artisan command with various flags
5. Integration test with real cache operations

### Step 10: Deployment and Monitoring
1. Deploy queue worker for 'cache-warming' queue
2. Verify scheduler is running (Laravel Horizon)
3. Monitor job success/failure rates
4. Set up alerts for consistent failures

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Jobs/BrandingCacheWarmerJobTest.php`

```php
<?php

use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use App\Services\Enterprise\BrandingCacheService;
use App\Services\Enterprise\WhiteLabelService;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Queue;

beforeEach(function () {
    Queue::fake();
    Cache::fake();
});

it('warms cache for specific organization', function () {
    $organization = Organization::factory()->create();
    WhiteLabelConfig::factory()->create([
        'organization_id' => $organization->id,
        'primary_color' => '#ff0000',
    ]);

    $job = new BrandingCacheWarmerJob($organization->id);
    $cacheService = app(BrandingCacheService::class);
    $whiteLabelService = app(WhiteLabelService::class);

    $job->handle($cacheService, $whiteLabelService);

    // Verify cache was set
    expect(Cache::has("branding:{$organization->id}:css"))->toBeTrue();
    expect(Cache::has("email_branding:{$organization->id}"))->toBeTrue();
});

it('warms cache for all organizations', function () {
    $orgs = Organization::factory(3)->create();

    foreach ($orgs as $org) {
        WhiteLabelConfig::factory()->create(['organization_id' => $org->id]);
    }

    $job = new BrandingCacheWarmerJob();
    $cacheService = app(BrandingCacheService::class);
    $whiteLabelService = app(WhiteLabelService::class);

    $job->handle($cacheService, $whiteLabelService);

    // Verify cache was set for all organizations
    foreach ($orgs as $org) {
        expect(Cache::has("branding:{$org->id}:css"))->toBeTrue();
    }
});

it('continues processing after single organization failure', function () {
    $org1 = Organization::factory()->create();
    $org2 = Organization::factory()->create(); // No config, will fail
    $org3 = Organization::factory()->create();

    WhiteLabelConfig::factory()->create(['organization_id' => $org1->id]);
    WhiteLabelConfig::factory()->create(['organization_id' => $org3->id]);

    $job = new BrandingCacheWarmerJob();
    $cacheService = app(BrandingCacheService::class);
    $whiteLabelService = app(WhiteLabelService::class);

    $job->handle($cacheService, $whiteLabelService);

    // Verify successful organizations were cached
    expect(Cache::has("branding:{$org1->id}:css"))->toBeTrue();
    expect(Cache::has("branding:{$org3->id}:css"))->toBeTrue();
});

it('clears cache before warming when specified', function () {
    $organization = Organization::factory()->create();
    WhiteLabelConfig::factory()->create(['organization_id' => $organization->id]);

    // Set initial cache
    Cache::put("branding:{$organization->id}:css", 'old-css', 3600);

    $job = new BrandingCacheWarmerJob($organization->id, clearCache: true);
    $cacheService = app(BrandingCacheService::class);
    $whiteLabelService = app(WhiteLabelService::class);

    $job->handle($cacheService, $whiteLabelService);

    // Verify cache was refreshed (not just the old value)
    $cachedCss = Cache::get("branding:{$organization->id}:css");
    expect($cachedCss)->not->toBe('old-css');
});

it('dispatches to cache-warming queue', function () {
    BrandingCacheWarmerJob::dispatch();

    Queue::assertPushedOn('cache-warming', BrandingCacheWarmerJob::class);
});

it('has correct Horizon tags', function () {
    $org = Organization::factory()->create();
    $job = new BrandingCacheWarmerJob($org->id);

    $tags = $job->tags();

    expect($tags)->toContain('branding');
    expect($tags)->toContain('cache-warming');
    expect($tags)->toContain("organization:{$org->id}");
});
```

### Integration Tests

**File:** `tests/Feature/Jobs/BrandingCacheWarmerIntegrationTest.php`

```php
<?php

use App\Events\Enterprise\WhiteLabelConfigUpdated;
use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;

it('warms cache via event when configuration updated', function () {
    Queue::fake();
    Event::fake([WhiteLabelConfigUpdated::class]);

    $organization = Organization::factory()->create();
    $config = WhiteLabelConfig::factory()->create([
        'organization_id' => $organization->id,
    ]);

    // Simulate configuration update
    event(new WhiteLabelConfigUpdated($organization));

    Queue::assertPushed(BrandingCacheWarmerJob::class, function ($job) use ($organization) {
        return $job->organizationId === $organization->id;
    });
});

it('warms cache when triggered via artisan command', function () {
    $organization = Organization::factory()->create();
    WhiteLabelConfig::factory()->create([
        'organization_id' => $organization->id,
        'primary_color' => '#00ff00',
    ]);

    $this->artisan('branding:warm-cache', ['organization' => $organization->id, '--sync' => true])
        ->assertSuccessful()
        ->expectsOutput("✓ Cache warming completed for: {$organization->name}");

    // Verify cache was actually set
    expect(Cache::has("branding:{$organization->id}:css"))->toBeTrue();
});

it('warms all organizations via artisan command', function () {
    $orgs = Organization::factory(5)->create();

    foreach ($orgs as $org) {
        WhiteLabelConfig::factory()->create(['organization_id' => $org->id]);
    }

    $this->artisan('branding:warm-cache', ['--sync' => true])
        ->assertSuccessful();

    // Verify all organizations have cached CSS
    foreach ($orgs as $org) {
        expect(Cache::has("branding:{$org->id}:css"))->toBeTrue();
    }
});

it('handles missing organization gracefully via artisan', function () {
    $this->artisan('branding:warm-cache', ['organization' => 99999])
        ->assertFailed()
        ->expectsOutput('Organization not found: 99999');
});
```

### Scheduler Tests

**File:** `tests/Feature/Scheduler/BrandingCacheSchedulerTest.php`

```php
<?php

use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use Illuminate\Support\Facades\Queue;

it('schedules daily cache warming job', function () {
    Queue::fake();

    // Run the scheduler for the daily cache warming time (2 AM)
    $this->artisan('schedule:run', ['--time' => '02:00'])
        ->assertSuccessful();

    Queue::assertPushed(BrandingCacheWarmerJob::class);
});
```

## Definition of Done

- [ ] BrandingCacheWarmerJob created implementing ShouldQueue
- [ ] Job dispatches to 'cache-warming' queue
- [ ] Warms cache for all organizations by default
- [ ] Accepts optional organization_id for selective warming
- [ ] Integrates with BrandingCacheService
- [ ] Integrates with WhiteLabelService for CSS generation
- [ ] Comprehensive error handling implemented
- [ ] Failed jobs logged with context
- [ ] Retry logic configured (3 retries, exponential backoff)
- [ ] Clears cache before regenerating (invalidate-then-populate)
- [ ] Warms CSS cache
- [ ] Warms email branding cache
- [ ] Warms favicon URLs cache
- [ ] WarmBrandingCache Artisan command created
- [ ] Command supports selective organization warming
- [ ] Command has --sync flag for synchronous execution
- [ ] Command has --no-clear flag to skip invalidation
- [ ] Progress bar displayed for synchronous execution
- [ ] WhiteLabelConfigUpdated event created
- [ ] WarmBrandingCacheOnUpdate listener created
- [ ] Event dispatched from WhiteLabelController::update()
- [ ] Scheduled to run daily at 2:00 AM
- [ ] Scheduler configured with withoutOverlapping()
- [ ] Scheduler configured with onOneServer()
- [ ] Horizon tags implemented for filtering
- [ ] Unit tests written (8+ tests, >90% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Scheduler test written
- [ ] Documentation updated with usage examples
- [ ] Code follows Laravel Job best practices
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved
- [ ] Deployed to staging and verified
- [ ] Horizon monitoring configured
- [ ] Performance verified (< 100ms per organization)

## Related Tasks

- **Depends on:** Task 2 (DynamicAssetController CSS generation)
- **Depends on:** Task 3 (BrandingCacheService Redis operations)
- **Integrates with:** Task 9 (Email branding cache warming)
- **Triggered by:** Task 5 (BrandingManager updates)
- **Monitors:** Task 7 (Favicon URL caching)
