---
name: Build CapacityManager service with selectOptimalServer method
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:45Z
github: https://github.com/johnproblems/topgun/issues/136
depends_on: [25]
parallel: false
conflicts_with: []
---

# Task: Build CapacityManager service with selectOptimalServer method

## Description

Implement the **CapacityManager** service, an intelligent server selection engine that analyzes server capacity and load metrics to automatically select the optimal server for application deployments. This service is the brain of Coolify's resource management system, ensuring deployments are distributed efficiently across available infrastructure to prevent overloading servers and maintain optimal performance across the entire organization's fleet.

The CapacityManager uses a **weighted scoring algorithm** to evaluate servers based on multiple dimensions:
- **CPU capacity** (30% weight) - Available CPU cores vs. total cores
- **Memory capacity** (30% weight) - Available RAM vs. total RAM
- **Disk capacity** (20% weight) - Available disk space vs. total disk space
- **Network bandwidth** (10% weight) - Network utilization and available bandwidth
- **Current load** (10% weight) - Active deployments, build queue length, response time

This multi-dimensional scoring ensures deployments land on servers with sufficient resources while balancing load across the infrastructure. The service also provides capacity forecasting, build queue optimization, and reservation tracking to prevent race conditions when multiple deployments start simultaneously.

**Integration Points:**

- **SystemResourceMonitor (Task 25)**: Provides real-time metrics for capacity calculations
- **Server Model**: Enhanced with capacity scoring and reservation tracking
- **Application Model**: Integration for deployment requirements calculation
- **EnhancedDeploymentService (Task 32)**: Uses CapacityManager for server selection before deployment
- **ResourceDashboard.vue (Task 29)**: Displays server capacity scores and recommendations
- **CapacityPlanner.vue (Task 30)**: Visualizes server selection logic and forecasting

**Why This Task Is Critical:**

Without intelligent capacity management, deployments can overload servers, causing:
- Application crashes from memory exhaustion
- Disk full errors during builds
- Slow deployment times from CPU contention
- Network bottlenecks from bandwidth saturation
- Poor user experience from random server selection

The CapacityManager transforms deployment orchestration from "hope this works" to "intelligently optimized," ensuring resources are used efficiently, deployments succeed predictably, and infrastructure costs are minimized through optimal resource utilization.

**Key Features:**

- **Weighted Scoring Algorithm**: Multi-dimensional server evaluation with configurable weights
- **Real-Time Capacity Analysis**: Live metric integration for up-to-date capacity decisions
- **Build Queue Optimization**: Distribute parallel builds across servers to minimize wait times
- **Resource Reservation**: Track in-flight deployments to prevent over-commitment
- **Capacity Forecasting**: Predict future capacity needs based on deployment trends
- **Organization Quotas**: Enforce resource limits from enterprise licenses
- **Fallback Strategies**: Graceful degradation when capacity is limited
- **Telemetry & Logging**: Detailed scoring breakdown for debugging and optimization

## Acceptance Criteria

- [ ] CapacityManager service implements CapacityManagerInterface with all required methods
- [ ] `selectOptimalServer()` method uses weighted scoring algorithm with 5 dimensions
- [ ] Weighted scoring algorithm: CPU (30%), Memory (30%), Disk (20%), Network (10%), Load (10%)
- [ ] Score calculation range: 0-100, higher scores indicate better capacity
- [ ] Server filtering excludes disabled servers, unreachable servers, and servers over quota
- [ ] Build queue optimization distributes parallel builds across available servers
- [ ] Resource reservation prevents double-booking during concurrent deployments
- [ ] `canServerHandleDeployment()` method validates server capacity before deployment
- [ ] `getServerCapacityScore()` method returns detailed scoring breakdown
- [ ] `forecastCapacityNeeds()` method predicts future capacity requirements
- [ ] Organization quota enforcement integrated with enterprise license limits
- [ ] Fallback to next-best server when optimal server is unavailable
- [ ] Comprehensive error handling for edge cases (no servers, all overloaded, etc.)
- [ ] Performance: Server selection completes in < 100ms for 100 servers
- [ ] Unit tests covering all public methods with >90% coverage

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/CapacityManager.php` (implementation)
- `/home/topgun/topgun/app/Contracts/CapacityManagerInterface.php` (interface)

**Configuration:**
- `/home/topgun/topgun/config/capacity.php` (capacity management settings)

**Models (Enhanced):**
- `/home/topgun/topgun/app/Models/Server.php` (add capacity scoring methods)
- `/home/topgun/topgun/app/Models/Application.php` (add resource requirement methods)

**Database Schema:**
- `/home/topgun/topgun/database/migrations/YYYY_MM_DD_create_capacity_reservations_table.php`

**Service Dependencies:**
- `/home/topgun/topgun/app/Services/Enterprise/SystemResourceMonitor.php` (Task 25)
- `/home/topgun/topgun/app/Services/Enterprise/LicensingService.php` (Task 2 - completed)

### Service Interface

**File:** `app/Contracts/CapacityManagerInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Server;
use App\Models\Application;
use App\Models\Organization;
use Illuminate\Support\Collection;

interface CapacityManagerInterface
{
    /**
     * Select the optimal server for deployment based on capacity
     *
     * @param Collection<Server> $servers Available servers
     * @param array $requirements Resource requirements for deployment
     * @param Organization|null $organization Organization context for quota checking
     * @return Server|null Optimal server or null if none available
     */
    public function selectOptimalServer(
        Collection $servers,
        array $requirements,
        ?Organization $organization = null
    ): ?Server;

    /**
     * Check if a server can handle a specific deployment
     *
     * @param Server $server
     * @param array $requirements Resource requirements
     * @return bool True if server has sufficient capacity
     */
    public function canServerHandleDeployment(Server $server, array $requirements): bool;

    /**
     * Get capacity score for a specific server
     *
     * @param Server $server
     * @return array Score breakdown with total and component scores
     */
    public function getServerCapacityScore(Server $server): array;

    /**
     * Get capacity scores for multiple servers
     *
     * @param Collection<Server> $servers
     * @return Collection<array> Servers with capacity scores
     */
    public function getServerCapacityScores(Collection $servers): Collection;

    /**
     * Reserve resources on a server for deployment
     *
     * @param Server $server
     * @param array $requirements
     * @param string $deploymentId Unique deployment identifier
     * @return bool True if reservation successful
     */
    public function reserveResources(Server $server, array $requirements, string $deploymentId): bool;

    /**
     * Release reserved resources after deployment
     *
     * @param string $deploymentId
     * @return bool True if release successful
     */
    public function releaseResources(string $deploymentId): bool;

    /**
     * Forecast capacity needs based on deployment trends
     *
     * @param Organization $organization
     * @param int $daysAhead Days to forecast
     * @return array Capacity forecast with predicted shortfalls
     */
    public function forecastCapacityNeeds(Organization $organization, int $daysAhead = 30): array;

    /**
     * Optimize build queue distribution across servers
     *
     * @param Collection<Application> $applications Applications waiting to build
     * @param Collection<Server> $servers Available build servers
     * @return array Server assignments for each application
     */
    public function optimizeBuildQueue(Collection $applications, Collection $servers): array;

    /**
     * Check organization resource quota compliance
     *
     * @param Organization $organization
     * @return array Quota usage with limits and availability
     */
    public function checkOrganizationQuota(Organization $organization): array;

    /**
     * Get servers approaching capacity limits
     *
     * @param float $threshold Warning threshold (0-1, e.g., 0.8 for 80%)
     * @return Collection<Server> Servers above threshold
     */
    public function getServersApproachingCapacity(float $threshold = 0.8): Collection;
}
```

### Service Implementation

**File:** `app/Services/Enterprise/CapacityManager.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\CapacityManagerInterface;
use App\Models\Server;
use App\Models\Application;
use App\Models\Organization;
use App\Models\ServerResourceMetric;
use App\Models\CapacityReservation;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class CapacityManager implements CapacityManagerInterface
{
    // Scoring weights (total must equal 1.0)
    private const WEIGHT_CPU = 0.30;
    private const WEIGHT_MEMORY = 0.30;
    private const WEIGHT_DISK = 0.20;
    private const WEIGHT_NETWORK = 0.10;
    private const WEIGHT_LOAD = 0.10;

    // Capacity thresholds
    private const CRITICAL_THRESHOLD = 0.90; // 90% capacity is critical
    private const WARNING_THRESHOLD = 0.80;  // 80% capacity is warning
    private const BUFFER_PERCENTAGE = 0.10;  // Reserve 10% buffer capacity

    // Cache configuration
    private const CACHE_TTL = 300; // 5 minutes
    private const CACHE_PREFIX = 'capacity:';

    public function __construct(
        private SystemResourceMonitor $resourceMonitor,
        private LicensingService $licensingService
    ) {}

    /**
     * Select the optimal server for deployment based on capacity
     */
    public function selectOptimalServer(
        Collection $servers,
        array $requirements,
        ?Organization $organization = null
    ): ?Server {
        Log::info('Selecting optimal server', [
            'server_count' => $servers->count(),
            'requirements' => $requirements,
            'organization_id' => $organization?->id,
        ]);

        // Filter eligible servers
        $eligibleServers = $this->filterEligibleServers($servers, $requirements, $organization);

        if ($eligibleServers->isEmpty()) {
            Log::warning('No eligible servers found for deployment', [
                'original_count' => $servers->count(),
                'requirements' => $requirements,
            ]);
            return null;
        }

        // Calculate capacity scores for all eligible servers
        $scoredServers = $eligibleServers->map(function (Server $server) use ($requirements) {
            $score = $this->calculateCapacityScore($server, $requirements);
            return [
                'server' => $server,
                'score' => $score['total'],
                'breakdown' => $score,
            ];
        });

        // Sort by score descending (highest score = best server)
        $sortedServers = $scoredServers->sortByDesc('score');

        // Select top server
        $optimal = $sortedServers->first();

        if ($optimal) {
            Log::info('Optimal server selected', [
                'server_id' => $optimal['server']->id,
                'server_name' => $optimal['server']->name,
                'score' => $optimal['score'],
                'breakdown' => $optimal['breakdown'],
            ]);

            return $optimal['server'];
        }

        return null;
    }

    /**
     * Check if a server can handle a specific deployment
     */
    public function canServerHandleDeployment(Server $server, array $requirements): bool
    {
        // Get current server metrics
        $metrics = $this->resourceMonitor->getCurrentMetrics($server);

        if (!$metrics) {
            Log::warning('No metrics available for server', ['server_id' => $server->id]);
            return false;
        }

        // Extract requirements
        $requiredCpuCores = $requirements['cpu_cores'] ?? 1;
        $requiredMemoryMb = $requirements['memory_mb'] ?? 512;
        $requiredDiskMb = $requirements['disk_mb'] ?? 1024;

        // Get available resources (accounting for buffer)
        $availableCpu = $this->getAvailableResource(
            $metrics['cpu_cores'],
            $metrics['cpu_used_cores'] ?? 0,
            self::BUFFER_PERCENTAGE
        );

        $availableMemory = $this->getAvailableResource(
            $metrics['memory_total_mb'],
            $metrics['memory_used_mb'] ?? 0,
            self::BUFFER_PERCENTAGE
        );

        $availableDisk = $this->getAvailableResource(
            $metrics['disk_total_mb'],
            $metrics['disk_used_mb'] ?? 0,
            self::BUFFER_PERCENTAGE
        );

        // Check if server has sufficient capacity
        $canHandle = (
            $availableCpu >= $requiredCpuCores &&
            $availableMemory >= $requiredMemoryMb &&
            $availableDisk >= $requiredDiskMb
        );

        Log::debug('Server capacity check', [
            'server_id' => $server->id,
            'can_handle' => $canHandle,
            'available' => [
                'cpu' => $availableCpu,
                'memory' => $availableMemory,
                'disk' => $availableDisk,
            ],
            'required' => [
                'cpu' => $requiredCpuCores,
                'memory' => $requiredMemoryMb,
                'disk' => $requiredDiskMb,
            ],
        ]);

        return $canHandle;
    }

    /**
     * Get capacity score for a specific server
     */
    public function getServerCapacityScore(Server $server): array
    {
        return $this->calculateCapacityScore($server, []);
    }

    /**
     * Get capacity scores for multiple servers
     */
    public function getServerCapacityScores(Collection $servers): Collection
    {
        return $servers->map(function (Server $server) {
            return [
                'server_id' => $server->id,
                'server_name' => $server->name,
                'score' => $this->getServerCapacityScore($server),
            ];
        });
    }

    /**
     * Reserve resources on a server for deployment
     */
    public function reserveResources(Server $server, array $requirements, string $deploymentId): bool
    {
        try {
            CapacityReservation::create([
                'server_id' => $server->id,
                'deployment_id' => $deploymentId,
                'cpu_cores_reserved' => $requirements['cpu_cores'] ?? 0,
                'memory_mb_reserved' => $requirements['memory_mb'] ?? 0,
                'disk_mb_reserved' => $requirements['disk_mb'] ?? 0,
                'reserved_at' => now(),
                'expires_at' => now()->addHours(2), // Reservation expires after 2 hours
            ]);

            Log::info('Resources reserved on server', [
                'server_id' => $server->id,
                'deployment_id' => $deploymentId,
                'requirements' => $requirements,
            ]);

            // Invalidate capacity cache for this server
            $this->invalidateServerCache($server);

            return true;

        } catch (\Exception $e) {
            Log::error('Failed to reserve resources', [
                'server_id' => $server->id,
                'deployment_id' => $deploymentId,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Release reserved resources after deployment
     */
    public function releaseResources(string $deploymentId): bool
    {
        try {
            $reservation = CapacityReservation::where('deployment_id', $deploymentId)->first();

            if (!$reservation) {
                Log::warning('No reservation found for deployment', ['deployment_id' => $deploymentId]);
                return false;
            }

            $serverId = $reservation->server_id;
            $reservation->delete();

            Log::info('Resources released', [
                'deployment_id' => $deploymentId,
                'server_id' => $serverId,
            ]);

            // Invalidate capacity cache
            $this->invalidateServerCache(Server::find($serverId));

            return true;

        } catch (\Exception $e) {
            Log::error('Failed to release resources', [
                'deployment_id' => $deploymentId,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Forecast capacity needs based on deployment trends
     */
    public function forecastCapacityNeeds(Organization $organization, int $daysAhead = 30): array
    {
        // Get historical deployment data
        $historicalDeployments = DB::table('deployments')
            ->join('applications', 'deployments.application_id', '=', 'applications.id')
            ->where('applications.organization_id', $organization->id)
            ->where('deployments.created_at', '>=', now()->subDays(30))
            ->select([
                DB::raw('DATE(deployments.created_at) as date'),
                DB::raw('COUNT(*) as deployment_count'),
                DB::raw('AVG(deployments.cpu_cores_used) as avg_cpu'),
                DB::raw('AVG(deployments.memory_mb_used) as avg_memory'),
                DB::raw('AVG(deployments.disk_mb_used) as avg_disk'),
            ])
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Calculate trend (simple linear regression)
        $trend = $this->calculateTrend($historicalDeployments);

        // Project future needs
        $forecastedNeeds = [];
        $baseDate = now();

        for ($day = 1; $day <= $daysAhead; $day++) {
            $date = $baseDate->copy()->addDays($day);
            $forecastedCount = max(0, $trend['intercept'] + ($trend['slope'] * $day));

            $forecastedNeeds[] = [
                'date' => $date->toDateString(),
                'predicted_deployments' => round($forecastedCount),
                'predicted_cpu_cores' => round($forecastedCount * ($trend['avg_cpu'] ?? 1)),
                'predicted_memory_mb' => round($forecastedCount * ($trend['avg_memory'] ?? 512)),
                'predicted_disk_mb' => round($forecastedCount * ($trend['avg_disk'] ?? 1024)),
            ];
        }

        // Check current capacity vs forecasted needs
        $currentCapacity = $this->getOrganizationTotalCapacity($organization);

        return [
            'historical_data' => $historicalDeployments,
            'forecast' => $forecastedNeeds,
            'current_capacity' => $currentCapacity,
            'capacity_shortfall' => $this->identifyCapacityShortfalls($forecastedNeeds, $currentCapacity),
        ];
    }

    /**
     * Optimize build queue distribution across servers
     */
    public function optimizeBuildQueue(Collection $applications, Collection $servers): array
    {
        $assignments = [];

        // Sort servers by current build queue length (ascending)
        $sortedServers = $servers->sortBy(function (Server $server) {
            return $server->builds()->where('status', 'running')->count();
        });

        // Assign each application to the server with the lightest load
        foreach ($applications as $application) {
            $requirements = [
                'cpu_cores' => $application->estimated_cpu_cores ?? 1,
                'memory_mb' => $application->estimated_memory_mb ?? 1024,
                'disk_mb' => $application->estimated_disk_mb ?? 2048,
            ];

            // Select optimal server for this build
            $server = $this->selectOptimalServer($sortedServers, $requirements);

            if ($server) {
                $assignments[] = [
                    'application_id' => $application->id,
                    'application_name' => $application->name,
                    'server_id' => $server->id,
                    'server_name' => $server->name,
                    'requirements' => $requirements,
                ];

                // Update server's perceived load for next iteration
                $sortedServers = $sortedServers->map(function ($s) use ($server) {
                    if ($s->id === $server->id) {
                        // Increment perceived build count
                        $s->setAttribute('_perceived_build_count', ($s->_perceived_build_count ?? 0) + 1);
                    }
                    return $s;
                })->sortBy('_perceived_build_count');
            }
        }

        Log::info('Build queue optimized', [
            'applications_count' => $applications->count(),
            'assignments_count' => count($assignments),
        ]);

        return $assignments;
    }

    /**
     * Check organization resource quota compliance
     */
    public function checkOrganizationQuota(Organization $organization): array
    {
        // Get license quotas
        $license = $organization->enterpriseLicense;

        if (!$license) {
            return [
                'has_quota' => false,
                'message' => 'No enterprise license found',
            ];
        }

        // Extract quota limits
        $quotas = $license->resource_quotas ?? [];
        $maxServers = $quotas['max_servers'] ?? null;
        $maxApplications = $quotas['max_applications'] ?? null;
        $maxDeploymentsPerMonth = $quotas['max_deployments_per_month'] ?? null;

        // Get current usage
        $currentServers = $organization->servers()->count();
        $currentApplications = $organization->applications()->count();
        $deploymentsThisMonth = DB::table('deployments')
            ->join('applications', 'deployments.application_id', '=', 'applications.id')
            ->where('applications.organization_id', $organization->id)
            ->where('deployments.created_at', '>=', now()->startOfMonth())
            ->count();

        // Calculate availability
        return [
            'has_quota' => true,
            'servers' => [
                'used' => $currentServers,
                'limit' => $maxServers,
                'available' => $maxServers ? max(0, $maxServers - $currentServers) : null,
                'percentage' => $maxServers ? min(100, ($currentServers / $maxServers) * 100) : 0,
            ],
            'applications' => [
                'used' => $currentApplications,
                'limit' => $maxApplications,
                'available' => $maxApplications ? max(0, $maxApplications - $currentApplications) : null,
                'percentage' => $maxApplications ? min(100, ($currentApplications / $maxApplications) * 100) : 0,
            ],
            'deployments_this_month' => [
                'used' => $deploymentsThisMonth,
                'limit' => $maxDeploymentsPerMonth,
                'available' => $maxDeploymentsPerMonth ? max(0, $maxDeploymentsPerMonth - $deploymentsThisMonth) : null,
                'percentage' => $maxDeploymentsPerMonth ? min(100, ($deploymentsThisMonth / $maxDeploymentsPerMonth) * 100) : 0,
            ],
        ];
    }

    /**
     * Get servers approaching capacity limits
     */
    public function getServersApproachingCapacity(float $threshold = 0.8): Collection
    {
        $allServers = Server::where('status', 'running')->get();

        return $allServers->filter(function (Server $server) use ($threshold) {
            $score = $this->getServerCapacityScore($server);
            $utilizationPercentage = 1 - ($score['total'] / 100); // Convert score to utilization

            return $utilizationPercentage >= $threshold;
        });
    }

    // Private helper methods

    /**
     * Filter servers that are eligible for deployment
     */
    private function filterEligibleServers(
        Collection $servers,
        array $requirements,
        ?Organization $organization
    ): Collection {
        return $servers->filter(function (Server $server) use ($requirements, $organization) {
            // Check server is running
            if ($server->status !== 'running') {
                return false;
            }

            // Check server is reachable
            if (!$server->is_reachable) {
                return false;
            }

            // Check basic capacity requirements
            if (!$this->canServerHandleDeployment($server, $requirements)) {
                return false;
            }

            // Check organization quota if applicable
            if ($organization) {
                $quota = $this->checkOrganizationQuota($organization);
                if (
                    $quota['has_quota'] &&
                    isset($quota['servers']) &&
                    $quota['servers']['available'] !== null &&
                    $quota['servers']['available'] <= 0
                ) {
                    return false;
                }
            }

            return true;
        });
    }

    /**
     * Calculate capacity score for a server
     *
     * @return array Score breakdown with total and component scores (0-100)
     */
    private function calculateCapacityScore(Server $server, array $requirements): array
    {
        $cacheKey = self::CACHE_PREFIX . "score:{$server->id}";

        return Cache::remember($cacheKey, self::CACHE_TTL, function () use ($server, $requirements) {
            $metrics = $this->resourceMonitor->getCurrentMetrics($server);

            if (!$metrics) {
                return [
                    'total' => 0,
                    'cpu' => 0,
                    'memory' => 0,
                    'disk' => 0,
                    'network' => 0,
                    'load' => 0,
                ];
            }

            // Calculate individual dimension scores (0-100)
            $cpuScore = $this->calculateResourceScore(
                $metrics['cpu_cores'],
                $metrics['cpu_used_cores'] ?? 0,
                $requirements['cpu_cores'] ?? 0
            );

            $memoryScore = $this->calculateResourceScore(
                $metrics['memory_total_mb'],
                $metrics['memory_used_mb'] ?? 0,
                $requirements['memory_mb'] ?? 0
            );

            $diskScore = $this->calculateResourceScore(
                $metrics['disk_total_mb'],
                $metrics['disk_used_mb'] ?? 0,
                $requirements['disk_mb'] ?? 0
            );

            $networkScore = $this->calculateNetworkScore($server);
            $loadScore = $this->calculateLoadScore($server);

            // Calculate weighted total score
            $totalScore = (
                ($cpuScore * self::WEIGHT_CPU) +
                ($memoryScore * self::WEIGHT_MEMORY) +
                ($diskScore * self::WEIGHT_DISK) +
                ($networkScore * self::WEIGHT_NETWORK) +
                ($loadScore * self::WEIGHT_LOAD)
            );

            return [
                'total' => round($totalScore, 2),
                'cpu' => round($cpuScore, 2),
                'memory' => round($memoryScore, 2),
                'disk' => round($diskScore, 2),
                'network' => round($networkScore, 2),
                'load' => round($loadScore, 2),
            ];
        });
    }

    /**
     * Calculate resource score for CPU/Memory/Disk
     *
     * @param float $total Total resource capacity
     * @param float $used Currently used resources
     * @param float $required Required resources for this deployment
     * @return float Score 0-100
     */
    private function calculateResourceScore(float $total, float $used, float $required): float
    {
        if ($total <= 0) {
            return 0;
        }

        // Calculate available resources after buffer
        $available = $this->getAvailableResource($total, $used, self::BUFFER_PERCENTAGE);

        // If required resources exceed available, score is 0
        if ($required > $available) {
            return 0;
        }

        // Calculate utilization percentage (0-1)
        $utilization = ($used + $required) / $total;

        // Score decreases as utilization increases
        // Score = 100 at 0% utilization, 0 at 100% utilization
        $score = max(0, (1 - $utilization) * 100);

        return $score;
    }

    /**
     * Calculate network score based on bandwidth utilization
     */
    private function calculateNetworkScore(Server $server): float
    {
        $metrics = $this->resourceMonitor->getCurrentMetrics($server);

        if (!$metrics || !isset($metrics['network_bandwidth_mbps'])) {
            return 50; // Neutral score if no data
        }

        $totalBandwidth = $metrics['network_bandwidth_mbps'];
        $usedBandwidth = $metrics['network_used_mbps'] ?? 0;

        if ($totalBandwidth <= 0) {
            return 50;
        }

        $utilization = $usedBandwidth / $totalBandwidth;
        $score = max(0, (1 - $utilization) * 100);

        return $score;
    }

    /**
     * Calculate load score based on active deployments and queue length
     */
    private function calculateLoadScore(Server $server): float
    {
        // Get active deployments count
        $activeDeployments = $server->deployments()
            ->whereIn('status', ['running', 'building'])
            ->count();

        // Get build queue length
        $queueLength = $server->builds()
            ->whereIn('status', ['queued', 'waiting'])
            ->count();

        // Calculate load penalty
        // Penalize 10 points per active deployment, 5 points per queued build
        $loadPenalty = ($activeDeployments * 10) + ($queueLength * 5);

        // Base score is 100, reduced by load
        $score = max(0, 100 - $loadPenalty);

        return $score;
    }

    /**
     * Get available resource accounting for buffer
     */
    private function getAvailableResource(float $total, float $used, float $bufferPercentage): float
    {
        $buffer = $total * $bufferPercentage;
        $usableCapacity = $total - $buffer;
        $available = max(0, $usableCapacity - $used);

        return $available;
    }

    /**
     * Calculate trend from historical data using linear regression
     */
    private function calculateTrend(Collection $historicalData): array
    {
        if ($historicalData->isEmpty()) {
            return [
                'slope' => 0,
                'intercept' => 0,
                'avg_cpu' => 1,
                'avg_memory' => 512,
                'avg_disk' => 1024,
            ];
        }

        $n = $historicalData->count();
        $sumX = 0;
        $sumY = 0;
        $sumXY = 0;
        $sumX2 = 0;

        foreach ($historicalData as $index => $data) {
            $x = $index + 1; // Day number
            $y = $data->deployment_count;

            $sumX += $x;
            $sumY += $y;
            $sumXY += ($x * $y);
            $sumX2 += ($x * $x);
        }

        // Linear regression: y = mx + b
        $slope = ($n * $sumXY - $sumX * $sumY) / ($n * $sumX2 - $sumX * $sumX);
        $intercept = ($sumY - $slope * $sumX) / $n;

        // Calculate averages
        $avgCpu = $historicalData->avg('avg_cpu') ?? 1;
        $avgMemory = $historicalData->avg('avg_memory') ?? 512;
        $avgDisk = $historicalData->avg('avg_disk') ?? 1024;

        return [
            'slope' => $slope,
            'intercept' => $intercept,
            'avg_cpu' => $avgCpu,
            'avg_memory' => $avgMemory,
            'avg_disk' => $avgDisk,
        ];
    }

    /**
     * Get total capacity for organization servers
     */
    private function getOrganizationTotalCapacity(Organization $organization): array
    {
        $servers = $organization->servers()->where('status', 'running')->get();

        $totalCpu = 0;
        $totalMemory = 0;
        $totalDisk = 0;

        foreach ($servers as $server) {
            $metrics = $this->resourceMonitor->getCurrentMetrics($server);
            if ($metrics) {
                $totalCpu += $metrics['cpu_cores'] ?? 0;
                $totalMemory += $metrics['memory_total_mb'] ?? 0;
                $totalDisk += $metrics['disk_total_mb'] ?? 0;
            }
        }

        return [
            'total_cpu_cores' => $totalCpu,
            'total_memory_mb' => $totalMemory,
            'total_disk_mb' => $totalDisk,
            'server_count' => $servers->count(),
        ];
    }

    /**
     * Identify capacity shortfalls in forecast
     */
    private function identifyCapacityShortfalls(array $forecast, array $currentCapacity): array
    {
        $shortfalls = [];

        foreach ($forecast as $day) {
            $shortfall = [];

            if ($day['predicted_cpu_cores'] > $currentCapacity['total_cpu_cores']) {
                $shortfall['cpu_cores'] = $day['predicted_cpu_cores'] - $currentCapacity['total_cpu_cores'];
            }

            if ($day['predicted_memory_mb'] > $currentCapacity['total_memory_mb']) {
                $shortfall['memory_mb'] = $day['predicted_memory_mb'] - $currentCapacity['total_memory_mb'];
            }

            if ($day['predicted_disk_mb'] > $currentCapacity['total_disk_mb']) {
                $shortfall['disk_mb'] = $day['predicted_disk_mb'] - $currentCapacity['total_disk_mb'];
            }

            if (!empty($shortfall)) {
                $shortfalls[] = [
                    'date' => $day['date'],
                    'shortfall' => $shortfall,
                ];
            }
        }

        return $shortfalls;
    }

    /**
     * Invalidate cache for a specific server
     */
    private function invalidateServerCache(?Server $server): void
    {
        if ($server) {
            Cache::forget(self::CACHE_PREFIX . "score:{$server->id}");
        }
    }
}
```

### Database Migration - Capacity Reservations

**File:** `database/migrations/YYYY_MM_DD_create_capacity_reservations_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('capacity_reservations', function (Blueprint $table) {
            $table->id();
            $table->foreignId('server_id')->constrained()->onDelete('cascade');
            $table->string('deployment_id')->index();
            $table->decimal('cpu_cores_reserved', 8, 2)->default(0);
            $table->bigInteger('memory_mb_reserved')->default(0);
            $table->bigInteger('disk_mb_reserved')->default(0);
            $table->timestamp('reserved_at');
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();

            $table->index(['server_id', 'expires_at']);
            $table->unique('deployment_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('capacity_reservations');
    }
};
```

### Model - CapacityReservation

**File:** `app/Models/CapacityReservation.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CapacityReservation extends Model
{
    protected $fillable = [
        'server_id',
        'deployment_id',
        'cpu_cores_reserved',
        'memory_mb_reserved',
        'disk_mb_reserved',
        'reserved_at',
        'expires_at',
    ];

    protected $casts = [
        'cpu_cores_reserved' => 'float',
        'memory_mb_reserved' => 'integer',
        'disk_mb_reserved' => 'integer',
        'reserved_at' => 'datetime',
        'expires_at' => 'datetime',
    ];

    public function server(): BelongsTo
    {
        return $this->belongsTo(Server::class);
    }

    /**
     * Check if reservation has expired
     */
    public function isExpired(): bool
    {
        return $this->expires_at && $this->expires_at->isPast();
    }

    /**
     * Scope to get active reservations
     */
    public function scopeActive($query)
    {
        return $query->where(function ($q) {
            $q->whereNull('expires_at')
                ->orWhere('expires_at', '>', now());
        });
    }
}
```

### Configuration File

**File:** `config/capacity.php`

```php
<?php

return [
    // Scoring weights (must sum to 1.0)
    'scoring_weights' => [
        'cpu' => env('CAPACITY_WEIGHT_CPU', 0.30),
        'memory' => env('CAPACITY_WEIGHT_MEMORY', 0.30),
        'disk' => env('CAPACITY_WEIGHT_DISK', 0.20),
        'network' => env('CAPACITY_WEIGHT_NETWORK', 0.10),
        'load' => env('CAPACITY_WEIGHT_LOAD', 0.10),
    ],

    // Capacity thresholds (0-1)
    'thresholds' => [
        'critical' => env('CAPACITY_THRESHOLD_CRITICAL', 0.90),
        'warning' => env('CAPACITY_THRESHOLD_WARNING', 0.80),
        'buffer_percentage' => env('CAPACITY_BUFFER_PERCENTAGE', 0.10),
    ],

    // Cache settings
    'cache' => [
        'enabled' => env('CAPACITY_CACHE_ENABLED', true),
        'ttl' => env('CAPACITY_CACHE_TTL', 300), // 5 minutes
        'prefix' => 'capacity:',
    ],

    // Reservation settings
    'reservations' => [
        'enabled' => env('CAPACITY_RESERVATIONS_ENABLED', true),
        'default_expiry_hours' => env('CAPACITY_RESERVATION_EXPIRY_HOURS', 2),
    ],

    // Forecasting settings
    'forecasting' => [
        'enabled' => env('CAPACITY_FORECASTING_ENABLED', true),
        'default_days_ahead' => env('CAPACITY_FORECAST_DAYS', 30),
        'historical_days' => env('CAPACITY_HISTORICAL_DAYS', 30),
    ],
];
```

### Enhanced Server Model Methods

**File:** `app/Models/Server.php` (add these methods)

```php
/**
 * Get active capacity reservations for this server
 */
public function activeReservations()
{
    return $this->hasMany(CapacityReservation::class)->active();
}

/**
 * Get total reserved resources
 */
public function getReservedResources(): array
{
    $reservations = $this->activeReservations()->get();

    return [
        'cpu_cores' => $reservations->sum('cpu_cores_reserved'),
        'memory_mb' => $reservations->sum('memory_mb_reserved'),
        'disk_mb' => $reservations->sum('disk_mb_reserved'),
    ];
}

/**
 * Check if server is approaching capacity
 */
public function isApproachingCapacity(float $threshold = 0.8): bool
{
    $capacityManager = app(\App\Contracts\CapacityManagerInterface::class);
    $score = $capacityManager->getServerCapacityScore($this);

    $utilizationPercentage = 1 - ($score['total'] / 100);

    return $utilizationPercentage >= $threshold;
}
```

## Implementation Approach

### Step 1: Create Service Interface
1. Create `app/Contracts/CapacityManagerInterface.php`
2. Define all public method signatures
3. Document each method with comprehensive PHPDoc blocks
4. Specify return types and parameter types precisely

### Step 2: Create Database Migration
1. Create `capacity_reservations` table migration
2. Add indexes for performance (server_id, deployment_id, expires_at)
3. Add foreign keys with cascade deletes
4. Run migration: `php artisan migrate`

### Step 3: Create CapacityReservation Model
1. Create model in `app/Models/CapacityReservation.php`
2. Define fillable fields and casts
3. Add relationship to Server
4. Add `active()` query scope for non-expired reservations
5. Add helper method `isExpired()`

### Step 4: Implement Core Service Methods
1. Create `app/Services/Enterprise/CapacityManager.php`
2. Implement `selectOptimalServer()` with filtering and scoring
3. Implement `canServerHandleDeployment()` with buffer logic
4. Implement `getServerCapacityScore()` with caching
5. Add scoring calculation methods for each dimension

### Step 5: Implement Reservation System
1. Implement `reserveResources()` with database persistence
2. Implement `releaseResources()` with cache invalidation
3. Add expiry logic for abandoned reservations
4. Create cleanup job for expired reservations

### Step 6: Implement Advanced Features
1. Implement `forecastCapacityNeeds()` with linear regression
2. Implement `optimizeBuildQueue()` with load balancing
3. Implement `checkOrganizationQuota()` with license integration
4. Implement `getServersApproachingCapacity()` with threshold filtering

### Step 7: Add Configuration and Caching
1. Create `config/capacity.php` with all settings
2. Implement Redis caching for capacity scores
3. Add cache invalidation on metric updates
4. Add environment variables to `.env.example`

### Step 8: Enhance Server Model
1. Add `activeReservations()` relationship
2. Add `getReservedResources()` helper method
3. Add `isApproachingCapacity()` helper method

### Step 9: Register Service
1. Add service binding in `EnterpriseServiceProvider`
2. Bind interface to implementation as singleton
3. Verify dependency injection works correctly

### Step 10: Testing
1. Unit tests for all service methods (>90% coverage)
2. Test scoring algorithm with various server states
3. Test reservation system with concurrent deployments
4. Test forecasting with mock historical data
5. Integration tests with real Server and Application models

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/CapacityManagerTest.php`

```php
<?php

use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\SystemResourceMonitor;
use App\Services\Enterprise\LicensingService;
use App\Models\Server;
use App\Models\Organization;
use App\Models\CapacityReservation;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    $this->resourceMonitor = Mockery::mock(SystemResourceMonitor::class);
    $this->licensingService = Mockery::mock(LicensingService::class);
    $this->service = new CapacityManager($this->resourceMonitor, $this->licensingService);
});

it('selects optimal server based on capacity scores', function () {
    $server1 = Server::factory()->create(['name' => 'Server 1']);
    $server2 = Server::factory()->create(['name' => 'Server 2']);
    $server3 = Server::factory()->create(['name' => 'Server 3']);

    // Mock metrics - server2 has best capacity
    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->with($server1)
        ->andReturn([
            'cpu_cores' => 4,
            'cpu_used_cores' => 3,
            'memory_total_mb' => 8192,
            'memory_used_mb' => 6000,
            'disk_total_mb' => 100000,
            'disk_used_mb' => 80000,
        ]);

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->with($server2)
        ->andReturn([
            'cpu_cores' => 8,
            'cpu_used_cores' => 2,
            'memory_total_mb' => 16384,
            'memory_used_mb' => 4000,
            'disk_total_mb' => 200000,
            'disk_used_mb' => 50000,
        ]);

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->with($server3)
        ->andReturn([
            'cpu_cores' => 4,
            'cpu_used_cores' => 3.5,
            'memory_total_mb' => 8192,
            'memory_used_mb' => 7000,
            'disk_total_mb' => 100000,
            'disk_used_mb' => 90000,
        ]);

    $servers = collect([$server1, $server2, $server3]);
    $requirements = [
        'cpu_cores' => 1,
        'memory_mb' => 1024,
        'disk_mb' => 5000,
    ];

    $optimalServer = $this->service->selectOptimalServer($servers, $requirements);

    expect($optimalServer->id)->toBe($server2->id)
        ->and($optimalServer->name)->toBe('Server 2');
});

it('returns null when no servers meet requirements', function () {
    $server = Server::factory()->create();

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->andReturn([
            'cpu_cores' => 2,
            'cpu_used_cores' => 1.9,
            'memory_total_mb' => 4096,
            'memory_used_mb' => 3900,
            'disk_total_mb' => 50000,
            'disk_used_mb' => 48000,
        ]);

    $servers = collect([$server]);
    $requirements = [
        'cpu_cores' => 2,
        'memory_mb' => 4096,
        'disk_mb' => 10000,
    ];

    $optimalServer = $this->service->selectOptimalServer($servers, $requirements);

    expect($optimalServer)->toBeNull();
});

it('checks if server can handle deployment', function () {
    $server = Server::factory()->create();

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->andReturn([
            'cpu_cores' => 4,
            'cpu_used_cores' => 1,
            'memory_total_mb' => 8192,
            'memory_used_mb' => 2048,
            'disk_total_mb' => 100000,
            'disk_used_mb' => 30000,
        ]);

    $requirements = [
        'cpu_cores' => 1,
        'memory_mb' => 1024,
        'disk_mb' => 5000,
    ];

    $canHandle = $this->service->canServerHandleDeployment($server, $requirements);

    expect($canHandle)->toBeTrue();
});

it('calculates server capacity score correctly', function () {
    $server = Server::factory()->create();

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->andReturn([
            'cpu_cores' => 8,
            'cpu_used_cores' => 2,
            'memory_total_mb' => 16384,
            'memory_used_mb' => 4096,
            'disk_total_mb' => 200000,
            'disk_used_mb' => 50000,
            'network_bandwidth_mbps' => 1000,
            'network_used_mbps' => 100,
        ]);

    $score = $this->service->getServerCapacityScore($server);

    expect($score)
        ->toHaveKeys(['total', 'cpu', 'memory', 'disk', 'network', 'load'])
        ->and($score['total'])->toBeGreaterThan(50)
        ->and($score['total'])->toBeLessThanOrEqual(100);
});

it('reserves resources on server', function () {
    $server = Server::factory()->create();
    $deploymentId = 'deployment-12345';

    $requirements = [
        'cpu_cores' => 2,
        'memory_mb' => 2048,
        'disk_mb' => 10000,
    ];

    $result = $this->service->reserveResources($server, $requirements, $deploymentId);

    expect($result)->toBeTrue();

    $this->assertDatabaseHas('capacity_reservations', [
        'server_id' => $server->id,
        'deployment_id' => $deploymentId,
        'cpu_cores_reserved' => 2,
        'memory_mb_reserved' => 2048,
        'disk_mb_reserved' => 10000,
    ]);
});

it('releases reserved resources', function () {
    $server = Server::factory()->create();
    $deploymentId = 'deployment-67890';

    CapacityReservation::create([
        'server_id' => $server->id,
        'deployment_id' => $deploymentId,
        'cpu_cores_reserved' => 1,
        'memory_mb_reserved' => 1024,
        'disk_mb_reserved' => 5000,
        'reserved_at' => now(),
        'expires_at' => now()->addHours(2),
    ]);

    $result = $this->service->releaseResources($deploymentId);

    expect($result)->toBeTrue();

    $this->assertDatabaseMissing('capacity_reservations', [
        'deployment_id' => $deploymentId,
    ]);
});

it('forecasts capacity needs based on trends', function () {
    $organization = Organization::factory()->create();

    // Mock historical deployment data
    DB::table('deployments')->insert([
        // Insert mock deployment history
    ]);

    $forecast = $this->service->forecastCapacityNeeds($organization, 7);

    expect($forecast)
        ->toHaveKeys(['historical_data', 'forecast', 'current_capacity', 'capacity_shortfall'])
        ->and($forecast['forecast'])->toHaveCount(7);
});

it('optimizes build queue distribution', function () {
    $server1 = Server::factory()->create();
    $server2 = Server::factory()->create();

    $app1 = Application::factory()->create();
    $app2 = Application::factory()->create();
    $app3 = Application::factory()->create();

    $applications = collect([$app1, $app2, $app3]);
    $servers = collect([$server1, $server2]);

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')->andReturn([
        'cpu_cores' => 8,
        'cpu_used_cores' => 2,
        'memory_total_mb' => 16384,
        'memory_used_mb' => 4096,
        'disk_total_mb' => 200000,
        'disk_used_mb' => 50000,
    ]);

    $assignments = $this->service->optimizeBuildQueue($applications, $servers);

    expect($assignments)->toHaveCount(3)
        ->and($assignments[0])->toHaveKeys(['application_id', 'server_id', 'requirements']);
});

it('checks organization quota compliance', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'resource_quotas' => [
            'max_servers' => 10,
            'max_applications' => 50,
            'max_deployments_per_month' => 500,
        ],
    ]);

    $quota = $this->service->checkOrganizationQuota($organization);

    expect($quota)
        ->toHaveKey('has_quota', true)
        ->toHaveKeys(['servers', 'applications', 'deployments_this_month']);
});

it('identifies servers approaching capacity', function () {
    $server1 = Server::factory()->create(['status' => 'running']);
    $server2 = Server::factory()->create(['status' => 'running']);

    // Server1 is at 90% capacity, Server2 at 50%
    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->with($server1)
        ->andReturn([
            'cpu_cores' => 4,
            'cpu_used_cores' => 3.6,
            'memory_total_mb' => 8192,
            'memory_used_mb' => 7372,
            'disk_total_mb' => 100000,
            'disk_used_mb' => 90000,
        ]);

    $this->resourceMonitor->shouldReceive('getCurrentMetrics')
        ->with($server2)
        ->andReturn([
            'cpu_cores' => 8,
            'cpu_used_cores' => 4,
            'memory_total_mb' => 16384,
            'memory_used_mb' => 8192,
            'disk_total_mb' => 200000,
            'disk_used_mb' => 100000,
        ]);

    $servers = $this->service->getServersApproachingCapacity(0.8);

    expect($servers)->toHaveCount(1)
        ->and($servers->first()->id)->toBe($server1->id);
});
```

### Integration Tests

**File:** `tests/Feature/CapacityManagementTest.php`

```php
<?php

use App\Services\Enterprise\CapacityManager;
use App\Models\Server;
use App\Models\Application;
use App\Models\Organization;

it('completes full server selection workflow', function () {
    $organization = Organization::factory()->create();

    $server1 = Server::factory()->create([
        'organization_id' => $organization->id,
        'status' => 'running',
        'is_reachable' => true,
    ]);

    $server2 = Server::factory()->create([
        'organization_id' => $organization->id,
        'status' => 'running',
        'is_reachable' => true,
    ]);

    // Create resource metrics
    ServerResourceMetric::factory()->create([
        'server_id' => $server1->id,
        'cpu_cores' => 4,
        'cpu_used_cores' => 2,
        'memory_total_mb' => 8192,
        'memory_used_mb' => 4096,
        'disk_total_mb' => 100000,
        'disk_used_mb' => 50000,
    ]);

    ServerResourceMetric::factory()->create([
        'server_id' => $server2->id,
        'cpu_cores' => 8,
        'cpu_used_cores' => 1,
        'memory_total_mb' => 16384,
        'memory_used_mb' => 2048,
        'disk_total_mb' => 200000,
        'disk_used_mb' => 30000,
    ]);

    $capacityManager = app(CapacityManager::class);

    $requirements = [
        'cpu_cores' => 2,
        'memory_mb' => 2048,
        'disk_mb' => 10000,
    ];

    // Select optimal server
    $selectedServer = $capacityManager->selectOptimalServer(
        $organization->servers,
        $requirements,
        $organization
    );

    expect($selectedServer)->not->toBeNull()
        ->and($selectedServer->id)->toBe($server2->id); // Server2 has better capacity

    // Reserve resources
    $deployed = $capacityManager->reserveResources(
        $selectedServer,
        $requirements,
        'deployment-test-123'
    );

    expect($deployed)->toBeTrue();

    // Verify reservation
    $this->assertDatabaseHas('capacity_reservations', [
        'server_id' => $selectedServer->id,
        'deployment_id' => 'deployment-test-123',
    ]);

    // Release resources
    $released = $capacityManager->releaseResources('deployment-test-123');

    expect($released)->toBeTrue();

    $this->assertDatabaseMissing('capacity_reservations', [
        'deployment_id' => 'deployment-test-123',
    ]);
});
```

## Definition of Done

- [ ] CapacityManagerInterface created with all method signatures
- [ ] CapacityManager service implementation complete
- [ ] Weighted scoring algorithm implemented (CPU 30%, Memory 30%, Disk 20%, Network 10%, Load 10%)
- [ ] `selectOptimalServer()` method working with filtering and scoring
- [ ] `canServerHandleDeployment()` method validating capacity
- [ ] `getServerCapacityScore()` method returning detailed breakdown
- [ ] `getServerCapacityScores()` method for batch scoring
- [ ] `reserveResources()` method with database persistence
- [ ] `releaseResources()` method with cache invalidation
- [ ] `forecastCapacityNeeds()` method with linear regression
- [ ] `optimizeBuildQueue()` method distributing builds optimally
- [ ] `checkOrganizationQuota()` method integrated with licensing
- [ ] `getServersApproachingCapacity()` method with threshold filtering
- [ ] CapacityReservation model created with relationships
- [ ] Database migration created and run successfully
- [ ] Configuration file created (`config/capacity.php`)
- [ ] Redis caching implemented for capacity scores
- [ ] Cache invalidation on metric updates working
- [ ] Server model enhanced with capacity methods
- [ ] Buffer percentage (10%) applied to capacity calculations
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Unit tests written (>90% coverage, 15+ tests)
- [ ] Integration tests written (full workflow coverage, 5+ tests)
- [ ] Performance verified (< 100ms for 100 servers)
- [ ] PHPDoc blocks complete for all public methods
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing completed with real server metrics
- [ ] Documentation updated
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 25 (SystemResourceMonitor service provides metrics)
- **Used by:** Task 32 (EnhancedDeploymentService uses CapacityManager)
- **Used by:** Task 36 (Pre-deployment capacity validation)
- **Visualized by:** Task 29 (ResourceDashboard.vue displays capacity scores)
- **Visualized by:** Task 30 (CapacityPlanner.vue shows server selection)
- **Integrated with:** Task 27 (Server scoring logic implementation)
- **Integrated with:** Task 28 (Organization quota enforcement)
