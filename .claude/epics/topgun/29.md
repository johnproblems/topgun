---
name: Build ResourceDashboard.vue with ApexCharts for metrics visualization
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:48Z
github: https://github.com/johnproblems/topgun/issues/139
depends_on: [25]
parallel: true
conflicts_with: []
---

# Task: Build ResourceDashboard.vue with ApexCharts for metrics visualization

## Description

Create a comprehensive real-time resource monitoring dashboard using Vue.js 3, ApexCharts, and Laravel Reverb for WebSocket communication. This dashboard provides organization administrators and DevOps teams with live visibility into server resource utilization, capacity trends, and system health across their entire infrastructure.

The ResourceDashboard.vue component serves as the central monitoring interface for the enterprise transformation project, displaying:

1. **Real-Time Metrics Visualization** - Live CPU, memory, disk, and network usage charts updated via WebSocket
2. **Multi-Server Overview** - Aggregate resource metrics across all servers in an organization
3. **Historical Trend Analysis** - Time-series data showing resource patterns over 1h, 6h, 24h, 7d, 30d periods
4. **Capacity Forecasting** - Predictive analytics showing when servers will reach capacity limits
5. **Alert Threshold Management** - Visual indicators when resources exceed configured thresholds
6. **Drill-Down Capability** - Click-to-expand detail views for individual server metrics

**Integration with Enterprise Architecture:**

- **Data Source:** SystemResourceMonitor service (Task 25) provides time-series metrics from `server_resource_metrics` table
- **Real-Time Updates:** Laravel Reverb broadcasts metric updates every 30 seconds via WebSocket channels
- **Capacity Context:** Integration with CapacityManager service for server scoring visualization
- **Organization Scoping:** Automatic filtering to show only organization-owned servers
- **Access Control:** Role-based visibility (admins see all servers, developers see assigned projects)

**Why This Task is Important:**

Without real-time monitoring visibility, organizations operate blind—unable to detect resource bottlenecks until applications crash or deployments fail. This dashboard transforms reactive firefighting into proactive capacity management. Administrators can:

- Identify underutilized servers for cost optimization
- Detect capacity constraints before they impact deployments
- Correlate resource spikes with application events
- Make data-driven infrastructure scaling decisions
- Monitor SLA compliance with resource quotas

The dashboard leverages ApexCharts for production-grade visualizations (smooth animations, responsive design, export capabilities) and Laravel Reverb for low-latency real-time updates without polling overhead. This combination provides enterprise-quality monitoring comparable to Datadog or Grafana, but integrated directly into the Coolify platform with organization-level multi-tenancy.

**User Workflow:**

1. Administrator navigates to **Infrastructure → Resource Monitoring**
2. Dashboard loads with current metrics for all organization servers
3. Charts update automatically every 30 seconds via WebSocket
4. User selects time range (1h/6h/24h/7d/30d) to view historical trends
5. User clicks server card to drill down into detailed metrics
6. Alert notifications appear when servers exceed capacity thresholds
7. User exports chart data or takes action (scale up, redistribute load)

## Acceptance Criteria

- [ ] ResourceDashboard.vue component created with Vue 3 Composition API
- [ ] ApexCharts library integrated with responsive chart configurations
- [ ] Real-time metrics displayed for CPU, memory, disk, network per server
- [ ] Aggregate organization-wide resource overview with totals and averages
- [ ] Time range selector supporting 1h, 6h, 24h, 7d, 30d historical views
- [ ] WebSocket integration using Laravel Echo for automatic metric updates
- [ ] Server list view with cards showing current resource utilization percentages
- [ ] Drill-down detail view for individual server metrics (click-to-expand)
- [ ] Alert indicators for servers exceeding threshold limits (visual warnings)
- [ ] Chart data export functionality (PNG, SVG, CSV formats)
- [ ] Responsive design working on desktop (1920x1080), tablet (768x1024), mobile (375x667)
- [ ] Dark mode support with Coolify color scheme
- [ ] Loading states with skeleton screens during data fetch
- [ ] Error handling for WebSocket disconnection with automatic reconnection
- [ ] Performance optimization: < 100ms chart updates, < 50MB memory footprint
- [ ] Accessibility compliance (ARIA labels, keyboard navigation, screen reader support)

## Technical Details

### File Paths

**Vue Component:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/Monitoring/ResourceDashboard.vue` (main component)
- `/home/topgun/topgun/resources/js/Components/Enterprise/Monitoring/ServerMetricCard.vue` (child component)
- `/home/topgun/topgun/resources/js/Components/Enterprise/Monitoring/MetricChart.vue` (reusable chart wrapper)
- `/home/topgun/topgun/resources/js/Components/Enterprise/Monitoring/TimeRangeSelector.vue` (time range picker)

**Backend Controller:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/MonitoringController.php` (API endpoints)

**API Routes:**
- `/home/topgun/topgun/routes/api.php` - Add monitoring endpoints

**WebSocket Channels:**
- `/home/topgun/topgun/routes/channels.php` - Define resource monitoring channels

**Frontend Dependencies:**
- `package.json` - Add ApexCharts, Laravel Echo, Pusher

### Component Architecture

```vue
<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { router } from '@inertiajs/vue3'
import VueApexCharts from 'vue3-apexcharts'
import Echo from 'laravel-echo'
import ServerMetricCard from './ServerMetricCard.vue'
import MetricChart from './MetricChart.vue'
import TimeRangeSelector from './TimeRangeSelector.vue'

const props = defineProps({
  organizationId: {
    type: Number,
    required: true
  },
  servers: {
    type: Array,
    required: true
  },
  initialMetrics: {
    type: Object,
    required: true
  },
  thresholds: {
    type: Object,
    default: () => ({
      cpu: 80,
      memory: 85,
      disk: 90,
      network: 1000 // Mbps
    })
  }
})

// State
const selectedTimeRange = ref('6h')
const selectedServer = ref(null)
const metrics = ref(props.initialMetrics)
const isLoading = ref(false)
const connectionStatus = ref('connecting')

// Computed
const aggregateMetrics = computed(() => {
  // Calculate organization-wide averages
  const serverCount = props.servers.length
  if (serverCount === 0) return null

  return {
    avgCpu: metrics.value.servers.reduce((sum, s) => sum + s.cpu, 0) / serverCount,
    avgMemory: metrics.value.servers.reduce((sum, s) => sum + s.memory, 0) / serverCount,
    avgDisk: metrics.value.servers.reduce((sum, s) => sum + s.disk, 0) / serverCount,
    totalServers: serverCount,
    healthyServers: metrics.value.servers.filter(s => s.status === 'healthy').length,
    warningServers: metrics.value.servers.filter(s => s.status === 'warning').length,
    criticalServers: metrics.value.servers.filter(s => s.status === 'critical').length
  }
})

const chartOptions = computed(() => ({
  chart: {
    type: 'line',
    height: 350,
    animations: {
      enabled: true,
      easing: 'easeinout',
      speed: 800
    },
    toolbar: {
      show: true,
      tools: {
        download: true,
        selection: true,
        zoom: true,
        zoomin: true,
        zoomout: true,
        pan: true,
        reset: true
      }
    },
    background: 'transparent'
  },
  theme: {
    mode: 'dark', // or light based on user preference
    palette: 'palette1'
  },
  stroke: {
    curve: 'smooth',
    width: 2
  },
  dataLabels: {
    enabled: false
  },
  xaxis: {
    type: 'datetime',
    labels: {
      datetimeUTC: false
    }
  },
  yaxis: {
    min: 0,
    max: 100,
    labels: {
      formatter: (value) => `${value.toFixed(1)}%`
    }
  },
  tooltip: {
    x: {
      format: 'dd MMM HH:mm'
    }
  },
  legend: {
    position: 'top',
    horizontalAlign: 'left'
  }
}))

// Methods
const fetchMetrics = async (timeRange) => {
  isLoading.value = true

  try {
    const response = await fetch(
      `/api/enterprise/organizations/${props.organizationId}/monitoring/metrics?range=${timeRange}`
    )

    const data = await response.json()
    metrics.value = data
  } catch (error) {
    console.error('Failed to fetch metrics:', error)
  } finally {
    isLoading.value = false
  }
}

const handleTimeRangeChange = (newRange) => {
  selectedTimeRange.value = newRange
  fetchMetrics(newRange)
}

const handleServerClick = (server) => {
  selectedServer.value = selectedServer.value?.id === server.id ? null : server
}

const getServerStatusClass = (server) => {
  if (server.cpu > props.thresholds.cpu || server.memory > props.thresholds.memory) {
    return 'status-critical'
  }
  if (server.cpu > props.thresholds.cpu * 0.7 || server.memory > props.thresholds.memory * 0.7) {
    return 'status-warning'
  }
  return 'status-healthy'
}

const exportChartData = (format) => {
  // Export chart data to PNG, SVG, or CSV
  // Implementation via ApexCharts export API
}

// WebSocket Setup
let echo = null

onMounted(() => {
  // Initialize Laravel Echo
  echo = new Echo({
    broadcaster: 'reverb',
    key: import.meta.env.VITE_REVERB_APP_KEY,
    wsHost: import.meta.env.VITE_REVERB_HOST,
    wsPort: import.meta.env.VITE_REVERB_PORT,
    forceTLS: false,
    enabledTransports: ['ws', 'wss']
  })

  // Subscribe to organization resource channel
  echo.private(`organization.${props.organizationId}.resources`)
    .listen('ResourceMetricsUpdated', (event) => {
      // Update metrics with new data
      const serverIndex = metrics.value.servers.findIndex(s => s.id === event.server_id)
      if (serverIndex !== -1) {
        metrics.value.servers[serverIndex] = {
          ...metrics.value.servers[serverIndex],
          cpu: event.cpu,
          memory: event.memory,
          disk: event.disk,
          network: event.network,
          timestamp: event.timestamp
        }
      }

      connectionStatus.value = 'connected'
    })
    .error((error) => {
      console.error('WebSocket error:', error)
      connectionStatus.value = 'error'
    })
})

onUnmounted(() => {
  if (echo) {
    echo.leave(`organization.${props.organizationId}.resources`)
    echo.disconnect()
  }
})
</script>

<template>
  <div class="resource-dashboard">
    <!-- Header -->
    <div class="dashboard-header">
      <div class="header-content">
        <h1 class="text-3xl font-bold">Resource Monitoring</h1>
        <div class="connection-status" :class="connectionStatus">
          <span class="status-indicator"></span>
          <span class="status-text">{{ connectionStatus }}</span>
        </div>
      </div>

      <TimeRangeSelector
        :selected="selectedTimeRange"
        @change="handleTimeRangeChange"
      />
    </div>

    <!-- Aggregate Metrics Overview -->
    <div class="metrics-overview">
      <div class="metric-card">
        <div class="metric-icon cpu-icon"></div>
        <div class="metric-content">
          <h3 class="metric-label">Average CPU</h3>
          <p class="metric-value">{{ aggregateMetrics?.avgCpu.toFixed(1) }}%</p>
        </div>
      </div>

      <div class="metric-card">
        <div class="metric-icon memory-icon"></div>
        <div class="metric-content">
          <h3 class="metric-label">Average Memory</h3>
          <p class="metric-value">{{ aggregateMetrics?.avgMemory.toFixed(1) }}%</p>
        </div>
      </div>

      <div class="metric-card">
        <div class="metric-icon disk-icon"></div>
        <div class="metric-content">
          <h3 class="metric-label">Average Disk</h3>
          <p class="metric-value">{{ aggregateMetrics?.avgDisk.toFixed(1) }}%</p>
        </div>
      </div>

      <div class="metric-card">
        <div class="metric-icon server-icon"></div>
        <div class="metric-content">
          <h3 class="metric-label">Server Health</h3>
          <p class="metric-value">
            {{ aggregateMetrics?.healthyServers }}/{{ aggregateMetrics?.totalServers }}
          </p>
        </div>
      </div>
    </div>

    <!-- Main Charts -->
    <div class="charts-grid">
      <div class="chart-container">
        <h2 class="chart-title">CPU Usage Over Time</h2>
        <MetricChart
          :series="metrics.charts.cpu"
          :options="{ ...chartOptions, colors: ['#3b82f6', '#8b5cf6'] }"
          type="line"
        />
      </div>

      <div class="chart-container">
        <h2 class="chart-title">Memory Usage Over Time</h2>
        <MetricChart
          :series="metrics.charts.memory"
          :options="{ ...chartOptions, colors: ['#10b981', '#14b8a6'] }"
          type="area"
        />
      </div>

      <div class="chart-container">
        <h2 class="chart-title">Disk Usage Over Time</h2>
        <MetricChart
          :series="metrics.charts.disk"
          :options="{ ...chartOptions, colors: ['#f59e0b', '#ef4444'] }"
          type="line"
        />
      </div>

      <div class="chart-container">
        <h2 class="chart-title">Network Throughput</h2>
        <MetricChart
          :series="metrics.charts.network"
          :options="{
            ...chartOptions,
            yaxis: {
              labels: {
                formatter: (value) => `${value} Mbps`
              }
            },
            colors: ['#06b6d4', '#0ea5e9']
          }"
          type="area"
        />
      </div>
    </div>

    <!-- Server List -->
    <div class="servers-section">
      <h2 class="section-title">Servers ({{ servers.length }})</h2>

      <div v-if="isLoading" class="skeleton-grid">
        <div v-for="i in 6" :key="i" class="skeleton-card"></div>
      </div>

      <div v-else class="servers-grid">
        <ServerMetricCard
          v-for="server in servers"
          :key="server.id"
          :server="server"
          :metrics="metrics.servers.find(s => s.id === server.id)"
          :thresholds="thresholds"
          :is-expanded="selectedServer?.id === server.id"
          @click="handleServerClick(server)"
        />
      </div>
    </div>

    <!-- Detailed Server View (Modal/Drawer) -->
    <Transition name="slide">
      <div v-if="selectedServer" class="server-detail-drawer">
        <div class="drawer-header">
          <h2>{{ selectedServer.name }}</h2>
          <button @click="selectedServer = null" class="close-btn">×</button>
        </div>

        <div class="drawer-content">
          <!-- Detailed metrics for selected server -->
          <div class="detail-chart">
            <h3>CPU Cores Breakdown</h3>
            <MetricChart
              :series="metrics.serverDetails[selectedServer.id].cpuCores"
              type="bar"
            />
          </div>

          <div class="detail-chart">
            <h3>Memory Distribution</h3>
            <MetricChart
              :series="metrics.serverDetails[selectedServer.id].memoryBreakdown"
              type="donut"
            />
          </div>

          <!-- Additional server info -->
          <div class="server-info">
            <p><strong>IP:</strong> {{ selectedServer.ip }}</p>
            <p><strong>Region:</strong> {{ selectedServer.region }}</p>
            <p><strong>Provider:</strong> {{ selectedServer.provider }}</p>
            <p><strong>Uptime:</strong> {{ selectedServer.uptime }}</p>
          </div>
        </div>
      </div>
    </Transition>
  </div>
</template>

<style scoped>
.resource-dashboard {
  padding: 2rem;
  max-width: 1920px;
  margin: 0 auto;
}

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.header-content {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  font-weight: 500;
}

.connection-status.connected {
  background-color: #d1fae5;
  color: #065f46;
}

.connection-status.connecting {
  background-color: #fef3c7;
  color: #92400e;
}

.connection-status.error {
  background-color: #fee2e2;
  color: #991b1b;
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: currentColor;
  animation: pulse 2s infinite;
}

.metrics-overview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.metric-card {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.5rem;
  background: white;
  border-radius: 0.75rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.dark .metric-card {
  background: #1f2937;
}

.metric-icon {
  width: 48px;
  height: 48px;
  border-radius: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.metric-value {
  font-size: 1.875rem;
  font-weight: 700;
  color: #111827;
}

.dark .metric-value {
  color: #f9fafb;
}

.charts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 2rem;
  margin-bottom: 3rem;
}

.chart-container {
  background: white;
  padding: 1.5rem;
  border-radius: 0.75rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.dark .chart-container {
  background: #1f2937;
}

.chart-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 1rem;
}

.servers-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
}

.server-detail-drawer {
  position: fixed;
  top: 0;
  right: 0;
  width: 600px;
  height: 100vh;
  background: white;
  box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  overflow-y: auto;
}

.dark .server-detail-drawer {
  background: #111827;
}

.drawer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.drawer-content {
  padding: 1.5rem;
}

.skeleton-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
}

.skeleton-card {
  height: 200px;
  background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 0.75rem;
}

@keyframes shimmer {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.slide-enter-active,
.slide-leave-active {
  transition: transform 0.3s ease;
}

.slide-enter-from,
.slide-leave-to {
  transform: translateX(100%);
}

@media (max-width: 768px) {
  .resource-dashboard {
    padding: 1rem;
  }

  .charts-grid {
    grid-template-columns: 1fr;
  }

  .server-detail-drawer {
    width: 100%;
  }
}
</style>
```

### Backend API Controller

**File:** `app/Http/Controllers/Enterprise/MonitoringController.php`

```php
<?php

namespace App\Http\Controllers\Enterprise;

use App\Http\Controllers\Controller;
use App\Services\Enterprise\SystemResourceMonitor;
use App\Models\Organization;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Cache;
use Carbon\Carbon;

class MonitoringController extends Controller
{
    public function __construct(
        private SystemResourceMonitor $monitor
    ) {}

    /**
     * Get resource metrics for organization servers
     *
     * @param Request $request
     * @param Organization $organization
     * @return JsonResponse
     */
    public function getMetrics(Request $request, Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $timeRange = $request->query('range', '6h');

        // Cache key with time range
        $cacheKey = "metrics:{$organization->id}:{$timeRange}";

        $metrics = Cache::remember($cacheKey, 60, function () use ($organization, $timeRange) {
            return $this->monitor->getOrganizationMetrics($organization, $timeRange);
        });

        return response()->json($metrics);
    }

    /**
     * Get detailed metrics for specific server
     *
     * @param Organization $organization
     * @param int $serverId
     * @return JsonResponse
     */
    public function getServerMetrics(Organization $organization, int $serverId): JsonResponse
    {
        $this->authorize('view', $organization);

        $server = $organization->servers()->findOrFail($serverId);

        $metrics = $this->monitor->getServerDetailedMetrics($server);

        return response()->json($metrics);
    }

    /**
     * Get aggregate organization resource usage
     *
     * @param Organization $organization
     * @return JsonResponse
     */
    public function getAggregateUsage(Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $usage = $this->monitor->getAggregateUsage($organization);

        return response()->json($usage);
    }

    /**
     * Export metrics data in various formats
     *
     * @param Request $request
     * @param Organization $organization
     * @return mixed
     */
    public function exportMetrics(Request $request, Organization $organization)
    {
        $this->authorize('view', $organization);

        $format = $request->query('format', 'csv'); // csv, json, xlsx
        $timeRange = $request->query('range', '24h');

        $metrics = $this->monitor->getOrganizationMetrics($organization, $timeRange);

        switch ($format) {
            case 'json':
                return response()->json($metrics);
            case 'csv':
                return $this->exportToCsv($metrics);
            case 'xlsx':
                return $this->exportToExcel($metrics);
            default:
                return response()->json(['error' => 'Invalid format'], 400);
        }
    }

    private function exportToCsv(array $metrics): Response
    {
        // Implementation for CSV export
        $csv = "Timestamp,Server,CPU,Memory,Disk,Network\n";

        foreach ($metrics['servers'] as $server) {
            foreach ($server['history'] as $point) {
                $csv .= sprintf(
                    "%s,%s,%.2f,%.2f,%.2f,%.2f\n",
                    $point['timestamp'],
                    $server['name'],
                    $point['cpu'],
                    $point['memory'],
                    $point['disk'],
                    $point['network']
                );
            }
        }

        return response($csv, 200, [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => 'attachment; filename="metrics-export.csv"'
        ]);
    }
}
```

### API Routes

```php
// routes/api.php

Route::middleware(['auth:sanctum', 'organization'])->group(function () {
    // Resource monitoring endpoints
    Route::get('/enterprise/organizations/{organization}/monitoring/metrics',
        [MonitoringController::class, 'getMetrics'])
        ->name('api.enterprise.monitoring.metrics');

    Route::get('/enterprise/organizations/{organization}/monitoring/servers/{server}',
        [MonitoringController::class, 'getServerMetrics'])
        ->name('api.enterprise.monitoring.server');

    Route::get('/enterprise/organizations/{organization}/monitoring/aggregate',
        [MonitoringController::class, 'getAggregateUsage'])
        ->name('api.enterprise.monitoring.aggregate');

    Route::get('/enterprise/organizations/{organization}/monitoring/export',
        [MonitoringController::class, 'exportMetrics'])
        ->name('api.enterprise.monitoring.export');
});
```

### WebSocket Channel Definition

```php
// routes/channels.php

use App\Models\Organization;
use App\Models\User;

// Organization resource monitoring channel
Broadcast::channel('organization.{organizationId}.resources', function (User $user, int $organizationId) {
    return $user->organizations()->where('organizations.id', $organizationId)->exists();
});
```

### Child Components

**ServerMetricCard.vue:**

```vue
<script setup>
import { computed } from 'vue'

const props = defineProps({
  server: Object,
  metrics: Object,
  thresholds: Object,
  isExpanded: Boolean
})

const emit = defineEmits(['click'])

const statusClass = computed(() => {
  if (!props.metrics) return 'status-unknown'

  const { cpu, memory } = props.metrics

  if (cpu > props.thresholds.cpu || memory > props.thresholds.memory) {
    return 'status-critical'
  }

  if (cpu > props.thresholds.cpu * 0.7 || memory > props.thresholds.memory * 0.7) {
    return 'status-warning'
  }

  return 'status-healthy'
})
</script>

<template>
  <div
    class="server-card"
    :class="[statusClass, { 'expanded': isExpanded }]"
    @click="emit('click', server)"
  >
    <div class="card-header">
      <h3 class="server-name">{{ server.name }}</h3>
      <span class="status-badge" :class="statusClass"></span>
    </div>

    <div class="metrics-grid">
      <div class="metric">
        <span class="metric-label">CPU</span>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :style="{ width: `${metrics?.cpu || 0}%` }"
            :class="{ 'critical': metrics?.cpu > thresholds.cpu }"
          ></div>
        </div>
        <span class="metric-value">{{ metrics?.cpu.toFixed(1) }}%</span>
      </div>

      <div class="metric">
        <span class="metric-label">Memory</span>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :style="{ width: `${metrics?.memory || 0}%` }"
            :class="{ 'critical': metrics?.memory > thresholds.memory }"
          ></div>
        </div>
        <span class="metric-value">{{ metrics?.memory.toFixed(1) }}%</span>
      </div>

      <div class="metric">
        <span class="metric-label">Disk</span>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :style="{ width: `${metrics?.disk || 0}%` }"
            :class="{ 'critical': metrics?.disk > thresholds.disk }"
          ></div>
        </div>
        <span class="metric-value">{{ metrics?.disk.toFixed(1) }}%</span>
      </div>
    </div>

    <div class="card-footer">
      <span class="server-ip">{{ server.ip }}</span>
      <span class="server-region">{{ server.region }}</span>
    </div>
  </div>
</template>

<style scoped>
.server-card {
  background: white;
  border-radius: 0.75rem;
  padding: 1.5rem;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid transparent;
}

.server-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.server-card.expanded {
  border-color: #3b82f6;
}

.server-card.status-critical {
  border-left: 4px solid #ef4444;
}

.server-card.status-warning {
  border-left: 4px solid #f59e0b;
}

.server-card.status-healthy {
  border-left: 4px solid #10b981;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.server-name {
  font-size: 1.125rem;
  font-weight: 600;
}

.status-badge {
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.status-badge.status-healthy {
  background-color: #10b981;
}

.status-badge.status-warning {
  background-color: #f59e0b;
}

.status-badge.status-critical {
  background-color: #ef4444;
}

.metrics-grid {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 1rem;
}

.metric {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.metric-label {
  width: 60px;
  font-size: 0.875rem;
  font-weight: 500;
  color: #6b7280;
}

.progress-bar {
  flex: 1;
  height: 8px;
  background: #e5e7eb;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #3b82f6;
  transition: width 0.3s ease;
}

.progress-fill.critical {
  background: #ef4444;
}

.metric-value {
  width: 60px;
  text-align: right;
  font-size: 0.875rem;
  font-weight: 600;
}

.card-footer {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: #9ca3af;
  padding-top: 1rem;
  border-top: 1px solid #e5e7eb;
}
</style>
```

### Frontend Dependencies

```bash
# Install required packages
npm install --save vue3-apexcharts apexcharts laravel-echo pusher-js
```

**package.json additions:**

```json
{
  "dependencies": {
    "vue3-apexcharts": "^1.4.1",
    "apexcharts": "^3.45.0",
    "laravel-echo": "^1.15.3",
    "pusher-js": "^8.4.0-rc2"
  }
}
```

## Implementation Approach

### Step 1: Install Frontend Dependencies
```bash
npm install --save vue3-apexcharts apexcharts laravel-echo pusher-js
```

### Step 2: Create Component Directory Structure
```bash
mkdir -p resources/js/Components/Enterprise/Monitoring
```

### Step 3: Build Core Dashboard Component
1. Create `ResourceDashboard.vue` with basic structure
2. Implement state management (refs for metrics, loading, connection status)
3. Add ApexCharts integration with responsive configurations
4. Implement time range selector functionality

### Step 4: Create Child Components
1. Build `ServerMetricCard.vue` for individual server display
2. Build `MetricChart.vue` as reusable chart wrapper
3. Build `TimeRangeSelector.vue` for time period selection
4. Ensure all components follow Vue 3 Composition API patterns

### Step 5: Implement Backend API Endpoints
1. Create `MonitoringController.php` with CRUD methods
2. Add API routes in `routes/api.php`
3. Implement authorization with organization scoping
4. Add caching layer for expensive metric queries

### Step 6: Configure WebSocket Broadcasting
1. Define private channel in `routes/channels.php`
2. Implement authorization callback checking organization membership
3. Create `ResourceMetricsUpdated` event class
4. Test WebSocket connection and message broadcasting

### Step 7: Integrate with SystemResourceMonitor
1. Call `SystemResourceMonitor::getOrganizationMetrics()` in controller
2. Format data for ApexCharts consumption
3. Implement time-series data aggregation logic
4. Add caching for historical queries

### Step 8: Add Real-Time Updates
1. Initialize Laravel Echo in component `onMounted()`
2. Subscribe to organization resource channel
3. Handle incoming metric updates
4. Update chart data reactively
5. Implement reconnection logic for dropped connections

### Step 9: Implement Export Functionality
1. Add CSV export method in controller
2. Add JSON export endpoint
3. Integrate with ApexCharts export API for PNG/SVG
4. Test download functionality across browsers

### Step 10: Style and Polish
1. Add responsive CSS for desktop/tablet/mobile
2. Implement dark mode using Tailwind dark: classes
3. Add loading skeletons during data fetch
4. Add animations and transitions
5. Ensure accessibility (ARIA labels, keyboard nav)

## Test Strategy

### Unit Tests (Vitest)

**File:** `resources/js/Components/Enterprise/Monitoring/__tests__/ResourceDashboard.spec.js`

```javascript
import { mount } from '@vue/test-utils'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import ResourceDashboard from '../ResourceDashboard.vue'
import VueApexCharts from 'vue3-apexcharts'

describe('ResourceDashboard.vue', () => {
  let wrapper

  const mockServers = [
    { id: 1, name: 'Server 1', ip: '10.0.0.1', region: 'us-east-1' },
    { id: 2, name: 'Server 2', ip: '10.0.0.2', region: 'eu-west-1' }
  ]

  const mockMetrics = {
    servers: [
      { id: 1, cpu: 45.5, memory: 60.2, disk: 70.0, network: 150 },
      { id: 2, cpu: 30.1, memory: 55.8, disk: 65.5, network: 120 }
    ],
    charts: {
      cpu: [{ name: 'Server 1', data: [[1704067200000, 45.5]] }],
      memory: [{ name: 'Server 1', data: [[1704067200000, 60.2]] }],
      disk: [{ name: 'Server 1', data: [[1704067200000, 70.0]] }],
      network: [{ name: 'Server 1', data: [[1704067200000, 150]] }]
    }
  }

  beforeEach(() => {
    wrapper = mount(ResourceDashboard, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialMetrics: mockMetrics
      },
      global: {
        components: {
          VueApexCharts
        },
        stubs: {
          MetricChart: true,
          ServerMetricCard: true,
          TimeRangeSelector: true
        }
      }
    })
  })

  it('renders dashboard with correct title', () => {
    expect(wrapper.find('h1').text()).toBe('Resource Monitoring')
  })

  it('calculates aggregate metrics correctly', () => {
    const aggregate = wrapper.vm.aggregateMetrics

    expect(aggregate.avgCpu).toBeCloseTo(37.8, 1) // (45.5 + 30.1) / 2
    expect(aggregate.avgMemory).toBeCloseTo(58.0, 1)
    expect(aggregate.totalServers).toBe(2)
  })

  it('displays metric overview cards', () => {
    const metricCards = wrapper.findAll('.metric-card')
    expect(metricCards.length).toBe(4) // CPU, Memory, Disk, Server Health
  })

  it('handles time range change', async () => {
    const fetchSpy = vi.spyOn(wrapper.vm, 'fetchMetrics')

    await wrapper.vm.handleTimeRangeChange('24h')

    expect(wrapper.vm.selectedTimeRange).toBe('24h')
    expect(fetchSpy).toHaveBeenCalledWith('24h')
  })

  it('toggles server detail drawer on click', async () => {
    expect(wrapper.vm.selectedServer).toBeNull()

    await wrapper.vm.handleServerClick(mockServers[0])

    expect(wrapper.vm.selectedServer).toEqual(mockServers[0])

    // Click again to close
    await wrapper.vm.handleServerClick(mockServers[0])

    expect(wrapper.vm.selectedServer).toBeNull()
  })

  it('applies correct status class based on thresholds', () => {
    const criticalServer = { cpu: 85, memory: 90 }
    const warningServer = { cpu: 60, memory: 65 }
    const healthyServer = { cpu: 30, memory: 40 }

    expect(wrapper.vm.getServerStatusClass(criticalServer)).toBe('status-critical')
    expect(wrapper.vm.getServerStatusClass(warningServer)).toBe('status-warning')
    expect(wrapper.vm.getServerStatusClass(healthyServer)).toBe('status-healthy')
  })

  it('updates connection status', async () => {
    expect(wrapper.vm.connectionStatus).toBe('connecting')

    // Simulate WebSocket connection
    wrapper.vm.connectionStatus = 'connected'
    await wrapper.vm.$nextTick()

    expect(wrapper.find('.connection-status').classes()).toContain('connected')
  })

  it('shows loading state', async () => {
    wrapper.vm.isLoading = true
    await wrapper.vm.$nextTick()

    expect(wrapper.find('.skeleton-grid').exists()).toBe(true)
  })

  it('renders ApexCharts components', () => {
    const charts = wrapper.findAllComponents({ name: 'MetricChart' })
    expect(charts.length).toBeGreaterThanOrEqual(4) // CPU, Memory, Disk, Network
  })
})
```

### Integration Tests (Pest)

**File:** `tests/Feature/Enterprise/MonitoringControllerTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use Illuminate\Support\Facades\Cache;

it('returns metrics for organization', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $server = Server::factory()->create(['organization_id' => $organization->id]);

    // Create sample metrics
    ServerResourceMetric::factory()->count(10)->create([
        'server_id' => $server->id,
        'cpu_usage' => 45.5,
        'memory_usage' => 60.2
    ]);

    $this->actingAs($user)
        ->getJson("/api/enterprise/organizations/{$organization->id}/monitoring/metrics?range=6h")
        ->assertOk()
        ->assertJsonStructure([
            'servers' => [
                '*' => ['id', 'cpu', 'memory', 'disk', 'network']
            ],
            'charts' => ['cpu', 'memory', 'disk', 'network']
        ]);
});

it('caches metric queries', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Cache::shouldReceive('remember')
        ->once()
        ->with("metrics:{$organization->id}:6h", 60, \Closure::class)
        ->andReturn(['servers' => [], 'charts' => []]);

    $this->actingAs($user)
        ->getJson("/api/enterprise/organizations/{$organization->id}/monitoring/metrics")
        ->assertOk();
});

it('prevents cross-organization access', function () {
    $org1 = Organization::factory()->create();
    $org2 = Organization::factory()->create();

    $user = User::factory()->create();
    $org1->users()->attach($user, ['role' => 'admin']);

    $this->actingAs($user)
        ->getJson("/api/enterprise/organizations/{$org2->id}/monitoring/metrics")
        ->assertForbidden();
});

it('exports metrics as CSV', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $response = $this->actingAs($user)
        ->get("/api/enterprise/organizations/{$organization->id}/monitoring/export?format=csv");

    $response->assertOk()
        ->assertHeader('Content-Type', 'text/csv')
        ->assertHeader('Content-Disposition', 'attachment; filename="metrics-export.csv"');
});

it('returns detailed server metrics', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $server = Server::factory()->create(['organization_id' => $organization->id]);

    $this->actingAs($user)
        ->getJson("/api/enterprise/organizations/{$organization->id}/monitoring/servers/{$server->id}")
        ->assertOk()
        ->assertJsonStructure([
            'cpuCores',
            'memoryBreakdown',
            'diskPartitions'
        ]);
});
```

### Browser Tests (Dusk)

**File:** `tests/Browser/Enterprise/ResourceMonitoringTest.php`

```php
<?php

use Laravel\Dusk\Browser;
use App\Models\Organization;
use App\Models\User;

it('displays resource dashboard', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($user) {
        $browser->loginAs($user)
            ->visit('/enterprise/monitoring')
            ->assertSee('Resource Monitoring')
            ->assertPresent('.metrics-overview')
            ->assertPresent('.charts-grid')
            ->assertPresent('.servers-grid');
    });
});

it('updates metrics in real-time', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($user) {
        $browser->loginAs($user)
            ->visit('/enterprise/monitoring')
            ->waitFor('.connection-status.connected', 5)
            ->assertSee('connected');

        // Trigger metric update via WebSocket
        // Assert chart updates
    });
});

it('opens server detail drawer on click', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $server = Server::factory()->create(['organization_id' => $organization->id]);

    $this->browse(function (Browser $browser) use ($user, $server) {
        $browser->loginAs($user)
            ->visit('/enterprise/monitoring')
            ->waitFor('.server-card')
            ->click('.server-card')
            ->waitFor('.server-detail-drawer')
            ->assertSee($server->name);
    });
});
```

## Definition of Done

- [ ] ResourceDashboard.vue component created with Vue 3 Composition API
- [ ] ApexCharts library integrated and configured
- [ ] ServerMetricCard.vue child component implemented
- [ ] MetricChart.vue reusable wrapper component implemented
- [ ] TimeRangeSelector.vue component implemented
- [ ] MonitoringController.php created with API endpoints
- [ ] API routes registered in routes/api.php
- [ ] WebSocket channel defined in routes/channels.php
- [ ] Laravel Echo configured and tested
- [ ] Real-time metric updates working via WebSocket
- [ ] Time range selector functional (1h, 6h, 24h, 7d, 30d)
- [ ] Aggregate metrics calculation accurate
- [ ] Server status indicators working (healthy/warning/critical)
- [ ] Server detail drawer implemented with drill-down
- [ ] Chart export functionality working (PNG, SVG, CSV)
- [ ] Responsive design tested on desktop/tablet/mobile
- [ ] Dark mode implemented and tested
- [ ] Loading states with skeleton screens implemented
- [ ] Error handling for WebSocket disconnection
- [ ] Automatic reconnection logic implemented
- [ ] Unit tests written (15+ tests, >85% coverage)
- [ ] Integration tests written (10+ tests)
- [ ] Browser tests written (5+ tests)
- [ ] Performance benchmarks met (< 100ms updates, < 50MB memory)
- [ ] Accessibility compliance verified (ARIA, keyboard nav)
- [ ] Code follows Vue.js and Laravel best practices
- [ ] Documentation updated (component props, API endpoints)
- [ ] Code reviewed and approved
- [ ] All tests passing

## Related Tasks

- **Depends on:** Task 25 (SystemResourceMonitor service provides metrics data)
- **Integrates with:** Task 26 (CapacityManager for server scoring context)
- **Used by:** Task 30 (CapacityPlanner.vue references dashboard data)
- **Parallel with:** Task 31 (WebSocket broadcasting enables real-time updates)
- **Data source:** Task 22 (Database schema for server_resource_metrics)
- **Metric collection:** Task 24 (ResourceMonitoringJob populates metrics)
