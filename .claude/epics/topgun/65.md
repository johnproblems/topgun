---
name: Integrate Route53 Domains API for AWS domain management
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:18Z
github: https://github.com/johnproblems/topgun/issues/173
depends_on: [63]
parallel: false
conflicts_with: []
---

# Task: Integrate Route53 Domains API for AWS domain management

## Description

Implement comprehensive AWS Route53 Domains API integration for automated domain registration, transfer, renewal, and DNS management. This implementation extends the domain management system with enterprise-grade AWS integration, enabling organizations to manage their entire domain portfolio programmatically through Coolify's white-label platform.

AWS Route53 Domains provides one of the most robust domain management APIs in the industry, supporting over 300 top-level domains (TLDs) with features including DNSSEC, domain locking, auto-renewal, privacy protection, and seamless integration with Route53 hosted zones. This integration transforms Coolify from a deployment platform into a complete infrastructure orchestration solution where users can register domains, configure DNS, deploy applications, and manage SSL certificates—all within a unified interface.

**Core Capabilities:**

1. **Domain Registration**: Register new domains across 300+ TLDs with automatic WHOIS privacy protection
2. **Domain Transfer**: Transfer existing domains from other registrars with automated authorization code handling
3. **Domain Renewal**: Automated renewal management with configurable auto-renew settings
4. **Domain Availability**: Real-time domain availability checking with pricing information
5. **DNS Integration**: Seamless Route53 hosted zone creation and DNS record management
6. **Contact Management**: WHOIS contact information management with privacy protection
7. **Domain Locking**: Transfer lock protection to prevent unauthorized domain transfers
8. **DNSSEC**: Domain Name System Security Extensions configuration
9. **Status Monitoring**: Track domain transfer, registration, and renewal operations
10. **Cost Management**: Domain pricing queries and cost estimation before operations

**Integration Architecture:**

The Route53Domains implementation follows the registrar factory pattern established in Task 63, providing a concrete implementation of the `DomainRegistrarInterface`. It leverages the AWS SDK for PHP to interact with Route53 Domains API, handling authentication via CloudProviderCredential for secure API key management.

**Key Integration Points:**

- **CloudProviderCredential Model**: Retrieves encrypted AWS credentials (access key, secret key, region)
- **DomainRegistrar Factory**: Returns Route53DomainsRegistrar instance when provider is 'aws'
- **OrganizationDomain Model**: Stores domain metadata, registration status, renewal dates
- **DnsRecord Model**: Manages DNS records linked to Route53 hosted zones
- **DomainManager.vue**: Frontend component for domain operations
- **Server Auto-Registration**: Links provisioned infrastructure to domain DNS automatically

**Why This Task is Critical:**

Domain management is a core infrastructure requirement for any white-label platform. Without automated domain registration and DNS management, organizations must manually register domains through third-party registrars, then manually configure DNS records—a time-consuming, error-prone process that creates friction in the deployment workflow.

AWS Route53 Domains offers several advantages:
- **Enterprise Reliability**: 100% uptime SLA for DNS queries with global anycast network
- **Integration**: Seamless integration with AWS ecosystem (EC2, CloudFront, S3, etc.)
- **Automation**: Full API support for programmatic domain lifecycle management
- **Compliance**: Built-in WHOIS privacy, DNSSEC, and regulatory compliance features
- **Cost Efficiency**: Competitive pricing with no markup on domain registration fees

This integration completes the infrastructure provisioning stack: Terraform provisions servers → Route53 registers domains → DNS records link domains to servers → SSL certificates secure connections → Applications deploy automatically. Users experience true "infrastructure as code" where a single configuration file can provision an entire production environment.

## Acceptance Criteria

- [ ] Route53DomainsRegistrar implements DomainRegistrarInterface completely
- [ ] AWS SDK for PHP v3 integrated with proper dependency injection
- [ ] Domain registration with all required contact information (registrant, admin, tech, billing)
- [ ] Domain transfer with authorization code and transfer lock handling
- [ ] Domain renewal with configurable auto-renew settings
- [ ] Domain availability checking with real-time AWS pricing
- [ ] Automatic Route53 hosted zone creation on domain registration
- [ ] DNS record synchronization between OrganizationDomain and Route53
- [ ] WHOIS privacy protection enabled by default
- [ ] Domain transfer lock management (lock/unlock operations)
- [ ] DNSSEC configuration support
- [ ] Operation status polling for async operations (registration, transfer take 1-3 days)
- [ ] Comprehensive error handling for AWS API errors (rate limits, quota exceeded, invalid contacts)
- [ ] AWS credential validation before operations
- [ ] Support for 20+ common TLDs (.com, .net, .org, .io, .app, .dev, .cloud, etc.)
- [ ] Integration tests with AWS SDK mocking
- [ ] Unit tests covering all public methods with >90% coverage

## Technical Details

### File Paths

**Registrar Implementation:**
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrars/Route53DomainsRegistrar.php` (new)

**Configuration:**
- `/home/topgun/topgun/config/domain-registrars.php` (modify - add Route53 config)

**AWS SDK:**
- Installed via Composer: `composer require aws/aws-sdk-php`

**Models (existing):**
- `/home/topgun/topgun/app/Models/CloudProviderCredential.php`
- `/home/topgun/topgun/app/Models/OrganizationDomain.php`
- `/home/topgun/topgun/app/Models/DnsRecord.php`

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/PollDomainOperationStatusJob.php` (new - async status polling)

### AWS SDK Integration

**Composer Dependencies:**

```bash
composer require aws/aws-sdk-php
```

**AWS SDK Configuration:**

The Route53 Domains API client requires:
- AWS Access Key ID
- AWS Secret Access Key
- AWS Region (Route53 Domains is available in us-east-1 only)

These credentials are retrieved from the `CloudProviderCredential` model with encrypted storage.

### Route53DomainsRegistrar Implementation

**File:** `app/Services/Enterprise/DomainRegistrars/Route53DomainsRegistrar.php`

```php
<?php

namespace App\Services\Enterprise\DomainRegistrars;

use App\Contracts\DomainRegistrarInterface;
use App\Models\CloudProviderCredential;
use App\Models\OrganizationDomain;
use App\Exceptions\DomainRegistrationException;
use App\Jobs\Enterprise\PollDomainOperationStatusJob;
use Aws\Route53Domains\Route53DomainsClient;
use Aws\Route53\Route53Client;
use Aws\Exception\AwsException;
use Illuminate\Support\Facades\Log;

class Route53DomainsRegistrar implements DomainRegistrarInterface
{
    private const ROUTE53_DOMAINS_REGION = 'us-east-1'; // Route53 Domains only available in us-east-1
    private const OPERATION_POLL_INTERVAL = 3600; // Poll every hour for pending operations

    private Route53DomainsClient $domainsClient;
    private Route53Client $route53Client;

    public function __construct(
        private CloudProviderCredential $credential
    ) {
        $this->initializeClients();
    }

    /**
     * Initialize AWS SDK clients
     *
     * @return void
     */
    private function initializeClients(): void
    {
        $awsConfig = [
            'version' => 'latest',
            'region' => self::ROUTE53_DOMAINS_REGION,
            'credentials' => [
                'key' => $this->credential->credentials['access_key_id'],
                'secret' => $this->credential->credentials['secret_access_key'],
            ],
        ];

        $this->domainsClient = new Route53DomainsClient($awsConfig);

        // Route53 DNS client uses organization's configured region
        $dnsConfig = $awsConfig;
        $dnsConfig['region'] = $this->credential->region ?? 'us-east-1';
        $this->route53Client = new Route53Client($dnsConfig);
    }

    /**
     * Check if domain is available for registration
     *
     * @param string $domain
     * @return bool
     */
    public function checkAvailability(string $domain): bool
    {
        try {
            $result = $this->domainsClient->checkDomainAvailability([
                'DomainName' => $domain,
            ]);

            $availability = $result['Availability'];

            Log::info('Route53 domain availability check', [
                'domain' => $domain,
                'availability' => $availability,
            ]);

            return in_array($availability, ['AVAILABLE', 'AVAILABLE_RESERVED', 'AVAILABLE_PREORDER']);

        } catch (AwsException $e) {
            Log::error('Route53 availability check failed', [
                'domain' => $domain,
                'error' => $e->getAwsErrorMessage(),
                'code' => $e->getAwsErrorCode(),
            ]);

            throw new DomainRegistrationException(
                "Failed to check domain availability: {$e->getAwsErrorMessage()}",
                $e->getStatusCode(),
                $e
            );
        }
    }

    /**
     * Register a new domain
     *
     * @param string $domain
     * @param array $contactInfo WHOIS contact information
     * @param int $years Number of years to register
     * @return OrganizationDomain
     */
    public function registerDomain(string $domain, array $contactInfo, int $years = 1): OrganizationDomain
    {
        try {
            // Validate contact information
            $this->validateContactInfo($contactInfo);

            // Build contact details in AWS format
            $registrantContact = $this->buildContactDetails($contactInfo['registrant'] ?? $contactInfo);
            $adminContact = $this->buildContactDetails($contactInfo['admin'] ?? $contactInfo);
            $techContact = $this->buildContactDetails($contactInfo['tech'] ?? $contactInfo);

            // Register domain
            $result = $this->domainsClient->registerDomain([
                'DomainName' => $domain,
                'DurationInYears' => $years,
                'AutoRenew' => $contactInfo['auto_renew'] ?? true,
                'PrivacyProtectAdminContact' => true,
                'PrivacyProtectRegistrantContact' => true,
                'PrivacyProtectTechContact' => true,
                'AdminContact' => $adminContact,
                'RegistrantContact' => $registrantContact,
                'TechContact' => $techContact,
            ]);

            $operationId = $result['OperationId'];

            Log::info('Route53 domain registration initiated', [
                'domain' => $domain,
                'operation_id' => $operationId,
                'years' => $years,
            ]);

            // Create OrganizationDomain record
            $organizationDomain = OrganizationDomain::create([
                'organization_id' => $this->credential->organization_id,
                'cloud_provider_credential_id' => $this->credential->id,
                'domain' => $domain,
                'registrar' => 'route53',
                'status' => 'pending_registration',
                'registration_date' => now(),
                'expiration_date' => now()->addYears($years),
                'auto_renew' => $contactInfo['auto_renew'] ?? true,
                'privacy_protection' => true,
                'transfer_lock' => true,
                'metadata' => [
                    'operation_id' => $operationId,
                    'contact_info' => $this->sanitizeContactInfo($contactInfo),
                ],
            ]);

            // Create hosted zone for DNS management
            $this->createHostedZone($organizationDomain);

            // Dispatch job to poll operation status
            PollDomainOperationStatusJob::dispatch($organizationDomain, $operationId)
                ->delay(now()->addMinutes(30)); // First poll after 30 minutes

            return $organizationDomain;

        } catch (AwsException $e) {
            Log::error('Route53 domain registration failed', [
                'domain' => $domain,
                'error' => $e->getAwsErrorMessage(),
                'code' => $e->getAwsErrorCode(),
            ]);

            throw new DomainRegistrationException(
                "Domain registration failed: {$e->getAwsErrorMessage()}",
                $e->getStatusCode(),
                $e
            );
        }
    }

    /**
     * Transfer domain from another registrar
     *
     * @param string $domain
     * @param string $authCode Authorization code from current registrar
     * @param array $contactInfo
     * @return OrganizationDomain
     */
    public function transferDomain(string $domain, string $authCode, array $contactInfo): OrganizationDomain
    {
        try {
            $this->validateContactInfo($contactInfo);

            $registrantContact = $this->buildContactDetails($contactInfo['registrant'] ?? $contactInfo);
            $adminContact = $this->buildContactDetails($contactInfo['admin'] ?? $contactInfo);
            $techContact = $this->buildContactDetails($contactInfo['tech'] ?? $contactInfo);

            $result = $this->domainsClient->transferDomain([
                'DomainName' => $domain,
                'AuthCode' => $authCode,
                'DurationInYears' => 1, // Transfers automatically add 1 year
                'AutoRenew' => true,
                'PrivacyProtectAdminContact' => true,
                'PrivacyProtectRegistrantContact' => true,
                'PrivacyProtectTechContact' => true,
                'AdminContact' => $adminContact,
                'RegistrantContact' => $registrantContact,
                'TechContact' => $techContact,
            ]);

            $operationId = $result['OperationId'];

            Log::info('Route53 domain transfer initiated', [
                'domain' => $domain,
                'operation_id' => $operationId,
            ]);

            $organizationDomain = OrganizationDomain::create([
                'organization_id' => $this->credential->organization_id,
                'cloud_provider_credential_id' => $this->credential->id,
                'domain' => $domain,
                'registrar' => 'route53',
                'status' => 'pending_transfer',
                'auto_renew' => true,
                'privacy_protection' => true,
                'transfer_lock' => false, // Unlock during transfer
                'metadata' => [
                    'operation_id' => $operationId,
                    'transfer_initiated_at' => now()->toIso8601String(),
                ],
            ]);

            // Poll transfer status
            PollDomainOperationStatusJob::dispatch($organizationDomain, $operationId)
                ->delay(now()->addHours(1)); // Transfers take longer, poll after 1 hour

            return $organizationDomain;

        } catch (AwsException $e) {
            Log::error('Route53 domain transfer failed', [
                'domain' => $domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            throw new DomainRegistrationException(
                "Domain transfer failed: {$e->getAwsErrorMessage()}",
                $e->getStatusCode(),
                $e
            );
        }
    }

    /**
     * Renew domain registration
     *
     * @param OrganizationDomain $domain
     * @param int $years
     * @return bool
     */
    public function renewDomain(OrganizationDomain $domain, int $years = 1): bool
    {
        try {
            $result = $this->domainsClient->renewDomain([
                'DomainName' => $domain->domain,
                'DurationInYears' => $years,
                'CurrentExpiryYear' => $domain->expiration_date->year,
            ]);

            $operationId = $result['OperationId'];

            Log::info('Route53 domain renewal initiated', [
                'domain' => $domain->domain,
                'operation_id' => $operationId,
                'years' => $years,
            ]);

            $domain->update([
                'expiration_date' => $domain->expiration_date->addYears($years),
                'status' => 'active',
                'metadata' => array_merge($domain->metadata ?? [], [
                    'last_renewal_operation' => $operationId,
                    'last_renewed_at' => now()->toIso8601String(),
                ]),
            ]);

            return true;

        } catch (AwsException $e) {
            Log::error('Route53 domain renewal failed', [
                'domain' => $domain->domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return false;
        }
    }

    /**
     * Get domain pricing information
     *
     * @param string $tld Top-level domain (e.g., 'com', 'net', 'org')
     * @return array Pricing information
     */
    public function getDomainPricing(string $tld): array
    {
        try {
            $result = $this->domainsClient->listPrices([
                'Tld' => ltrim($tld, '.'),
            ]);

            $prices = $result['Prices'] ?? [];

            if (empty($prices)) {
                return [
                    'tld' => $tld,
                    'available' => false,
                ];
            }

            $priceData = $prices[0];

            return [
                'tld' => $tld,
                'available' => true,
                'registration_price' => $priceData['RegistrationPrice']['Price'] ?? null,
                'renewal_price' => $priceData['RenewalPrice']['Price'] ?? null,
                'transfer_price' => $priceData['TransferPrice']['Price'] ?? null,
                'currency' => $priceData['RegistrationPrice']['Currency'] ?? 'USD',
            ];

        } catch (AwsException $e) {
            Log::warning('Failed to get Route53 domain pricing', [
                'tld' => $tld,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return [
                'tld' => $tld,
                'available' => false,
                'error' => $e->getAwsErrorMessage(),
            ];
        }
    }

    /**
     * Get domain details from Route53
     *
     * @param string $domain
     * @return array
     */
    public function getDomainDetails(string $domain): array
    {
        try {
            $result = $this->domainsClient->getDomainDetail([
                'DomainName' => $domain,
            ]);

            return [
                'domain' => $result['DomainName'],
                'status' => $result['StatusList'] ?? [],
                'creation_date' => $result['CreationDate'],
                'expiration_date' => $result['ExpirationDate'],
                'updated_date' => $result['UpdatedDate'],
                'auto_renew' => $result['AutoRenew'],
                'transfer_lock' => $result['TransferLock'],
                'privacy_protection' => [
                    'admin' => $result['AdminPrivacy'] ?? false,
                    'registrant' => $result['RegistrantPrivacy'] ?? false,
                    'tech' => $result['TechPrivacy'] ?? false,
                ],
                'nameservers' => $result['Nameservers'] ?? [],
                'dnssec' => $result['DnsSec'] ?? 'DISABLED',
            ];

        } catch (AwsException $e) {
            Log::error('Failed to get Route53 domain details', [
                'domain' => $domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            throw new DomainRegistrationException(
                "Failed to get domain details: {$e->getAwsErrorMessage()}",
                $e->getStatusCode(),
                $e
            );
        }
    }

    /**
     * Enable or disable domain transfer lock
     *
     * @param OrganizationDomain $domain
     * @param bool $locked
     * @return bool
     */
    public function setTransferLock(OrganizationDomain $domain, bool $locked): bool
    {
        try {
            $this->domainsClient->updateDomainTransferLock([
                'DomainName' => $domain->domain,
                'TransferLock' => $locked,
            ]);

            $domain->update(['transfer_lock' => $locked]);

            Log::info('Route53 domain transfer lock updated', [
                'domain' => $domain->domain,
                'locked' => $locked,
            ]);

            return true;

        } catch (AwsException $e) {
            Log::error('Failed to update Route53 domain transfer lock', [
                'domain' => $domain->domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return false;
        }
    }

    /**
     * Enable or disable auto-renewal
     *
     * @param OrganizationDomain $domain
     * @param bool $enabled
     * @return bool
     */
    public function setAutoRenew(OrganizationDomain $domain, bool $enabled): bool
    {
        try {
            $this->domainsClient->updateDomainAutoRenew([
                'DomainName' => $domain->domain,
                'AutoRenew' => $enabled,
            ]);

            $domain->update(['auto_renew' => $enabled]);

            Log::info('Route53 domain auto-renew updated', [
                'domain' => $domain->domain,
                'auto_renew' => $enabled,
            ]);

            return true;

        } catch (AwsException $e) {
            Log::error('Failed to update Route53 auto-renew', [
                'domain' => $domain->domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return false;
        }
    }

    /**
     * Get operation status (for async operations like registration, transfer)
     *
     * @param string $operationId
     * @return array
     */
    public function getOperationStatus(string $operationId): array
    {
        try {
            $result = $this->domainsClient->getOperationDetail([
                'OperationId' => $operationId,
            ]);

            return [
                'operation_id' => $result['OperationId'],
                'status' => $result['Status'],
                'domain' => $result['DomainName'],
                'type' => $result['Type'],
                'submitted_date' => $result['SubmittedDate'],
                'last_updated_date' => $result['LastUpdatedDate'] ?? null,
                'message' => $result['Message'] ?? null,
            ];

        } catch (AwsException $e) {
            Log::error('Failed to get Route53 operation status', [
                'operation_id' => $operationId,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return [
                'operation_id' => $operationId,
                'status' => 'UNKNOWN',
                'error' => $e->getAwsErrorMessage(),
            ];
        }
    }

    /**
     * Create Route53 hosted zone for DNS management
     *
     * @param OrganizationDomain $domain
     * @return string Hosted zone ID
     */
    private function createHostedZone(OrganizationDomain $domain): string
    {
        try {
            $result = $this->route53Client->createHostedZone([
                'Name' => $domain->domain,
                'CallerReference' => uniqid('coolify-', true),
                'HostedZoneConfig' => [
                    'Comment' => "Managed by Coolify for organization {$domain->organization_id}",
                    'PrivateZone' => false,
                ],
            ]);

            $hostedZoneId = $result['HostedZone']['Id'];
            $nameservers = array_map(
                fn ($ns) => $ns,
                $result['DelegationSet']['NameServers']
            );

            Log::info('Route53 hosted zone created', [
                'domain' => $domain->domain,
                'hosted_zone_id' => $hostedZoneId,
                'nameservers' => $nameservers,
            ]);

            // Update domain with hosted zone information
            $domain->update([
                'metadata' => array_merge($domain->metadata ?? [], [
                    'hosted_zone_id' => $hostedZoneId,
                    'nameservers' => $nameservers,
                ]),
            ]);

            // Update domain nameservers at registrar
            $this->updateNameservers($domain, $nameservers);

            return $hostedZoneId;

        } catch (AwsException $e) {
            Log::error('Failed to create Route53 hosted zone', [
                'domain' => $domain->domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            throw new DomainRegistrationException(
                "Failed to create hosted zone: {$e->getAwsErrorMessage()}",
                $e->getStatusCode(),
                $e
            );
        }
    }

    /**
     * Update domain nameservers
     *
     * @param OrganizationDomain $domain
     * @param array $nameservers
     * @return bool
     */
    private function updateNameservers(OrganizationDomain $domain, array $nameservers): bool
    {
        try {
            $nsRecords = array_map(
                fn ($ns) => ['Name' => $ns],
                $nameservers
            );

            $this->domainsClient->updateDomainNameservers([
                'DomainName' => $domain->domain,
                'Nameservers' => $nsRecords,
            ]);

            Log::info('Route53 domain nameservers updated', [
                'domain' => $domain->domain,
                'nameservers' => $nameservers,
            ]);

            return true;

        } catch (AwsException $e) {
            Log::error('Failed to update Route53 domain nameservers', [
                'domain' => $domain->domain,
                'error' => $e->getAwsErrorMessage(),
            ]);

            return false;
        }
    }

    /**
     * Build AWS contact details structure
     *
     * @param array $contact
     * @return array
     */
    private function buildContactDetails(array $contact): array
    {
        return [
            'FirstName' => $contact['first_name'],
            'LastName' => $contact['last_name'],
            'ContactType' => $contact['contact_type'] ?? 'PERSON',
            'OrganizationName' => $contact['organization'] ?? null,
            'AddressLine1' => $contact['address_line_1'],
            'AddressLine2' => $contact['address_line_2'] ?? null,
            'City' => $contact['city'],
            'State' => $contact['state'] ?? null,
            'CountryCode' => $contact['country_code'],
            'ZipCode' => $contact['zip_code'],
            'PhoneNumber' => $contact['phone_number'],
            'Email' => $contact['email'],
        ];
    }

    /**
     * Validate contact information structure
     *
     * @param array $contactInfo
     * @return void
     * @throws DomainRegistrationException
     */
    private function validateContactInfo(array $contactInfo): void
    {
        $required = ['first_name', 'last_name', 'email', 'phone_number', 'address_line_1', 'city', 'country_code', 'zip_code'];

        $contact = $contactInfo['registrant'] ?? $contactInfo;

        foreach ($required as $field) {
            if (empty($contact[$field])) {
                throw new DomainRegistrationException("Missing required contact field: {$field}");
            }
        }
    }

    /**
     * Sanitize contact info for storage (remove sensitive data)
     *
     * @param array $contactInfo
     * @return array
     */
    private function sanitizeContactInfo(array $contactInfo): array
    {
        // Remove phone numbers and emails for privacy
        $sanitized = $contactInfo;

        if (isset($sanitized['registrant']['phone_number'])) {
            $sanitized['registrant']['phone_number'] = '***-***-****';
        }

        if (isset($sanitized['registrant']['email'])) {
            $sanitized['registrant']['email'] = str_replace(
                strstr($sanitized['registrant']['email'], '@'),
                '@***',
                $sanitized['registrant']['email']
            );
        }

        return $sanitized;
    }
}
```

### Background Job for Operation Status Polling

**File:** `app/Jobs/Enterprise/PollDomainOperationStatusJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\OrganizationDomain;
use App\Services\Enterprise\DomainRegistrarService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class PollDomainOperationStatusJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $timeout = 120;

    public function __construct(
        private OrganizationDomain $domain,
        private string $operationId
    ) {
        $this->onQueue('domain-operations');
    }

    public function handle(DomainRegistrarService $registrarService): void
    {
        try {
            $registrar = $registrarService->getRegistrar($this->domain);

            // Get operation status from AWS
            $status = $registrar->getOperationStatus($this->operationId);

            Log::info('Domain operation status polled', [
                'domain' => $this->domain->domain,
                'operation_id' => $this->operationId,
                'status' => $status['status'],
            ]);

            // Update domain status based on operation result
            match ($status['status']) {
                'SUCCESSFUL' => $this->handleSuccess(),
                'FAILED' => $this->handleFailure($status['message'] ?? 'Operation failed'),
                'IN_PROGRESS', 'PENDING' => $this->scheduleNextPoll(),
                default => Log::warning('Unknown operation status', ['status' => $status]),
            };

        } catch (\Exception $e) {
            Log::error('Failed to poll domain operation status', [
                'domain_id' => $this->domain->id,
                'operation_id' => $this->operationId,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    private function handleSuccess(): void
    {
        $newStatus = match ($this->domain->status) {
            'pending_registration' => 'active',
            'pending_transfer' => 'active',
            default => 'active',
        };

        $this->domain->update([
            'status' => $newStatus,
            'metadata' => array_merge($this->domain->metadata ?? [], [
                'operation_completed_at' => now()->toIso8601String(),
            ]),
        ]);

        Log::info('Domain operation completed successfully', [
            'domain' => $this->domain->domain,
            'new_status' => $newStatus,
        ]);
    }

    private function handleFailure(string $message): void
    {
        $this->domain->update([
            'status' => 'failed',
            'metadata' => array_merge($this->domain->metadata ?? [], [
                'operation_failed_at' => now()->toIso8601String(),
                'failure_reason' => $message,
            ]),
        ]);

        Log::error('Domain operation failed', [
            'domain' => $this->domain->domain,
            'reason' => $message,
        ]);
    }

    private function scheduleNextPoll(): void
    {
        // Schedule next poll in 1 hour
        self::dispatch($this->domain, $this->operationId)
            ->delay(now()->addHour());
    }

    public function tags(): array
    {
        return [
            'domain-operations',
            "domain:{$this->domain->id}",
            "organization:{$this->domain->organization_id}",
        ];
    }
}
```

### Configuration Updates

**File:** `config/domain-registrars.php` (add Route53 configuration)

```php
return [
    'providers' => [
        'namecheap' => [
            'enabled' => env('NAMECHEAP_ENABLED', false),
            'api_user' => env('NAMECHEAP_API_USER'),
            'api_key' => env('NAMECHEAP_API_KEY'),
            'sandbox' => env('NAMECHEAP_SANDBOX', true),
        ],
        'route53' => [
            'enabled' => env('ROUTE53_ENABLED', true),
            'region' => env('ROUTE53_REGION', 'us-east-1'),
            'supported_tlds' => [
                'com', 'net', 'org', 'info', 'biz',
                'io', 'app', 'dev', 'cloud', 'tech',
                'xyz', 'online', 'site', 'store', 'shop',
                'co', 'me', 'tv', 'cc', 'name',
            ],
        ],
    ],

    'default_provider' => env('DEFAULT_DOMAIN_REGISTRAR', 'route53'),

    'operation_polling' => [
        'interval_minutes' => 60, // Poll every hour
        'max_attempts' => 72, // 72 hours max (3 days)
    ],
];
```

### Factory Integration

**File:** `app/Services/Enterprise/DomainRegistrarService.php` (modify factory method)

```php
public function getRegistrar(OrganizationDomain $domain): DomainRegistrarInterface
{
    $credential = $domain->cloudProviderCredential;

    return match ($domain->registrar) {
        'namecheap' => new NamecheapRegistrar($credential),
        'route53' => new Route53DomainsRegistrar($credential),
        default => throw new \InvalidArgumentException("Unsupported registrar: {$domain->registrar}"),
    };
}
```

## Implementation Approach

### Step 1: Install AWS SDK
```bash
composer require aws/aws-sdk-php
```

### Step 2: Create Route53DomainsRegistrar Class
1. Create class in `app/Services/Enterprise/DomainRegistrars/`
2. Implement `DomainRegistrarInterface`
3. Initialize AWS SDK clients (Route53Domains + Route53 DNS)
4. Inject `CloudProviderCredential` dependency

### Step 3: Implement Core Registration Methods
1. `checkAvailability()` - Domain availability checking
2. `registerDomain()` - New domain registration with hosted zone creation
3. `transferDomain()` - Domain transfer with auth code
4. `renewDomain()` - Domain renewal management
5. `getDomainPricing()` - Real-time pricing information

### Step 4: Implement Domain Management Methods
1. `getDomainDetails()` - Fetch domain metadata from Route53
2. `setTransferLock()` - Enable/disable transfer protection
3. `setAutoRenew()` - Configure auto-renewal
4. `updateNameservers()` - Update domain nameservers
5. `getOperationStatus()` - Poll async operation status

### Step 5: Hosted Zone Integration
1. `createHostedZone()` - Automatic hosted zone creation
2. Nameserver propagation to domain
3. Integration with DnsManagementService (Task 67)
4. Automatic DNS record creation

### Step 6: Async Operation Polling
1. Create `PollDomainOperationStatusJob`
2. Schedule recurring status checks
3. Update `OrganizationDomain` status on completion
4. Handle success/failure states

### Step 7: Error Handling and Logging
1. Comprehensive AWS exception handling
2. Detailed error logging with context
3. User-friendly error messages
4. Retry logic for transient failures

### Step 8: Testing
1. Unit tests with AWS SDK mocking
2. Integration tests with full workflow
3. Test error scenarios (rate limits, quota exceeded)
4. Test async operation polling

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/Route53DomainsRegistrarTest.php`

```php
<?php

use App\Services\Enterprise\DomainRegistrars\Route53DomainsRegistrar;
use App\Models\CloudProviderCredential;
use App\Models\Organization;
use Aws\Route53Domains\Route53DomainsClient;
use Aws\Route53\Route53Client;
use Aws\Result;

beforeEach(function () {
    $this->organization = Organization::factory()->create();

    $this->credential = CloudProviderCredential::factory()->create([
        'organization_id' => $this->organization->id,
        'provider' => 'aws',
        'credentials' => [
            'access_key_id' => 'AKIAIOSFODNN7EXAMPLE',
            'secret_access_key' => 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
            'region' => 'us-east-1',
        ],
    ]);
});

it('checks domain availability successfully', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('checkDomainAvailability')
        ->once()
        ->with(['DomainName' => 'example.com'])
        ->andReturn(new Result(['Availability' => 'AVAILABLE']));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $available = $registrar->checkAvailability('example.com');

    expect($available)->toBeTrue();
});

it('returns false when domain is unavailable', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('checkDomainAvailability')
        ->once()
        ->andReturn(new Result(['Availability' => 'UNAVAILABLE']));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $available = $registrar->checkAvailability('unavailable.com');

    expect($available)->toBeFalse();
});

it('registers domain with hosted zone creation', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockRoute53Client = Mockery::mock(Route53Client::class);

    // Mock domain registration
    $mockDomainsClient->shouldReceive('registerDomain')
        ->once()
        ->andReturn(new Result(['OperationId' => 'operation-12345']));

    // Mock hosted zone creation
    $mockRoute53Client->shouldReceive('createHostedZone')
        ->once()
        ->andReturn(new Result([
            'HostedZone' => ['Id' => '/hostedzone/Z1234567890ABC'],
            'DelegationSet' => [
                'NameServers' => [
                    'ns-1.awsdns-01.com',
                    'ns-2.awsdns-02.net',
                ],
            ],
        ]));

    // Mock nameserver update
    $mockDomainsClient->shouldReceive('updateDomainNameservers')
        ->once()
        ->andReturn(new Result([]));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;
    invade($registrar)->route53Client = $mockRoute53Client;

    $contactInfo = [
        'first_name' => 'John',
        'last_name' => 'Doe',
        'email' => 'john@example.com',
        'phone_number' => '+1.2025551234',
        'address_line_1' => '123 Main St',
        'city' => 'New York',
        'state' => 'NY',
        'country_code' => 'US',
        'zip_code' => '10001',
    ];

    $domain = $registrar->registerDomain('example.com', $contactInfo, 1);

    expect($domain)
        ->toBeInstanceOf(\App\Models\OrganizationDomain::class)
        ->status->toBe('pending_registration')
        ->domain->toBe('example.com')
        ->metadata->toHaveKey('operation_id', 'operation-12345')
        ->metadata->toHaveKey('hosted_zone_id');
});

it('transfers domain with authorization code', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('transferDomain')
        ->once()
        ->with(Mockery::on(function ($args) {
            return $args['DomainName'] === 'transfer.com'
                && $args['AuthCode'] === 'AUTH123456';
        }))
        ->andReturn(new Result(['OperationId' => 'transfer-op-789']));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $contactInfo = [
        'first_name' => 'Jane',
        'last_name' => 'Smith',
        'email' => 'jane@example.com',
        'phone_number' => '+1.2025555678',
        'address_line_1' => '456 Oak Ave',
        'city' => 'Los Angeles',
        'state' => 'CA',
        'country_code' => 'US',
        'zip_code' => '90001',
    ];

    $domain = $registrar->transferDomain('transfer.com', 'AUTH123456', $contactInfo);

    expect($domain)
        ->status->toBe('pending_transfer')
        ->domain->toBe('transfer.com')
        ->transfer_lock->toBeFalse();
});

it('renews domain successfully', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('renewDomain')
        ->once()
        ->andReturn(new Result(['OperationId' => 'renewal-op-456']));

    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $this->organization->id,
        'cloud_provider_credential_id' => $this->credential->id,
        'domain' => 'renew.com',
        'expiration_date' => now()->addMonths(2),
    ]);

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $result = $registrar->renewDomain($domain, 1);

    expect($result)->toBeTrue();
    expect($domain->fresh()->expiration_date->year)->toBe(now()->addYear()->addMonths(2)->year);
});

it('gets domain pricing information', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('listPrices')
        ->once()
        ->with(['Tld' => 'com'])
        ->andReturn(new Result([
            'Prices' => [
                [
                    'RegistrationPrice' => ['Price' => 12.00, 'Currency' => 'USD'],
                    'RenewalPrice' => ['Price' => 12.00, 'Currency' => 'USD'],
                    'TransferPrice' => ['Price' => 12.00, 'Currency' => 'USD'],
                ],
            ],
        ]));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $pricing = $registrar->getDomainPricing('com');

    expect($pricing)
        ->toHaveKey('tld', 'com')
        ->toHaveKey('registration_price', 12.00)
        ->toHaveKey('renewal_price', 12.00)
        ->toHaveKey('currency', 'USD');
});

it('sets transfer lock', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('updateDomainTransferLock')
        ->once()
        ->with(['DomainName' => 'locked.com', 'TransferLock' => true])
        ->andReturn(new Result([]));

    $domain = OrganizationDomain::factory()->create([
        'domain' => 'locked.com',
        'transfer_lock' => false,
    ]);

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $result = $registrar->setTransferLock($domain, true);

    expect($result)->toBeTrue();
    expect($domain->fresh()->transfer_lock)->toBeTrue();
});

it('gets operation status', function () {
    $mockDomainsClient = Mockery::mock(Route53DomainsClient::class);
    $mockDomainsClient->shouldReceive('getOperationDetail')
        ->once()
        ->with(['OperationId' => 'op-123'])
        ->andReturn(new Result([
            'OperationId' => 'op-123',
            'Status' => 'SUCCESSFUL',
            'DomainName' => 'example.com',
            'Type' => 'REGISTER_DOMAIN',
            'SubmittedDate' => now()->subHours(2),
        ]));

    $registrar = new Route53DomainsRegistrar($this->credential);
    invade($registrar)->domainsClient = $mockDomainsClient;

    $status = $registrar->getOperationStatus('op-123');

    expect($status)
        ->toHaveKey('operation_id', 'op-123')
        ->toHaveKey('status', 'SUCCESSFUL')
        ->toHaveKey('domain', 'example.com');
});
```

### Integration Tests

**File:** `tests/Feature/Route53DomainManagementTest.php`

```php
<?php

use App\Services\Enterprise\DomainRegistrarService;
use App\Models\CloudProviderCredential;
use App\Models\Organization;
use App\Jobs\Enterprise\PollDomainOperationStatusJob;
use Illuminate\Support\Facades\Queue;

it('registers domain with Route53 end-to-end', function () {
    Queue::fake();

    $organization = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'aws',
    ]);

    $registrarService = app(DomainRegistrarService::class);

    // Mock AWS SDK responses
    // (In real implementation, use AWS SDK mocking or VCR for HTTP recording)

    $contactInfo = [
        'first_name' => 'Test',
        'last_name' => 'User',
        'email' => 'test@example.com',
        'phone_number' => '+1.2025551234',
        'address_line_1' => '123 Test St',
        'city' => 'Test City',
        'country_code' => 'US',
        'zip_code' => '12345',
    ];

    // This would call real AWS API in integration environment
    // For unit tests, we mock the registrar
    $domain = $registrarService->registerDomain(
        $organization,
        $credential,
        'testdomain.com',
        $contactInfo
    );

    expect($domain)
        ->toBeInstanceOf(\App\Models\OrganizationDomain::class)
        ->status->toBe('pending_registration');

    // Verify operation polling job was dispatched
    Queue::assertPushed(PollDomainOperationStatusJob::class);
});
```

## Definition of Done

- [ ] Route53DomainsRegistrar class created implementing DomainRegistrarInterface
- [ ] AWS SDK for PHP installed and configured
- [ ] `checkAvailability()` method implemented with real-time checks
- [ ] `registerDomain()` method implemented with hosted zone creation
- [ ] `transferDomain()` method implemented with auth code handling
- [ ] `renewDomain()` method implemented
- [ ] `getDomainPricing()` method implemented
- [ ] `getDomainDetails()` method implemented
- [ ] `setTransferLock()` method implemented
- [ ] `setAutoRenew()` method implemented
- [ ] `getOperationStatus()` method implemented
- [ ] Automatic Route53 hosted zone creation on registration
- [ ] Nameserver propagation to domain after hosted zone creation
- [ ] WHOIS privacy protection enabled by default
- [ ] PollDomainOperationStatusJob created for async status polling
- [ ] Job scheduled hourly for pending operations
- [ ] Configuration file updated with Route53 settings
- [ ] Factory method updated to instantiate Route53DomainsRegistrar
- [ ] Comprehensive error handling for AWS exceptions
- [ ] Detailed logging with operation context
- [ ] Unit tests written (12+ tests, >90% coverage)
- [ ] AWS SDK mocking working in tests
- [ ] Integration tests written (3+ tests)
- [ ] Contact information validation implemented
- [ ] Support for 20+ common TLDs verified
- [ ] PHPDoc blocks complete for all public methods
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing with AWS sandbox completed
- [ ] Documentation updated with Route53 usage examples
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 63 (DomainRegistrarInterface and factory pattern)
- **Integrates with:** Task 67 (DnsManagementService for DNS records)
- **Used by:** Task 70 (DomainManager.vue frontend component)
- **Integrates with:** Task 68 (Let's Encrypt SSL for registered domains)
- **Used by:** Task 19 (Server auto-registration with domain DNS)
