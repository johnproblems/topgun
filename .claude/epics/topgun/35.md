---
name: Implement canary deployment strategy with traffic splitting
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:53Z
github: https://github.com/johnproblems/topgun/issues/145
depends_on: [32]
parallel: false
conflicts_with: []
---

# Task: Implement canary deployment strategy with traffic splitting

## Description

Implement a sophisticated canary deployment strategy that gradually shifts traffic from stable production instances to new canary instances, enabling safe deployments with automatic rollback capabilities. This advanced deployment pattern minimizes risk by exposing new code to a small percentage of users first, monitoring key metrics, and progressively increasing traffic only when the canary proves stable.

Canary deployments are the gold standard for risk mitigation in production environments. Unlike rolling updates that replace all instances sequentially or blue-green deployments that switch all traffic at once, canary deployments allow incremental validation with real production traffic. This enables early detection of subtle issues (performance degradation, edge case bugs, resource leaks) that may not appear in testing but emerge under real load patterns.

**Core Deployment Workflow:**

1. **Deploy Canary**: Launch new application version on a small subset of servers (typically 10-20% of total capacity)
2. **Initial Traffic Split**: Route 5-10% of production traffic to canary instances
3. **Health Monitoring**: Track error rates, response times, CPU/memory usage on canary vs. stable
4. **Progressive Rollout**: If metrics are healthy, gradually increase canary traffic (10% → 25% → 50% → 75% → 100%)
5. **Completion**: Once 100% of traffic is on canary, terminate old stable instances
6. **Automatic Rollback**: If health checks fail at any stage, immediately route all traffic back to stable instances and alert operators

**Traffic Splitting Mechanics:**

Traffic distribution is controlled at the **proxy layer** (Nginx/Traefik) using weighted upstream server pools. For example, with a 30% canary split:

```nginx
upstream app_backend {
    server stable-1:3000 weight=70;
    server stable-2:3000 weight=70;
    server canary-1:3000 weight=30;
    server canary-2:3000 weight=30;
}
```

The deployment service dynamically regenerates proxy configurations as traffic percentages change, applying new configurations with zero-downtime reloads (e.g., `nginx -s reload` or Traefik's dynamic configuration API).

**Integration with Existing Coolify Architecture:**

- **Builds on**: Task 32 (EnhancedDeploymentService foundation with `deployWithStrategy()` method)
- **Uses**: CapacityManager (Task 26) for intelligent server selection for canary instances
- **Leverages**: SystemResourceMonitor (Task 25) for real-time canary health metrics
- **Integrates with**: Existing `ApplicationDeploymentJob` for container orchestration
- **Extends**: Server proxy configuration system (Nginx/Traefik) for traffic splitting
- **Complements**: Task 33 (Rolling Updates) and Task 34 (Blue-Green) as deployment strategy options

**Why Canary Deployments Are Critical for Enterprise Coolify:**

1. **Risk Mitigation**: Limits blast radius of deployment failures to 5-30% of users instead of 100%
2. **Early Detection**: Real production traffic reveals issues that testing environments miss
3. **Gradual Validation**: Operators can verify metrics at each traffic percentage before proceeding
4. **User Experience**: Majority of users remain on stable version during risky deployment phases
5. **Compliance**: Many regulated industries (finance, healthcare) require gradual rollout capabilities
6. **Confidence**: Teams can deploy more frequently knowing risks are contained

For enterprise users managing critical applications with SLAs, canary deployments transform deployment from a high-risk event into a controlled, observable process with built-in safety mechanisms.

## Acceptance Criteria

- [ ] CanaryDeploymentStrategy class implements DeploymentStrategyInterface
- [ ] Strategy initiates by deploying canary instances to 10-20% of server capacity
- [ ] Initial traffic split defaults to 10% canary, 90% stable (configurable)
- [ ] Progressive rollout stages: 10% → 25% → 50% → 75% → 100% (configurable percentages and stage count)
- [ ] Each stage waits for configurable stabilization period (default 5 minutes)
- [ ] Health checks validate canary instances at each stage before progressing
- [ ] Metric comparison between canary and stable: error rate, p95 response time, CPU, memory
- [ ] Automatic rollback if canary error rate exceeds stable by >5% (configurable threshold)
- [ ] Automatic rollback if canary p95 latency exceeds stable by >50% (configurable threshold)
- [ ] Automatic rollback if canary health checks fail 3 consecutive times
- [ ] Manual promotion option to skip stages and immediately promote canary
- [ ] Manual rollback option to immediately revert to stable
- [ ] Proxy configuration (Nginx/Traefik) dynamically updated for each traffic split change
- [ ] Deployment status tracked with real-time progress updates via WebSocket
- [ ] Deployment history logs each stage transition with metrics snapshot
- [ ] Integration with EnhancedDeploymentService as selectable strategy
- [ ] Support for user-specified canary configuration (traffic percentages, stage durations, thresholds)

## Technical Details

### File Paths

**Strategy Implementation:**
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/CanaryDeploymentStrategy.php` (new)
- `/home/topgun/topgun/app/Contracts/Deployment/DeploymentStrategyInterface.php` (existing interface)

**Configuration:**
- `/home/topgun/topgun/config/deployment.php` (add canary settings)

**Database Migrations:**
- `/home/topgun/topgun/database/migrations/2025_XX_XX_XXXXXX_add_canary_deployment_tracking_columns.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Deployment.php` (enhance with canary tracking)
- `/home/topgun/topgun/app/Models/Application.php` (existing)
- `/home/topgun/topgun/app/Models/Server.php` (existing)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/CanaryProgressionJob.php` (new - handles stage transitions)
- `/home/topgun/topgun/app/Jobs/Enterprise/CanaryHealthCheckJob.php` (new - monitors canary metrics)

**Services:**
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/EnhancedDeploymentService.php` (existing, integrate canary)
- `/home/topgun/topgun/app/Services/Enterprise/ProxyConfigService.php` (new - manages Nginx/Traefik configs)
- `/home/topgun/topgun/app/Services/Enterprise/CapacityManager.php` (existing - server selection)
- `/home/topgun/topgun/app/Services/Enterprise/SystemResourceMonitor.php` (existing - health metrics)

### Database Schema Enhancement

**Migration:** `database/migrations/2025_XX_XX_XXXXXX_add_canary_deployment_tracking_columns.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('deployments', function (Blueprint $table) {
            // Canary deployment tracking
            $table->string('deployment_strategy')->default('standard')->after('status');
            $table->json('canary_config')->nullable()->after('deployment_strategy');
            $table->integer('current_canary_stage')->default(0)->after('canary_config');
            $table->integer('canary_traffic_percentage')->default(0)->after('current_canary_stage');
            $table->json('canary_server_ids')->nullable()->after('canary_traffic_percentage');
            $table->json('stable_server_ids')->nullable()->after('canary_server_ids');
            $table->json('canary_metrics_snapshot')->nullable()->after('stable_server_ids');
            $table->timestamp('canary_stage_started_at')->nullable()->after('canary_metrics_snapshot');
            $table->string('canary_status')->nullable()->after('canary_stage_started_at');
            // Possible values: pending, in_progress, monitoring, promoting, rolling_back, completed, failed

            $table->index(['deployment_strategy', 'status']);
            $table->index('canary_status');
        });
    }

    public function down(): void
    {
        Schema::table('deployments', function (Blueprint $table) {
            $table->dropIndex(['deployment_strategy', 'status']);
            $table->dropIndex(['canary_status']);

            $table->dropColumn([
                'deployment_strategy',
                'canary_config',
                'current_canary_stage',
                'canary_traffic_percentage',
                'canary_server_ids',
                'stable_server_ids',
                'canary_metrics_snapshot',
                'canary_stage_started_at',
                'canary_status',
            ]);
        });
    }
};
```

### Deployment Strategy Interface

**File:** `app/Contracts/Deployment/DeploymentStrategyInterface.php` (existing, for reference)

```php
<?php

namespace App\Contracts\Deployment;

use App\Models\Application;
use App\Models\Deployment;

interface DeploymentStrategyInterface
{
    /**
     * Execute deployment using this strategy
     *
     * @param Application $application
     * @param array $config Strategy-specific configuration
     * @return Deployment
     */
    public function deploy(Application $application, array $config = []): Deployment;

    /**
     * Rollback deployment to previous stable version
     *
     * @param Deployment $deployment
     * @return bool
     */
    public function rollback(Deployment $deployment): bool;

    /**
     * Get deployment status and progress
     *
     * @param Deployment $deployment
     * @return array
     */
    public function getStatus(Deployment $deployment): array;

    /**
     * Validate configuration for this strategy
     *
     * @param array $config
     * @return array Validation errors (empty if valid)
     */
    public function validateConfig(array $config): array;
}
```

### Canary Deployment Strategy Implementation

**File:** `app/Services/Enterprise/Deployment/CanaryDeploymentStrategy.php`

```php
<?php

namespace App\Services\Enterprise\Deployment;

use App\Contracts\Deployment\DeploymentStrategyInterface;
use App\Jobs\Enterprise\CanaryProgressionJob;
use App\Jobs\Enterprise\CanaryHealthCheckJob;
use App\Models\Application;
use App\Models\Deployment;
use App\Models\Server;
use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\ProxyConfigService;
use App\Services\Enterprise\SystemResourceMonitor;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

class CanaryDeploymentStrategy implements DeploymentStrategyInterface
{
    private const DEFAULT_STAGES = [10, 25, 50, 75, 100]; // Traffic percentages
    private const DEFAULT_STAGE_DURATION = 300; // 5 minutes in seconds
    private const ERROR_RATE_THRESHOLD = 5.0; // % increase over stable
    private const LATENCY_THRESHOLD = 50.0; // % increase over stable
    private const HEALTH_CHECK_FAILURES_THRESHOLD = 3;

    public function __construct(
        private CapacityManager $capacityManager,
        private ProxyConfigService $proxyService,
        private SystemResourceMonitor $resourceMonitor
    ) {}

    /**
     * Execute canary deployment
     *
     * @param Application $application
     * @param array $config
     * @return Deployment
     */
    public function deploy(Application $application, array $config = []): Deployment
    {
        Log::info('Starting canary deployment', [
            'application_id' => $application->id,
            'application_name' => $application->name,
            'config' => $config,
        ]);

        // Validate configuration
        $errors = $this->validateConfig($config);
        if (!empty($errors)) {
            throw new \InvalidArgumentException('Invalid canary configuration: ' . implode(', ', $errors));
        }

        return DB::transaction(function () use ($application, $config) {
            // Step 1: Create deployment record
            $deployment = $this->createDeployment($application, $config);

            try {
                // Step 2: Select servers for canary and stable
                $this->selectCanaryAndStableServers($deployment, $application);

                // Step 3: Deploy canary version to canary servers
                $this->deployCanaryInstances($deployment, $application);

                // Step 4: Initialize traffic split at 0% (canary deployed but not serving traffic yet)
                $this->updateTrafficSplit($deployment, 0);

                // Step 5: Start canary progression (async)
                CanaryProgressionJob::dispatch($deployment)
                    ->delay(now()->addSeconds(30)); // 30 second warm-up period

                // Step 6: Start health monitoring (async, runs every 30 seconds)
                CanaryHealthCheckJob::dispatch($deployment)
                    ->delay(now()->addSeconds(30));

                $deployment->update([
                    'canary_status' => 'monitoring',
                    'canary_stage_started_at' => now(),
                ]);

                Log::info('Canary deployment initialized successfully', [
                    'deployment_id' => $deployment->id,
                    'canary_servers' => $deployment->canary_server_ids,
                    'stable_servers' => $deployment->stable_server_ids,
                ]);

                return $deployment->fresh();

            } catch (\Exception $e) {
                Log::error('Canary deployment initialization failed', [
                    'deployment_id' => $deployment->id,
                    'error' => $e->getMessage(),
                    'trace' => $e->getTraceAsString(),
                ]);

                $deployment->update([
                    'status' => 'failed',
                    'canary_status' => 'failed',
                    'error_message' => $e->getMessage(),
                ]);

                throw $e;
            }
        });
    }

    /**
     * Rollback canary deployment to stable version
     *
     * @param Deployment $deployment
     * @return bool
     */
    public function rollback(Deployment $deployment): bool
    {
        Log::warning('Initiating canary rollback', [
            'deployment_id' => $deployment->id,
            'current_stage' => $deployment->current_canary_stage,
            'current_traffic' => $deployment->canary_traffic_percentage,
        ]);

        try {
            $deployment->update([
                'canary_status' => 'rolling_back',
            ]);

            // Step 1: Route 100% traffic to stable servers
            $this->updateTrafficSplit($deployment, 0);

            // Step 2: Terminate canary instances
            $this->terminateCanaryInstances($deployment);

            // Step 3: Update deployment status
            $deployment->update([
                'status' => 'rolled_back',
                'canary_status' => 'rolled_back',
                'canary_traffic_percentage' => 0,
                'completed_at' => now(),
            ]);

            Log::info('Canary rollback completed successfully', [
                'deployment_id' => $deployment->id,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Canary rollback failed', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            $deployment->update([
                'canary_status' => 'rollback_failed',
                'error_message' => "Rollback failed: {$e->getMessage()}",
            ]);

            return false;
        }
    }

    /**
     * Get canary deployment status and metrics
     *
     * @param Deployment $deployment
     * @return array
     */
    public function getStatus(Deployment $deployment): array
    {
        $canaryConfig = $deployment->canary_config ?? [];
        $stages = $canaryConfig['stages'] ?? self::DEFAULT_STAGES;

        return [
            'id' => $deployment->id,
            'strategy' => 'canary',
            'status' => $deployment->status,
            'canary_status' => $deployment->canary_status,
            'current_stage' => $deployment->current_canary_stage,
            'total_stages' => count($stages),
            'current_traffic_percentage' => $deployment->canary_traffic_percentage,
            'target_traffic_percentage' => $stages[$deployment->current_canary_stage] ?? 100,
            'canary_servers' => $this->getServerDetails($deployment->canary_server_ids ?? []),
            'stable_servers' => $this->getServerDetails($deployment->stable_server_ids ?? []),
            'metrics' => $deployment->canary_metrics_snapshot ?? [],
            'stage_started_at' => $deployment->canary_stage_started_at?->toIso8601String(),
            'next_stage_at' => $this->calculateNextStageTime($deployment),
            'can_promote' => $this->canPromote($deployment),
            'can_rollback' => $this->canRollback($deployment),
        ];
    }

    /**
     * Validate canary configuration
     *
     * @param array $config
     * @return array Validation errors
     */
    public function validateConfig(array $config): array
    {
        $errors = [];

        // Validate stages
        if (isset($config['stages'])) {
            if (!is_array($config['stages'])) {
                $errors[] = 'stages must be an array';
            } else {
                foreach ($config['stages'] as $stage) {
                    if (!is_numeric($stage) || $stage < 0 || $stage > 100) {
                        $errors[] = 'stage percentages must be between 0 and 100';
                        break;
                    }
                }
            }
        }

        // Validate stage duration
        if (isset($config['stage_duration'])) {
            if (!is_numeric($config['stage_duration']) || $config['stage_duration'] < 60) {
                $errors[] = 'stage_duration must be at least 60 seconds';
            }
        }

        // Validate thresholds
        if (isset($config['error_rate_threshold'])) {
            if (!is_numeric($config['error_rate_threshold']) || $config['error_rate_threshold'] <= 0) {
                $errors[] = 'error_rate_threshold must be a positive number';
            }
        }

        if (isset($config['latency_threshold'])) {
            if (!is_numeric($config['latency_threshold']) || $config['latency_threshold'] <= 0) {
                $errors[] = 'latency_threshold must be a positive number';
            }
        }

        // Validate canary server count
        if (isset($config['canary_server_count'])) {
            if (!is_int($config['canary_server_count']) || $config['canary_server_count'] < 1) {
                $errors[] = 'canary_server_count must be at least 1';
            }
        }

        return $errors;
    }

    /**
     * Progress canary to next stage
     *
     * @param Deployment $deployment
     * @return bool
     */
    public function progressToNextStage(Deployment $deployment): bool
    {
        $canaryConfig = $deployment->canary_config ?? [];
        $stages = $canaryConfig['stages'] ?? self::DEFAULT_STAGES;

        $currentStage = $deployment->current_canary_stage;
        $nextStage = $currentStage + 1;

        if ($nextStage >= count($stages)) {
            // Final stage reached, promote canary to stable
            return $this->promoteCanaryToStable($deployment);
        }

        $targetTrafficPercentage = $stages[$nextStage];

        Log::info('Progressing canary to next stage', [
            'deployment_id' => $deployment->id,
            'current_stage' => $currentStage,
            'next_stage' => $nextStage,
            'target_traffic' => $targetTrafficPercentage,
        ]);

        try {
            // Update traffic split
            $this->updateTrafficSplit($deployment, $targetTrafficPercentage);

            // Update deployment record
            $deployment->update([
                'current_canary_stage' => $nextStage,
                'canary_traffic_percentage' => $targetTrafficPercentage,
                'canary_stage_started_at' => now(),
            ]);

            Log::info('Canary progressed to next stage', [
                'deployment_id' => $deployment->id,
                'new_stage' => $nextStage,
                'new_traffic' => $targetTrafficPercentage,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Failed to progress canary to next stage', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Check if canary metrics are healthy compared to stable
     *
     * @param Deployment $deployment
     * @return array [healthy => bool, reasons => array]
     */
    public function checkCanaryHealth(Deployment $deployment): array
    {
        $canaryServers = Server::whereIn('id', $deployment->canary_server_ids ?? [])->get();
        $stableServers = Server::whereIn('id', $deployment->stable_server_ids ?? [])->get();

        if ($canaryServers->isEmpty() || $stableServers->isEmpty()) {
            return ['healthy' => false, 'reasons' => ['No servers available for comparison']];
        }

        $canaryConfig = $deployment->canary_config ?? [];
        $errorRateThreshold = $canaryConfig['error_rate_threshold'] ?? self::ERROR_RATE_THRESHOLD;
        $latencyThreshold = $canaryConfig['latency_threshold'] ?? self::LATENCY_THRESHOLD;

        $reasons = [];
        $healthy = true;

        // Collect metrics
        $canaryMetrics = $this->collectMetrics($canaryServers, $deployment->application);
        $stableMetrics = $this->collectMetrics($stableServers, $deployment->application);

        // Compare error rates
        $errorRateDiff = $canaryMetrics['error_rate'] - $stableMetrics['error_rate'];
        if ($errorRateDiff > $errorRateThreshold) {
            $healthy = false;
            $reasons[] = "Canary error rate {$errorRateDiff}% higher than stable (threshold: {$errorRateThreshold}%)";
        }

        // Compare latency (p95)
        if ($stableMetrics['p95_latency'] > 0) {
            $latencyIncrease = (($canaryMetrics['p95_latency'] - $stableMetrics['p95_latency']) / $stableMetrics['p95_latency']) * 100;
            if ($latencyIncrease > $latencyThreshold) {
                $healthy = false;
                $reasons[] = "Canary latency {$latencyIncrease}% higher than stable (threshold: {$latencyThreshold}%)";
            }
        }

        // Check health check failures
        if ($canaryMetrics['health_check_failures'] >= self::HEALTH_CHECK_FAILURES_THRESHOLD) {
            $healthy = false;
            $reasons[] = "Canary health checks failing ({$canaryMetrics['health_check_failures']} consecutive failures)";
        }

        // Store metrics snapshot
        $deployment->update([
            'canary_metrics_snapshot' => [
                'canary' => $canaryMetrics,
                'stable' => $stableMetrics,
                'timestamp' => now()->toIso8601String(),
            ],
        ]);

        return [
            'healthy' => $healthy,
            'reasons' => $reasons,
            'metrics' => [
                'canary' => $canaryMetrics,
                'stable' => $stableMetrics,
            ],
        ];
    }

    // Private helper methods

    private function createDeployment(Application $application, array $config): Deployment
    {
        $canaryConfig = array_merge([
            'stages' => self::DEFAULT_STAGES,
            'stage_duration' => self::DEFAULT_STAGE_DURATION,
            'error_rate_threshold' => self::ERROR_RATE_THRESHOLD,
            'latency_threshold' => self::LATENCY_THRESHOLD,
            'canary_server_percentage' => 20, // Deploy canary to 20% of servers
        ], $config);

        return Deployment::create([
            'application_id' => $application->id,
            'organization_id' => $application->organization_id,
            'deployment_strategy' => 'canary',
            'status' => 'pending',
            'canary_status' => 'pending',
            'canary_config' => $canaryConfig,
            'current_canary_stage' => 0,
            'canary_traffic_percentage' => 0,
            'started_at' => now(),
        ]);
    }

    private function selectCanaryAndStableServers(Deployment $deployment, Application $application): void
    {
        $canaryConfig = $deployment->canary_config ?? [];
        $canaryServerPercentage = $canaryConfig['canary_server_percentage'] ?? 20;

        // Get all available servers for this application
        $availableServers = $this->capacityManager->getAvailableServers($application);

        if ($availableServers->count() < 2) {
            throw new \RuntimeException('Canary deployment requires at least 2 servers');
        }

        // Calculate canary server count (at least 1, max 50% of total)
        $totalServers = $availableServers->count();
        $canaryCount = max(1, min(
            (int) ceil($totalServers * ($canaryServerPercentage / 100)),
            (int) floor($totalServers / 2)
        ));

        // Select best servers for canary based on capacity scores
        $canaryServers = $this->capacityManager->selectOptimalServers($availableServers, $canaryCount);
        $stableServers = $availableServers->diff($canaryServers);

        $deployment->update([
            'canary_server_ids' => $canaryServers->pluck('id')->toArray(),
            'stable_server_ids' => $stableServers->pluck('id')->toArray(),
        ]);

        Log::info('Selected canary and stable servers', [
            'deployment_id' => $deployment->id,
            'canary_count' => $canaryServers->count(),
            'stable_count' => $stableServers->count(),
        ]);
    }

    private function deployCanaryInstances(Deployment $deployment, Application $application): void
    {
        $canaryServers = Server::whereIn('id', $deployment->canary_server_ids ?? [])->get();

        foreach ($canaryServers as $server) {
            // Deploy new version to canary server
            // This integrates with existing ApplicationDeploymentJob
            $this->deployToServer($application, $server, $deployment);
        }

        Log::info('Canary instances deployed', [
            'deployment_id' => $deployment->id,
            'canary_server_count' => $canaryServers->count(),
        ]);
    }

    private function updateTrafficSplit(Deployment $deployment, int $canaryPercentage): void
    {
        $canaryServers = Server::whereIn('id', $deployment->canary_server_ids ?? [])->get();
        $stableServers = Server::whereIn('id', $deployment->stable_server_ids ?? [])->get();

        // Update proxy configuration (Nginx/Traefik) with weighted upstream
        $this->proxyService->updateTrafficSplit(
            $deployment->application,
            [
                'canary' => [
                    'servers' => $canaryServers,
                    'weight' => $canaryPercentage,
                ],
                'stable' => [
                    'servers' => $stableServers,
                    'weight' => 100 - $canaryPercentage,
                ],
            ]
        );

        Log::info('Traffic split updated', [
            'deployment_id' => $deployment->id,
            'canary_percentage' => $canaryPercentage,
            'stable_percentage' => 100 - $canaryPercentage,
        ]);
    }

    private function promoteCanaryToStable(Deployment $deployment): bool
    {
        Log::info('Promoting canary to stable', [
            'deployment_id' => $deployment->id,
        ]);

        try {
            // Step 1: Ensure 100% traffic on canary
            $this->updateTrafficSplit($deployment, 100);

            // Step 2: Terminate old stable instances
            $this->terminateStableInstances($deployment);

            // Step 3: Promote canary servers to stable
            $deployment->update([
                'stable_server_ids' => $deployment->canary_server_ids,
                'canary_server_ids' => [],
                'status' => 'completed',
                'canary_status' => 'completed',
                'canary_traffic_percentage' => 100,
                'completed_at' => now(),
            ]);

            // Step 4: Reset proxy to normal configuration
            $this->proxyService->resetToStandardConfig($deployment->application);

            Log::info('Canary promoted to stable successfully', [
                'deployment_id' => $deployment->id,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Failed to promote canary to stable', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    private function terminateCanaryInstances(Deployment $deployment): void
    {
        $canaryServers = Server::whereIn('id', $deployment->canary_server_ids ?? [])->get();

        foreach ($canaryServers as $server) {
            // Terminate canary containers on this server
            $this->terminateContainersOnServer($deployment->application, $server);
        }

        Log::info('Canary instances terminated', [
            'deployment_id' => $deployment->id,
        ]);
    }

    private function terminateStableInstances(Deployment $deployment): void
    {
        $stableServers = Server::whereIn('id', $deployment->stable_server_ids ?? [])->get();

        foreach ($stableServers as $server) {
            // Terminate old stable containers on this server
            $this->terminateContainersOnServer($deployment->application, $server);
        }

        Log::info('Old stable instances terminated', [
            'deployment_id' => $deployment->id,
        ]);
    }

    private function deployToServer(Application $application, Server $server, Deployment $deployment): void
    {
        // Integration with existing Coolify deployment logic
        // This would use ExecuteRemoteCommand trait to deploy containers via Docker

        // Simplified placeholder - actual implementation would use ApplicationDeploymentJob
        Log::info('Deploying to server', [
            'application_id' => $application->id,
            'server_id' => $server->id,
            'deployment_id' => $deployment->id,
        ]);
    }

    private function terminateContainersOnServer(Application $application, Server $server): void
    {
        // Integration with existing Coolify container management
        // This would use ExecuteRemoteCommand to stop/remove containers

        Log::info('Terminating containers on server', [
            'application_id' => $application->id,
            'server_id' => $server->id,
        ]);
    }

    private function collectMetrics($servers, Application $application): array
    {
        // Collect real-time metrics from SystemResourceMonitor
        $metrics = $this->resourceMonitor->getAggregatedMetrics($servers, $application);

        return [
            'error_rate' => $metrics['error_rate'] ?? 0.0,
            'p95_latency' => $metrics['p95_latency_ms'] ?? 0.0,
            'cpu_usage' => $metrics['avg_cpu_percent'] ?? 0.0,
            'memory_usage' => $metrics['avg_memory_percent'] ?? 0.0,
            'request_count' => $metrics['total_requests'] ?? 0,
            'health_check_failures' => $metrics['health_check_failures'] ?? 0,
        ];
    }

    private function getServerDetails(array $serverIds): array
    {
        return Server::whereIn('id', $serverIds)
            ->get()
            ->map(fn($server) => [
                'id' => $server->id,
                'name' => $server->name,
                'ip' => $server->ip,
                'status' => $server->status,
            ])
            ->toArray();
    }

    private function calculateNextStageTime(Deployment $deployment): ?string
    {
        if ($deployment->canary_status !== 'monitoring') {
            return null;
        }

        $canaryConfig = $deployment->canary_config ?? [];
        $stageDuration = $canaryConfig['stage_duration'] ?? self::DEFAULT_STAGE_DURATION;

        if (!$deployment->canary_stage_started_at) {
            return null;
        }

        return $deployment->canary_stage_started_at
            ->addSeconds($stageDuration)
            ->toIso8601String();
    }

    private function canPromote(Deployment $deployment): bool
    {
        return in_array($deployment->canary_status, ['monitoring', 'in_progress']);
    }

    private function canRollback(Deployment $deployment): bool
    {
        return in_array($deployment->canary_status, ['monitoring', 'in_progress', 'promoting']);
    }
}
```

### Background Jobs

**File:** `app/Jobs/Enterprise/CanaryProgressionJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\Deployment;
use App\Services\Enterprise\Deployment\CanaryDeploymentStrategy;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class CanaryProgressionJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 1; // Don't retry automatically
    public int $timeout = 600; // 10 minutes

    public function __construct(
        public Deployment $deployment
    ) {
        $this->onQueue('deployments');
    }

    /**
     * Execute canary progression
     *
     * @param CanaryDeploymentStrategy $strategy
     * @return void
     */
    public function handle(CanaryDeploymentStrategy $strategy): void
    {
        $deployment = $this->deployment->fresh();

        if ($deployment->canary_status !== 'monitoring') {
            Log::info('Canary progression skipped - not in monitoring state', [
                'deployment_id' => $deployment->id,
                'canary_status' => $deployment->canary_status,
            ]);
            return;
        }

        $canaryConfig = $deployment->canary_config ?? [];
        $stageDuration = $canaryConfig['stage_duration'] ?? 300;

        // Check if stage duration has elapsed
        $stageElapsedSeconds = $deployment->canary_stage_started_at?->diffInSeconds(now()) ?? 0;

        if ($stageElapsedSeconds < $stageDuration) {
            // Stage duration not elapsed yet, re-schedule
            $remainingSeconds = $stageDuration - $stageElapsedSeconds;
            CanaryProgressionJob::dispatch($deployment)
                ->delay(now()->addSeconds($remainingSeconds));

            return;
        }

        // Stage duration elapsed, progress to next stage
        $success = $strategy->progressToNextStage($deployment);

        if (!$success) {
            Log::error('Failed to progress canary to next stage', [
                'deployment_id' => $deployment->id,
            ]);
            return;
        }

        // Schedule next progression check
        CanaryProgressionJob::dispatch($deployment->fresh())
            ->delay(now()->addSeconds($stageDuration));
    }

    public function tags(): array
    {
        return [
            'deployment',
            'canary',
            "deployment:{$this->deployment->id}",
            "application:{$this->deployment->application_id}",
        ];
    }
}
```

**File:** `app/Jobs/Enterprise/CanaryHealthCheckJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\Deployment;
use App\Services\Enterprise\Deployment\CanaryDeploymentStrategy;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class CanaryHealthCheckJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 1;
    public int $timeout = 60;

    private const HEALTH_CHECK_INTERVAL = 30; // seconds

    public function __construct(
        public Deployment $deployment
    ) {
        $this->onQueue('monitoring');
    }

    /**
     * Execute health check
     *
     * @param CanaryDeploymentStrategy $strategy
     * @return void
     */
    public function handle(CanaryDeploymentStrategy $strategy): void
    {
        $deployment = $this->deployment->fresh();

        if (!in_array($deployment->canary_status, ['monitoring', 'in_progress'])) {
            Log::info('Health check stopped - canary not active', [
                'deployment_id' => $deployment->id,
                'canary_status' => $deployment->canary_status,
            ]);
            return;
        }

        // Check canary health
        $healthResult = $strategy->checkCanaryHealth($deployment);

        if (!$healthResult['healthy']) {
            Log::warning('Canary health check failed, initiating rollback', [
                'deployment_id' => $deployment->id,
                'reasons' => $healthResult['reasons'],
            ]);

            // Automatic rollback
            $strategy->rollback($deployment);

            // Alert operators
            // event(new CanaryDeploymentFailed($deployment, $healthResult['reasons']));

            return;
        }

        // Health check passed, schedule next check
        CanaryHealthCheckJob::dispatch($deployment)
            ->delay(now()->addSeconds(self::HEALTH_CHECK_INTERVAL));
    }

    public function tags(): array
    {
        return [
            'deployment',
            'canary',
            'health-check',
            "deployment:{$this->deployment->id}",
        ];
    }
}
```

### Proxy Configuration Service

**File:** `app/Services/Enterprise/ProxyConfigService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Models\Application;
use App\Models\Server;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;

class ProxyConfigService
{
    /**
     * Update proxy configuration for canary traffic split
     *
     * @param Application $application
     * @param array $config ['canary' => [...], 'stable' => [...]]
     * @return void
     */
    public function updateTrafficSplit(Application $application, array $config): void
    {
        $proxyType = $application->server->proxyType();

        if ($proxyType === 'NGINX') {
            $this->updateNginxConfig($application, $config);
        } elseif ($proxyType === 'TRAEFIK') {
            $this->updateTraefikConfig($application, $config);
        } else {
            throw new \RuntimeException("Unsupported proxy type: {$proxyType}");
        }

        Log::info('Proxy traffic split updated', [
            'application_id' => $application->id,
            'proxy_type' => $proxyType,
            'canary_weight' => $config['canary']['weight'],
            'stable_weight' => $config['stable']['weight'],
        ]);
    }

    /**
     * Reset proxy to standard configuration (no traffic splitting)
     *
     * @param Application $application
     * @return void
     */
    public function resetToStandardConfig(Application $application): void
    {
        // Generate standard proxy config without traffic splitting
        $application->generate_configuration_file();
        $application->server->reloadProxy();

        Log::info('Proxy reset to standard configuration', [
            'application_id' => $application->id,
        ]);
    }

    /**
     * Update Nginx configuration with weighted upstream
     *
     * @param Application $application
     * @param array $config
     * @return void
     */
    private function updateNginxConfig(Application $application, array $config): void
    {
        $canaryServers = $config['canary']['servers'];
        $stableServers = $config['stable']['servers'];
        $canaryWeight = $config['canary']['weight'];
        $stableWeight = $config['stable']['weight'];

        // Generate Nginx upstream configuration
        $upstreamConfig = "upstream {$application->uuid}_backend {\n";

        foreach ($stableServers as $server) {
            $upstreamConfig .= "    server {$server->ip}:{$application->port} weight={$stableWeight};\n";
        }

        foreach ($canaryServers as $server) {
            $upstreamConfig .= "    server {$server->ip}:{$application->port} weight={$canaryWeight};\n";
        }

        $upstreamConfig .= "}\n";

        // Write configuration file
        $configPath = "/etc/nginx/conf.d/{$application->uuid}.conf";
        // This would use ExecuteRemoteCommand to write config to server
        // Simplified for example

        // Reload Nginx
        $application->server->reloadProxy();
    }

    /**
     * Update Traefik configuration with weighted services
     *
     * @param Application $application
     * @param array $config
     * @return void
     */
    private function updateTraefikConfig(Application $application, array $config): void
    {
        $canaryServers = $config['canary']['servers'];
        $stableServers = $config['stable']['servers'];
        $canaryWeight = $config['canary']['weight'];
        $stableWeight = $config['stable']['weight'];

        // Generate Traefik dynamic configuration
        $traefikConfig = [
            'http' => [
                'services' => [
                    "{$application->uuid}_weighted" => [
                        'weighted' => [
                            'services' => [
                                [
                                    'name' => "{$application->uuid}_stable",
                                    'weight' => $stableWeight,
                                ],
                                [
                                    'name' => "{$application->uuid}_canary",
                                    'weight' => $canaryWeight,
                                ],
                            ],
                        ],
                    ],
                    "{$application->uuid}_stable" => [
                        'loadBalancer' => [
                            'servers' => $stableServers->map(fn($s) => [
                                'url' => "http://{$s->ip}:{$application->port}"
                            ])->toArray(),
                        ],
                    ],
                    "{$application->uuid}_canary" => [
                        'loadBalancer' => [
                            'servers' => $canaryServers->map(fn($s) => [
                                'url' => "http://{$s->ip}:{$application->port}"
                            ])->toArray(),
                        ],
                    ],
                ],
            ],
        ];

        // Write Traefik dynamic configuration
        // This would use Traefik's file provider or HTTP API
        // Simplified for example
    }
}
```

### Integration with EnhancedDeploymentService

**File:** `app/Services/Enterprise/Deployment/EnhancedDeploymentService.php` (enhance existing)

```php
public function deployWithStrategy(Application $application, string $strategy, array $config = []): Deployment
{
    // ... existing code ...

    $strategyInstance = match ($strategy) {
        'rolling' => app(RollingUpdateDeploymentStrategy::class),
        'blue-green' => app(BlueGreenDeploymentStrategy::class),
        'canary' => app(CanaryDeploymentStrategy::class), // NEW
        default => throw new \InvalidArgumentException("Unknown deployment strategy: {$strategy}"),
    };

    return $strategyInstance->deploy($application, $config);
}
```

## Implementation Approach

### Step 1: Database Schema
1. Create migration for canary tracking columns
2. Run migration: `php artisan migrate`
3. Update Deployment model with canary accessors

### Step 2: Create Strategy Class
1. Create `CanaryDeploymentStrategy` implementing `DeploymentStrategyInterface`
2. Implement core methods: `deploy()`, `rollback()`, `getStatus()`, `validateConfig()`
3. Add helper methods for server selection, traffic splitting, metric collection

### Step 3: Create Background Jobs
1. Create `CanaryProgressionJob` for stage transitions
2. Create `CanaryHealthCheckJob` for continuous monitoring
3. Configure job queues and retry logic

### Step 4: Create Proxy Configuration Service
1. Create `ProxyConfigService` with Nginx and Traefik support
2. Implement `updateTrafficSplit()` method
3. Implement `resetToStandardConfig()` method
4. Test with mock proxy configurations

### Step 5: Integrate with EnhancedDeploymentService
1. Add canary strategy to `deployWithStrategy()` method
2. Register service bindings in service provider
3. Add canary strategy to deployment API endpoints

### Step 6: Metrics Collection
1. Integrate with `SystemResourceMonitor` for real-time metrics
2. Implement metric comparison logic (error rate, latency)
3. Add health check failure tracking

### Step 7: Testing
1. Unit tests for strategy logic
2. Integration tests for full canary workflow
3. Test automatic rollback scenarios
4. Test manual promotion/rollback

### Step 8: Observability
1. Add deployment progress WebSocket broadcasts
2. Add Horizon tags for job monitoring
3. Add detailed logging for debugging
4. Create metrics dashboard

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/CanaryDeploymentStrategyTest.php`

```php
<?php

use App\Services\Enterprise\Deployment\CanaryDeploymentStrategy;
use App\Models\Application;
use App\Models\Deployment;
use App\Models\Server;
use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\ProxyConfigService;
use App\Services\Enterprise\SystemResourceMonitor;

beforeEach(function () {
    $this->capacityManager = \Mockery::mock(CapacityManager::class);
    $this->proxyService = \Mockery::mock(ProxyConfigService::class);
    $this->resourceMonitor = \Mockery::mock(SystemResourceMonitor::class);

    $this->strategy = new CanaryDeploymentStrategy(
        $this->capacityManager,
        $this->proxyService,
        $this->resourceMonitor
    );
});

it('validates canary configuration correctly', function () {
    $validConfig = [
        'stages' => [10, 25, 50, 100],
        'stage_duration' => 300,
        'error_rate_threshold' => 5.0,
    ];

    $errors = $this->strategy->validateConfig($validConfig);

    expect($errors)->toBeEmpty();
});

it('rejects invalid stage percentages', function () {
    $invalidConfig = [
        'stages' => [10, 150, 50], // 150 is invalid
    ];

    $errors = $this->strategy->validateConfig($invalidConfig);

    expect($errors)->not->toBeEmpty()
        ->and($errors[0])->toContain('between 0 and 100');
});

it('rejects too-short stage duration', function () {
    $invalidConfig = [
        'stage_duration' => 30, // Less than 60 seconds
    ];

    $errors = $this->strategy->validateConfig($invalidConfig);

    expect($errors)->toHaveCount(1)
        ->and($errors[0])->toContain('at least 60 seconds');
});

it('detects unhealthy canary based on error rate', function () {
    $deployment = Deployment::factory()->create([
        'deployment_strategy' => 'canary',
        'canary_server_ids' => [1, 2],
        'stable_server_ids' => [3, 4],
    ]);

    $canaryServers = Server::factory(2)->create();
    $stableServers = Server::factory(2)->create();

    // Mock high error rate on canary
    $this->resourceMonitor->shouldReceive('getAggregatedMetrics')
        ->with(\Mockery::type(Collection::class), \Mockery::type(Application::class))
        ->andReturn(
            ['error_rate' => 10.0, 'p95_latency_ms' => 100, 'health_check_failures' => 0],
            ['error_rate' => 2.0, 'p95_latency_ms' => 100, 'health_check_failures' => 0]
        );

    $healthResult = $this->strategy->checkCanaryHealth($deployment);

    expect($healthResult['healthy'])->toBeFalse()
        ->and($healthResult['reasons'])->toHaveCount(1);
});

it('detects healthy canary with normal metrics', function () {
    $deployment = Deployment::factory()->create([
        'deployment_strategy' => 'canary',
        'canary_server_ids' => [1, 2],
        'stable_server_ids' => [3, 4],
    ]);

    // Mock healthy metrics
    $this->resourceMonitor->shouldReceive('getAggregatedMetrics')
        ->andReturn([
            'error_rate' => 1.0,
            'p95_latency_ms' => 100,
            'health_check_failures' => 0,
        ]);

    $healthResult = $this->strategy->checkCanaryHealth($deployment);

    expect($healthResult['healthy'])->toBeTrue()
        ->and($healthResult['reasons'])->toBeEmpty();
});
```

### Integration Tests

**File:** `tests/Feature/Deployment/CanaryDeploymentTest.php`

```php
<?php

use App\Services\Enterprise\Deployment\CanaryDeploymentStrategy;
use App\Models\Application;
use App\Models\Server;
use App\Models\Deployment;
use Illuminate\Support\Facades\Queue;

it('completes full canary deployment workflow', function () {
    Queue::fake();

    $application = Application::factory()->create();
    $servers = Server::factory(4)->create();

    $strategy = app(CanaryDeploymentStrategy::class);

    $deployment = $strategy->deploy($application, [
        'stages' => [25, 50, 100],
        'stage_duration' => 60,
    ]);

    expect($deployment->deployment_strategy)->toBe('canary')
        ->and($deployment->canary_status)->toBe('monitoring')
        ->and($deployment->canary_server_ids)->not->toBeEmpty()
        ->and($deployment->stable_server_ids)->not->toBeEmpty();

    // Verify jobs were dispatched
    Queue::assertPushed(\App\Jobs\Enterprise\CanaryProgressionJob::class);
    Queue::assertPushed(\App\Jobs\Enterprise\CanaryHealthCheckJob::class);
});

it('rolls back canary on health check failure', function () {
    $deployment = Deployment::factory()->create([
        'deployment_strategy' => 'canary',
        'canary_status' => 'monitoring',
        'canary_server_ids' => [1, 2],
        'stable_server_ids' => [3, 4],
        'canary_traffic_percentage' => 25,
    ]);

    $strategy = app(CanaryDeploymentStrategy::class);

    $result = $strategy->rollback($deployment);

    expect($result)->toBeTrue()
        ->and($deployment->fresh()->canary_status)->toBe('rolled_back')
        ->and($deployment->fresh()->canary_traffic_percentage)->toBe(0);
});

it('progresses through canary stages successfully', function () {
    $deployment = Deployment::factory()->create([
        'deployment_strategy' => 'canary',
        'canary_status' => 'monitoring',
        'current_canary_stage' => 0,
        'canary_config' => ['stages' => [10, 25, 50, 100]],
        'canary_server_ids' => [1, 2],
        'stable_server_ids' => [3, 4],
    ]);

    $strategy = app(CanaryDeploymentStrategy::class);

    // Progress to stage 1 (25%)
    $result = $strategy->progressToNextStage($deployment);

    expect($result)->toBeTrue()
        ->and($deployment->fresh()->current_canary_stage)->toBe(1)
        ->and($deployment->fresh()->canary_traffic_percentage)->toBe(25);
});
```

## Definition of Done

- [ ] CanaryDeploymentStrategy class created implementing DeploymentStrategyInterface
- [ ] Database migration for canary tracking columns created and run
- [ ] Deployment model enhanced with canary accessors
- [ ] `deploy()` method implements full canary deployment workflow
- [ ] `rollback()` method terminates canary and routes traffic to stable
- [ ] `getStatus()` method returns comprehensive canary status and metrics
- [ ] `validateConfig()` method validates all configuration parameters
- [ ] `progressToNextStage()` method advances canary through traffic stages
- [ ] `checkCanaryHealth()` method compares canary vs. stable metrics
- [ ] Server selection logic chooses 10-20% of servers for canary
- [ ] Canary instances deployed to selected servers successfully
- [ ] Traffic splitting implemented with Nginx configuration
- [ ] Traffic splitting implemented with Traefik configuration
- [ ] CanaryProgressionJob created for stage transitions
- [ ] CanaryHealthCheckJob created for continuous monitoring
- [ ] ProxyConfigService created for dynamic proxy configuration
- [ ] Integration with EnhancedDeploymentService complete
- [ ] Integration with CapacityManager for server selection
- [ ] Integration with SystemResourceMonitor for health metrics
- [ ] Automatic rollback triggered on health check failures
- [ ] Manual promotion endpoint implemented
- [ ] Manual rollback endpoint implemented
- [ ] Deployment progress tracked with real-time updates
- [ ] WebSocket broadcasts for deployment status changes
- [ ] Horizon tags implemented for job monitoring
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written (full workflow coverage)
- [ ] Rollback scenarios tested
- [ ] Edge cases tested (insufficient servers, metric collection failures)
- [ ] Code follows Laravel and Coolify patterns
- [ ] PHPStan level 5 passing with zero errors
- [ ] Laravel Pint formatting applied
- [ ] Documentation updated with canary deployment guide
- [ ] Code reviewed and approved
- [ ] Manual testing completed with real applications
- [ ] Performance verified (stage transitions < 10 seconds)

## Related Tasks

- **Depends on:** Task 32 (EnhancedDeploymentService foundation)
- **Integrates with:** Task 26 (CapacityManager for server selection)
- **Integrates with:** Task 25 (SystemResourceMonitor for health metrics)
- **Complements:** Task 33 (Rolling Updates deployment strategy)
- **Complements:** Task 34 (Blue-Green deployment strategy)
- **Used by:** Task 39 (DeploymentManager.vue for strategy selection UI)
- **Used by:** Task 40 (StrategySelector.vue for canary configuration)
