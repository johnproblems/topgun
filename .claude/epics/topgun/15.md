---
name: Create modular Terraform templates for AWS EC2
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:33Z
github: https://github.com/johnproblems/topgun/issues/125
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Create modular Terraform templates for AWS EC2

## Description

Design and implement modular, reusable Terraform templates (HCL files) for provisioning AWS EC2 infrastructure with comprehensive networking, security, and SSH access configuration. These templates serve as the foundation for Coolify's AWS infrastructure provisioning capabilities, enabling users to create production-ready EC2 instances through the TerraformService with minimal configuration.

The template system provides a flexible, parameterized approach to EC2 provisioning that abstracts the complexity of AWS resource management while maintaining best practices for security, networking, and resource organization. The templates are designed to be provider-agnostic at the variable level, allowing the TerraformService to inject organization-specific configurations dynamically.

**Template Components:**

1. **VPC and Networking**: Create isolated VPCs with public/private subnets, internet gateways, and route tables
2. **Security Groups**: Firewall rules for SSH, HTTP, HTTPS, and custom application ports
3. **EC2 Instances**: Parameterized compute instances with flexible sizing and AMI selection
4. **SSH Key Management**: Dynamic SSH key pair creation or existing key association
5. **Elastic IPs**: Optional static IP assignment for stable server addressing
6. **Outputs**: Structured output of instance IDs, IP addresses, and resource identifiers

**Design Principles:**

- **Modularity**: Separate files for variables, resources, and outputs
- **Flexibility**: Parameterized variables for instance type, region, AMI, networking
- **Security**: Restrictive security groups with least-privilege access
- **Idempotency**: Templates can be run multiple times safely
- **Cost Optimization**: Default to cost-effective instance types and configurations
- **Production Ready**: Follow AWS best practices for networking and security

**Integration with Coolify:**

The templates are loaded by TerraformService (Task 14) during infrastructure provisioning. The service copies template files to deployment workspaces, injects organization credentials via terraform.tfvars, and executes the Terraform workflow. Post-provisioning, Terraform outputs (IP addresses, instance IDs) are parsed and stored in the TerraformDeployment model for server auto-registration (Task 19).

**Why This Task Is Critical:**

AWS is the largest cloud provider, and EC2 is the most commonly used compute service. These templates enable Coolify to automatically provision AWS infrastructure, eliminating manual server setup. By providing production-ready templates, we reduce the barrier to entry for organizations wanting to deploy on AWS while ensuring security and networking best practices are followed. This transforms Coolify from requiring pre-existing servers into a complete infrastructure-as-code platform.

## Acceptance Criteria

- [ ] Terraform templates written in HCL format with Terraform 1.5+ compatibility
- [ ] `variables.tf` defines all configurable parameters with descriptions and defaults
- [ ] `main.tf` contains VPC, subnet, security group, EC2 instance, and SSH key resources
- [ ] `outputs.tf` exports instance ID, public IP, private IP, and VPC identifiers
- [ ] Security group configured with SSH (22), HTTP (80), HTTPS (443), and custom ports
- [ ] VPC configuration supports both single-AZ and multi-AZ deployments
- [ ] Instance type parameterized with default of `t3.medium`
- [ ] AMI selection parameterized with defaults for Ubuntu 22.04 LTS per region
- [ ] SSH key pair creation with public key injection
- [ ] Elastic IP association optional via boolean variable
- [ ] User data script support for instance initialization
- [ ] Tags applied to all resources for organization and billing tracking
- [ ] Example `terraform.tfvars` file with realistic sample values
- [ ] Template validation via `terraform validate` passes with zero errors
- [ ] Documentation explaining all variables and resource relationships

## Technical Details

### File Structure

```
storage/app/terraform/templates/aws/
├── main.tf              # Core resource definitions
├── variables.tf         # Input variable declarations
├── outputs.tf           # Output value definitions
├── versions.tf          # Terraform and provider version constraints
├── terraform.tfvars.example  # Example variable values
└── README.md            # Template documentation
```

### File: `variables.tf`

```hcl
# AWS Provider Configuration
variable "aws_access_key_id" {
  description = "AWS Access Key ID for authentication"
  type        = string
  sensitive   = true
}

variable "aws_secret_access_key" {
  description = "AWS Secret Access Key for authentication"
  type        = string
  sensitive   = true
}

variable "aws_region" {
  description = "AWS region for resource deployment"
  type        = string
  default     = "us-east-1"
}

# Deployment Metadata
variable "deployment_name" {
  description = "Name for this deployment (used for resource naming)"
  type        = string
  default     = "coolify-server"
}

variable "organization_id" {
  description = "Coolify organization ID for tagging and billing"
  type        = string
}

variable "organization_name" {
  description = "Organization name for resource tagging"
  type        = string
}

# Networking Configuration
variable "vpc_cidr" {
  description = "CIDR block for VPC (e.g., 10.0.0.0/16)"
  type        = string
  default     = "10.0.0.0/16"
}

variable "public_subnet_cidr" {
  description = "CIDR block for public subnet"
  type        = string
  default     = "10.0.1.0/24"
}

variable "availability_zone" {
  description = "AWS availability zone for subnet placement"
  type        = string
  default     = null  # Use first available AZ in region
}

variable "create_vpc" {
  description = "Whether to create a new VPC or use existing"
  type        = bool
  default     = true
}

variable "existing_vpc_id" {
  description = "ID of existing VPC to use (if create_vpc = false)"
  type        = string
  default     = null
}

variable "existing_subnet_id" {
  description = "ID of existing subnet to use (if create_vpc = false)"
  type        = string
  default     = null
}

# EC2 Instance Configuration
variable "instance_type" {
  description = "EC2 instance type (t3.medium, t3.large, etc.)"
  type        = string
  default     = "t3.medium"
}

variable "ami_id" {
  description = "AMI ID to use for EC2 instance (defaults to Ubuntu 22.04 LTS)"
  type        = string
  default     = ""  # Dynamically selected in main.tf if empty
}

variable "root_volume_size" {
  description = "Size of root EBS volume in GB"
  type        = number
  default     = 50
}

variable "root_volume_type" {
  description = "EBS volume type (gp3, gp2, io1, io2)"
  type        = string
  default     = "gp3"
}

variable "enable_monitoring" {
  description = "Enable detailed CloudWatch monitoring"
  type        = bool
  default     = false
}

# SSH and Access Configuration
variable "ssh_public_key" {
  description = "SSH public key for EC2 access"
  type        = string
}

variable "ssh_key_name" {
  description = "Name for SSH key pair (auto-generated if not provided)"
  type        = string
  default     = null
}

variable "allowed_ssh_cidr_blocks" {
  description = "CIDR blocks allowed to SSH to instance"
  type        = list(string)
  default     = ["0.0.0.0/0"]  # Restrict in production
}

# Elastic IP Configuration
variable "allocate_elastic_ip" {
  description = "Whether to allocate and associate an Elastic IP"
  type        = bool
  default     = true
}

# Security Group Configuration
variable "allowed_ingress_ports" {
  description = "Additional ingress ports to allow (beyond SSH/HTTP/HTTPS)"
  type        = list(number)
  default     = [8080, 3000, 5432, 6379]  # Common application ports
}

variable "allow_all_egress" {
  description = "Allow all outbound traffic from instance"
  type        = bool
  default     = true
}

# User Data / Initialization
variable "user_data_script" {
  description = "User data script to run on instance boot"
  type        = string
  default     = ""
}

# Resource Tagging
variable "additional_tags" {
  description = "Additional tags to apply to all resources"
  type        = map(string)
  default     = {}
}
```

### File: `main.tf`

```hcl
# AWS Provider Configuration
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region     = var.aws_region
  access_key = var.aws_access_key_id
  secret_key = var.aws_secret_access_key

  default_tags {
    tags = merge(
      {
        ManagedBy        = "Coolify"
        OrganizationID   = var.organization_id
        OrganizationName = var.organization_name
        DeploymentName   = var.deployment_name
        Environment      = "production"
      },
      var.additional_tags
    )
  }
}

# Data Sources
data "aws_availability_zones" "available" {
  state = "available"
}

# AMI Selection - Ubuntu 22.04 LTS
data "aws_ami" "ubuntu" {
  count       = var.ami_id == "" ? 1 : 0
  most_recent = true
  owners      = ["099720109477"]  # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

# Local Variables
locals {
  ami_id             = var.ami_id != "" ? var.ami_id : data.aws_ami.ubuntu[0].id
  availability_zone  = var.availability_zone != null ? var.availability_zone : data.aws_availability_zones.available.names[0]
  ssh_key_name       = var.ssh_key_name != null ? var.ssh_key_name : "${var.deployment_name}-key"

  common_tags = {
    Name        = var.deployment_name
    Terraform   = "true"
    CreatedAt   = timestamp()
  }
}

# VPC Resources
resource "aws_vpc" "main" {
  count                = var.create_vpc ? 1 : 0
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-vpc"
  })
}

resource "aws_internet_gateway" "main" {
  count  = var.create_vpc ? 1 : 0
  vpc_id = aws_vpc.main[0].id

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-igw"
  })
}

resource "aws_subnet" "public" {
  count                   = var.create_vpc ? 1 : 0
  vpc_id                  = aws_vpc.main[0].id
  cidr_block              = var.public_subnet_cidr
  availability_zone       = local.availability_zone
  map_public_ip_on_launch = true

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-public-subnet"
    Type = "public"
  })
}

resource "aws_route_table" "public" {
  count  = var.create_vpc ? 1 : 0
  vpc_id = aws_vpc.main[0].id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main[0].id
  }

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-public-rt"
  })
}

resource "aws_route_table_association" "public" {
  count          = var.create_vpc ? 1 : 0
  subnet_id      = aws_subnet.public[0].id
  route_table_id = aws_route_table.public[0].id
}

# Security Group
resource "aws_security_group" "server" {
  name        = "${var.deployment_name}-sg"
  description = "Security group for Coolify-managed server"
  vpc_id      = var.create_vpc ? aws_vpc.main[0].id : var.existing_vpc_id

  # SSH Access
  ingress {
    description = "SSH access"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = var.allowed_ssh_cidr_blocks
  }

  # HTTP Access
  ingress {
    description = "HTTP access"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # HTTPS Access
  ingress {
    description = "HTTPS access"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # Additional Application Ports
  dynamic "ingress" {
    for_each = var.allowed_ingress_ports
    content {
      description = "Application port ${ingress.value}"
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }

  # Egress Rules
  egress {
    description = "All outbound traffic"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-sg"
  })
}

# SSH Key Pair
resource "aws_key_pair" "server" {
  key_name   = local.ssh_key_name
  public_key = var.ssh_public_key

  tags = merge(local.common_tags, {
    Name = local.ssh_key_name
  })
}

# EC2 Instance
resource "aws_instance" "server" {
  ami                    = local.ami_id
  instance_type          = var.instance_type
  key_name               = aws_key_pair.server.key_name
  vpc_security_group_ids = [aws_security_group.server.id]
  subnet_id              = var.create_vpc ? aws_subnet.public[0].id : var.existing_subnet_id
  monitoring             = var.enable_monitoring

  root_block_device {
    volume_size           = var.root_volume_size
    volume_type           = var.root_volume_type
    delete_on_termination = true
    encrypted             = true

    tags = merge(local.common_tags, {
      Name = "${var.deployment_name}-root-volume"
    })
  }

  user_data = var.user_data_script != "" ? var.user_data_script : templatefile("${path.module}/user-data.sh", {
    deployment_name = var.deployment_name
  })

  metadata_options {
    http_endpoint               = "enabled"
    http_tokens                 = "required"  # Enforce IMDSv2
    http_put_response_hop_limit = 1
    instance_metadata_tags      = "enabled"
  }

  tags = merge(local.common_tags, {
    Name = var.deployment_name
  })

  lifecycle {
    ignore_changes = [
      user_data,  # Prevent replacement on user_data changes
      ami,        # Prevent replacement on AMI updates
    ]
  }
}

# Elastic IP (Optional)
resource "aws_eip" "server" {
  count    = var.allocate_elastic_ip ? 1 : 0
  instance = aws_instance.server.id
  domain   = "vpc"

  tags = merge(local.common_tags, {
    Name = "${var.deployment_name}-eip"
  })

  depends_on = [aws_internet_gateway.main]
}
```

### File: `outputs.tf`

```hcl
# Instance Outputs
output "instance_id" {
  description = "EC2 instance ID"
  value       = aws_instance.server.id
}

output "instance_arn" {
  description = "EC2 instance ARN"
  value       = aws_instance.server.arn
}

output "instance_state" {
  description = "EC2 instance state"
  value       = aws_instance.server.instance_state
}

# IP Address Outputs
output "public_ip" {
  description = "Public IP address of the instance (Elastic IP if allocated)"
  value       = var.allocate_elastic_ip ? aws_eip.server[0].public_ip : aws_instance.server.public_ip
}

output "private_ip" {
  description = "Private IP address of the instance"
  value       = aws_instance.server.private_ip
}

output "elastic_ip_id" {
  description = "Elastic IP allocation ID (if allocated)"
  value       = var.allocate_elastic_ip ? aws_eip.server[0].id : null
}

# Networking Outputs
output "vpc_id" {
  description = "VPC ID"
  value       = var.create_vpc ? aws_vpc.main[0].id : var.existing_vpc_id
}

output "subnet_id" {
  description = "Subnet ID"
  value       = var.create_vpc ? aws_subnet.public[0].id : var.existing_subnet_id
}

output "security_group_id" {
  description = "Security group ID"
  value       = aws_security_group.server.id
}

# SSH Access Outputs
output "ssh_key_name" {
  description = "SSH key pair name"
  value       = aws_key_pair.server.key_name
}

output "ssh_connection_string" {
  description = "SSH connection string for the server"
  value       = "ssh ubuntu@${var.allocate_elastic_ip ? aws_eip.server[0].public_ip : aws_instance.server.public_ip}"
}

# Resource Identifiers (for cleanup)
output "resource_identifiers" {
  description = "All resource identifiers for management and cleanup"
  value = {
    instance_id        = aws_instance.server.id
    key_pair_name      = aws_key_pair.server.key_name
    security_group_id  = aws_security_group.server.id
    vpc_id             = var.create_vpc ? aws_vpc.main[0].id : null
    subnet_id          = var.create_vpc ? aws_subnet.public[0].id : null
    elastic_ip_id      = var.allocate_elastic_ip ? aws_eip.server[0].id : null
  }
}

# Deployment Metadata
output "deployment_metadata" {
  description = "Deployment metadata for Coolify integration"
  value = {
    deployment_name   = var.deployment_name
    organization_id   = var.organization_id
    organization_name = var.organization_name
    region            = var.aws_region
    availability_zone = aws_instance.server.availability_zone
    instance_type     = var.instance_type
    ami_id            = aws_instance.server.ami
    created_at        = aws_instance.server.instance_state == "running" ? timestamp() : null
  }
}
```

### File: `versions.tf`

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

### File: `terraform.tfvars.example`

```hcl
# AWS Credentials (injected by Coolify TerraformService)
aws_access_key_id     = "AKIAIOSFODNN7EXAMPLE"
aws_secret_access_key = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
aws_region            = "us-east-1"

# Deployment Configuration
deployment_name   = "coolify-production-server-1"
organization_id   = "org_abc123xyz"
organization_name = "Acme Corporation"

# Networking
vpc_cidr           = "10.0.0.0/16"
public_subnet_cidr = "10.0.1.0/24"
create_vpc         = true

# EC2 Instance
instance_type      = "t3.medium"
root_volume_size   = 100
root_volume_type   = "gp3"
enable_monitoring  = false

# SSH Configuration
ssh_public_key         = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD... user@example.com"
allowed_ssh_cidr_blocks = ["203.0.113.0/24"]  # Restrict to office IP

# Elastic IP
allocate_elastic_ip = true

# Additional Application Ports
allowed_ingress_ports = [8080, 3000, 5432]

# Tags
additional_tags = {
  Environment = "production"
  Project     = "web-platform"
  CostCenter  = "engineering"
}
```

### File: `user-data.sh`

```bash
#!/bin/bash
# Coolify EC2 Instance Initialization Script

set -e

# Update system packages
apt-get update
apt-get upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# Add ubuntu user to docker group
usermod -aG docker ubuntu

# Install Docker Compose
DOCKER_COMPOSE_VERSION="2.24.0"
curl -L "https://github.com/docker/compose/releases/download/v${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# Enable Docker service
systemctl enable docker
systemctl start docker

# Install useful utilities
apt-get install -y \
  curl \
  wget \
  git \
  vim \
  htop \
  net-tools \
  ufw

# Configure UFW firewall (allow SSH, HTTP, HTTPS)
ufw --force enable
ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp

# Set hostname
hostnamectl set-hostname ${deployment_name}

# Create deployment marker file
echo "Provisioned by Coolify Terraform at $(date)" > /root/coolify-provisioned.txt

# Signal completion
echo "Instance initialization complete"
```

### File: `README.md`

```markdown
# AWS EC2 Terraform Template for Coolify

This Terraform template provisions a complete AWS EC2 infrastructure for Coolify-managed servers.

## Resources Created

- **VPC**: Isolated virtual network (10.0.0.0/16)
- **Subnet**: Public subnet with internet access
- **Internet Gateway**: Enables internet connectivity
- **Security Group**: Firewall rules for SSH, HTTP, HTTPS, and application ports
- **EC2 Instance**: Ubuntu 22.04 LTS compute instance
- **SSH Key Pair**: Dynamic key pair for server access
- **Elastic IP** (optional): Static public IP address

## Variables

### Required Variables

- `aws_access_key_id`: AWS access key
- `aws_secret_access_key`: AWS secret key
- `organization_id`: Coolify organization identifier
- `organization_name`: Organization name for tagging
- `ssh_public_key`: SSH public key for server access

### Optional Variables

- `aws_region`: AWS region (default: us-east-1)
- `instance_type`: EC2 instance type (default: t3.medium)
- `root_volume_size`: Root disk size in GB (default: 50)
- `allocate_elastic_ip`: Whether to allocate Elastic IP (default: true)

See `variables.tf` for complete list.

## Outputs

- `public_ip`: Public IP address for server access
- `instance_id`: EC2 instance ID
- `ssh_connection_string`: Ready-to-use SSH command

## Usage with Coolify

This template is automatically used by Coolify's TerraformService when provisioning AWS infrastructure. Variables are injected from organization credentials and deployment configuration.

## Manual Testing

```bash
# Initialize Terraform
terraform init

# Validate configuration
terraform validate

# Plan deployment (review changes)
terraform plan -var-file="terraform.tfvars"

# Apply configuration (provision infrastructure)
terraform apply -var-file="terraform.tfvars"

# Destroy infrastructure
terraform destroy -var-file="terraform.tfvars"
```

## Cost Optimization

Default configuration uses cost-effective resources:
- t3.medium instance (~$30/month)
- gp3 EBS volumes (cheaper than gp2)
- Single availability zone
- No NAT gateway (public subnet only)

## Security Notes

- Security group allows SSH from anywhere by default
  - **Restrict `allowed_ssh_cidr_blocks` in production**
- IMDSv2 enforced for instance metadata
- EBS encryption enabled
- Default tags applied for tracking

## Customization

### Use Existing VPC

```hcl
create_vpc        = false
existing_vpc_id   = "vpc-12345678"
existing_subnet_id = "subnet-87654321"
```

### Custom AMI

```hcl
ami_id = "ami-0123456789abcdef0"
```

### Additional Application Ports

```hcl
allowed_ingress_ports = [8080, 3000, 5432, 6379, 27017]
```
```

## Implementation Approach

### Step 1: Create Template Directory Structure
1. Create `storage/app/terraform/templates/aws/` directory
2. Verify directory permissions (writable by Laravel)
3. Create placeholder files

### Step 2: Write Core Template Files
1. Create `variables.tf` with all variable definitions
2. Add descriptions and default values
3. Mark sensitive variables appropriately
4. Group variables logically (provider, networking, instance, security)

### Step 3: Implement Resource Definitions
1. Create `main.tf` with provider configuration
2. Add VPC and networking resources
3. Add security group with ingress/egress rules
4. Add EC2 instance resource with proper configuration
5. Add SSH key pair resource
6. Add optional Elastic IP resource

### Step 4: Define Outputs
1. Create `outputs.tf` with all required outputs
2. Export instance identifiers (ID, IP addresses)
3. Export networking identifiers (VPC, subnet, security group)
4. Create structured metadata output for Coolify integration

### Step 5: Add Version Constraints
1. Create `versions.tf` with Terraform version requirement
2. Specify AWS provider version constraint
3. Test compatibility with Terraform 1.5+

### Step 6: Create Example Configuration
1. Create `terraform.tfvars.example` with realistic values
2. Document all variables with examples
3. Include comments explaining configuration options

### Step 7: Write User Data Script
1. Create `user-data.sh` initialization script
2. Install Docker and Docker Compose
3. Configure firewall and system settings
4. Create marker file for verification

### Step 8: Add Documentation
1. Create comprehensive `README.md`
2. Document all resources created
3. Add usage examples and customization guide
4. Include security and cost optimization notes

### Step 9: Validate Templates
1. Run `terraform init` to initialize providers
2. Run `terraform validate` to check syntax
3. Run `terraform fmt` to format HCL files
4. Test with example variables

### Step 10: Integration Testing
1. Test template loading in TerraformService
2. Verify variable injection works correctly
3. Test actual provisioning with real AWS credentials
4. Verify outputs are correctly parsed

## Test Strategy

### Template Validation Tests

**File:** `tests/Feature/Terraform/AwsTemplateValidationTest.php`

```php
<?php

use Symfony\Component\Process\Process;

it('passes terraform validation', function () {
    $templateDir = storage_path('app/terraform/templates/aws');

    // Initialize Terraform
    $initProcess = new Process(['terraform', 'init'], $templateDir);
    $initProcess->run();

    expect($initProcess->isSuccessful())->toBeTrue();

    // Validate configuration
    $validateProcess = new Process(['terraform', 'validate', '-json'], $templateDir);
    $validateProcess->run();

    $output = json_decode($validateProcess->getOutput(), true);

    expect($output['valid'])->toBeTrue()
        ->and($output['error_count'])->toBe(0);
});

it('has required variables defined', function () {
    $variablesFile = storage_path('app/terraform/templates/aws/variables.tf');

    expect(file_exists($variablesFile))->toBeTrue();

    $content = file_get_contents($variablesFile);

    $requiredVars = [
        'aws_access_key_id',
        'aws_secret_access_key',
        'organization_id',
        'ssh_public_key',
    ];

    foreach ($requiredVars as $var) {
        expect($content)->toContain("variable \"{$var}\"");
    }
});

it('has required outputs defined', function () {
    $outputsFile = storage_path('app/terraform/templates/aws/outputs.tf');

    expect(file_exists($outputsFile))->toBeTrue();

    $content = file_get_contents($outputsFile);

    $requiredOutputs = [
        'instance_id',
        'public_ip',
        'private_ip',
        'ssh_connection_string',
    ];

    foreach ($requiredOutputs as $output) {
        expect($content)->toContain("output \"{$output}\"");
    }
});

it('formats correctly with terraform fmt', function () {
    $templateDir = storage_path('app/terraform/templates/aws');

    $fmtProcess = new Process(
        ['terraform', 'fmt', '-check', '-diff'],
        $templateDir
    );

    $fmtProcess->run();

    expect($fmtProcess->getExitCode())->toBe(0);
});
```

### Integration Tests

```php
it('integrates with TerraformService', function () {
    $templateDir = storage_path('app/terraform/templates/aws');

    expect(file_exists("{$templateDir}/main.tf"))->toBeTrue()
        ->and(file_exists("{$templateDir}/variables.tf"))->toBeTrue()
        ->and(file_exists("{$templateDir}/outputs.tf"))->toBeTrue();

    $service = app(\App\Contracts\TerraformServiceInterface::class);

    $result = $service->validateTemplate("{$templateDir}/main.tf");

    expect($result['valid'])->toBeTrue();
});
```

### Manual Testing Checklist

```bash
# 1. Initialize and validate
cd storage/app/terraform/templates/aws
terraform init
terraform validate

# 2. Format check
terraform fmt -check

# 3. Plan with example vars (requires AWS credentials)
terraform plan -var-file="terraform.tfvars.example"

# 4. Test variable substitution
terraform console
> var.instance_type
"t3.medium"

# 5. Verify outputs structure
terraform show -json | jq '.values.outputs'
```

## Definition of Done

- [ ] Directory structure created in `storage/app/terraform/templates/aws/`
- [ ] `variables.tf` created with 25+ variables
- [ ] `main.tf` created with VPC, subnet, security group, EC2 instance, SSH key
- [ ] `outputs.tf` created with 10+ outputs
- [ ] `versions.tf` created with Terraform 1.5+ and AWS provider 5.0 requirements
- [ ] `terraform.tfvars.example` created with realistic sample values
- [ ] `user-data.sh` script created with Docker installation
- [ ] `README.md` documentation complete
- [ ] `terraform init` runs successfully
- [ ] `terraform validate` passes with zero errors
- [ ] `terraform fmt` formatting check passes
- [ ] All variables have descriptions and appropriate defaults
- [ ] Security group configured for SSH, HTTP, HTTPS, custom ports
- [ ] VPC supports both new and existing VPC scenarios
- [ ] Elastic IP allocation configurable
- [ ] SSH key pair creation working
- [ ] Template produces valid outputs JSON
- [ ] Integration with TerraformService verified
- [ ] Manual provisioning test successful (with real AWS credentials)
- [ ] Template documentation complete
- [ ] Code reviewed and approved

## Related Tasks

- **Used by:** Task 14 (TerraformService loads and executes template)
- **Parallel with:** Task 16 (DigitalOcean/Hetzner templates)
- **Enables:** Task 18 (TerraformDeploymentJob async provisioning)
- **Enables:** Task 19 (Server auto-registration after provisioning)
- **Configured via:** Task 20 (TerraformManager.vue UI)
