---
name: Implement CloudProviderCredential model with encrypted attribute casting
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:31Z
github: https://github.com/johnproblems/topgun/issues/123
depends_on: [12]
parallel: false
conflicts_with: []
---

# Task: Implement CloudProviderCredential model with encrypted attribute casting

## Description

Create an Eloquent model for `CloudProviderCredential` with automatic encryption/decryption of sensitive cloud API credentials. This model serves as the secure gateway for storing and retrieving cloud provider authentication data, implementing Laravel's encrypted casting for transparent encryption at rest.

### Integration with Existing Patterns

Following Coolify's server management patterns:
- Organization-scoped queries using global scopes (similar to `Server` model)
- Relationship methods with proper type hints
- Factory pattern for testing
- Validation before credential usage
- Integration with existing `ExecuteRemoteCommand` trait patterns for API calls

### Encryption Strategy

- **Laravel Encrypted Cast**: Use `'encrypted' => 'json'` for credentials column
- **Separate Key Rotation**: Credentials encrypted with `APP_KEY`, state files with separate key
- **Validation Pipeline**: Test credentials against provider APIs before storing
- **Audit Trail**: Track credential usage and validation attempts

## Acceptance Criteria

- [ ] Model created with proper namespace and base class extension
- [ ] Encrypted casting configured for credentials JSON column
- [ ] Organization relationship defined with proper type hints
- [ ] TerraformDeployment relationship defined (hasMany)
- [ ] Global scope added for automatic organization filtering
- [ ] Validation methods for testing credentials against cloud provider APIs
- [ ] Factory created with realistic fake credentials for testing
- [ ] Model events (creating, updating) fire for audit logging
- [ ] Accessor/mutator methods for credential components
- [ ] Integration with existing Coolify authorization policies
- [ ] PHPDoc blocks document all methods and properties
- [ ] Unit tests verify encryption/decryption works correctly

## Technical Details

### Model Structure

**File**: `app/Models/CloudProviderCredential.php`

```php
<?php

namespace App\Models;

use App\Traits\ClearsGlobalSearchCache;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Facades\Crypt;
use OpenApi\Attributes as OA;

#[OA\Schema(
    description: 'Cloud Provider Credential model',
    type: 'object',
    properties: [
        'id' => ['type' => 'integer'],
        'uuid' => ['type' => 'string'],
        'organization_id' => ['type' => 'integer'],
        'name' => ['type' => 'string', 'description' => 'User-friendly credential name'],
        'provider' => ['type' => 'string', 'enum' => ['aws', 'digitalocean', 'hetzner', 'gcp', 'azure']],
        'description' => ['type' => 'string'],
        'is_active' => ['type' => 'boolean'],
        'validation_status' => ['type' => 'string', 'enum' => ['pending', 'valid', 'invalid']],
        'last_validated_at' => ['type' => 'string', 'format' => 'date-time'],
    ]
)]
class CloudProviderCredential extends BaseModel
{
    use ClearsGlobalSearchCache, HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'organization_id',
        'name',
        'provider',
        'description',
        'credentials',
        'metadata',
        'is_active',
        'validation_status',
        'validation_error',
        'last_validated_at',
    ];

    protected $casts = [
        'credentials' => 'encrypted:json', // Auto encrypt/decrypt
        'metadata' => 'json',
        'is_active' => 'boolean',
        'last_validated_at' => 'datetime',
    ];

    protected $hidden = [
        'credentials', // Never expose in API responses
    ];

    protected static function booted(): void
    {
        static::creating(function ($credential) {
            if (empty($credential->uuid)) {
                $credential->uuid = (string) new \Visus\Cuid2\Cuid2();
            }
        });

        static::saving(function ($credential) {
            // Validate credentials format before saving
            $credential->validateCredentialsFormat();
        });
    }

    // Relationships
    public function organization(): BelongsTo
    {
        return $this->belongsTo(Organization::class);
    }

    public function terraformDeployments(): HasMany
    {
        return $this->hasMany(TerraformDeployment::class);
    }

    // Validation Methods
    public function validateCredentials(): bool
    {
        return match ($this->provider) {
            'aws' => $this->validateAwsCredentials(),
            'digitalocean' => $this->validateDigitalOceanCredentials(),
            'hetzner' => $this->validateHetznerCredentials(),
            'gcp' => $this->validateGcpCredentials(),
            'azure' => $this->validateAzureCredentials(),
            default => false,
        };
    }

    protected function validateCredentialsFormat(): void
    {
        $required = match ($this->provider) {
            'aws' => ['access_key_id', 'secret_access_key', 'region'],
            'digitalocean' => ['api_token'],
            'hetzner' => ['api_token'],
            'gcp' => ['service_account_json', 'project_id'],
            'azure' => ['subscription_id', 'tenant_id', 'client_id', 'client_secret'],
            default => [],
        };

        foreach ($required as $key) {
            if (empty($this->credentials[$key])) {
                throw new \InvalidArgumentException("Missing required credential: {$key}");
            }
        }
    }

    // Accessor Methods for specific credential components
    protected function awsAccessKeyId(): Attribute
    {
        return Attribute::make(
            get: fn () => $this->provider === 'aws' ? $this->credentials['access_key_id'] ?? null : null
        );
    }

    protected function region(): Attribute
    {
        return Attribute::make(
            get: fn () => match ($this->provider) {
                'aws' => $this->credentials['region'] ?? null,
                'digitalocean' => $this->credentials['region'] ?? null,
                'hetzner' => $this->credentials['location'] ?? null,
                default => null,
            }
        );
    }

    // Helper Methods
    public function markAsValid(): void
    {
        $this->update([
            'validation_status' => 'valid',
            'last_validated_at' => now(),
            'validation_error' => null,
        ]);
    }

    public function markAsInvalid(string $error): void
    {
        $this->update([
            'validation_status' => 'invalid',
            'validation_error' => $error,
        ]);
    }

    public function canBeUsed(): bool
    {
        return $this->is_active && $this->validation_status === 'valid';
    }

    // Provider-specific validation methods (simplified - full implementation in service)
    protected function validateAwsCredentials(): bool
    {
        try {
            // Use AWS SDK to verify credentials
            $client = new \Aws\Sts\StsClient([
                'version' => 'latest',
                'region' => $this->credentials['region'],
                'credentials' => [
                    'key' => $this->credentials['access_key_id'],
                    'secret' => $this->credentials['secret_access_key'],
                ],
            ]);

            $result = $client->getCallerIdentity();
            $this->markAsValid();
            return true;
        } catch (\Exception $e) {
            $this->markAsInvalid($e->getMessage());
            return false;
        }
    }

    protected function validateDigitalOceanCredentials(): bool
    {
        try {
            // Verify DigitalOcean API token
            $response = \Illuminate\Support\Facades\Http::withToken($this->credentials['api_token'])
                ->get('https://api.digitalocean.com/v2/account');

            if ($response->successful()) {
                $this->markAsValid();
                return true;
            }

            $this->markAsInvalid('Invalid API token');
            return false;
        } catch (\Exception $e) {
            $this->markAsInvalid($e->getMessage());
            return false;
        }
    }

    protected function validateHetznerCredentials(): bool
    {
        try {
            // Verify Hetzner API token
            $response = \Illuminate\Support\Facades\Http::withToken($this->credentials['api_token'])
                ->get('https://api.hetzner.cloud/v1/locations');

            if ($response->successful()) {
                $this->markAsValid();
                return true;
            }

            $this->markAsInvalid('Invalid API token');
            return false;
        } catch (\Exception $e) {
            $this->markAsInvalid($e->getMessage());
            return false;
        }
    }

    // Additional provider validation methods...
}
```

### Model Factory

**File**: `database/factories/CloudProviderCredentialFactory.php`

```php
<?php

namespace Database\Factories;

use App\Models\CloudProviderCredential;
use App\Models\Organization;
use Illuminate\Database\Eloquent\Factories\Factory;

class CloudProviderCredentialFactory extends Factory
{
    protected $model = CloudProviderCredential::class;

    public function definition(): array
    {
        $provider = $this->faker->randomElement(['aws', 'digitalocean', 'hetzner']);

        return [
            'uuid' => (string) new \Visus\Cuid2\Cuid2(),
            'organization_id' => Organization::factory(),
            'name' => $this->faker->company . ' ' . strtoupper($provider),
            'provider' => $provider,
            'description' => $this->faker->sentence,
            'credentials' => $this->getCredentialsForProvider($provider),
            'metadata' => [],
            'is_active' => true,
            'validation_status' => 'valid',
            'last_validated_at' => now(),
        ];
    }

    protected function getCredentialsForProvider(string $provider): array
    {
        return match ($provider) {
            'aws' => [
                'access_key_id' => 'AKIA' . strtoupper($this->faker->bothify('??????????????')),
                'secret_access_key' => $this->faker->bothify('????????????????????????????????????????'),
                'region' => $this->faker->randomElement(['us-east-1', 'us-west-2', 'eu-west-1']),
            ],
            'digitalocean' => [
                'api_token' => 'dop_v1_' . $this->faker->bothify('????????????????????????????????'),
                'region' => $this->faker->randomElement(['nyc3', 'sfo3', 'ams3']),
            ],
            'hetzner' => [
                'api_token' => $this->faker->bothify('????????????????????????????????'),
                'location' => $this->faker->randomElement(['nbg1', 'fsn1', 'hel1']),
            ],
            default => [],
        };
    }

    // State methods for testing
    public function aws(): static
    {
        return $this->state(fn (array $attributes) => [
            'provider' => 'aws',
            'credentials' => $this->getCredentialsForProvider('aws'),
        ]);
    }

    public function digitalocean(): static
    {
        return $this->state(fn (array $attributes) => [
            'provider' => 'digitalocean',
            'credentials' => $this->getCredentialsForProvider('digitalocean'),
        ]);
    }

    public function invalid(): static
    {
        return $this->state(fn (array $attributes) => [
            'validation_status' => 'invalid',
            'validation_error' => 'Invalid credentials',
            'is_active' => false,
        ]);
    }
}
```

### Implementation Approach

1. **Create Model File**
   ```bash
   php artisan make:model CloudProviderCredential
   ```

2. **Add Encrypted Casting**
   - Configure `credentials` column with `encrypted:json` cast
   - Ensure `credentials` is in `$hidden` array to prevent exposure

3. **Implement Relationships**
   - `belongsTo(Organization::class)` with proper return type
   - `hasMany(TerraformDeployment::class)`

4. **Add Validation Logic**
   - Provider-specific credential validation methods
   - API calls to verify credentials are valid
   - Status tracking (valid/invalid/pending)

5. **Create Factory**
   ```bash
   php artisan make:factory CloudProviderCredentialFactory
   ```
   - Include realistic fake credentials for all providers
   - State methods for testing different scenarios

6. **Add Policy** (follows Coolify pattern)
   ```bash
   php artisan make:policy CloudProviderCredentialPolicy --model=CloudProviderCredential
   ```

### Test Strategy

**Unit Tests** (`tests/Unit/Models/CloudProviderCredentialTest.php`):

```php
use App\Models\CloudProviderCredential;
use App\Models\Organization;

it('encrypts credentials when storing', function () {
    $credential = CloudProviderCredential::factory()->aws()->create();

    // Check database has encrypted value
    $rawValue = DB::table('cloud_provider_credentials')
        ->where('id', $credential->id)
        ->value('credentials');

    expect($rawValue)->not->toContain('AKIA'); // Should be encrypted
    expect($credential->credentials['access_key_id'])->toStartWith('AKIA'); // Decrypted
});

it('validates AWS credential format', function () {
    expect(fn () => CloudProviderCredential::factory()->create([
        'provider' => 'aws',
        'credentials' => ['region' => 'us-east-1'], // Missing keys
    ]))->toThrow(InvalidArgumentException::class);
});

it('belongs to an organization', function () {
    $credential = CloudProviderCredential::factory()->create();

    expect($credential->organization)->toBeInstanceOf(Organization::class);
});

it('has many terraform deployments', function () {
    $credential = CloudProviderCredential::factory()->create();

    expect($credential->terraformDeployments())->toBeInstanceOf(HasMany::class);
});

it('marks credential as valid after successful validation', function () {
    $credential = CloudProviderCredential::factory()->create([
        'validation_status' => 'pending',
    ]);

    $credential->markAsValid();

    expect($credential->validation_status)->toBe('valid')
        ->and($credential->last_validated_at)->not->toBeNull();
});

it('marks credential as invalid with error message', function () {
    $credential = CloudProviderCredential::factory()->create();

    $credential->markAsInvalid('API token expired');

    expect($credential->validation_status)->toBe('invalid')
        ->and($credential->validation_error)->toBe('API token expired');
});

it('provides accessor for AWS region', function () {
    $credential = CloudProviderCredential::factory()->aws()->create();

    expect($credential->region)->toBe($credential->credentials['region']);
});
```

**Integration Tests**:

```php
it('automatically generates UUID on creation', function () {
    $credential = CloudProviderCredential::factory()->create(['uuid' => null]);

    expect($credential->uuid)->not->toBeNull()
        ->and(strlen($credential->uuid))->toBeGreaterThan(20);
});

it('hides credentials in JSON serialization', function () {
    $credential = CloudProviderCredential::factory()->create();

    $json = $credential->toArray();

    expect($json)->not->toHaveKey('credentials');
});

it('soft deletes credential', function () {
    $credential = CloudProviderCredential::factory()->create();

    $credential->delete();

    expect(CloudProviderCredential::find($credential->id))->toBeNull()
        ->and(CloudProviderCredential::withTrashed()->find($credential->id))->not->toBeNull();
});
```

## Definition of Done

- [ ] Model class created extending BaseModel
- [ ] Encrypted casting configured for credentials column
- [ ] All relationships defined with proper type hints
- [ ] Factory created with realistic test data for all providers
- [ ] Validation methods implemented for AWS, DigitalOcean, Hetzner
- [ ] Accessor methods for extracting credential components
- [ ] Helper methods (markAsValid, markAsInvalid, canBeUsed) implemented
- [ ] Credentials hidden from JSON serialization
- [ ] UUID automatically generated on model creation
- [ ] Soft deletes enabled and working
- [ ] Unit tests verify encryption/decryption
- [ ] Unit tests verify all relationships
- [ ] Unit tests verify validation logic
- [ ] Integration tests verify model behavior
- [ ] PHPDoc blocks document all public methods
- [ ] Code follows PSR-12 standards
- [ ] No PHPStan errors (level 5+)
- [ ] Policy created and registered in AuthServiceProvider
