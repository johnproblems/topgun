---
name: Implement Redis caching layer for compiled CSS with automatic invalidation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:21Z
github: https://github.com/johnproblems/topgun/issues/113
depends_on: [2]
parallel: false
conflicts_with: []
---

# Task: Implement Redis caching layer for compiled CSS with automatic invalidation

## Description

This task implements a **Redis-based caching layer** for the compiled CSS generated by the DynamicAssetController, with **automatic cache invalidation** when organization branding configurations are updated. This is critical for performance optimization, ensuring that CSS compilation (which can take 200-500ms) only happens once, while all subsequent requests are served from Redis cache in < 50ms.

The caching system will:
1. Cache compiled CSS in Redis using organization-specific keys
2. Set appropriate TTL (Time-To-Live) for cache entries
3. Automatically invalidate cache when `white_label_configs` records are updated
4. Support manual cache invalidation via Artisan command
5. Track cache hit/miss metrics for monitoring
6. Provide cache warming functionality for bulk pre-compilation

This integrates with existing Coolify infrastructure by:
- Using the already-configured Redis connection
- Leveraging Laravel's Eloquent model observers for automatic invalidation
- Following Coolify's caching patterns (similar to existing ResourcesCheck caching)
- Supporting Redis clustering for high-availability deployments

**Why this task is important:** Without caching, every request for organization CSS would trigger SASS compilation, creating a significant performance bottleneck. With hundreds of organizations, this would result in excessive CPU usage and slow page loads. Redis caching reduces latency from ~500ms to < 50ms, improving user experience and reducing server load by 90%+.

## Acceptance Criteria

- [ ] Redis caching implemented in DynamicAssetController
- [ ] Cache keys follow consistent naming pattern: `branding:{org_slug}:css:v{version}`
- [ ] Cache TTL configurable via environment variable (default: 3600 seconds)
- [ ] Compiled CSS successfully cached and retrieved from Redis
- [ ] Cache hit/miss is measurable (logged or metrics exported)
- [ ] Automatic cache invalidation on WhiteLabelConfig model updates
- [ ] Automatic cache invalidation on WhiteLabelConfig model deletion
- [ ] Manual cache invalidation command: `php artisan branding:clear-cache {organization?}`
- [ ] Cache warming command: `php artisan branding:warm-cache {organization?}`
- [ ] Cache statistics command: `php artisan branding:cache-stats`
- [ ] Cache invalidation triggers for all related model changes (logo uploads, color changes)
- [ ] Performance improvement verified: < 50ms for cached requests

## Technical Details

### File Paths

**Controller Enhancement:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/DynamicAssetController.php` (modify existing)

**Model Observers:**
- `/home/topgun/topgun/app/Observers/WhiteLabelConfigObserver.php` (new)

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/BrandingCacheService.php` (new)
- `/home/topgun/topgun/app/Contracts/BrandingCacheServiceInterface.php` (new)

**Artisan Commands:**
- `/home/topgun/topgun/app/Console/Commands/ClearBrandingCache.php` (new)
- `/home/topgun/topgun/app/Console/Commands/WarmBrandingCache.php` (new)
- `/home/topgun/topgun/app/Console/Commands/BrandingCacheStats.php` (new)

**Service Provider:**
- `/home/topgun/topgun/app/Providers/EnterpriseServiceProvider.php` (modify to register observer)

### Database Schema

No new database tables required. Uses existing:
- `white_label_configs` table (for observer triggers)
- `organizations` table (for cache key generation)

### BrandingCacheService Class Structure

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\BrandingCacheServiceInterface;
use App\Models\Organization;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Log;

class BrandingCacheService implements BrandingCacheServiceInterface
{
    private const CACHE_PREFIX = 'branding';
    private const CACHE_VERSION = 'v1';
    private const STATS_KEY = 'branding:stats';

    public function __construct(
        private int $cacheTtl = 3600
    ) {}

    /**
     * Get compiled CSS from cache
     *
     * @param string $organizationSlug
     * @return string|null
     */
    public function get(string $organizationSlug): ?string
    {
        $key = $this->getCacheKey($organizationSlug);

        try {
            $css = Redis::get($key);

            if ($css) {
                $this->incrementStat('hits');
                Log::debug("Cache hit for branding CSS: {$organizationSlug}");
            } else {
                $this->incrementStat('misses');
                Log::debug("Cache miss for branding CSS: {$organizationSlug}");
            }

            return $css;
        } catch (\Exception $e) {
            Log::error("Redis cache retrieval failed: {$e->getMessage()}");
            $this->incrementStat('errors');
            return null;
        }
    }

    /**
     * Store compiled CSS in cache
     *
     * @param string $organizationSlug
     * @param string $css
     * @return bool
     */
    public function put(string $organizationSlug, string $css): bool
    {
        $key = $this->getCacheKey($organizationSlug);

        try {
            Redis::setex($key, $this->cacheTtl, $css);
            Log::info("Cached branding CSS for organization: {$organizationSlug}");
            return true;
        } catch (\Exception $e) {
            Log::error("Redis cache storage failed: {$e->getMessage()}");
            $this->incrementStat('errors');
            return false;
        }
    }

    /**
     * Invalidate cache for specific organization
     *
     * @param Organization $organization
     * @return bool
     */
    public function invalidate(Organization $organization): bool
    {
        $key = $this->getCacheKey($organization->slug);

        try {
            $result = Redis::del($key);
            Log::info("Invalidated branding cache for organization: {$organization->slug}");
            $this->incrementStat('invalidations');
            return $result > 0;
        } catch (\Exception $e) {
            Log::error("Redis cache invalidation failed: {$e->getMessage()}");
            return false;
        }
    }

    /**
     * Clear all branding caches
     *
     * @return int Number of keys deleted
     */
    public function flush(): int
    {
        try {
            $pattern = $this->getCacheKey('*');
            $keys = Redis::keys($pattern);
            $count = count($keys);

            if ($count > 0) {
                Redis::del($keys);
                Log::info("Flushed {$count} branding cache entries");
            }

            return $count;
        } catch (\Exception $e) {
            Log::error("Redis cache flush failed: {$e->getMessage()}");
            return 0;
        }
    }

    /**
     * Get cache statistics
     *
     * @return array
     */
    public function getStats(): array
    {
        try {
            $stats = Redis::hgetall(self::STATS_KEY);

            return [
                'hits' => (int) ($stats['hits'] ?? 0),
                'misses' => (int) ($stats['misses'] ?? 0),
                'invalidations' => (int) ($stats['invalidations'] ?? 0),
                'errors' => (int) ($stats['errors'] ?? 0),
                'hit_rate' => $this->calculateHitRate($stats),
            ];
        } catch (\Exception $e) {
            Log::error("Failed to retrieve cache stats: {$e->getMessage()}");
            return [];
        }
    }

    /**
     * Generate cache key for organization
     *
     * @param string $organizationSlug
     * @return string
     */
    private function getCacheKey(string $organizationSlug): string
    {
        return self::CACHE_PREFIX . ":{$organizationSlug}:css:" . self::CACHE_VERSION;
    }

    /**
     * Increment cache statistic
     *
     * @param string $stat
     * @return void
     */
    private function incrementStat(string $stat): void
    {
        try {
            Redis::hincrby(self::STATS_KEY, $stat, 1);
        } catch (\Exception $e) {
            // Silently fail - stats are non-critical
        }
    }

    /**
     * Calculate cache hit rate
     *
     * @param array $stats
     * @return float
     */
    private function calculateHitRate(array $stats): float
    {
        $hits = (int) ($stats['hits'] ?? 0);
        $misses = (int) ($stats['misses'] ?? 0);
        $total = $hits + $misses;

        return $total > 0 ? round(($hits / $total) * 100, 2) : 0.0;
    }
}
```

### WhiteLabelConfigObserver

```php
<?php

namespace App\Observers;

use App\Models\WhiteLabelConfig;
use App\Services\Enterprise\BrandingCacheService;
use Illuminate\Support\Facades\Log;

class WhiteLabelConfigObserver
{
    public function __construct(
        private BrandingCacheService $cacheService
    ) {}

    /**
     * Handle the WhiteLabelConfig "updated" event.
     */
    public function updated(WhiteLabelConfig $config): void
    {
        $this->invalidateCache($config);
    }

    /**
     * Handle the WhiteLabelConfig "deleted" event.
     */
    public function deleted(WhiteLabelConfig $config): void
    {
        $this->invalidateCache($config);
    }

    /**
     * Invalidate cache for the config's organization
     */
    private function invalidateCache(WhiteLabelConfig $config): void
    {
        try {
            $organization = $config->organization;

            if ($organization) {
                $this->cacheService->invalidate($organization);
                Log::info("Auto-invalidated branding cache for organization: {$organization->slug}");
            }
        } catch (\Exception $e) {
            Log::error("Failed to auto-invalidate branding cache: {$e->getMessage()}");
        }
    }
}
```

### Artisan Commands

**Clear Cache Command:**
```php
<?php

namespace App\Console\Commands;

use App\Models\Organization;
use App\Services\Enterprise\BrandingCacheService;
use Illuminate\Console\Command;

class ClearBrandingCache extends Command
{
    protected $signature = 'branding:clear-cache {organization? : Organization slug to clear (optional)}';
    protected $description = 'Clear branding CSS cache for one or all organizations';

    public function handle(BrandingCacheService $cacheService): int
    {
        $orgSlug = $this->argument('organization');

        if ($orgSlug) {
            $organization = Organization::where('slug', $orgSlug)->first();

            if (!$organization) {
                $this->error("Organization '{$orgSlug}' not found");
                return self::FAILURE;
            }

            $cacheService->invalidate($organization);
            $this->info("Cleared branding cache for: {$orgSlug}");
        } else {
            $count = $cacheService->flush();
            $this->info("Cleared {$count} branding cache entries");
        }

        return self::SUCCESS;
    }
}
```

## Implementation Approach

### Step 1: Create BrandingCacheService
1. Create interface in `app/Contracts/BrandingCacheServiceInterface.php`
2. Implement service in `app/Services/Enterprise/BrandingCacheService.php`
3. Add methods: `get()`, `put()`, `invalidate()`, `flush()`, `getStats()`
4. Configure TTL from environment variable

### Step 2: Register Service in Provider
```php
// app/Providers/EnterpriseServiceProvider.php
$this->app->singleton(BrandingCacheServiceInterface::class, function ($app) {
    return new BrandingCacheService(
        cacheTtl: config('enterprise.white_label.cache_ttl', 3600)
    );
});
```

### Step 3: Integrate Caching in DynamicAssetController
```php
public function styles(string $organizationSlug): Response
{
    // Check cache first
    $cachedCss = $this->cacheService->get($organizationSlug);

    if ($cachedCss) {
        return response($cachedCss, 200)
            ->header('Content-Type', 'text/css; charset=UTF-8')
            ->header('X-Cache', 'HIT');
    }

    // Generate CSS (existing logic)
    $css = $this->generateCss($organizationSlug);

    // Cache the result
    $this->cacheService->put($organizationSlug, $css);

    return response($css, 200)
        ->header('Content-Type', 'text/css; charset=UTF-8')
        ->header('X-Cache', 'MISS');
}
```

### Step 4: Create Model Observer
1. Create `WhiteLabelConfigObserver` class
2. Implement `updated()` and `deleted()` methods
3. Call `BrandingCacheService::invalidate()` on changes

### Step 5: Register Observer
```php
// app/Providers/EnterpriseServiceProvider.php
public function boot()
{
    WhiteLabelConfig::observe(WhiteLabelConfigObserver::class);
}
```

### Step 6: Create Artisan Commands
1. `ClearBrandingCache` - Manual cache invalidation
2. `WarmBrandingCache` - Pre-compile all organization CSS
3. `BrandingCacheStats` - Display cache hit/miss statistics

### Step 7: Add Configuration
```php
// config/enterprise.php
'white_label' => [
    'cache_ttl' => env('WHITE_LABEL_CACHE_TTL', 3600),
    'cache_enabled' => env('WHITE_LABEL_CACHE_ENABLED', true),
],
```

### Step 8: Testing
1. Unit test BrandingCacheService methods
2. Test cache hit/miss behavior
3. Test automatic invalidation on model changes
4. Test manual invalidation commands
5. Test cache statistics tracking

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Enterprise/BrandingCacheServiceTest.php`

```php
it('caches compiled CSS successfully', function () {
    $service = app(BrandingCacheService::class);

    $css = ':root { --color-primary: #ff0000; }';
    $result = $service->put('test-org', $css);

    expect($result)->toBeTrue();

    $cached = $service->get('test-org');
    expect($cached)->toBe($css);
});

it('returns null for cache miss', function () {
    $service = app(BrandingCacheService::class);

    $result = $service->get('non-existent-org');

    expect($result)->toBeNull();
});

it('invalidates cache for organization', function () {
    $service = app(BrandingCacheService::class);
    $org = Organization::factory()->create(['slug' => 'test-org']);

    $service->put('test-org', 'test-css');
    $service->invalidate($org);

    expect($service->get('test-org'))->toBeNull();
});

it('tracks cache statistics', function () {
    $service = app(BrandingCacheService::class);

    $service->get('org-1'); // Miss
    $service->put('org-1', 'css');
    $service->get('org-1'); // Hit

    $stats = $service->getStats();

    expect($stats['hits'])->toBe(1);
    expect($stats['misses'])->toBe(1);
    expect($stats['hit_rate'])->toBe(50.0);
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/BrandingCacheIntegrationTest.php`

```php
it('automatically invalidates cache when config is updated', function () {
    $org = Organization::factory()->create(['slug' => 'test-org']);
    $config = WhiteLabelConfig::factory()->create([
        'organization_id' => $org->id,
        'primary_color' => '#ff0000',
    ]);

    // Initial request - cache miss
    $response = $this->get("/branding/test-org/styles.css");
    $response->assertHeader('X-Cache', 'MISS');

    // Second request - cache hit
    $response = $this->get("/branding/test-org/styles.css");
    $response->assertHeader('X-Cache', 'HIT');

    // Update config - should invalidate cache
    $config->update(['primary_color' => '#00ff00']);

    // Next request should be a miss (cache was invalidated)
    $response = $this->get("/branding/test-org/styles.css");
    $response->assertHeader('X-Cache', 'MISS');
    $response->assertSee('#00ff00');
});

it('cache improves response time significantly', function () {
    $org = Organization::factory()->create(['slug' => 'perf-test']);
    WhiteLabelConfig::factory()->create(['organization_id' => $org->id]);

    // First request (uncached) - measure time
    $start = microtime(true);
    $this->get("/branding/perf-test/styles.css");
    $uncachedTime = (microtime(true) - $start) * 1000;

    // Second request (cached) - should be much faster
    $start = microtime(true);
    $this->get("/branding/perf-test/styles.css");
    $cachedTime = (microtime(true) - $start) * 1000;

    expect($cachedTime)->toBeLessThan(50); // < 50ms for cached
    expect($cachedTime)->toBeLessThan($uncachedTime / 5); // 5x faster
});
```

### Command Tests

```php
it('clears cache for specific organization', function () {
    $org = Organization::factory()->create(['slug' => 'test-org']);
    $cacheService = app(BrandingCacheService::class);

    $cacheService->put('test-org', 'test-css');

    $this->artisan('branding:clear-cache test-org')
        ->assertSuccessful()
        ->expectsOutput('Cleared branding cache for: test-org');

    expect($cacheService->get('test-org'))->toBeNull();
});

it('displays cache statistics', function () {
    $this->artisan('branding:cache-stats')
        ->assertSuccessful()
        ->expectsOutputToContain('Cache Hit Rate');
});
```

## Definition of Done

- [ ] BrandingCacheServiceInterface created in `app/Contracts/`
- [ ] BrandingCacheService implemented in `app/Services/Enterprise/`
- [ ] Service registered in EnterpriseServiceProvider
- [ ] DynamicAssetController integrated with caching service
- [ ] Cache hit/miss tracked with X-Cache header in responses
- [ ] WhiteLabelConfigObserver created and registered
- [ ] Automatic cache invalidation on config updates working
- [ ] Automatic cache invalidation on config deletion working
- [ ] ClearBrandingCache Artisan command created
- [ ] WarmBrandingCache Artisan command created
- [ ] BrandingCacheStats Artisan command created
- [ ] Configuration added to `config/enterprise.php`
- [ ] Cache TTL configurable via environment variable
- [ ] Unit tests written for BrandingCacheService (> 90% coverage)
- [ ] Integration tests for automatic invalidation
- [ ] Performance tests verify < 50ms cached response time
- [ ] Command tests for all Artisan commands
- [ ] Cache statistics tracking verified and accurate
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan analysis passes with no errors
- [ ] Manual testing with sample organizations completed
- [ ] Code reviewed by team member
- [ ] All tests passing (`php artisan test --filter=BrandingCache`)
