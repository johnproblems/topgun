---
name: Implement blue-green deployment strategy
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:52Z
github: https://github.com/johnproblems/topgun/issues/144
depends_on: [32]
parallel: false
conflicts_with: []
---

# Task: Implement blue-green deployment strategy

## Description

Implement a comprehensive blue-green deployment strategy for zero-downtime application updates with automated health checking, traffic switching, and rollback capabilities. This advanced deployment pattern maintains two identical production environments ("blue" and "green"), allowing seamless version transitions by switching traffic between environments only after verifying the new deployment is healthy.

**The Zero-Downtime Challenge:**

Traditional deployment strategies suffer from unavoidable downtime:
1. **Direct Replacement**: Stop old version → Deploy new version → Start new version (downtime: 30-120 seconds)
2. **Rolling Update**: Update instances one-by-one (partial capacity, potential version conflicts)
3. **Recreate Strategy**: Delete all instances → Create new instances (complete outage)

Even "rolling updates" create problems: version mismatches during transition, degraded capacity, database migration timing issues, and no instant rollback capability. For mission-critical applications, these approaches are unacceptable.

**The Blue-Green Solution:**

Blue-green deployment eliminates downtime by maintaining two complete production environments:

1. **Blue Environment**: Currently serving live production traffic
2. **Green Environment**: Newly deployed version running in isolation, receiving synthetic health checks

The deployment process:
1. Deploy new version to idle "green" environment
2. Run comprehensive health checks against green environment
3. If healthy: Switch traffic from blue to green (atomic operation, < 100ms)
4. If unhealthy: Keep traffic on blue, investigate green environment issues
5. After successful switch: Blue becomes the new idle environment for next deployment

**Key Benefits:**

- **Zero Downtime**: Traffic switch is instantaneous (proxy rule change)
- **Instant Rollback**: If issues arise, switch traffic back to blue immediately
- **Safe Testing**: Green environment is fully deployed and testable before receiving real traffic
- **Database Safety**: Migrations run before traffic switch, with rollback capability
- **Audit Trail**: Both environments exist for comparison during troubleshooting

**Integration Architecture:**

This task extends the EnhancedDeploymentService created in Task 32, adding blue-green as one of several deployment strategies alongside rolling updates (Task 33) and canary deployments (Task 35).

**Dependencies:**
- **Task 32 (EnhancedDeploymentService)**: Base deployment service with strategy pattern
- **Task 26 (CapacityManager)**: Server selection and capacity validation
- **Task 14 (TerraformService)**: Optional infrastructure provisioning for green environment
- **Existing Coolify**: ApplicationDeploymentJob, Server model, Application model, proxy configuration

**Integration Points:**
- **EnhancedDeploymentService**: Implements `deployBlueGreen()` method
- **Application Model**: Tracks current active environment (blue/green)
- **Proxy Configuration**: Nginx/Traefik rule switching for traffic redirection
- **Health Check System**: HTTP endpoint validation, custom health check scripts
- **Database Migrations**: Safe migration execution with rollback capability
- **Docker Containers**: Environment-specific container naming (app-blue, app-green)

**Why This Task is Critical:**

For enterprise customers, downtime is measured in revenue loss (e.g., $10,000/minute for e-commerce sites). Blue-green deployment transforms the deployment process from "risky maintenance window" to "routine, safe, automated operation." Operations teams gain confidence knowing they can deploy multiple times per day without risking production stability. The instant rollback capability means issues can be addressed within seconds rather than minutes, dramatically reducing mean time to recovery (MTTR).

## Acceptance Criteria

- [ ] Blue-green deployment strategy implemented in EnhancedDeploymentService
- [ ] Maintains two complete application environments (blue and green)
- [ ] Deploys new version to idle environment without affecting active environment
- [ ] Comprehensive health check validation before traffic switch
- [ ] HTTP health checks with configurable endpoints (default: /health, /api/health)
- [ ] Custom health check script support (exit code 0 = healthy)
- [ ] Database migration execution with rollback capability
- [ ] Atomic traffic switching via proxy configuration update
- [ ] Supports both Nginx and Traefik proxies
- [ ] Instant rollback capability to previous environment
- [ ] Application model tracks current active environment (blue/green)
- [ ] Environment-specific Docker container naming (app-blue-{id}, app-green-{id})
- [ ] Comprehensive error handling and logging
- [ ] Deployment history records environment switches
- [ ] Pre-deployment capacity validation using CapacityManager
- [ ] Optional infrastructure provisioning if capacity insufficient
- [ ] WebSocket broadcasting for real-time deployment status updates
- [ ] Configurable health check timeout (default: 60 seconds)
- [ ] Configurable health check retry count (default: 5 attempts)
- [ ] Automatic cleanup of old environment after successful switch

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/EnhancedDeploymentService.php` (modify)
- `/home/topgun/topgun/app/Contracts/EnhancedDeploymentServiceInterface.php` (modify)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/BlueGreenDeploymentJob.php` (new)
- `/home/topgun/topgun/app/Jobs/Enterprise/HealthCheckJob.php` (new)

**Database Migrations:**
- `/home/topgun/topgun/database/migrations/xxxx_add_blue_green_fields_to_applications_table.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Application.php` (modify)
- `/home/topgun/topgun/app/Models/ApplicationDeploymentHistory.php` (new)

**Actions:**
- `/home/topgun/topgun/app/Actions/Deployment/SwitchTrafficAction.php` (new)
- `/home/topgun/topgun/app/Actions/Deployment/RunHealthChecksAction.php` (new)
- `/home/topgun/topgun/app/Actions/Proxy/UpdateProxyConfigurationAction.php` (new)

**Tests:**
- `/home/topgun/topgun/tests/Unit/Services/EnhancedDeploymentServiceTest.php` (modify)
- `/home/topgun/topgun/tests/Feature/Deployment/BlueGreenDeploymentTest.php` (new)

### Database Schema Enhancement

Add blue-green tracking columns to `applications` table:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('applications', function (Blueprint $table) {
            // Blue-green deployment fields
            $table->enum('active_environment', ['blue', 'green'])->default('blue')->after('status');
            $table->string('blue_container_id')->nullable()->after('active_environment');
            $table->string('green_container_id')->nullable()->after('blue_container_id');
            $table->timestamp('last_environment_switch_at')->nullable()->after('green_container_id');

            // Health check configuration
            $table->string('health_check_endpoint')->default('/health')->after('last_environment_switch_at');
            $table->integer('health_check_timeout')->default(60)->after('health_check_endpoint'); // seconds
            $table->integer('health_check_retries')->default(5)->after('health_check_timeout');
            $table->text('health_check_script')->nullable()->after('health_check_retries'); // Custom health check command

            // Deployment strategy configuration
            $table->enum('deployment_strategy', ['rolling', 'blue_green', 'canary', 'recreate'])
                ->default('rolling')
                ->after('health_check_script');

            $table->index(['active_environment', 'status'], 'app_environment_status_idx');
        });
    }

    public function down(): void
    {
        Schema::table('applications', function (Blueprint $table) {
            $table->dropIndex('app_environment_status_idx');

            $table->dropColumn([
                'active_environment',
                'blue_container_id',
                'green_container_id',
                'last_environment_switch_at',
                'health_check_endpoint',
                'health_check_timeout',
                'health_check_retries',
                'health_check_script',
                'deployment_strategy',
            ]);
        });
    }
};
```

### Create ApplicationDeploymentHistory Model

Track deployment history with environment switches:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('application_deployment_history', function (Blueprint $table) {
            $table->id();
            $table->foreignId('application_id')->constrained('applications')->cascadeOnDelete();
            $table->foreignId('initiated_by_user_id')->nullable()->constrained('users')->nullOnDelete();

            $table->enum('deployment_strategy', ['rolling', 'blue_green', 'canary', 'recreate']);
            $table->enum('status', ['pending', 'in_progress', 'health_checking', 'switching_traffic', 'completed', 'failed', 'rolled_back']);

            // Blue-green specific fields
            $table->enum('deployed_to_environment', ['blue', 'green'])->nullable();
            $table->enum('active_environment_before', ['blue', 'green'])->nullable();
            $table->enum('active_environment_after', ['blue', 'green'])->nullable();
            $table->timestamp('traffic_switched_at')->nullable();

            // Deployment metadata
            $table->string('git_commit_hash')->nullable();
            $table->string('git_branch')->nullable();
            $table->string('docker_image_tag')->nullable();

            // Health check results
            $table->json('health_check_results')->nullable();
            $table->boolean('health_checks_passed')->default(false);

            // Timing
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->integer('duration_seconds')->nullable();

            // Error tracking
            $table->text('error_message')->nullable();
            $table->json('error_context')->nullable();

            $table->timestamps();

            $table->index(['application_id', 'status'], 'deployment_history_app_status_idx');
            $table->index(['created_at'], 'deployment_history_created_idx');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('application_deployment_history');
    }
};
```

### EnhancedDeploymentService - Blue-Green Method

**File:** `app/Services/Enterprise/EnhancedDeploymentService.php` (add to existing service)

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\EnhancedDeploymentServiceInterface;
use App\Contracts\CapacityManagerInterface;
use App\Models\Application;
use App\Models\ApplicationDeploymentHistory;
use App\Jobs\Enterprise\BlueGreenDeploymentJob;
use App\Actions\Deployment\RunHealthChecksAction;
use App\Actions\Deployment\SwitchTrafficAction;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

class EnhancedDeploymentService implements EnhancedDeploymentServiceInterface
{
    public function __construct(
        private CapacityManagerInterface $capacityManager,
        private RunHealthChecksAction $healthCheckAction,
        private SwitchTrafficAction $trafficSwitchAction
    ) {
    }

    /**
     * Deploy application using blue-green strategy
     *
     * @param Application $application
     * @param array $options Deployment options (git_branch, commit_hash, etc.)
     * @return ApplicationDeploymentHistory
     * @throws \Exception
     */
    public function deployBlueGreen(Application $application, array $options = []): ApplicationDeploymentHistory
    {
        // Validate application supports blue-green
        $this->validateBlueGreenSupport($application);

        // Create deployment history record
        $deployment = $this->createDeploymentHistory($application, 'blue_green', $options);

        try {
            DB::beginTransaction();

            // Step 1: Determine target environment (opposite of current active)
            $targetEnvironment = $this->getTargetEnvironment($application);
            $deployment->update([
                'deployed_to_environment' => $targetEnvironment,
                'active_environment_before' => $application->active_environment,
                'status' => 'in_progress',
                'started_at' => now(),
            ]);

            Log::info("Starting blue-green deployment", [
                'application_id' => $application->id,
                'application_name' => $application->name,
                'current_environment' => $application->active_environment,
                'target_environment' => $targetEnvironment,
                'deployment_id' => $deployment->id,
            ]);

            // Step 2: Validate capacity
            $server = $this->validateCapacity($application);

            // Step 3: Deploy to target environment
            $this->deployToEnvironment($application, $targetEnvironment, $server, $options);

            // Update deployment status
            $deployment->update(['status' => 'health_checking']);

            // Step 4: Run health checks
            $healthCheckResults = $this->runHealthChecks($application, $targetEnvironment, $deployment);

            if (!$healthCheckResults['healthy']) {
                throw new \Exception(
                    "Health checks failed for {$targetEnvironment} environment: " .
                    ($healthCheckResults['error'] ?? 'Unknown error')
                );
            }

            // Update deployment with health check results
            $deployment->update([
                'health_check_results' => $healthCheckResults,
                'health_checks_passed' => true,
                'status' => 'switching_traffic',
            ]);

            // Step 5: Switch traffic to new environment
            $this->switchTraffic($application, $targetEnvironment, $deployment);

            // Step 6: Update application active environment
            $application->update([
                'active_environment' => $targetEnvironment,
                'last_environment_switch_at' => now(),
            ]);

            // Step 7: Complete deployment
            $deployment->update([
                'status' => 'completed',
                'active_environment_after' => $targetEnvironment,
                'traffic_switched_at' => now(),
                'completed_at' => now(),
                'duration_seconds' => now()->diffInSeconds($deployment->started_at),
            ]);

            DB::commit();

            Log::info("Blue-green deployment completed successfully", [
                'application_id' => $application->id,
                'deployment_id' => $deployment->id,
                'new_active_environment' => $targetEnvironment,
                'duration_seconds' => $deployment->duration_seconds,
            ]);

            // Optional: Schedule cleanup of old environment
            $this->scheduleEnvironmentCleanup($application, $deployment);

            return $deployment;

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error("Blue-green deployment failed", [
                'application_id' => $application->id,
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            $deployment->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
                'error_context' => [
                    'trace' => $e->getTraceAsString(),
                    'file' => $e->getFile(),
                    'line' => $e->getLine(),
                ],
                'completed_at' => now(),
                'duration_seconds' => now()->diffInSeconds($deployment->started_at),
            ]);

            throw $e;
        }
    }

    /**
     * Rollback to previous environment (instant traffic switch)
     *
     * @param Application $application
     * @param ApplicationDeploymentHistory $deployment
     * @return void
     */
    public function rollbackBlueGreen(Application $application, ApplicationDeploymentHistory $deployment): void
    {
        $previousEnvironment = $deployment->active_environment_before;

        if (!$previousEnvironment) {
            throw new \Exception("Cannot rollback: No previous environment recorded");
        }

        Log::warning("Initiating blue-green rollback", [
            'application_id' => $application->id,
            'current_environment' => $application->active_environment,
            'rollback_to_environment' => $previousEnvironment,
        ]);

        DB::beginTransaction();

        try {
            // Switch traffic back to previous environment
            $this->switchTraffic($application, $previousEnvironment, $deployment);

            // Update application
            $application->update([
                'active_environment' => $previousEnvironment,
                'last_environment_switch_at' => now(),
            ]);

            // Update deployment history
            $deployment->update([
                'status' => 'rolled_back',
                'active_environment_after' => $previousEnvironment,
                'completed_at' => now(),
            ]);

            DB::commit();

            Log::info("Blue-green rollback completed", [
                'application_id' => $application->id,
                'rolled_back_to' => $previousEnvironment,
            ]);

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error("Blue-green rollback failed", [
                'application_id' => $application->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Validate application supports blue-green deployment
     *
     * @param Application $application
     * @return void
     * @throws \Exception
     */
    protected function validateBlueGreenSupport(Application $application): void
    {
        if (!$application->destination) {
            throw new \Exception("Application has no server destination configured");
        }

        if (!$application->destination->server) {
            throw new \Exception("Application destination has no server assigned");
        }

        if (!$application->git_repository && !$application->docker_image) {
            throw new \Exception("Application has no git repository or docker image configured");
        }

        // Ensure health check endpoint is configured
        if (empty($application->health_check_endpoint)) {
            Log::warning("No health check endpoint configured, using default /health");
            $application->update(['health_check_endpoint' => '/health']);
        }
    }

    /**
     * Get target environment for deployment (opposite of current active)
     *
     * @param Application $application
     * @return string
     */
    protected function getTargetEnvironment(Application $application): string
    {
        return $application->active_environment === 'blue' ? 'green' : 'blue';
    }

    /**
     * Validate server has capacity for deployment
     *
     * @param Application $application
     * @return \App\Models\Server
     * @throws \Exception
     */
    protected function validateCapacity(Application $application): \App\Models\Server
    {
        $server = $application->destination->server;

        $canHandle = $this->capacityManager->canServerHandleDeployment(
            $server,
            $application
        );

        if (!$canHandle) {
            throw new \Exception(
                "Server {$server->name} does not have sufficient capacity for deployment. " .
                "Consider provisioning additional infrastructure."
            );
        }

        return $server;
    }

    /**
     * Deploy application to specific environment
     *
     * @param Application $application
     * @param string $environment (blue|green)
     * @param \App\Models\Server $server
     * @param array $options
     * @return void
     */
    protected function deployToEnvironment(
        Application $application,
        string $environment,
        \App\Models\Server $server,
        array $options
    ): void {
        // Container name includes environment suffix
        $containerName = "{$application->uuid}-{$environment}";

        // Build deployment command
        $deployCommand = $this->buildDeployCommand($application, $containerName, $options);

        // Execute deployment on server
        $result = $server->executeRemoteCommand($deployCommand);

        if ($result['exitCode'] !== 0) {
            throw new \Exception(
                "Deployment to {$environment} environment failed: " .
                ($result['stderr'] ?? 'Unknown error')
            );
        }

        // Store container ID
        $containerIdField = "{$environment}_container_id";
        $application->update([$containerIdField => $result['container_id'] ?? null]);

        Log::info("Successfully deployed to {$environment} environment", [
            'application_id' => $application->id,
            'container_name' => $containerName,
            'environment' => $environment,
        ]);
    }

    /**
     * Build deployment command for environment
     *
     * @param Application $application
     * @param string $containerName
     * @param array $options
     * @return string
     */
    protected function buildDeployCommand(
        Application $application,
        string $containerName,
        array $options
    ): string {
        // This is a simplified example - actual implementation would use
        // existing Coolify deployment logic from ApplicationDeploymentJob

        $gitBranch = $options['git_branch'] ?? $application->git_branch;
        $commitHash = $options['git_commit_hash'] ?? null;

        // Build docker run command with environment-specific naming
        $command = "docker run -d --name {$containerName}";

        // Add environment variables
        foreach ($application->environment_variables ?? [] as $key => $value) {
            $command .= " -e {$key}='{$value}'";
        }

        // Add port mappings (using temporary port for non-active environment)
        if ($application->ports) {
            foreach ($application->ports as $port) {
                $command .= " -p {$port}";
            }
        }

        // Add docker image or build from git
        if ($application->docker_image) {
            $command .= " {$application->docker_image}";
        } else {
            // Build from git repository
            $command .= " {$application->uuid}:latest";
        }

        return $command;
    }

    /**
     * Run health checks against environment
     *
     * @param Application $application
     * @param string $environment
     * @param ApplicationDeploymentHistory $deployment
     * @return array
     */
    protected function runHealthChecks(
        Application $application,
        string $environment,
        ApplicationDeploymentHistory $deployment
    ): array {
        return $this->healthCheckAction->execute(
            $application,
            $environment,
            $deployment
        );
    }

    /**
     * Switch traffic to target environment
     *
     * @param Application $application
     * @param string $targetEnvironment
     * @param ApplicationDeploymentHistory $deployment
     * @return void
     */
    protected function switchTraffic(
        Application $application,
        string $targetEnvironment,
        ApplicationDeploymentHistory $deployment
    ): void {
        $this->trafficSwitchAction->execute(
            $application,
            $targetEnvironment,
            $deployment
        );
    }

    /**
     * Create deployment history record
     *
     * @param Application $application
     * @param string $strategy
     * @param array $options
     * @return ApplicationDeploymentHistory
     */
    protected function createDeploymentHistory(
        Application $application,
        string $strategy,
        array $options
    ): ApplicationDeploymentHistory {
        return ApplicationDeploymentHistory::create([
            'application_id' => $application->id,
            'initiated_by_user_id' => auth()->id(),
            'deployment_strategy' => $strategy,
            'status' => 'pending',
            'git_branch' => $options['git_branch'] ?? $application->git_branch,
            'git_commit_hash' => $options['git_commit_hash'] ?? null,
            'docker_image_tag' => $options['docker_image_tag'] ?? null,
        ]);
    }

    /**
     * Schedule cleanup of old environment after successful deployment
     *
     * @param Application $application
     * @param ApplicationDeploymentHistory $deployment
     * @return void
     */
    protected function scheduleEnvironmentCleanup(
        Application $application,
        ApplicationDeploymentHistory $deployment
    ): void {
        // Keep old environment running for 24 hours for easy rollback
        // Then optionally clean it up to free resources

        // This could be implemented as a scheduled job
        Log::info("Old environment will be retained for rollback capability", [
            'application_id' => $application->id,
            'old_environment' => $deployment->active_environment_before,
        ]);
    }
}
```

### RunHealthChecksAction Implementation

**File:** `app/Actions/Deployment/RunHealthChecksAction.php`

```php
<?php

namespace App\Actions\Deployment;

use App\Models\Application;
use App\Models\ApplicationDeploymentHistory;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class RunHealthChecksAction
{
    /**
     * Execute health checks against deployed environment
     *
     * @param Application $application
     * @param string $environment
     * @param ApplicationDeploymentHistory $deployment
     * @return array
     */
    public function execute(
        Application $application,
        string $environment,
        ApplicationDeploymentHistory $deployment
    ): array {
        $maxRetries = $application->health_check_retries ?? 5;
        $timeout = $application->health_check_timeout ?? 60;
        $endpoint = $application->health_check_endpoint ?? '/health';

        $results = [
            'healthy' => false,
            'attempts' => 0,
            'checks' => [],
            'error' => null,
        ];

        Log::info("Starting health checks", [
            'application_id' => $application->id,
            'environment' => $environment,
            'endpoint' => $endpoint,
            'max_retries' => $maxRetries,
        ]);

        // Get container URL for the environment
        $containerUrl = $this->getContainerUrl($application, $environment);

        if (!$containerUrl) {
            $results['error'] = "Could not determine container URL for {$environment} environment";
            return $results;
        }

        // Attempt health checks with retries
        for ($attempt = 1; $attempt <= $maxRetries; $attempt++) {
            $results['attempts'] = $attempt;

            try {
                // HTTP health check
                $checkResult = $this->performHttpHealthCheck(
                    $containerUrl,
                    $endpoint,
                    $timeout
                );

                $results['checks'][] = $checkResult;

                if ($checkResult['success']) {
                    // Custom health check script (if configured)
                    if ($application->health_check_script) {
                        $customCheckResult = $this->performCustomHealthCheck(
                            $application,
                            $environment
                        );

                        $results['checks'][] = $customCheckResult;

                        if (!$customCheckResult['success']) {
                            $results['error'] = $customCheckResult['error'];
                            continue; // Retry
                        }
                    }

                    // All checks passed
                    $results['healthy'] = true;

                    Log::info("Health checks passed", [
                        'application_id' => $application->id,
                        'environment' => $environment,
                        'attempts' => $attempt,
                    ]);

                    return $results;
                }

                $results['error'] = $checkResult['error'];

            } catch (\Exception $e) {
                $results['error'] = $e->getMessage();
                $results['checks'][] = [
                    'type' => 'http',
                    'success' => false,
                    'error' => $e->getMessage(),
                    'timestamp' => now()->toIso8601String(),
                ];
            }

            // Wait before retry (exponential backoff)
            if ($attempt < $maxRetries) {
                $waitSeconds = min(30, pow(2, $attempt - 1)); // 1, 2, 4, 8, 16, 30 seconds
                Log::debug("Health check failed, retrying in {$waitSeconds} seconds", [
                    'attempt' => $attempt,
                    'max_retries' => $maxRetries,
                ]);
                sleep($waitSeconds);
            }
        }

        Log::warning("Health checks failed after {$maxRetries} attempts", [
            'application_id' => $application->id,
            'environment' => $environment,
            'final_error' => $results['error'],
        ]);

        return $results;
    }

    /**
     * Perform HTTP health check
     *
     * @param string $baseUrl
     * @param string $endpoint
     * @param int $timeout
     * @return array
     */
    protected function performHttpHealthCheck(
        string $baseUrl,
        string $endpoint,
        int $timeout
    ): array {
        $url = rtrim($baseUrl, '/') . '/' . ltrim($endpoint, '/');

        try {
            $response = Http::timeout($timeout)
                ->withHeaders([
                    'User-Agent' => 'Coolify-HealthCheck/1.0',
                    'X-Health-Check' => 'true',
                ])
                ->get($url);

            $success = $response->successful() && $response->status() === 200;

            return [
                'type' => 'http',
                'url' => $url,
                'success' => $success,
                'status_code' => $response->status(),
                'response_time_ms' => $response->transferStats?->getTransferTime() * 1000 ?? null,
                'body' => $response->body(),
                'error' => $success ? null : "HTTP {$response->status()}",
                'timestamp' => now()->toIso8601String(),
            ];

        } catch (\Exception $e) {
            return [
                'type' => 'http',
                'url' => $url,
                'success' => false,
                'error' => $e->getMessage(),
                'timestamp' => now()->toIso8601String(),
            ];
        }
    }

    /**
     * Perform custom health check script
     *
     * @param Application $application
     * @param string $environment
     * @return array
     */
    protected function performCustomHealthCheck(
        Application $application,
        string $environment
    ): array {
        $script = $application->health_check_script;
        $containerName = "{$application->uuid}-{$environment}";

        try {
            // Execute custom health check script inside container
            $command = "docker exec {$containerName} /bin/sh -c " . escapeshellarg($script);

            $result = $application->destination->server->executeRemoteCommand($command);

            $success = $result['exitCode'] === 0;

            return [
                'type' => 'custom_script',
                'script' => $script,
                'success' => $success,
                'exit_code' => $result['exitCode'],
                'stdout' => $result['stdout'] ?? '',
                'stderr' => $result['stderr'] ?? '',
                'error' => $success ? null : "Script exited with code {$result['exitCode']}",
                'timestamp' => now()->toIso8601String(),
            ];

        } catch (\Exception $e) {
            return [
                'type' => 'custom_script',
                'script' => $script,
                'success' => false,
                'error' => $e->getMessage(),
                'timestamp' => now()->toIso8601String(),
            ];
        }
    }

    /**
     * Get container URL for environment
     *
     * @param Application $application
     * @param string $environment
     * @return string|null
     */
    protected function getContainerUrl(Application $application, string $environment): ?string
    {
        // For blue-green, containers run on different ports
        // The inactive environment uses a temporary port, active uses the configured port

        $server = $application->destination->server;
        $containerName = "{$application->uuid}-{$environment}";

        // Get container's exposed port
        $command = "docker port {$containerName}";
        $result = $server->executeRemoteCommand($command);

        if ($result['exitCode'] !== 0) {
            return null;
        }

        // Parse port output (e.g., "80/tcp -> 0.0.0.0:8080")
        preg_match('/0\.0\.0\.0:(\d+)/', $result['stdout'], $matches);

        if (!isset($matches[1])) {
            return null;
        }

        $port = $matches[1];

        return "http://{$server->ip}:{$port}";
    }
}
```

### SwitchTrafficAction Implementation

**File:** `app/Actions/Deployment/SwitchTrafficAction.php`

```php
<?php

namespace App\Actions\Deployment;

use App\Models\Application;
use App\Models\ApplicationDeploymentHistory;
use App\Actions\Proxy\UpdateProxyConfigurationAction;
use Illuminate\Support\Facades\Log;

class SwitchTrafficAction
{
    public function __construct(
        private UpdateProxyConfigurationAction $proxyUpdateAction
    ) {
    }

    /**
     * Switch traffic to target environment
     *
     * @param Application $application
     * @param string $targetEnvironment
     * @param ApplicationDeploymentHistory $deployment
     * @return void
     */
    public function execute(
        Application $application,
        string $targetEnvironment,
        ApplicationDeploymentHistory $deployment
    ): void {
        Log::info("Switching traffic to {$targetEnvironment} environment", [
            'application_id' => $application->id,
            'target_environment' => $targetEnvironment,
            'deployment_id' => $deployment->id,
        ]);

        // Update proxy configuration (Nginx or Traefik)
        $this->proxyUpdateAction->execute($application, $targetEnvironment);

        // Reload proxy to apply configuration
        $this->reloadProxy($application);

        // Broadcast event for real-time UI updates
        event(new \App\Events\Deployment\TrafficSwitched(
            $application,
            $targetEnvironment,
            $deployment
        ));

        Log::info("Traffic switch completed", [
            'application_id' => $application->id,
            'now_serving_from' => $targetEnvironment,
        ]);
    }

    /**
     * Reload proxy server to apply new configuration
     *
     * @param Application $application
     * @return void
     */
    protected function reloadProxy(Application $application): void
    {
        $server = $application->destination->server;
        $proxyType = $server->proxy_type ?? 'nginx'; // or 'traefik'

        if ($proxyType === 'nginx') {
            $reloadCommand = 'nginx -s reload';
        } elseif ($proxyType === 'traefik') {
            // Traefik auto-reloads configuration
            return;
        } else {
            Log::warning("Unknown proxy type: {$proxyType}");
            return;
        }

        $result = $server->executeRemoteCommand($reloadCommand);

        if ($result['exitCode'] !== 0) {
            throw new \Exception(
                "Failed to reload {$proxyType}: " . ($result['stderr'] ?? 'Unknown error')
            );
        }

        Log::info("Proxy reloaded successfully", [
            'proxy_type' => $proxyType,
            'server_id' => $server->id,
        ]);
    }
}
```

### UpdateProxyConfigurationAction Implementation

**File:** `app/Actions/Proxy/UpdateProxyConfigurationAction.php`

```php
<?php

namespace App\Actions\Proxy;

use App\Models\Application;
use Illuminate\Support\Facades\Log;

class UpdateProxyConfigurationAction
{
    /**
     * Update proxy configuration to route traffic to specific environment
     *
     * @param Application $application
     * @param string $targetEnvironment
     * @return void
     */
    public function execute(Application $application, string $targetEnvironment): void
    {
        $server = $application->destination->server;
        $proxyType = $server->proxy_type ?? 'nginx';

        if ($proxyType === 'nginx') {
            $this->updateNginxConfig($application, $targetEnvironment);
        } elseif ($proxyType === 'traefik') {
            $this->updateTraefikConfig($application, $targetEnvironment);
        } else {
            throw new \Exception("Unsupported proxy type: {$proxyType}");
        }
    }

    /**
     * Update Nginx configuration
     *
     * @param Application $application
     * @param string $targetEnvironment
     * @return void
     */
    protected function updateNginxConfig(Application $application, string $targetEnvironment): void
    {
        $containerName = "{$application->uuid}-{$targetEnvironment}";
        $domain = $application->fqdn ?? $application->uuid;

        $nginxConfig = <<<NGINX
        # Coolify - Blue-Green Deployment for {$application->name}
        # Active Environment: {$targetEnvironment}
        # Updated: {{ now()->toIso8601String() }}

        upstream app_{$application->uuid} {
            server {$containerName}:80;
        }

        server {
            listen 80;
            server_name {$domain};

            location / {
                proxy_pass http://app_{$application->uuid};
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
            }
        }
        NGINX;

        $configPath = "/etc/nginx/sites-available/{$application->uuid}.conf";
        $server = $application->destination->server;

        // Write configuration file
        $writeCommand = "echo " . escapeshellarg($nginxConfig) . " | sudo tee {$configPath}";
        $result = $server->executeRemoteCommand($writeCommand);

        if ($result['exitCode'] !== 0) {
            throw new \Exception("Failed to write Nginx configuration");
        }

        // Enable site if not already enabled
        $enableCommand = "sudo ln -sf {$configPath} /etc/nginx/sites-enabled/{$application->uuid}.conf";
        $server->executeRemoteCommand($enableCommand);

        Log::info("Nginx configuration updated", [
            'application_id' => $application->id,
            'target_environment' => $targetEnvironment,
            'config_path' => $configPath,
        ]);
    }

    /**
     * Update Traefik configuration
     *
     * @param Application $application
     * @param string $targetEnvironment
     * @return void
     */
    protected function updateTraefikConfig(Application $application, string $targetEnvironment): void
    {
        // Traefik uses Docker labels for configuration
        // Update the container labels to route traffic

        $containerName = "{$application->uuid}-{$targetEnvironment}";
        $domain = $application->fqdn ?? $application->uuid;

        // Add/update Traefik labels
        $labels = [
            "traefik.enable=true",
            "traefik.http.routers.{$application->uuid}.rule=Host(`{$domain}`)",
            "traefik.http.routers.{$application->uuid}.entrypoints=web",
            "traefik.http.services.{$application->uuid}.loadbalancer.server.port=80",
        ];

        foreach ($labels as $label) {
            $command = "docker update --label-add '{$label}' {$containerName}";
            $application->destination->server->executeRemoteCommand($command);
        }

        Log::info("Traefik configuration updated", [
            'application_id' => $application->id,
            'target_environment' => $targetEnvironment,
        ]);
    }
}
```

## Implementation Approach

### Step 1: Database Migrations
1. Create migration for `applications` table blue-green fields
2. Create `application_deployment_history` table migration
3. Run migrations: `php artisan migrate`

### Step 2: Create ApplicationDeploymentHistory Model
1. Create model in `app/Models/`
2. Add relationships (belongsTo Application, User)
3. Add casts for JSON fields
4. Update Application model with hasMany relationship

### Step 3: Implement Health Check Action
1. Create `RunHealthChecksAction` in `app/Actions/Deployment/`
2. Implement HTTP health check with configurable endpoint
3. Implement custom script health check support
4. Add retry logic with exponential backoff
5. Return comprehensive health check results

### Step 4: Implement Traffic Switch Action
1. Create `SwitchTrafficAction` in `app/Actions/Deployment/`
2. Create `UpdateProxyConfigurationAction` in `app/Actions/Proxy/`
3. Implement Nginx configuration update
4. Implement Traefik configuration update
5. Add proxy reload logic

### Step 5: Extend EnhancedDeploymentService
1. Add `deployBlueGreen()` method
2. Add `rollbackBlueGreen()` method
3. Implement environment determination logic
4. Integrate with CapacityManager for validation
5. Implement deployment to environment logic
6. Integrate health check and traffic switch actions

### Step 6: Create Deployment Job
1. Create `BlueGreenDeploymentJob` for async execution
2. Implement queueable job with progress tracking
3. Add WebSocket broadcasting for status updates
4. Integrate with EnhancedDeploymentService

### Step 7: Create Events
1. Create `TrafficSwitched` event for broadcasting
2. Create `DeploymentFailed` event
3. Create `HealthChecksFailed` event
4. Register events in EventServiceProvider

### Step 8: Controller Integration
1. Add route for blue-green deployment trigger
2. Create controller method to dispatch job
3. Add rollback endpoint
4. Add deployment history endpoint

### Step 9: Testing
1. Unit test health check action
2. Unit test traffic switch action
3. Unit test proxy configuration updates
4. Integration test full blue-green deployment
5. Test rollback functionality
6. Test capacity validation
7. Test error handling and retry logic

### Step 10: Documentation and Deployment
1. Document blue-green deployment configuration
2. Create user guide for deployment strategies
3. Add runbook for troubleshooting failed deployments
4. Deploy to staging and verify
5. Monitor production deployments

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Actions/RunHealthChecksActionTest.php`

```php
<?php

use App\Actions\Deployment\RunHealthChecksAction;
use App\Models\Application;
use App\Models\ApplicationDeploymentHistory;
use App\Models\Server;
use Illuminate\Support\Facades\Http;

beforeEach(function () {
    $this->action = new RunHealthChecksAction();
});

it('performs HTTP health check successfully', function () {
    Http::fake([
        '*' => Http::response(['status' => 'healthy'], 200),
    ]);

    $application = Application::factory()->create([
        'health_check_endpoint' => '/health',
        'health_check_timeout' => 5,
        'health_check_retries' => 3,
    ]);

    $deployment = ApplicationDeploymentHistory::factory()->create([
        'application_id' => $application->id,
    ]);

    $result = $this->action->execute($application, 'green', $deployment);

    expect($result['healthy'])->toBeTrue();
    expect($result['attempts'])->toBe(1);
    expect($result['checks'])->toHaveCount(1);
    expect($result['checks'][0]['success'])->toBeTrue();
});

it('retries health checks with exponential backoff', function () {
    Http::fake([
        '*' => Http::sequence()
            ->push(['status' => 'unhealthy'], 500) // Attempt 1
            ->push(['status' => 'unhealthy'], 500) // Attempt 2
            ->push(['status' => 'healthy'], 200),  // Attempt 3 - success
    ]);

    $application = Application::factory()->create([
        'health_check_retries' => 5,
    ]);

    $deployment = ApplicationDeploymentHistory::factory()->create();

    $result = $this->action->execute($application, 'green', $deployment);

    expect($result['healthy'])->toBeTrue();
    expect($result['attempts'])->toBe(3); // Succeeded on third attempt
});

it('fails after max retries exceeded', function () {
    Http::fake([
        '*' => Http::response(['status' => 'unhealthy'], 500),
    ]);

    $application = Application::factory()->create([
        'health_check_retries' => 3,
    ]);

    $deployment = ApplicationDeploymentHistory::factory()->create();

    $result = $this->action->execute($application, 'green', $deployment);

    expect($result['healthy'])->toBeFalse();
    expect($result['attempts'])->toBe(3);
    expect($result['error'])->toContain('HTTP 500');
});
```

### Integration Tests

**File:** `tests/Feature/Deployment/BlueGreenDeploymentTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Server;
use App\Models\Organization;
use App\Models\User;
use App\Services\Enterprise\EnhancedDeploymentService;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\Http;

it('deploys application using blue-green strategy', function () {
    Http::fake(['*' => Http::response(['status' => 'healthy'], 200)]);
    Queue::fake();

    $organization = Organization::factory()->create();
    $server = Server::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $application = Application::factory()->create([
        'active_environment' => 'blue',
        'deployment_strategy' => 'blue_green',
    ]);

    $service = app(EnhancedDeploymentService::class);

    $deployment = $service->deployBlueGreen($application, [
        'git_branch' => 'main',
    ]);

    expect($deployment->status)->toBe('completed');
    expect($deployment->deployed_to_environment)->toBe('green');
    expect($deployment->active_environment_after)->toBe('green');
    expect($deployment->health_checks_passed)->toBeTrue();

    $application->refresh();
    expect($application->active_environment)->toBe('green');
    expect($application->last_environment_switch_at)->not->toBeNull();
});

it('rolls back to previous environment on health check failure', function () {
    Http::fake(['*' => Http::response(['status' => 'unhealthy'], 500)]);

    $application = Application::factory()->create([
        'active_environment' => 'blue',
        'health_check_retries' => 2,
    ]);

    $service = app(EnhancedDeploymentService::class);

    expect(fn() => $service->deployBlueGreen($application))
        ->toThrow(\Exception::class, 'Health checks failed');

    $application->refresh();
    expect($application->active_environment)->toBe('blue'); // Still on blue
});

it('performs instant rollback to previous environment', function () {
    $application = Application::factory()->create([
        'active_environment' => 'green',
    ]);

    $deployment = ApplicationDeploymentHistory::factory()->create([
        'application_id' => $application->id,
        'active_environment_before' => 'blue',
        'active_environment_after' => 'green',
    ]);

    $service = app(EnhancedDeploymentService::class);
    $service->rollbackBlueGreen($application, $deployment);

    $application->refresh();
    expect($application->active_environment)->toBe('blue');

    $deployment->refresh();
    expect($deployment->status)->toBe('rolled_back');
});

it('validates capacity before deployment', function () {
    $application = Application::factory()->create();

    // Mock capacity manager to return false
    $this->mock(CapacityManagerInterface::class, function ($mock) {
        $mock->shouldReceive('canServerHandleDeployment')
            ->andReturn(false);
    });

    $service = app(EnhancedDeploymentService::class);

    expect(fn() => $service->deployBlueGreen($application))
        ->toThrow(\Exception::class, 'does not have sufficient capacity');
});

it('records deployment history with all details', function () {
    Http::fake(['*' => Http::response(['status' => 'healthy'], 200)]);

    $user = User::factory()->create();
    $this->actingAs($user);

    $application = Application::factory()->create([
        'active_environment' => 'blue',
    ]);

    $service = app(EnhancedDeploymentService::class);

    $deployment = $service->deployBlueGreen($application, [
        'git_branch' => 'feature-branch',
        'git_commit_hash' => 'abc123def456',
    ]);

    expect($deployment)->toBeInstanceOf(ApplicationDeploymentHistory::class);
    expect($deployment->initiated_by_user_id)->toBe($user->id);
    expect($deployment->deployment_strategy)->toBe('blue_green');
    expect($deployment->git_branch)->toBe('feature-branch');
    expect($deployment->git_commit_hash)->toBe('abc123def456');
    expect($deployment->duration_seconds)->toBeGreaterThan(0);
});
```

### Browser Tests

**File:** `tests/Browser/Deployment/BlueGreenDeploymentTest.php`

```php
<?php

use Laravel\Dusk\Browser;
use App\Models\Application;
use App\Models\User;

it('triggers blue-green deployment from UI', function () {
    $user = User::factory()->create();
    $application = Application::factory()->create([
        'deployment_strategy' => 'blue_green',
    ]);

    $this->browse(function (Browser $browser) use ($user, $application) {
        $browser->loginAs($user)
            ->visit("/applications/{$application->uuid}/deploy")
            ->select('deployment_strategy', 'blue_green')
            ->press('Deploy')
            ->waitForText('Deployment started')
            ->assertSee('Deploying to green environment')
            ->waitForText('Health checks in progress', 60)
            ->waitForText('Deployment completed successfully', 120)
            ->assertSee('Active environment: green');
    });
});

it('displays rollback button after deployment', function () {
    $user = User::factory()->create();
    $application = Application::factory()->create([
        'active_environment' => 'green',
    ]);

    $this->browse(function (Browser $browser) use ($user, $application) {
        $browser->loginAs($user)
            ->visit("/applications/{$application->uuid}")
            ->assertSee('Rollback to Blue')
            ->press('Rollback to Blue')
            ->waitForText('Rolling back...')
            ->waitForText('Rollback completed', 30)
            ->assertSee('Active environment: blue');
    });
});
```

## Definition of Done

- [ ] Database migration created for blue-green fields in applications table
- [ ] Database migration created for application_deployment_history table
- [ ] ApplicationDeploymentHistory model created with relationships
- [ ] Application model updated with blue-green fields and relationships
- [ ] RunHealthChecksAction implemented with HTTP and custom script support
- [ ] SwitchTrafficAction implemented with proxy configuration update
- [ ] UpdateProxyConfigurationAction supports both Nginx and Traefik
- [ ] EnhancedDeploymentService::deployBlueGreen() method implemented
- [ ] EnhancedDeploymentService::rollbackBlueGreen() method implemented
- [ ] Environment determination logic implemented (opposite of current)
- [ ] Capacity validation integrated with CapacityManager
- [ ] Deployment to environment logic implemented
- [ ] Container naming includes environment suffix (app-blue, app-green)
- [ ] Health check retry logic with exponential backoff
- [ ] Traffic switch updates proxy configuration atomically
- [ ] Comprehensive error handling and logging
- [ ] Deployment history records all deployment details
- [ ] TrafficSwitched event created and broadcasted
- [ ] Unit tests written for health check action (5+ tests)
- [ ] Unit tests written for traffic switch action (3+ tests)
- [ ] Integration tests written for full deployment flow (8+ tests)
- [ ] Browser tests written for UI deployment trigger (2+ tests)
- [ ] Test coverage > 90% for new code
- [ ] Code follows Laravel and Coolify coding standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing with zero errors
- [ ] Documentation updated with blue-green deployment guide
- [ ] User guide created for deployment strategies
- [ ] Troubleshooting runbook created for failed deployments
- [ ] Code reviewed and approved
- [ ] Deployed to staging and verified
- [ ] Performance benchmarks met (traffic switch < 1 second)
- [ ] Manual testing completed with real applications

## Related Tasks

- **Depends on:** Task 32 (EnhancedDeploymentService base implementation)
- **Integrates with:** Task 26 (CapacityManager for capacity validation)
- **Integrates with:** Task 14 (TerraformService for infrastructure provisioning)
- **Parallel with:** Task 33 (Rolling update strategy)
- **Parallel with:** Task 35 (Canary deployment strategy)
- **Uses:** Existing Coolify ApplicationDeploymentJob, Server model, Application model
