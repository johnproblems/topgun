---
name: Add comprehensive deployment tests for all strategies
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:57Z
github: https://github.com/johnproblems/topgun/issues/150
depends_on: [33, 34, 35, 38]
parallel: false
conflicts_with: []
---

# Task: Add comprehensive deployment tests for all strategies

## Description

Create a comprehensive test suite for the EnhancedDeploymentService that validates all deployment strategies (rolling, blue-green, canary) under various conditions including success scenarios, failure scenarios, rollback behavior, capacity constraints, and edge cases. This testing infrastructure ensures deployment reliability, prevents regressions, and validates that the automatic rollback mechanism works correctly across all failure modes.

**Testing Philosophy:**

The deployment system is mission-criticalâ€”failed deployments can cause downtime, data loss, or security vulnerabilities. Comprehensive testing is not optional; it's the foundation that allows us to deploy confidently. These tests serve multiple purposes:

1. **Regression Prevention**: Ensure changes to deployment logic don't break existing strategies
2. **Behavior Documentation**: Tests serve as executable specifications showing how each strategy should work
3. **Rollback Validation**: Prove that automatic rollback works correctly when deployments fail
4. **Capacity Integration**: Verify integration with CapacityManager for resource-aware deployments
5. **Edge Case Coverage**: Handle scenarios like partial failures, network errors, timeout conditions

**What Makes This Task Critical:**

Without comprehensive testing, deployment strategies become fragile and unpredictable. A single regression could cause production outages for hundreds of organizations. By testing all code paths, failure scenarios, and rollback mechanisms, we create a safety net that allows rapid iteration on deployment features while maintaining reliability.

This task creates the testing foundation that will:
- Enable confident refactoring of deployment logic
- Catch bugs before they reach production
- Document expected behavior for future developers
- Validate complex multi-step operations like blue-green cutover and canary promotion
- Ensure rollback mechanisms work under all failure conditions

**Integration Architecture:**

The test suite integrates with multiple components:

**Services Under Test:**
- **EnhancedDeploymentService** (Task 32): Core deployment orchestration
- **RollingUpdateStrategy** (Task 33): Rolling deployment implementation
- **BlueGreenStrategy** (Task 34): Blue-green deployment implementation
- **CanaryStrategy** (Task 35): Canary deployment implementation
- **RollbackMechanism** (Task 38): Automatic rollback on failures

**Mocked Dependencies:**
- **CapacityManager** (Task 26): Server selection and capacity validation
- **SystemResourceMonitor** (Task 25): Resource metric collection
- **Docker API**: Container lifecycle operations
- **Health Check Endpoints**: Application health validation
- **Load Balancer API**: Traffic routing for blue-green and canary

**Test Categories:**

1. **Unit Tests** - Isolated service logic without external dependencies
2. **Integration Tests** - Full deployment workflows with mocked infrastructure
3. **Rollback Tests** - Failure injection and rollback validation
4. **Capacity Tests** - Resource constraint handling and server selection
5. **Browser Tests** - End-to-end UI testing with Dusk (optional)

## Acceptance Criteria

- [ ] Unit tests written for EnhancedDeploymentService core methods (10+ tests)
- [ ] Integration tests for rolling update strategy (8+ scenarios)
- [ ] Integration tests for blue-green strategy (8+ scenarios)
- [ ] Integration tests for canary strategy (8+ scenarios)
- [ ] Rollback tests for all strategies with various failure triggers (12+ tests)
- [ ] Capacity integration tests with CapacityManager (6+ tests)
- [ ] Health check failure simulation tests (5+ tests)
- [ ] Timeout and resource exhaustion tests (4+ tests)
- [ ] Concurrent deployment conflict tests (3+ tests)
- [ ] Test coverage > 95% for EnhancedDeploymentService and strategy classes
- [ ] All tests use Laravel Pest syntax (not PHPUnit)
- [ ] Factories created for Deployment, Application, Server, Container models
- [ ] Test traits created for deployment testing utilities
- [ ] Mocking helpers for Docker API, health checks, load balancers
- [ ] Tests run in < 60 seconds total (fast feedback loop)
- [ ] All tests passing with zero warnings or deprecations
- [ ] Tests added to CI/CD pipeline with quality gate enforcement

## Technical Details

### File Paths

**Test Files:**
- `/home/topgun/topgun/tests/Unit/Services/EnhancedDeploymentServiceTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Deployment/RollingUpdateTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Deployment/BlueGreenDeploymentTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Deployment/CanaryDeploymentTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Deployment/DeploymentRollbackTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Deployment/CapacityAwareDeploymentTest.php` (new)

**Test Utilities:**
- `/home/topgun/topgun/tests/Helpers/DeploymentTestTrait.php` (new)
- `/home/topgun/topgun/tests/Helpers/DockerApiMockTrait.php` (new)
- `/home/topgun/topgun/tests/Helpers/HealthCheckMockTrait.php` (new)

**Factories:**
- `/home/topgun/topgun/database/factories/DeploymentFactory.php` (enhance existing)
- `/home/topgun/topgun/database/factories/ContainerFactory.php` (new)
- `/home/topgun/topgun/database/factories/ServerFactory.php` (enhance existing)

**Services Being Tested:**
- `/home/topgun/topgun/app/Services/Enterprise/EnhancedDeploymentService.php` (exists from Task 32)
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/RollingUpdateStrategy.php` (exists from Task 33)
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/BlueGreenStrategy.php` (exists from Task 34)
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/CanaryStrategy.php` (exists from Task 35)
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/RollbackMechanism.php` (exists from Task 38)

### Test Strategy Overview

**1. Unit Tests - EnhancedDeploymentService**

Test core service methods in isolation with all dependencies mocked:

```php
it('selects correct deployment strategy based on configuration')
it('validates application configuration before deployment')
it('reserves server resources during deployment')
it('releases server resources after deployment completion')
it('throws exception when invalid strategy specified')
it('logs deployment lifecycle events correctly')
it('calculates deployment progress percentage')
it('handles concurrent deployment attempts')
it('updates deployment status at each lifecycle stage')
it('dispatches deployment events correctly')
```

**2. Integration Tests - Rolling Update Strategy**

Test complete rolling update workflows with mocked infrastructure:

```php
it('deploys application in batches with configurable batch size')
it('waits for health checks between batches')
it('continues deployment when batch succeeds')
it('rolls back entire deployment when batch fails')
it('respects max concurrent deployments limit')
it('handles server unavailability mid-deployment')
it('completes deployment with all containers running')
it('updates load balancer configuration during rollout')
```

**3. Integration Tests - Blue-Green Strategy**

Test blue-green deployment with traffic cutover:

```php
it('deploys green environment while blue remains active')
it('validates green environment health before cutover')
it('switches traffic from blue to green atomically')
it('maintains blue environment for rollback capability')
it('rolls back to blue on green health check failure')
it('cleans up blue environment after successful deployment')
it('handles insufficient capacity for green environment')
it('preserves database connections during cutover')
```

**4. Integration Tests - Canary Strategy**

Test canary deployment with gradual traffic shifting:

```php
it('deploys canary with initial 10% traffic split')
it('increases traffic gradually based on success metrics')
it('promotes canary to full deployment after validation')
it('aborts canary and rolls back on error rate spike')
it('monitors canary metrics during deployment')
it('handles canary health check failures')
it('respects traffic shift percentage configuration')
it('maintains stable deployment during canary testing')
```

**5. Rollback Tests**

Test automatic rollback under various failure conditions:

```php
it('rolls back on health check failures')
it('rolls back on deployment timeout')
it('rolls back on container startup failures')
it('rolls back on resource exhaustion')
it('rolls back on database migration failures')
it('restores previous container versions correctly')
it('restores load balancer configuration on rollback')
it('cleans up failed deployment artifacts')
it('notifies administrators of rollback events')
it('logs rollback reason and failure details')
it('handles cascading failures during rollback')
it('completes rollback within timeout period')
```

**6. Capacity Integration Tests**

Test integration with CapacityManager:

```php
it('selects optimal server using CapacityManager')
it('respects organization resource quotas')
it('provisions additional capacity if needed')
it('queues deployment when capacity unavailable')
it('distributes containers across multiple servers')
it('handles server removal during deployment')
```

### Core Test Implementation

**File:** `tests/Unit/Services/EnhancedDeploymentServiceTest.php`

```php
<?php

use App\Services\Enterprise\EnhancedDeploymentService;
use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\Deployment\RollingUpdateStrategy;
use App\Services\Enterprise\Deployment\BlueGreenStrategy;
use App\Services\Enterprise\Deployment\CanaryStrategy;
use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Log;

beforeEach(function () {
    $this->capacityManager = Mockery::mock(CapacityManager::class);
    $this->rollingStrategy = Mockery::mock(RollingUpdateStrategy::class);
    $this->blueGreenStrategy = Mockery::mock(BlueGreenStrategy::class);
    $this->canaryStrategy = Mockery::mock(CanaryStrategy::class);

    $this->service = new EnhancedDeploymentService(
        $this->capacityManager,
        $this->rollingStrategy,
        $this->blueGreenStrategy,
        $this->canaryStrategy
    );
});

it('selects rolling update strategy when configured', function () {
    $application = Application::factory()->create([
        'deployment_strategy' => 'rolling',
    ]);

    $strategy = $this->service->getStrategyForApplication($application);

    expect($strategy)->toBeInstanceOf(RollingUpdateStrategy::class);
});

it('selects blue-green strategy when configured', function () {
    $application = Application::factory()->create([
        'deployment_strategy' => 'blue-green',
    ]);

    $strategy = $this->service->getStrategyForApplication($application);

    expect($strategy)->toBeInstanceOf(BlueGreenStrategy::class);
});

it('selects canary strategy when configured', function () {
    $application = Application::factory()->create([
        'deployment_strategy' => 'canary',
    ]);

    $strategy = $this->service->getStrategyForApplication($application);

    expect($strategy)->toBeInstanceOf(CanaryStrategy::class);
});

it('throws exception for invalid strategy', function () {
    $application = Application::factory()->create([
        'deployment_strategy' => 'invalid-strategy',
    ]);

    expect(fn() => $this->service->getStrategyForApplication($application))
        ->toThrow(\InvalidArgumentException::class, 'Invalid deployment strategy');
});

it('validates application configuration before deployment', function () {
    $application = Application::factory()->create([
        'git_repository' => null, // Invalid: missing repository
    ]);

    expect(fn() => $this->service->deployWithStrategy($application, 'rolling'))
        ->toThrow(\InvalidArgumentException::class);
});

it('reserves server resources during deployment', function () {
    $application = Application::factory()->create();
    $server = Server::factory()->create();

    $this->capacityManager
        ->shouldReceive('selectOptimalServer')
        ->once()
        ->andReturn($server);

    $this->capacityManager
        ->shouldReceive('reserveResources')
        ->once()
        ->with($server, Mockery::type('array'))
        ->andReturn(true);

    $this->rollingStrategy
        ->shouldReceive('deploy')
        ->once()
        ->andReturn(['status' => 'success']);

    $this->service->deployWithStrategy($application, 'rolling');

    // Verify resource reservation was called
    $this->capacityManager->shouldHaveReceived('reserveResources');
});

it('releases server resources after deployment completion', function () {
    $application = Application::factory()->create();
    $server = Server::factory()->create();

    $this->capacityManager
        ->shouldReceive('selectOptimalServer')
        ->andReturn($server);

    $this->capacityManager
        ->shouldReceive('reserveResources')
        ->andReturn(true);

    $this->capacityManager
        ->shouldReceive('releaseResources')
        ->once()
        ->with($server, Mockery::type('array'));

    $this->rollingStrategy
        ->shouldReceive('deploy')
        ->andReturn(['status' => 'success']);

    $this->service->deployWithStrategy($application, 'rolling');

    // Verify resources were released
    $this->capacityManager->shouldHaveReceived('releaseResources');
});

it('logs deployment lifecycle events', function () {
    Log::spy();

    $application = Application::factory()->create();
    $server = Server::factory()->create();

    $this->capacityManager
        ->shouldReceive('selectOptimalServer')
        ->andReturn($server);

    $this->capacityManager
        ->shouldReceive('reserveResources')
        ->andReturn(true);

    $this->capacityManager
        ->shouldReceive('releaseResources');

    $this->rollingStrategy
        ->shouldReceive('deploy')
        ->andReturn(['status' => 'success']);

    $this->service->deployWithStrategy($application, 'rolling');

    Log::shouldHaveReceived('info')
        ->withArgs(fn($message) => str_contains($message, 'Deployment started'));

    Log::shouldHaveReceived('info')
        ->withArgs(fn($message) => str_contains($message, 'Deployment completed'));
});

it('handles concurrent deployment attempts correctly', function () {
    $application = Application::factory()->create();

    // Simulate ongoing deployment
    $application->update(['deployment_status' => 'in_progress']);

    expect(fn() => $this->service->deployWithStrategy($application, 'rolling'))
        ->toThrow(\Exception::class, 'Deployment already in progress');
});

it('calculates deployment progress percentage', function () {
    $deployment = [
        'total_steps' => 10,
        'completed_steps' => 7,
    ];

    $progress = $this->service->calculateProgress($deployment);

    expect($progress)->toBe(70);
});

it('dispatches deployment events correctly', function () {
    Event::fake();

    $application = Application::factory()->create();
    $server = Server::factory()->create();

    $this->capacityManager
        ->shouldReceive('selectOptimalServer')
        ->andReturn($server);

    $this->capacityManager
        ->shouldReceive('reserveResources')
        ->andReturn(true);

    $this->capacityManager
        ->shouldReceive('releaseResources');

    $this->rollingStrategy
        ->shouldReceive('deploy')
        ->andReturn(['status' => 'success']);

    $this->service->deployWithStrategy($application, 'rolling');

    Event::assertDispatched(\App\Events\DeploymentStarted::class);
    Event::assertDispatched(\App\Events\DeploymentCompleted::class);
});
```

### Rolling Update Integration Tests

**File:** `tests/Feature/Deployment/RollingUpdateTest.php`

```php
<?php

use App\Services\Enterprise\EnhancedDeploymentService;
use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use Tests\Helpers\DeploymentTestTrait;
use Tests\Helpers\DockerApiMockTrait;
use Tests\Helpers\HealthCheckMockTrait;

uses(DeploymentTestTrait::class);
uses(DockerApiMockTrait::class);
uses(HealthCheckMockTrait::class);

beforeEach(function () {
    $this->organization = Organization::factory()->create();
    $this->servers = Server::factory(3)->create([
        'organization_id' => $this->organization->id,
    ]);

    $this->application = Application::factory()->create([
        'organization_id' => $this->organization->id,
        'deployment_strategy' => 'rolling',
        'rolling_batch_size' => 1,
    ]);

    $this->deploymentService = app(EnhancedDeploymentService::class);
});

it('deploys application in batches with configurable batch size', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('success');
    expect($result['batches_completed'])->toBe(3); // 3 servers, batch size 1
});

it('waits for health checks between batches', function () {
    $this->mockDockerApiSuccess();

    $healthCheckCalls = 0;
    $this->mockHealthCheck(function() use (&$healthCheckCalls) {
        $healthCheckCalls++;
        return $healthCheckCalls <= 3; // Succeed after 3 attempts per batch
    });

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($healthCheckCalls)->toBeGreaterThanOrEqual(9); // 3 batches Ã— 3 checks each
    expect($result['status'])->toBe('success');
});

it('continues deployment when batch succeeds', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $deployedServers = [];
    $this->captureDeployedServers($deployedServers);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($deployedServers)->toHaveCount(3);
    expect($result['status'])->toBe('success');
});

it('rolls back entire deployment when batch fails', function () {
    $this->mockDockerApiFailOnThirdCall();
    $this->mockHealthCheckSuccess();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['failure_reason'])->toContain('Docker API error');

    // Verify all servers rolled back to previous version
    foreach ($this->servers as $server) {
        $this->assertServerRolledBack($server);
    }
});

it('respects max concurrent deployments limit', function () {
    $this->application->update(['rolling_batch_size' => 2]);

    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $concurrentDeployments = [];
    $this->trackConcurrentDeployments($concurrentDeployments);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    // At most 2 servers deploying concurrently
    expect(max($concurrentDeployments))->toBeLessThanOrEqual(2);
    expect($result['status'])->toBe('success');
});

it('handles server unavailability mid-deployment', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Make second server unavailable
    $this->servers[1]->update(['status' => 'offline']);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    // Should skip offline server and complete on remaining servers
    expect($result['status'])->toBe('partial_success');
    expect($result['servers_deployed'])->toBe(2);
    expect($result['servers_skipped'])->toBe(1);
});

it('completes deployment with all containers running', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('success');

    // Verify containers are running on all servers
    foreach ($this->servers as $server) {
        $containers = $this->getRunningContainers($server, $this->application);
        expect($containers)->toHaveCount(1);
        expect($containers[0]['status'])->toBe('running');
    }
});

it('updates load balancer configuration during rollout', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $loadBalancerUpdates = [];
    $this->trackLoadBalancerUpdates($loadBalancerUpdates);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    // Load balancer should be updated after each batch
    expect($loadBalancerUpdates)->toHaveCount(3);
    expect($result['status'])->toBe('success');
});
```

### Blue-Green Deployment Tests

**File:** `tests/Feature/Deployment/BlueGreenDeploymentTest.php`

```php
<?php

use App\Services\Enterprise\EnhancedDeploymentService;
use App\Models\Application;
use App\Models\Server;
use Tests\Helpers\DeploymentTestTrait;

uses(DeploymentTestTrait::class);

beforeEach(function () {
    $this->application = Application::factory()->create([
        'deployment_strategy' => 'blue-green',
    ]);

    $this->blueServer = Server::factory()->create(['environment_label' => 'blue']);
    $this->greenServer = Server::factory()->create(['environment_label' => 'green']);

    $this->deploymentService = app(EnhancedDeploymentService::class);
});

it('deploys green environment while blue remains active', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Blue environment is currently active
    $this->setActiveEnvironment($this->application, 'blue');

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    // Blue should still be active during green deployment
    expect($this->getActiveEnvironment($this->application))->toBe('blue');
    expect($result['green_deployment_status'])->toBe('success');
});

it('validates green environment health before cutover', function () {
    $this->mockDockerApiSuccess();

    $healthCheckAttempts = 0;
    $this->mockHealthCheck(function() use (&$healthCheckAttempts) {
        $healthCheckAttempts++;
        return $healthCheckAttempts > 5; // Fail first 5, then succeed
    });

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($healthCheckAttempts)->toBeGreaterThan(5);
    expect($result['status'])->toBe('success');
    expect($result['health_check_attempts'])->toBe($healthCheckAttempts);
});

it('switches traffic from blue to green atomically', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $this->setActiveEnvironment($this->application, 'blue');

    $trafficDuringCutover = [];
    $this->monitorTrafficDistribution($trafficDuringCutover);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBe('success');
    expect($this->getActiveEnvironment($this->application))->toBe('green');

    // Verify traffic switched atomically (no split traffic)
    foreach ($trafficDuringCutover as $snapshot) {
        expect($snapshot['blue'] + $snapshot['green'])->toBe(100);
        expect($snapshot['blue'])->toBeIn([0, 100]);
        expect($snapshot['green'])->toBeIn([0, 100]);
    }
});

it('maintains blue environment for rollback capability', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBe('success');

    // Blue containers should still exist for quick rollback
    $blueContainers = $this->getRunningContainers($this->blueServer, $this->application);
    expect($blueContainers)->toHaveCount(1);
    expect($blueContainers[0]['status'])->toBe('running');
});

it('rolls back to blue on green health check failure', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure(); // Green health checks fail

    $this->setActiveEnvironment($this->application, 'blue');

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($this->getActiveEnvironment($this->application))->toBe('blue');
    expect($result['rollback_reason'])->toContain('health check');
});

it('cleans up blue environment after successful deployment', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $this->application->update(['blue_green_cleanup_delay' => 0]); // Immediate cleanup

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBe('success');

    // Wait for cleanup
    sleep(1);

    // Blue containers should be removed
    $blueContainers = $this->getRunningContainers($this->blueServer, $this->application);
    expect($blueContainers)->toHaveCount(0);
});

it('handles insufficient capacity for green environment', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Simulate green server at capacity
    $this->greenServer->update([
        'memory_used_percentage' => 95,
        'cpu_used_percentage' => 90,
    ]);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBeIn(['queued', 'failed']);
    expect($result['failure_reason'])->toContain('capacity');
});

it('preserves database connections during cutover', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Simulate active database connections
    $activeConnections = $this->createDatabaseConnections($this->application, 10);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'blue-green'
    );

    expect($result['status'])->toBe('success');

    // Verify connections were gracefully transferred
    $droppedConnections = $this->getDroppedConnections($activeConnections);
    expect($droppedConnections)->toBe(0);
});
```

### Canary Deployment Tests

**File:** `tests/Feature/Deployment/CanaryDeploymentTest.php`

```php
<?php

use App\Services\Enterprise\EnhancedDeploymentService;
use App\Models\Application;
use App\Models\Server;
use Tests\Helpers\DeploymentTestTrait;

uses(DeploymentTestTrait::class);

beforeEach(function () {
    $this->application = Application::factory()->create([
        'deployment_strategy' => 'canary',
        'canary_traffic_percentage' => 10,
        'canary_error_threshold' => 5.0, // 5% error rate
    ]);

    $this->stableServers = Server::factory(3)->create();
    $this->canaryServer = Server::factory()->create();

    $this->deploymentService = app(EnhancedDeploymentService::class);
});

it('deploys canary with initial 10% traffic split', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $trafficDistribution = [];
    $this->monitorTrafficDistribution($trafficDistribution);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    $initialDistribution = $trafficDistribution[0];
    expect($initialDistribution['canary'])->toBe(10);
    expect($initialDistribution['stable'])->toBe(90);
});

it('increases traffic gradually based on success metrics', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();
    $this->mockCanaryMetrics(['error_rate' => 0.5, 'latency_p95' => 150]);

    $trafficDistribution = [];
    $this->monitorTrafficDistribution($trafficDistribution);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    expect($result['status'])->toBe('success');

    // Traffic should increase: 10% â†’ 25% â†’ 50% â†’ 100%
    $finalDistribution = end($trafficDistribution);
    expect($finalDistribution['canary'])->toBe(100);
});

it('promotes canary to full deployment after validation', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();
    $this->mockCanaryMetrics(['error_rate' => 0.2, 'latency_p95' => 100]);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    expect($result['status'])->toBe('promoted');
    expect($result['canary_promoted'])->toBeTrue();

    // Canary should become the new stable deployment
    $activeContainers = $this->getActiveContainers($this->application);
    expect($activeContainers)->toHaveCount(1);
    expect($activeContainers[0]['version'])->toBe($result['canary_version']);
});

it('aborts canary and rolls back on error rate spike', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Simulate high error rate on canary
    $this->mockCanaryMetrics(['error_rate' => 8.5, 'latency_p95' => 200]);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    expect($result['status'])->toBe('aborted');
    expect($result['abort_reason'])->toContain('error rate');

    // Canary should be removed, stable remains
    $canaryContainers = $this->getRunningContainers($this->canaryServer, $this->application);
    expect($canaryContainers)->toHaveCount(0);

    $stableContainers = $this->getRunningContainers($this->stableServers[0], $this->application);
    expect($stableContainers)->toHaveCount(1);
});

it('monitors canary metrics during deployment', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    $metricsCollected = [];
    $this->captureCanaryMetrics($metricsCollected);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    expect($metricsCollected)->toHaveCount(greaterThan(5));
    expect($metricsCollected[0])->toHaveKeys(['error_rate', 'latency_p95', 'request_count']);
});

it('handles canary health check failures', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure(); // Canary health checks fail

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    expect($result['status'])->toBe('aborted');
    expect($result['abort_reason'])->toContain('health check');
});

it('respects traffic shift percentage configuration', function () {
    $this->application->update([
        'canary_traffic_steps' => [10, 30, 60, 100], // Custom steps
    ]);

    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();
    $this->mockCanaryMetrics(['error_rate' => 0.1, 'latency_p95' => 90]);

    $trafficDistribution = [];
    $this->monitorTrafficDistribution($trafficDistribution);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    // Verify custom traffic steps were followed
    $steps = array_column($trafficDistribution, 'canary');
    expect($steps)->toContain(10);
    expect($steps)->toContain(30);
    expect($steps)->toContain(60);
    expect($steps)->toContain(100);
});

it('maintains stable deployment during canary testing', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();
    $this->mockCanaryMetrics(['error_rate' => 0.5, 'latency_p95' => 120]);

    $stableServersBefore = $this->getRunningContainers($this->stableServers[0], $this->application);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'canary'
    );

    $stableServersAfter = $this->getRunningContainers($this->stableServers[0], $this->application);

    // Stable deployment should remain unchanged until canary promoted
    expect($stableServersAfter)->toEqual($stableServersBefore);
});
```

### Rollback Tests

**File:** `tests/Feature/Deployment/DeploymentRollbackTest.php`

```php
<?php

use App\Services\Enterprise\EnhancedDeploymentService;
use App\Models\Application;
use App\Models\Server;
use Tests\Helpers\DeploymentTestTrait;

uses(DeploymentTestTrait::class);

beforeEach(function () {
    $this->application = Application::factory()->create();
    $this->server = Server::factory()->create();
    $this->deploymentService = app(EnhancedDeploymentService::class);

    // Create initial successful deployment
    $this->previousDeployment = $this->createSuccessfulDeployment(
        $this->application,
        'v1.0.0'
    );
});

it('rolls back on health check failures', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['rollback_reason'])->toContain('health check');

    // Verify rolled back to previous version
    $currentVersion = $this->getCurrentDeploymentVersion($this->application);
    expect($currentVersion)->toBe('v1.0.0');
});

it('rolls back on deployment timeout', function () {
    $this->mockDockerApiTimeout();
    $this->mockHealthCheckSuccess();

    $this->application->update(['deployment_timeout' => 10]); // 10 seconds

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['rollback_reason'])->toContain('timeout');
});

it('rolls back on container startup failures', function () {
    $this->mockDockerApiContainerStartFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['rollback_reason'])->toContain('container startup');
});

it('rolls back on resource exhaustion', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();

    // Simulate resource exhaustion during deployment
    $this->server->update([
        'memory_available_mb' => 100, // Very low memory
    ]);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['rollback_reason'])->toContain('resource');
});

it('rolls back on database migration failures', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckSuccess();
    $this->mockDatabaseMigrationFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');
    expect($result['rollback_reason'])->toContain('migration');
});

it('restores previous container versions correctly', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $containersBefore = $this->getRunningContainers($this->server, $this->application);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    $containersAfter = $this->getRunningContainers($this->server, $this->application);

    // Containers should match pre-deployment state
    expect($containersAfter)->toHaveCount(count($containersBefore));
    expect($containersAfter[0]['image_tag'])->toBe($containersBefore[0]['image_tag']);
});

it('restores load balancer configuration on rollback', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $loadBalancerConfigBefore = $this->getLoadBalancerConfig($this->application);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    $loadBalancerConfigAfter = $this->getLoadBalancerConfig($this->application);

    expect($loadBalancerConfigAfter)->toEqual($loadBalancerConfigBefore);
});

it('cleans up failed deployment artifacts', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rolled_back');

    // Failed containers should be removed
    $failedContainers = $this->getStoppedContainers($this->server, $this->application);
    expect($failedContainers)->toHaveCount(0);
});

it('notifies administrators of rollback events', function () {
    Notification::fake();

    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    Notification::assertSentTo(
        $this->application->organization->admins(),
        \App\Notifications\DeploymentRolledBack::class
    );
});

it('logs rollback reason and failure details', function () {
    Log::spy();

    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    Log::shouldHaveReceived('error')
        ->withArgs(fn($message) => str_contains($message, 'Deployment rolled back'));

    Log::shouldHaveReceived('error')
        ->withArgs(fn($message, $context) =>
            isset($context['rollback_reason']) &&
            isset($context['failure_details'])
        );
});

it('handles cascading failures during rollback', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();
    $this->mockRollbackFailure(); // Simulate rollback also failing

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    expect($result['status'])->toBe('rollback_failed');
    expect($result['requires_manual_intervention'])->toBeTrue();
});

it('completes rollback within timeout period', function () {
    $this->mockDockerApiSuccess();
    $this->mockHealthCheckFailure();

    $startTime = microtime(true);

    $result = $this->deploymentService->deployWithStrategy(
        $this->application,
        'rolling'
    );

    $duration = microtime(true) - $startTime;

    expect($result['status'])->toBe('rolled_back');
    expect($duration)->toBeLessThan(30); // Rollback should complete in < 30 seconds
});
```

### Test Utilities and Helpers

**File:** `tests/Helpers/DeploymentTestTrait.php`

```php
<?php

namespace Tests\Helpers;

use App\Models\Application;
use App\Models\Server;
use App\Models\Deployment;

trait DeploymentTestTrait
{
    protected function createSuccessfulDeployment(Application $application, string $version): Deployment
    {
        return Deployment::factory()->create([
            'application_id' => $application->id,
            'version' => $version,
            'status' => 'success',
            'deployed_at' => now()->subHours(2),
        ]);
    }

    protected function getCurrentDeploymentVersion(Application $application): string
    {
        return $application->currentDeployment->version;
    }

    protected function getRunningContainers(Server $server, Application $application): array
    {
        // Mock implementation - returns array of container data
        return [
            [
                'id' => 'container_123',
                'status' => 'running',
                'image_tag' => $application->currentDeployment->version,
            ],
        ];
    }

    protected function assertServerRolledBack(Server $server): void
    {
        $containers = $this->getRunningContainers($server, $this->application);

        expect($containers)->toHaveCount(1);
        expect($containers[0]['image_tag'])->toBe($this->previousDeployment->version);
    }

    protected function setActiveEnvironment(Application $application, string $environment): void
    {
        $application->update(['active_environment' => $environment]);
    }

    protected function getActiveEnvironment(Application $application): string
    {
        return $application->fresh()->active_environment;
    }

    protected function monitorTrafficDistribution(array &$distribution): void
    {
        // Mock implementation - captures traffic distribution snapshots
    }

    protected function getLoadBalancerConfig(Application $application): array
    {
        return [
            'upstream_servers' => [],
            'health_check_path' => '/health',
        ];
    }
}
```

## Implementation Approach

### Step 1: Set Up Test Infrastructure
1. Create test directory structure in `tests/Unit/Services/` and `tests/Feature/Deployment/`
2. Create test helper traits in `tests/Helpers/`
3. Create or enhance factories for Deployment, Application, Server, Container models

### Step 2: Create Unit Tests
1. Write EnhancedDeploymentServiceTest with 10+ test cases
2. Test strategy selection, resource management, lifecycle events
3. Mock all dependencies (CapacityManager, strategies)

### Step 3: Create Rolling Update Tests
1. Write RollingUpdateTest with 8+ scenarios
2. Test batch deployment, health checks, rollback
3. Mock Docker API and health check endpoints

### Step 4: Create Blue-Green Tests
1. Write BlueGreenDeploymentTest with 8+ scenarios
2. Test environment switching, traffic cutover, rollback
3. Mock load balancer and environment management

### Step 5: Create Canary Tests
1. Write CanaryDeploymentTest with 8+ scenarios
2. Test traffic shifting, metric monitoring, promotion/abort
3. Mock metrics collection and analysis

### Step 6: Create Rollback Tests
1. Write DeploymentRollbackTest with 12+ scenarios
2. Test rollback triggers, artifact cleanup, notifications
3. Inject various failure conditions

### Step 7: Create Capacity Integration Tests
1. Write CapacityAwareDeploymentTest
2. Test server selection, quota enforcement, capacity provisioning
3. Mock CapacityManager and resource monitoring

### Step 8: Add Test Utilities
1. Create DeploymentTestTrait with common helpers
2. Create DockerApiMockTrait for Docker mocking
3. Create HealthCheckMockTrait for health check simulation

### Step 9: Run and Debug Tests
1. Run test suite: `php artisan test --filter=Deployment`
2. Debug failing tests
3. Achieve > 95% coverage for deployment services

### Step 10: CI/CD Integration
1. Add deployment tests to CI pipeline
2. Set quality gates (coverage, performance)
3. Configure test parallelization for speed

## Definition of Done

- [ ] Unit tests for EnhancedDeploymentService written (10+ tests)
- [ ] Rolling update integration tests written (8+ tests)
- [ ] Blue-green deployment tests written (8+ tests)
- [ ] Canary deployment tests written (8+ tests)
- [ ] Rollback tests written (12+ tests)
- [ ] Capacity integration tests written (6+ tests)
- [ ] Health check failure tests written (5+ tests)
- [ ] Timeout and resource tests written (4+ tests)
- [ ] Concurrent deployment tests written (3+ tests)
- [ ] Test coverage > 95% for all deployment services
- [ ] All tests use Pest syntax
- [ ] DeploymentTestTrait created with helpers
- [ ] DockerApiMockTrait created
- [ ] HealthCheckMockTrait created
- [ ] Factories created/enhanced for all models
- [ ] All tests passing with zero warnings
- [ ] Tests run in < 60 seconds total
- [ ] Tests added to CI/CD pipeline
- [ ] Quality gates configured (coverage, performance)
- [ ] Documentation updated with testing guide
- [ ] Code follows Laravel testing best practices
- [ ] PHPStan level 5 passing on tests
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 32 (EnhancedDeploymentService)
- **Depends on:** Task 33 (RollingUpdateStrategy)
- **Depends on:** Task 34 (BlueGreenStrategy)
- **Depends on:** Task 35 (CanaryStrategy)
- **Depends on:** Task 38 (RollbackMechanism)
- **Integrates with:** Task 26 (CapacityManager - mocked in tests)
- **Integrates with:** Task 25 (SystemResourceMonitor - mocked in tests)
- **Quality Gate for:** All deployment feature development
