---
name: Write API tests with organization scoping validation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:29Z
github: https://github.com/johnproblems/topgun/issues/185
depends_on: [61, 76]
parallel: false
conflicts_with: []
---

# Task: Write API tests with organization scoping validation

## Description

Develop comprehensive API integration tests that rigorously validate organization-scoped data access, multi-tenant security boundaries, rate limiting enforcement, and API authentication mechanisms. This testing suite ensures the Coolify Enterprise API maintains strict data isolation between organizations while providing enterprise-grade security and performance guarantees.

**The Multi-Tenant Security Challenge:**

In a multi-tenant enterprise platform, the API is the most critical attack surface. A single flaw in organization scoping could expose one organization's sensitive data (servers, applications, credentials) to another organization—a catastrophic security breach. Traditional API tests focus on happy paths and basic authentication, but multi-tenant systems require adversarial testing:

1. **Cross-Tenant Access Attempts**: Can Organization A access Organization B's resources by manipulating IDs?
2. **Token Scope Violations**: Can a token issued for Organization A be used to query Organization B's data?
3. **Privilege Escalation**: Can a sub-user token access resources restricted to organization admins?
4. **Rate Limit Bypass**: Can attackers exceed rate limits through token rotation or request patterns?
5. **Cache Poisoning**: Can cached organization data be accessed by unauthorized tenants?

**What This Task Delivers:**

This task creates a comprehensive test suite covering:

- **Organization Scoping Tests**: Verify API endpoints filter data by organization context automatically
- **Multi-Tenant Security Tests**: Attempt cross-tenant access and verify rejection (adversarial testing)
- **Rate Limiting Tests**: Validate tier-based rate limits with Redis tracking and header verification
- **Authentication Tests**: Sanctum token validation, organization context injection, ability scoping
- **API Endpoint Tests**: Full CRUD coverage for all enterprise endpoints (organizations, servers, applications, resources)
- **Error Handling Tests**: Validate proper HTTP status codes and error messages
- **Performance Tests**: Verify API response times under load, concurrent request handling
- **Webhook Tests**: Validate webhook authentication and payload integrity

**Integration Architecture:**

This test suite integrates with:

- **Task 52-61 (Enhanced API System)**: Tests all API endpoints, middleware, and rate limiting
- **Task 76 (Enterprise Service Unit Tests)**: Builds on unit tests with full API integration testing
- **Task 1-2 (Organization Hierarchy & Licensing)**: Validates organization context and license enforcement

**Testing Technology Stack:**

- **Pest PHP**: Laravel-optimized testing framework with expressive syntax
- **Laravel Sanctum**: API token generation and authentication simulation
- **RefreshDatabase**: Clean test database state per test
- **Factories & Seeders**: Realistic test data generation for organizations, users, resources
- **Redis Mocking**: Simulated cache and rate limiting for deterministic tests
- **HTTP Assertions**: Response status, headers, JSON structure validation

**Why This Task is Critical:**

Security vulnerabilities in multi-tenant APIs can destroy business value overnight. A single cross-tenant data leak:

- **Legal Liability**: GDPR violations ($20M+ fines), data breach notification requirements
- **Customer Trust**: Immediate customer exodus, permanent brand damage
- **Regulatory Compliance**: Loss of SOC2, ISO27001 certifications
- **Financial Impact**: Lawsuits, customer refunds, business closure

Comprehensive API testing is not optional—it's the foundation of multi-tenant security. These tests provide:

1. **Security Assurance**: Prove organization data is isolated correctly
2. **Regression Prevention**: Catch security regressions before production deployment
3. **Compliance Evidence**: Demonstrate security controls for audits and certifications
4. **Performance Validation**: Ensure rate limiting and caching work under load
5. **Developer Confidence**: Safe refactoring and feature development

The test suite also serves as **living documentation** for API behavior, providing clear examples of correct usage patterns, error handling, and security boundaries.

## Acceptance Criteria

- [ ] Organization scoping tests for all API endpoints (servers, applications, databases, credentials)
- [ ] Multi-tenant security tests attempting cross-organization access (expect 403/404)
- [ ] Rate limiting tests for all tiers (Starter: 100/min, Pro: 500/min, Enterprise: 2000/min)
- [ ] Rate limit header validation (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)
- [ ] Sanctum token authentication tests with organization context
- [ ] Token ability scoping tests (read-only tokens, admin tokens, resource-specific tokens)
- [ ] CRUD operation tests for all enterprise endpoints
- [ ] Query parameter filtering tests (pagination, sorting, filtering)
- [ ] Error handling tests (400, 401, 403, 404, 422, 429, 500)
- [ ] Concurrent request tests for race conditions
- [ ] Cache invalidation tests for organization data
- [ ] Webhook signature validation tests (HMAC)
- [ ] API versioning tests (future-proofing)
- [ ] Performance tests (response time < 200ms for 95th percentile)
- [ ] Test coverage for API tests > 95%

## Technical Details

### File Paths

**API Test Directory:**
- `/home/topgun/topgun/tests/Feature/Api/` (API integration tests)

**Test Files:**
- `/home/topgun/topgun/tests/Feature/Api/OrganizationScopingTest.php` (core scoping tests)
- `/home/topgun/topgun/tests/Feature/Api/MultiTenantSecurityTest.php` (adversarial tests)
- `/home/topgun/topgun/tests/Feature/Api/RateLimitingTest.php` (rate limit enforcement)
- `/home/topgun/topgun/tests/Feature/Api/AuthenticationTest.php` (token and authentication)
- `/home/topgun/topgun/tests/Feature/Api/OrganizationApiTest.php` (organization CRUD)
- `/home/topgun/topgun/tests/Feature/Api/ServerApiTest.php` (server management API)
- `/home/topgun/topgun/tests/Feature/Api/ApplicationApiTest.php` (application deployment API)
- `/home/topgun/topgun/tests/Feature/Api/ResourceMonitoringApiTest.php` (metrics API)
- `/home/topgun/topgun/tests/Feature/Api/WebhookTest.php` (webhook handling)

**Supporting Files:**
- `/home/topgun/topgun/tests/Traits/ApiTestHelpers.php` (reusable test helpers)
- `/home/topgun/topgun/tests/Traits/MultiTenantTestHelpers.php` (multi-tenant test utilities)

### Test Architecture

**Base Structure for All API Tests:**

```php
<?php

namespace Tests\Feature\Api;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use App\Models\User;
use App\Models\Organization;

abstract class ApiTestCase extends TestCase
{
    use RefreshDatabase;

    /**
     * Create organization with user and Sanctum token
     *
     * @param string $role Organization role (admin, member)
     * @param array $abilities Token abilities
     * @return array ['organization', 'user', 'token']
     */
    protected function createOrganizationContext(
        string $role = 'admin',
        array $abilities = ['*']
    ): array {
        $organization = Organization::factory()->create();
        $user = User::factory()->create();

        $organization->users()->attach($user, ['role' => $role]);

        $token = $user->createToken('test-token', $abilities);

        // Set organization context in token
        $token->accessToken->forceFill([
            'organization_id' => $organization->id,
        ])->save();

        Sanctum::actingAs($user, $abilities);

        return [
            'organization' => $organization,
            'user' => $user,
            'token' => $token->plainTextToken,
        ];
    }

    /**
     * Add default API headers
     *
     * @param string $token
     * @return array
     */
    protected function apiHeaders(string $token): array
    {
        return [
            'Authorization' => "Bearer {$token}",
            'Accept' => 'application/json',
            'Content-Type' => 'application/json',
        ];
    }

    /**
     * Assert rate limit headers are present and valid
     *
     * @param \Illuminate\Testing\TestResponse $response
     * @param int $expectedLimit
     * @return void
     */
    protected function assertRateLimitHeaders(
        $response,
        int $expectedLimit
    ): void {
        $response->assertHeader('X-RateLimit-Limit', $expectedLimit);

        $remaining = $response->headers->get('X-RateLimit-Remaining');
        $this->assertIsNumeric($remaining);
        $this->assertLessThanOrEqual($expectedLimit, (int) $remaining);

        $reset = $response->headers->get('X-RateLimit-Reset');
        $this->assertIsNumeric($reset);
        $this->assertGreaterThan(time(), (int) $reset);
    }
}
```

### Organization Scoping Tests

**File:** `tests/Feature/Api/OrganizationScopingTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Organization;
use App\Models\Server;
use App\Models\Application;
use App\Models\User;

it('scopes server list to organization', function () {
    // Organization A
    $contextA = $this->createOrganizationContext();
    $serverA1 = Server::factory()->create(['organization_id' => $contextA['organization']->id]);
    $serverA2 = Server::factory()->create(['organization_id' => $contextA['organization']->id]);

    // Organization B (should not be visible)
    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    $response = $this->getJson(
        '/api/v1/servers',
        $this->apiHeaders($contextA['token'])
    );

    $response->assertOk()
        ->assertJsonCount(2, 'data')
        ->assertJsonPath('data.0.id', $serverA1->id)
        ->assertJsonPath('data.1.id', $serverA2->id);

    // Verify Organization B's server is NOT present
    $serverIds = collect($response->json('data'))->pluck('id')->all();
    expect($serverIds)->not->toContain($serverB->id);
});

it('scopes application list to organization', function () {
    $contextA = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $contextA['organization']->id]);
    $appA = Application::factory()->create([
        'organization_id' => $contextA['organization']->id,
        'server_id' => $server->id,
    ]);

    // Organization B's application
    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);
    $appB = Application::factory()->create([
        'organization_id' => $orgB->id,
        'server_id' => $serverB->id,
    ]);

    $response = $this->getJson(
        '/api/v1/applications',
        $this->apiHeaders($contextA['token'])
    );

    $response->assertOk()
        ->assertJsonCount(1, 'data')
        ->assertJsonPath('data.0.id', $appA->id);

    $appIds = collect($response->json('data'))->pluck('id')->all();
    expect($appIds)->not->toContain($appB->id);
});

it('scopes single resource retrieval to organization', function () {
    $contextA = $this->createOrganizationContext();
    $serverA = Server::factory()->create(['organization_id' => $contextA['organization']->id]);

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Can retrieve own server
    $response = $this->getJson(
        "/api/v1/servers/{$serverA->id}",
        $this->apiHeaders($contextA['token'])
    );

    $response->assertOk()
        ->assertJsonPath('data.id', $serverA->id);

    // Cannot retrieve other organization's server
    $response = $this->getJson(
        "/api/v1/servers/{$serverB->id}",
        $this->apiHeaders($contextA['token'])
    );

    $response->assertNotFound();
});

it('scopes create operations to organization', function () {
    $context = $this->createOrganizationContext();

    $response = $this->postJson(
        '/api/v1/servers',
        [
            'name' => 'Test Server',
            'ip' => '192.168.1.100',
            'port' => 22,
            'user' => 'root',
        ],
        $this->apiHeaders($context['token'])
    );

    $response->assertCreated()
        ->assertJsonPath('data.organization_id', $context['organization']->id);

    // Verify server was created with correct organization_id
    $this->assertDatabaseHas('servers', [
        'name' => 'Test Server',
        'organization_id' => $context['organization']->id,
    ]);
});

it('scopes update operations to organization', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Can update own server
    $response = $this->patchJson(
        "/api/v1/servers/{$server->id}",
        ['name' => 'Updated Name'],
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonPath('data.name', 'Updated Name');

    // Cannot update other organization's server
    $response = $this->patchJson(
        "/api/v1/servers/{$serverB->id}",
        ['name' => 'Hacked Name'],
        $this->apiHeaders($context['token'])
    );

    $response->assertNotFound();

    // Verify other server was NOT updated
    $serverB->refresh();
    expect($serverB->name)->not->toBe('Hacked Name');
});

it('scopes delete operations to organization', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Can delete own server
    $response = $this->deleteJson(
        "/api/v1/servers/{$server->id}",
        [],
        $this->apiHeaders($context['token'])
    );

    $response->assertNoContent();
    $this->assertSoftDeleted('servers', ['id' => $server->id]);

    // Cannot delete other organization's server
    $response = $this->deleteJson(
        "/api/v1/servers/{$serverB->id}",
        [],
        $this->apiHeaders($context['token'])
    );

    $response->assertNotFound();
    $this->assertDatabaseHas('servers', ['id' => $serverB->id, 'deleted_at' => null]);
});

it('scopes nested resources to organization', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);
    $app = Application::factory()->create([
        'organization_id' => $context['organization']->id,
        'server_id' => $server->id,
    ]);

    // Access nested resource through parent
    $response = $this->getJson(
        "/api/v1/servers/{$server->id}/applications",
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonCount(1, 'data')
        ->assertJsonPath('data.0.id', $app->id);
});

it('prevents organization_id manipulation in request payload', function () {
    $contextA = $this->createOrganizationContext();
    $orgB = Organization::factory()->create();

    // Attempt to create resource for different organization via payload manipulation
    $response = $this->postJson(
        '/api/v1/servers',
        [
            'name' => 'Malicious Server',
            'ip' => '192.168.1.200',
            'organization_id' => $orgB->id, // Attempt to set different org
        ],
        $this->apiHeaders($contextA['token'])
    );

    // Should either ignore organization_id or fail validation
    if ($response->status() === 201) {
        // If created, must be in correct organization
        $response->assertJsonPath('data.organization_id', $contextA['organization']->id);

        $this->assertDatabaseHas('servers', [
            'name' => 'Malicious Server',
            'organization_id' => $contextA['organization']->id,
        ]);

        $this->assertDatabaseMissing('servers', [
            'name' => 'Malicious Server',
            'organization_id' => $orgB->id,
        ]);
    } else {
        // Or reject request entirely
        $response->assertStatus(422);
    }
});
```

### Multi-Tenant Security Tests (Adversarial)

**File:** `tests/Feature/Api/MultiTenantSecurityTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Organization;
use App\Models\Server;
use App\Models\Application;
use App\Models\User;
use App\Models\CloudProviderCredential;

it('prevents cross-tenant access via ID manipulation', function () {
    // Setup: Two organizations with resources
    $contextA = $this->createOrganizationContext();
    $serverA = Server::factory()->create(['organization_id' => $contextA['organization']->id]);

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Attack: Organization A tries to access Organization B's server
    $response = $this->getJson(
        "/api/v1/servers/{$serverB->id}",
        $this->apiHeaders($contextA['token'])
    );

    $response->assertNotFound(); // Should return 404, not 403 (prevents info leakage)
});

it('prevents cross-tenant resource updates', function () {
    $contextA = $this->createOrganizationContext();

    $orgB = Organization::factory()->create();
    $appB = Application::factory()->create(['organization_id' => $orgB->id]);

    // Attack: Update another organization's application
    $originalName = $appB->name;

    $response = $this->patchJson(
        "/api/v1/applications/{$appB->id}",
        ['name' => 'Compromised App'],
        $this->apiHeaders($contextA['token'])
    );

    $response->assertNotFound();

    // Verify resource was NOT modified
    $appB->refresh();
    expect($appB->name)->toBe($originalName);
});

it('prevents cross-tenant resource deletion', function () {
    $contextA = $this->createOrganizationContext();

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Attack: Delete another organization's server
    $response = $this->deleteJson(
        "/api/v1/servers/{$serverB->id}",
        [],
        $this->apiHeaders($contextA['token'])
    );

    $response->assertNotFound();

    // Verify resource still exists
    $this->assertDatabaseHas('servers', [
        'id' => $serverB->id,
        'deleted_at' => null,
    ]);
});

it('prevents access to sensitive credentials across tenants', function () {
    $contextA = $this->createOrganizationContext();

    $orgB = Organization::factory()->create();
    $credentialB = CloudProviderCredential::factory()->create([
        'organization_id' => $orgB->id,
        'provider' => 'aws',
        'credentials' => encrypt(['access_key' => 'secret123']),
    ]);

    // Attack: Access another organization's credentials
    $response = $this->getJson(
        "/api/v1/cloud-credentials/{$credentialB->id}",
        $this->apiHeaders($contextA['token'])
    );

    $response->assertNotFound();
});

it('prevents organization switching via token manipulation', function () {
    $contextA = $this->createOrganizationContext();
    $orgB = Organization::factory()->create();

    // Attack: Try to query with organization_id query parameter
    $response = $this->getJson(
        "/api/v1/servers?organization_id={$orgB->id}",
        $this->apiHeaders($contextA['token'])
    );

    // Should ignore query parameter and use token's organization context
    $response->assertOk();

    $data = $response->json('data');

    if (!empty($data)) {
        // All returned servers should belong to Organization A
        foreach ($data as $server) {
            expect($server['organization_id'])->toBe($contextA['organization']->id);
        }
    }
});

it('prevents privilege escalation via role manipulation', function () {
    // Create organization with regular member (not admin)
    $context = $this->createOrganizationContext(role: 'member', abilities: ['servers:read']);

    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    // Member with read-only token attempts to delete
    $response = $this->deleteJson(
        "/api/v1/servers/{$server->id}",
        [],
        $this->apiHeaders($context['token'])
    );

    $response->assertForbidden();

    $this->assertDatabaseHas('servers', ['id' => $server->id, 'deleted_at' => null]);
});

it('prevents batch operations across organizations', function () {
    $contextA = $this->createOrganizationContext();
    $serverA = Server::factory()->create(['organization_id' => $contextA['organization']->id]);

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Attack: Attempt batch delete with mixed organization IDs
    $response = $this->deleteJson(
        '/api/v1/servers/batch',
        ['ids' => [$serverA->id, $serverB->id]],
        $this->apiHeaders($contextA['token'])
    );

    // Should only delete authorized server
    $this->assertSoftDeleted('servers', ['id' => $serverA->id]);
    $this->assertDatabaseHas('servers', ['id' => $serverB->id, 'deleted_at' => null]);
});

it('prevents sub-organization access without explicit permission', function () {
    // Create organization hierarchy: Parent -> Child
    $parent = Organization::factory()->create();
    $child = Organization::factory()->create(['parent_organization_id' => $parent->id]);

    $userParent = User::factory()->create();
    $parent->users()->attach($userParent, ['role' => 'admin']);

    $tokenParent = $userParent->createToken('parent-token', ['*']);
    $tokenParent->accessToken->forceFill(['organization_id' => $parent->id])->save();

    $childServer = Server::factory()->create(['organization_id' => $child->id]);

    // Parent organization admin attempts to access child's resource
    $response = $this->getJson(
        "/api/v1/servers/{$childServer->id}",
        $this->apiHeaders($tokenParent->plainTextToken)
    );

    // Should be denied unless cross-organization access is explicitly granted
    $response->assertNotFound(); // Or 403 if policy is explicit
});
```

### Rate Limiting Tests

**File:** `tests/Feature/Api/RateLimitingTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\EnterpriseLicense;
use App\Models\Organization;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    Redis::flushall();
    Cache::flush();
});

it('enforces rate limit for Starter tier (100 requests/minute)', function () {
    $context = $this->createOrganizationContext();

    // Assign Starter license
    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Starter',
        'api_rate_limit' => 100,
    ]);

    $headers = $this->apiHeaders($context['token']);

    // Make 100 requests (should all succeed)
    for ($i = 0; $i < 100; $i++) {
        $response = $this->getJson('/api/v1/servers', $headers);
        $response->assertOk();
        $this->assertRateLimitHeaders($response, 100);
    }

    // 101st request should be rate limited
    $response = $this->getJson('/api/v1/servers', $headers);
    $response->assertStatus(429)
        ->assertJsonPath('message', 'Too Many Attempts.');

    $this->assertRateLimitHeaders($response, 100);
});

it('enforces rate limit for Pro tier (500 requests/minute)', function () {
    $context = $this->createOrganizationContext();

    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Pro',
        'api_rate_limit' => 500,
    ]);

    $headers = $this->apiHeaders($context['token']);

    // Make 500 requests rapidly
    for ($i = 0; $i < 500; $i++) {
        $response = $this->getJson('/api/v1/servers', $headers);
        $response->assertOk();
    }

    // 501st should fail
    $response = $this->getJson('/api/v1/servers', $headers);
    $response->assertStatus(429);
});

it('enforces rate limit for Enterprise tier (2000 requests/minute)', function () {
    $context = $this->createOrganizationContext();

    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Enterprise',
        'api_rate_limit' => 2000,
    ]);

    $headers = $this->apiHeaders($context['token']);

    // Sample 100 requests (full 2000 would be slow)
    for ($i = 0; $i < 100; $i++) {
        $response = $this->getJson('/api/v1/servers', $headers);
        $response->assertOk();
        $this->assertRateLimitHeaders($response, 2000);
    }
});

it('includes correct rate limit headers in responses', function () {
    $context = $this->createOrganizationContext();

    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Pro',
        'api_rate_limit' => 500,
    ]);

    $response = $this->getJson('/api/v1/servers', $this->apiHeaders($context['token']));

    $response->assertHeader('X-RateLimit-Limit', 500);

    $remaining = $response->headers->get('X-RateLimit-Remaining');
    expect((int) $remaining)->toBeLessThanOrEqual(500);
    expect((int) $remaining)->toBeGreaterThanOrEqual(0);

    $reset = $response->headers->get('X-RateLimit-Reset');
    expect((int) $reset)->toBeGreaterThan(time());
});

it('resets rate limit after time window expires', function () {
    $context = $this->createOrganizationContext();

    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Starter',
        'api_rate_limit' => 5, // Very low limit for testing
    ]);

    $headers = $this->apiHeaders($context['token']);

    // Exhaust rate limit
    for ($i = 0; $i < 5; $i++) {
        $this->getJson('/api/v1/servers', $headers)->assertOk();
    }

    // Should be rate limited
    $response = $this->getJson('/api/v1/servers', $headers);
    $response->assertStatus(429);

    // Wait for rate limit window to expire (simulate with Cache::forget)
    $rateLimitKey = "api_rate_limit:{$context['organization']->id}";
    Cache::forget($rateLimitKey);

    // Should succeed again
    $response = $this->getJson('/api/v1/servers', $headers);
    $response->assertOk();
});

it('applies different rate limits per organization', function () {
    // Organization A (Starter: 100/min)
    $contextA = $this->createOrganizationContext();
    EnterpriseLicense::factory()->create([
        'organization_id' => $contextA['organization']->id,
        'tier' => 'Starter',
        'api_rate_limit' => 100,
    ]);

    // Organization B (Enterprise: 2000/min)
    $contextB = $this->createOrganizationContext();
    EnterpriseLicense::factory()->create([
        'organization_id' => $contextB['organization']->id,
        'tier' => 'Enterprise',
        'api_rate_limit' => 2000,
    ]);

    // Exhaust Org A's limit
    for ($i = 0; $i < 100; $i++) {
        $this->getJson('/api/v1/servers', $this->apiHeaders($contextA['token']))->assertOk();
    }

    $this->getJson('/api/v1/servers', $this->apiHeaders($contextA['token']))->assertStatus(429);

    // Org B should still have quota
    $this->getJson('/api/v1/servers', $this->apiHeaders($contextB['token']))->assertOk();
});

it('excludes specific endpoints from rate limiting (health checks)', function () {
    $context = $this->createOrganizationContext();

    EnterpriseLicense::factory()->create([
        'organization_id' => $context['organization']->id,
        'tier' => 'Starter',
        'api_rate_limit' => 5,
    ]);

    $headers = $this->apiHeaders($context['token']);

    // Exhaust rate limit
    for ($i = 0; $i < 5; $i++) {
        $this->getJson('/api/v1/servers', $headers)->assertOk();
    }

    // Regular endpoint should be rate limited
    $this->getJson('/api/v1/servers', $headers)->assertStatus(429);

    // Health check should NOT be rate limited
    $response = $this->getJson('/api/v1/health', $headers);
    $response->assertOk();
});
```

### Authentication & Token Tests

**File:** `tests/Feature/Api/AuthenticationTest.php`

```php
<?php

namespace Tests\Feature/Api;

use App\Models\User;
use App\Models\Organization;
use Laravel\Sanctum\Sanctum;

it('requires authentication for API access', function () {
    $response = $this->getJson('/api/v1/servers');

    $response->assertUnauthorized()
        ->assertJsonPath('message', 'Unauthenticated.');
});

it('accepts valid Sanctum token', function () {
    $context = $this->createOrganizationContext();

    $response = $this->getJson(
        '/api/v1/servers',
        $this->apiHeaders($context['token'])
    );

    $response->assertOk();
});

it('rejects invalid token', function () {
    $response = $this->getJson('/api/v1/servers', [
        'Authorization' => 'Bearer invalid-token-12345',
        'Accept' => 'application/json',
    ]);

    $response->assertUnauthorized();
});

it('enforces token abilities (read-only token)', function () {
    $context = $this->createOrganizationContext(abilities: ['servers:read']);

    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    // Read should work
    $response = $this->getJson(
        "/api/v1/servers/{$server->id}",
        $this->apiHeaders($context['token'])
    );
    $response->assertOk();

    // Write should fail
    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => 'New Server', 'ip' => '192.168.1.1'],
        $this->apiHeaders($context['token'])
    );
    $response->assertForbidden();
});

it('enforces token abilities (admin token)', function () {
    $context = $this->createOrganizationContext(abilities: ['*']);

    // Should have full CRUD access
    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => 'New Server', 'ip' => '192.168.1.1'],
        $this->apiHeaders($context['token'])
    );
    $response->assertCreated();
});

it('requires organization context in token', function () {
    $user = User::factory()->create();
    $token = $user->createToken('test-token', ['*'])->plainTextToken;

    // Token without organization_id should be rejected or return empty results
    $response = $this->getJson('/api/v1/servers', $this->apiHeaders($token));

    // Either forbidden or empty result set
    if ($response->status() === 200) {
        $response->assertJsonCount(0, 'data');
    } else {
        $response->assertForbidden();
    }
});

it('validates token expiration', function () {
    $context = $this->createOrganizationContext();

    // Expire the token
    $context['user']->tokens()->update(['expires_at' => now()->subDay()]);

    $response = $this->getJson(
        '/api/v1/servers',
        $this->apiHeaders($context['token'])
    );

    $response->assertUnauthorized();
});

it('supports resource-specific token scoping', function () {
    $context = $this->createOrganizationContext(abilities: ['servers:*', 'applications:read']);

    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);
    $app = Application::factory()->create(['organization_id' => $context['organization']->id]);

    // Full server access
    $this->postJson('/api/v1/servers', ['name' => 'Test'], $this->apiHeaders($context['token']))
        ->assertCreated();

    // Read-only application access
    $this->getJson("/api/v1/applications/{$app->id}", $this->apiHeaders($context['token']))
        ->assertOk();

    $this->deleteJson("/api/v1/applications/{$app->id}", [], $this->apiHeaders($context['token']))
        ->assertForbidden();
});
```

### CRUD Endpoint Tests

**File:** `tests/Feature/Api/ServerApiTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Server;
use App\Models\Organization;

it('lists servers with pagination', function () {
    $context = $this->createOrganizationContext();

    Server::factory(25)->create(['organization_id' => $context['organization']->id]);

    $response = $this->getJson(
        '/api/v1/servers?page=1&per_page=10',
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonCount(10, 'data')
        ->assertJsonStructure([
            'data' => [
                '*' => ['id', 'name', 'ip', 'status', 'organization_id'],
            ],
            'meta' => ['current_page', 'last_page', 'total'],
            'links' => ['first', 'last', 'prev', 'next'],
        ]);
});

it('retrieves single server', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    $response = $this->getJson(
        "/api/v1/servers/{$server->id}",
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonPath('data.id', $server->id)
        ->assertJsonPath('data.name', $server->name)
        ->assertJsonPath('data.ip', $server->ip);
});

it('creates server', function () {
    $context = $this->createOrganizationContext();

    $response = $this->postJson(
        '/api/v1/servers',
        [
            'name' => 'Production Server',
            'ip' => '192.168.1.100',
            'port' => 22,
            'user' => 'root',
        ],
        $this->apiHeaders($context['token'])
    );

    $response->assertCreated()
        ->assertJsonPath('data.name', 'Production Server')
        ->assertJsonPath('data.ip', '192.168.1.100')
        ->assertJsonPath('data.organization_id', $context['organization']->id);

    $this->assertDatabaseHas('servers', [
        'name' => 'Production Server',
        'organization_id' => $context['organization']->id,
    ]);
});

it('validates server creation payload', function () {
    $context = $this->createOrganizationContext();

    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => ''], // Missing required fields
        $this->apiHeaders($context['token'])
    );

    $response->assertStatus(422)
        ->assertJsonValidationErrors(['name', 'ip']);
});

it('updates server', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    $response = $this->patchJson(
        "/api/v1/servers/{$server->id}",
        ['name' => 'Updated Server Name'],
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonPath('data.name', 'Updated Server Name');

    $server->refresh();
    expect($server->name)->toBe('Updated Server Name');
});

it('soft deletes server', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    $response = $this->deleteJson(
        "/api/v1/servers/{$server->id}",
        [],
        $this->apiHeaders($context['token'])
    );

    $response->assertNoContent();

    $this->assertSoftDeleted('servers', ['id' => $server->id]);
});

it('filters servers by status', function () {
    $context = $this->createOrganizationContext();

    Server::factory()->create(['organization_id' => $context['organization']->id, 'status' => 'running']);
    Server::factory()->create(['organization_id' => $context['organization']->id, 'status' => 'stopped']);
    Server::factory()->create(['organization_id' => $context['organization']->id, 'status' => 'running']);

    $response = $this->getJson(
        '/api/v1/servers?filter[status]=running',
        $this->apiHeaders($context['token'])
    );

    $response->assertOk()
        ->assertJsonCount(2, 'data');

    foreach ($response->json('data') as $server) {
        expect($server['status'])->toBe('running');
    }
});

it('sorts servers by name', function () {
    $context = $this->createOrganizationContext();

    Server::factory()->create(['organization_id' => $context['organization']->id, 'name' => 'Zulu']);
    Server::factory()->create(['organization_id' => $context['organization']->id, 'name' => 'Alpha']);
    Server::factory()->create(['organization_id' => $context['organization']->id, 'name' => 'Bravo']);

    $response = $this->getJson(
        '/api/v1/servers?sort=name',
        $this->apiHeaders($context['token'])
    );

    $response->assertOk();

    $names = collect($response->json('data'))->pluck('name')->all();
    expect($names)->toBe(['Alpha', 'Bravo', 'Zulu']);
});
```

### Error Handling Tests

**File:** `tests/Feature/Api/ErrorHandlingTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Server;

it('returns 404 for non-existent resource', function () {
    $context = $this->createOrganizationContext();

    $response = $this->getJson(
        '/api/v1/servers/99999',
        $this->apiHeaders($context['token'])
    );

    $response->assertNotFound()
        ->assertJsonPath('message', 'Resource not found.');
});

it('returns 422 for validation errors', function () {
    $context = $this->createOrganizationContext();

    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => '', 'ip' => 'invalid-ip'],
        $this->apiHeaders($context['token'])
    );

    $response->assertStatus(422)
        ->assertJsonStructure([
            'message',
            'errors' => ['name', 'ip'],
        ]);
});

it('returns 403 for forbidden actions', function () {
    $context = $this->createOrganizationContext(role: 'member', abilities: ['servers:read']);

    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => 'Test', 'ip' => '192.168.1.1'],
        $this->apiHeaders($context['token'])
    );

    $response->assertForbidden()
        ->assertJsonPath('message', 'This action is unauthorized.');
});

it('returns 500 for server errors with proper logging', function () {
    // This test would require mocking a service to throw an exception
    // and verifying the error is logged and returned as 500
});

it('sanitizes error messages to prevent information leakage', function () {
    $context = $this->createOrganizationContext();

    // Trigger database error (invalid data)
    $response = $this->postJson(
        '/api/v1/servers',
        ['name' => str_repeat('a', 300), 'ip' => '192.168.1.1'],
        $this->apiHeaders($context['token'])
    );

    $response->assertStatus(422);

    // Error message should NOT contain SQL details
    expect($response->json('message'))->not->toContain('SQL');
    expect($response->json('message'))->not->toContain('SQLSTATE');
});
```

### Performance & Concurrency Tests

**File:** `tests/Feature/Api/PerformanceTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Server;

it('handles concurrent requests without race conditions', function () {
    $context = $this->createOrganizationContext();
    $server = Server::factory()->create(['organization_id' => $context['organization']->id]);

    // Simulate concurrent update requests
    $responses = [];

    for ($i = 0; $i < 5; $i++) {
        $responses[] = $this->patchJson(
            "/api/v1/servers/{$server->id}",
            ['name' => "Updated Name {$i}"],
            $this->apiHeaders($context['token'])
        );
    }

    // All requests should succeed
    foreach ($responses as $response) {
        expect($response->status())->toBe(200);
    }

    // Final state should be consistent
    $server->refresh();
    expect($server->name)->toStartWith('Updated Name');
});

it('completes API requests within performance threshold', function () {
    $context = $this->createOrganizationContext();
    Server::factory(10)->create(['organization_id' => $context['organization']->id]);

    $start = microtime(true);

    $response = $this->getJson(
        '/api/v1/servers',
        $this->apiHeaders($context['token'])
    );

    $duration = (microtime(true) - $start) * 1000; // Convert to milliseconds

    $response->assertOk();

    // Response should be under 200ms (adjust based on requirements)
    expect($duration)->toBeLessThan(200);
});
```

## Implementation Approach

### Step 1: Create Test Base Classes
1. Create `ApiTestCase` abstract class with helper methods
2. Create `MultiTenantTestHelpers` trait
3. Set up test database configuration

### Step 2: Organization Scoping Tests
1. Write tests for server API scoping
2. Write tests for application API scoping
3. Write tests for all enterprise resource endpoints
4. Test CRUD operations with cross-tenant access attempts

### Step 3: Multi-Tenant Security Tests
1. Write adversarial tests for ID manipulation
2. Test privilege escalation attempts
3. Test batch operation security
4. Test credential isolation

### Step 4: Rate Limiting Tests
1. Test tier-based rate limits (Starter, Pro, Enterprise)
2. Verify rate limit headers
3. Test rate limit reset behavior
4. Test per-organization rate limit isolation

### Step 5: Authentication Tests
1. Test Sanctum token validation
2. Test token abilities and scoping
3. Test token expiration
4. Test organization context enforcement

### Step 6: CRUD Endpoint Tests
1. Write full CRUD tests for all API endpoints
2. Test pagination, filtering, sorting
3. Test validation and error handling
4. Test nested resource access

### Step 7: Error Handling Tests
1. Test all HTTP error codes (400, 401, 403, 404, 422, 429, 500)
2. Verify error message sanitization
3. Test exception logging

### Step 8: Performance Tests
1. Test concurrent request handling
2. Measure API response times
3. Test under load with multiple organizations

### Step 9: Code Coverage Analysis
1. Run PHPUnit with coverage reporting
2. Ensure > 95% coverage for API endpoints
3. Identify and test edge cases

### Step 10: Documentation
1. Document test patterns and conventions
2. Create testing guide for new API endpoints
3. Document security test requirements

## Test Strategy

### Unit Tests vs Integration Tests

**Integration Tests (API Tests):**
- Test full HTTP request/response cycle
- Test middleware (authentication, rate limiting, organization scoping)
- Test controller logic and database interactions
- Test Sanctum token authentication
- Test multi-tenant security boundaries

**Not Covered in This Task (Unit Tests):**
- Service layer logic (covered in Task 76)
- Model methods and relationships
- Helper functions and utilities

### Test Data Management

**Factory Usage:**
```php
// Organization with users and tokens
$context = $this->createOrganizationContext();

// Create related resources
Server::factory()->create(['organization_id' => $context['organization']->id]);
Application::factory(5)->create(['organization_id' => $context['organization']->id]);
```

**Database State:**
- Use `RefreshDatabase` trait for clean state per test
- Use transactions for faster test execution
- Seed minimal required data per test

### Assertion Patterns

**API Response Assertions:**
```php
$response->assertOk(); // 200
$response->assertCreated(); // 201
$response->assertNoContent(); // 204
$response->assertNotFound(); // 404
$response->assertForbidden(); // 403
$response->assertStatus(422); // Validation errors
$response->assertStatus(429); // Rate limited

$response->assertJsonPath('data.id', 123);
$response->assertJsonCount(10, 'data');
$response->assertJsonStructure(['data', 'meta', 'links']);
```

**Database Assertions:**
```php
$this->assertDatabaseHas('servers', ['id' => $server->id]);
$this->assertDatabaseMissing('servers', ['organization_id' => $wrongOrg->id]);
$this->assertSoftDeleted('servers', ['id' => $server->id]);
```

### Test Performance

**Optimization Techniques:**
- Use database transactions where possible
- Mock external services (Terraform, payment gateways)
- Use Redis mocking for rate limiting tests
- Limit data generation to minimum required

**Expected Execution Times:**
- Organization scoping tests: < 30 seconds
- Security tests: < 45 seconds
- Rate limiting tests: < 60 seconds (Redis operations)
- Total test suite: < 5 minutes

### Continuous Integration

**CI Pipeline Integration:**
```bash
# Run API tests only
php artisan test --testsuite=Feature --filter=Api

# Run with coverage
php artisan test --testsuite=Feature --filter=Api --coverage --min=95

# Parallel execution
php artisan test --parallel
```

**Quality Gates:**
- All API tests must pass
- Minimum 95% code coverage for API controllers
- No security test failures allowed
- Performance tests must meet thresholds

## Definition of Done

- [ ] ApiTestCase base class created with helper methods
- [ ] MultiTenantTestHelpers trait created
- [ ] OrganizationScopingTest created with 10+ tests
- [ ] MultiTenantSecurityTest created with 8+ adversarial tests
- [ ] RateLimitingTest created with 7+ rate limit tests
- [ ] AuthenticationTest created with 8+ authentication tests
- [ ] ServerApiTest created with 10+ CRUD tests
- [ ] ApplicationApiTest created with CRUD tests
- [ ] ResourceMonitoringApiTest created with metrics tests
- [ ] OrganizationApiTest created with hierarchy tests
- [ ] ErrorHandlingTest created with error code tests
- [ ] PerformanceTest created with concurrency tests
- [ ] All tests use Pest syntax
- [ ] All tests use RefreshDatabase trait
- [ ] Test data created via factories (no manual DB inserts)
- [ ] Cross-tenant access attempts tested and rejected
- [ ] Rate limiting tested for all tiers (Starter, Pro, Enterprise)
- [ ] Rate limit headers validated in all rate limit tests
- [ ] Sanctum token authentication tested
- [ ] Token abilities and scoping tested
- [ ] Organization context enforcement tested
- [ ] CRUD operations tested for all major endpoints
- [ ] Pagination, filtering, sorting tested
- [ ] Validation error tests (422)
- [ ] Authorization error tests (403)
- [ ] Not found error tests (404)
- [ ] Rate limit error tests (429)
- [ ] Concurrent request handling tested
- [ ] API response time tests (< 200ms threshold)
- [ ] Test coverage > 95% for API controllers
- [ ] All tests passing (`php artisan test --filter=Api`)
- [ ] No security test failures
- [ ] Performance thresholds met
- [ ] Code follows Laravel 12 and Pest testing patterns
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing for test files
- [ ] Documentation updated with testing guidelines
- [ ] CI/CD pipeline includes API tests
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 61 (API endpoints and middleware implementation)
- **Depends on:** Task 76 (Enterprise service unit tests provide foundation)
- **Integrates with:** Task 52-60 (Enhanced API System features)
- **Validates:** Task 1-2 (Organization hierarchy and licensing enforcement)
- **Validates:** Task 54-55 (Rate limiting middleware and headers)
