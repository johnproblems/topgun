---
name: Implement server scoring logic with weighted algorithm
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:46Z
github: https://github.com/johnproblems/topgun/issues/137
depends_on: [26]
parallel: false
conflicts_with: []
---

# Task: Implement server scoring logic with weighted algorithm

## Description

Implement an intelligent server selection algorithm within the CapacityManager service that assigns weighted scores to servers based on multiple resource factors. This scoring system enables optimal server selection for application deployments by evaluating available capacity across CPU, memory, disk, network bandwidth, and current system load metrics.

The server scoring algorithm is the decision-making engine of the capacity management system. When a new application deployment is requested, the CapacityManager must determine which server in the organization's infrastructure pool is best suited to handle the workload. A naive approach (first-available or round-robin) leads to suboptimal resource utilization—some servers become overloaded while others sit idle.

This task implements a **multi-factor weighted scoring algorithm** that evaluates each server against five key metrics:

1. **CPU Availability (30% weight)** - Remaining CPU capacity for compute-intensive workloads
2. **Memory Availability (30% weight)** - Free RAM for application processes and caching
3. **Disk Space (20% weight)** - Storage capacity for application data and Docker images
4. **Network Bandwidth (10% weight)** - Available bandwidth for traffic handling
5. **Current System Load (10% weight)** - Real-time load average indicating server stress

Each server receives a score from 0-100, where higher scores indicate better suitability for deployment. The weighted algorithm balances different resource constraints based on their typical impact on application performance—CPU and memory are critical (30% each), disk is important but less dynamic (20%), while network and load provide additional optimization (10% each).

**Why This Task is Critical:**

Without intelligent server selection:
- **Unbalanced Load:** Popular servers become overloaded while newer servers remain underutilized
- **Performance Degradation:** Applications deployed to saturated servers experience resource starvation
- **Deployment Failures:** Servers with insufficient capacity accept deployments they can't support
- **Manual Intervention:** Administrators must manually investigate and select servers

With the weighted scoring algorithm:
- **Automated Optimization:** System automatically selects the best server for each deployment
- **Resource Efficiency:** Balanced utilization across the entire infrastructure pool
- **Predictable Performance:** Applications consistently get adequate resources
- **Scalability:** Algorithm works equally well with 3 servers or 300 servers

**Integration Architecture:**

This scoring logic integrates with multiple components:

- **CapacityManager::selectOptimalServer()** - Primary consumer of server scores
- **SystemResourceMonitor** (Task 25) - Provides real-time metrics for scoring calculations
- **Server Model** - Stores baseline capacity specifications (CPU cores, RAM, disk size)
- **server_resource_metrics table** (Task 22) - Historical and current resource usage data
- **EnhancedDeploymentService** (Tasks 32-41) - Requests optimal server before deployment
- **ResourceDashboard.vue** (Task 29) - Displays server scores for visibility

**Scoring Algorithm Formula:**

```
ServerScore = (
    (AvailableCPU / TotalCPU) * 0.30 +
    (AvailableMemory / TotalMemory) * 0.30 +
    (AvailableDisk / TotalDisk) * 0.20 +
    (AvailableNetwork / TotalNetwork) * 0.10 +
    (1 - (CurrentLoad / MaxLoad)) * 0.10
) * 100
```

The algorithm normalizes each metric to a 0-1 range, applies the percentage weight, sums the weighted factors, and scales to 0-100 for intuitive scoring.

**Advanced Features:**

- **Minimum Threshold Enforcement:** Servers scoring below 50 are excluded from consideration
- **Application-Specific Weighting:** Adjustable weights based on application requirements (CPU-heavy vs memory-heavy)
- **Blacklist Support:** Servers can be manually excluded from selection (maintenance, testing, etc.)
- **Resource Reservation:** Planned deployments reserve capacity to prevent race conditions
- **Historical Performance:** Optionally factor in past deployment success rates per server

**Real-World Example:**

Given three servers in an organization:

**Server A (High-End):**
- CPU: 16 cores, 2 cores available (12.5% free)
- Memory: 64GB, 8GB available (12.5% free)
- Disk: 1TB, 500GB available (50% free)
- Network: 10Gbps, 8Gbps available (80% free)
- Load: 0.4 average (low load)

**Score A = (0.125 × 0.30) + (0.125 × 0.30) + (0.50 × 0.20) + (0.80 × 0.10) + (0.96 × 0.10) = 0.351 × 100 = 35.1**
❌ Below threshold, not selected (heavily utilized)

**Server B (Mid-Range):**
- CPU: 8 cores, 5 cores available (62.5% free)
- Memory: 32GB, 20GB available (62.5% free)
- Disk: 500GB, 300GB available (60% free)
- Network: 1Gbps, 800Mbps available (80% free)
- Load: 0.2 average (very low load)

**Score B = (0.625 × 0.30) + (0.625 × 0.30) + (0.60 × 0.20) + (0.80 × 0.10) + (0.98 × 0.10) = 0.673 × 100 = 67.3**
✅ **Selected** (best balance of resources)

**Server C (New Server):**
- CPU: 4 cores, 4 cores available (100% free)
- Memory: 16GB, 15GB available (93.75% free)
- Disk: 250GB, 200GB available (80% free)
- Network: 1Gbps, 900Mbps available (90% free)
- Load: 0.0 average (idle)

**Score C = (1.0 × 0.30) + (0.9375 × 0.30) + (0.80 × 0.20) + (0.90 × 0.10) + (1.0 × 0.10) = 0.931 × 100 = 93.1**
✅ Highest score, but smaller capacity (good for small apps)

In this scenario:
- **Small app deployment:** Server C (highest score, plenty of headroom)
- **Large app deployment:** Server B (more total capacity, good score)
- **Server A:** Excluded due to high utilization

This demonstrates how the algorithm balances absolute capacity with available headroom to make intelligent decisions.

## Acceptance Criteria

- [ ] Server scoring method implemented in CapacityManager service
- [ ] Weighted algorithm calculates scores using 5 factors (CPU 30%, memory 30%, disk 20%, network 10%, load 10%)
- [ ] Each metric normalized to 0-1 range before applying weights
- [ ] Final score scaled to 0-100 for intuitive interpretation
- [ ] Minimum score threshold enforced (default: 50, configurable)
- [ ] Servers below threshold excluded from selection
- [ ] Handle edge cases: zero total resources, missing metrics, negative values
- [ ] Support for application-specific weight adjustments
- [ ] Integration with SystemResourceMonitor for real-time metrics
- [ ] Integration with Server model for baseline capacity specifications
- [ ] Server blacklist support for maintenance exclusion
- [ ] Resource reservation system to prevent double-allocation
- [ ] Logging of scoring decisions for debugging and auditing
- [ ] Configurable weights via config file or database
- [ ] Performance optimization: score calculation < 50ms for 100 servers

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/CapacityManager.php` (enhance existing from Task 26)
- `/home/topgun/topgun/app/Contracts/CapacityManagerInterface.php` (update interface)

**Configuration:**
- `/home/topgun/topgun/config/enterprise.php` (add capacity scoring config section)

**Models:**
- `/home/topgun/topgun/app/Models/Server.php` (add scoring accessors if needed)

**Database:**
- Uses existing `servers` table and `server_resource_metrics` table from Task 22
- Potentially add `server_blacklist` or `server_maintenance` flag to servers table

### Database Schema Enhancement (Optional)

If adding maintenance mode and manual scoring overrides:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('servers', function (Blueprint $table) {
            $table->boolean('maintenance_mode')->default(false)->after('status');
            $table->integer('manual_score_override')->nullable()->after('maintenance_mode')
                ->comment('Manual override score 0-100, null for automatic scoring');
            $table->text('maintenance_notes')->nullable()->after('manual_score_override');
            $table->timestamp('maintenance_started_at')->nullable();
        });

        // Add index for fast filtering of active servers
        Schema::table('servers', function (Blueprint $table) {
            $table->index(['organization_id', 'maintenance_mode', 'status'], 'idx_servers_active_selection');
        });
    }

    public function down(): void
    {
        Schema::table('servers', function (Blueprint $table) {
            $table->dropIndex('idx_servers_active_selection');
            $table->dropColumn([
                'maintenance_mode',
                'manual_score_override',
                'maintenance_notes',
                'maintenance_started_at',
            ]);
        });
    }
};
```

### CapacityManager Service Enhancement

**File:** `app/Services/Enterprise/CapacityManager.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\CapacityManagerInterface;
use App\Contracts\SystemResourceMonitorInterface;
use App\Models\Organization;
use App\Models\Server;
use App\Models\Application;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class CapacityManager implements CapacityManagerInterface
{
    // Scoring weight configuration
    private const DEFAULT_WEIGHTS = [
        'cpu' => 0.30,      // 30% weight
        'memory' => 0.30,   // 30% weight
        'disk' => 0.20,     // 20% weight
        'network' => 0.10,  // 10% weight
        'load' => 0.10,     // 10% weight
    ];

    private const MIN_SCORE_THRESHOLD = 50.0; // Minimum acceptable score
    private const SCORE_CACHE_TTL = 60; // Cache scores for 60 seconds

    public function __construct(
        private SystemResourceMonitorInterface $resourceMonitor
    ) {}

    /**
     * Calculate weighted score for a single server
     *
     * @param Server $server
     * @param array|null $customWeights Optional custom weights for scoring
     * @return float Score from 0-100
     */
    public function calculateServerScore(Server $server, ?array $customWeights = null): float
    {
        // Check cache first
        $cacheKey = "server_score:{$server->id}";

        if ($cachedScore = Cache::get($cacheKey)) {
            return $cachedScore;
        }

        // Check manual override
        if ($server->manual_score_override !== null) {
            Log::debug("Using manual score override for server {$server->id}", [
                'server_id' => $server->id,
                'override_score' => $server->manual_score_override,
            ]);
            return (float) $server->manual_score_override;
        }

        // Check maintenance mode
        if ($server->maintenance_mode) {
            Log::debug("Server {$server->id} in maintenance mode, score = 0");
            return 0.0;
        }

        // Get weights (custom or default)
        $weights = $customWeights ?? config('enterprise.capacity.scoring_weights', self::DEFAULT_WEIGHTS);

        // Validate weights sum to 1.0
        $weightSum = array_sum($weights);
        if (abs($weightSum - 1.0) > 0.01) {
            Log::warning("Scoring weights do not sum to 1.0, normalizing", [
                'weights' => $weights,
                'sum' => $weightSum,
            ]);
            // Normalize weights
            $weights = array_map(fn($w) => $w / $weightSum, $weights);
        }

        // Get current resource metrics
        $metrics = $this->resourceMonitor->getServerMetrics($server);

        if (!$metrics) {
            Log::warning("No metrics available for server {$server->id}, defaulting to score 0");
            return 0.0;
        }

        // Calculate individual factor scores (0-1 range)
        $cpuScore = $this->calculateCpuScore($server, $metrics);
        $memoryScore = $this->calculateMemoryScore($server, $metrics);
        $diskScore = $this->calculateDiskScore($server, $metrics);
        $networkScore = $this->calculateNetworkScore($server, $metrics);
        $loadScore = $this->calculateLoadScore($server, $metrics);

        // Apply weights and calculate final score
        $score = (
            $cpuScore * $weights['cpu'] +
            $memoryScore * $weights['memory'] +
            $diskScore * $weights['disk'] +
            $networkScore * $weights['network'] +
            $loadScore * $weights['load']
        ) * 100;

        // Ensure score is in valid range
        $score = max(0.0, min(100.0, $score));

        Log::debug("Calculated server score", [
            'server_id' => $server->id,
            'server_name' => $server->name,
            'cpu_score' => round($cpuScore, 3),
            'memory_score' => round($memoryScore, 3),
            'disk_score' => round($diskScore, 3),
            'network_score' => round($networkScore, 3),
            'load_score' => round($loadScore, 3),
            'final_score' => round($score, 2),
        ]);

        // Cache the score
        Cache::put($cacheKey, $score, self::SCORE_CACHE_TTL);

        return round($score, 2);
    }

    /**
     * Calculate CPU availability score (0-1)
     *
     * @param Server $server
     * @param array $metrics
     * @return float
     */
    private function calculateCpuScore(Server $server, array $metrics): float
    {
        $totalCpu = $metrics['cpu_total'] ?? $server->cpu_count ?? 1;
        $usedCpu = $metrics['cpu_used'] ?? 0;

        if ($totalCpu <= 0) {
            return 0.0;
        }

        $availableCpu = max(0, $totalCpu - $usedCpu);
        $score = $availableCpu / $totalCpu;

        return min(1.0, max(0.0, $score));
    }

    /**
     * Calculate memory availability score (0-1)
     *
     * @param Server $server
     * @param array $metrics
     * @return float
     */
    private function calculateMemoryScore(Server $server, array $metrics): float
    {
        $totalMemory = $metrics['memory_total'] ?? $server->ram_total ?? 1;
        $usedMemory = $metrics['memory_used'] ?? 0;

        if ($totalMemory <= 0) {
            return 0.0;
        }

        $availableMemory = max(0, $totalMemory - $usedMemory);
        $score = $availableMemory / $totalMemory;

        return min(1.0, max(0.0, $score));
    }

    /**
     * Calculate disk space availability score (0-1)
     *
     * @param Server $server
     * @param array $metrics
     * @return float
     */
    private function calculateDiskScore(Server $server, array $metrics): float
    {
        $totalDisk = $metrics['disk_total'] ?? $server->disk_total ?? 1;
        $usedDisk = $metrics['disk_used'] ?? 0;

        if ($totalDisk <= 0) {
            return 0.0;
        }

        $availableDisk = max(0, $totalDisk - $usedDisk);
        $score = $availableDisk / $totalDisk;

        return min(1.0, max(0.0, $score));
    }

    /**
     * Calculate network bandwidth availability score (0-1)
     *
     * @param Server $server
     * @param array $metrics
     * @return float
     */
    private function calculateNetworkScore(Server $server, array $metrics): float
    {
        $totalBandwidth = $metrics['network_bandwidth_total'] ?? $server->network_bandwidth ?? 1000; // Default 1Gbps
        $usedBandwidth = $metrics['network_bandwidth_used'] ?? 0;

        if ($totalBandwidth <= 0) {
            return 0.0;
        }

        $availableBandwidth = max(0, $totalBandwidth - $usedBandwidth);
        $score = $availableBandwidth / $totalBandwidth;

        return min(1.0, max(0.0, $score));
    }

    /**
     * Calculate system load score (0-1)
     * Lower load = higher score
     *
     * @param Server $server
     * @param array $metrics
     * @return float
     */
    private function calculateLoadScore(Server $server, array $metrics): float
    {
        $currentLoad = $metrics['load_average_1min'] ?? 0.0;
        $cpuCount = $metrics['cpu_total'] ?? $server->cpu_count ?? 1;

        // Normalize load by CPU count (load of 1.0 per core is max)
        $normalizedLoad = $currentLoad / $cpuCount;

        // Invert score: low load = high score
        // Clamp at 2.0 (if load is 2x CPU count, score = 0)
        $score = 1.0 - min(1.0, $normalizedLoad / 2.0);

        return min(1.0, max(0.0, $score));
    }

    /**
     * Select optimal server from collection based on scoring
     *
     * @param Collection<Server> $servers
     * @param array|null $requirements Optional application resource requirements
     * @param array|null $customWeights Optional custom scoring weights
     * @return Server|null
     */
    public function selectOptimalServer(
        Collection $servers,
        ?array $requirements = null,
        ?array $customWeights = null
    ): ?Server {
        if ($servers->isEmpty()) {
            Log::warning("No servers available for selection");
            return null;
        }

        // Filter out maintenance servers and calculate scores
        $scoredServers = $servers
            ->filter(fn(Server $server) => !$server->maintenance_mode)
            ->map(function (Server $server) use ($customWeights) {
                $score = $this->calculateServerScore($server, $customWeights);
                return [
                    'server' => $server,
                    'score' => $score,
                ];
            })
            ->filter(function ($item) {
                // Exclude servers below minimum threshold
                $threshold = config('enterprise.capacity.min_score_threshold', self::MIN_SCORE_THRESHOLD);
                return $item['score'] >= $threshold;
            })
            ->sortByDesc('score');

        if ($scoredServers->isEmpty()) {
            Log::warning("No servers meet minimum score threshold", [
                'threshold' => config('enterprise.capacity.min_score_threshold', self::MIN_SCORE_THRESHOLD),
                'total_servers' => $servers->count(),
            ]);
            return null;
        }

        $selectedServer = $scoredServers->first();

        Log::info("Selected optimal server", [
            'server_id' => $selectedServer['server']->id,
            'server_name' => $selectedServer['server']->name,
            'score' => $selectedServer['score'],
            'total_candidates' => $scoredServers->count(),
        ]);

        return $selectedServer['server'];
    }

    /**
     * Get all servers with their scores for visualization
     *
     * @param Organization $organization
     * @param array|null $customWeights
     * @return Collection
     */
    public function getServerScores(Organization $organization, ?array $customWeights = null): Collection
    {
        $servers = $organization->servers()
            ->where('status', 'active')
            ->get();

        return $servers->map(function (Server $server) use ($customWeights) {
            return [
                'server_id' => $server->id,
                'server_name' => $server->name,
                'score' => $this->calculateServerScore($server, $customWeights),
                'maintenance_mode' => $server->maintenance_mode,
                'manual_override' => $server->manual_score_override,
            ];
        })->sortByDesc('score')->values();
    }

    /**
     * Clear server score cache
     *
     * @param Server|null $server Specific server or null for all
     * @return void
     */
    public function clearScoreCache(?Server $server = null): void
    {
        if ($server) {
            Cache::forget("server_score:{$server->id}");
        } else {
            // Clear all server score caches (pattern-based)
            Cache::tags(['server_scores'])->flush();
        }
    }

    /**
     * Check if server can handle application requirements
     *
     * @param Server $server
     * @param array $requirements
     * @return bool
     */
    public function canServerHandleRequirements(Server $server, array $requirements): bool
    {
        $metrics = $this->resourceMonitor->getServerMetrics($server);

        if (!$metrics) {
            return false;
        }

        // Check CPU requirement
        if (isset($requirements['cpu'])) {
            $availableCpu = ($metrics['cpu_total'] ?? 0) - ($metrics['cpu_used'] ?? 0);
            if ($availableCpu < $requirements['cpu']) {
                return false;
            }
        }

        // Check memory requirement
        if (isset($requirements['memory'])) {
            $availableMemory = ($metrics['memory_total'] ?? 0) - ($metrics['memory_used'] ?? 0);
            if ($availableMemory < $requirements['memory']) {
                return false;
            }
        }

        // Check disk requirement
        if (isset($requirements['disk'])) {
            $availableDisk = ($metrics['disk_total'] ?? 0) - ($metrics['disk_used'] ?? 0);
            if ($availableDisk < $requirements['disk']) {
                return false;
            }
        }

        return true;
    }
}
```

### Interface Update

**File:** `app/Contracts/CapacityManagerInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Organization;
use App\Models\Server;
use Illuminate\Support\Collection;

interface CapacityManagerInterface
{
    /**
     * Calculate weighted score for a server
     *
     * @param Server $server
     * @param array|null $customWeights
     * @return float Score from 0-100
     */
    public function calculateServerScore(Server $server, ?array $customWeights = null): float;

    /**
     * Select optimal server from collection
     *
     * @param Collection<Server> $servers
     * @param array|null $requirements
     * @param array|null $customWeights
     * @return Server|null
     */
    public function selectOptimalServer(
        Collection $servers,
        ?array $requirements = null,
        ?array $customWeights = null
    ): ?Server;

    /**
     * Get all servers with scores
     *
     * @param Organization $organization
     * @param array|null $customWeights
     * @return Collection
     */
    public function getServerScores(Organization $organization, ?array $customWeights = null): Collection;

    /**
     * Clear server score cache
     *
     * @param Server|null $server
     * @return void
     */
    public function clearScoreCache(?Server $server = null): void;

    /**
     * Check if server can handle requirements
     *
     * @param Server $server
     * @param array $requirements
     * @return bool
     */
    public function canServerHandleRequirements(Server $server, array $requirements): bool;
}
```

### Configuration File

**File:** `config/enterprise.php` (add to existing config)

```php
return [
    // ... existing configuration ...

    'capacity' => [
        // Server scoring algorithm weights
        'scoring_weights' => [
            'cpu' => env('CAPACITY_WEIGHT_CPU', 0.30),
            'memory' => env('CAPACITY_WEIGHT_MEMORY', 0.30),
            'disk' => env('CAPACITY_WEIGHT_DISK', 0.20),
            'network' => env('CAPACITY_WEIGHT_NETWORK', 0.10),
            'load' => env('CAPACITY_WEIGHT_LOAD', 0.10),
        ],

        // Minimum score threshold (0-100)
        'min_score_threshold' => env('CAPACITY_MIN_SCORE', 50.0),

        // Score cache TTL in seconds
        'score_cache_ttl' => env('CAPACITY_SCORE_CACHE_TTL', 60),

        // Enable manual score overrides
        'allow_manual_overrides' => env('CAPACITY_ALLOW_OVERRIDES', true),

        // Application-specific weight profiles
        'weight_profiles' => [
            'cpu_intensive' => [
                'cpu' => 0.50,
                'memory' => 0.20,
                'disk' => 0.15,
                'network' => 0.10,
                'load' => 0.05,
            ],
            'memory_intensive' => [
                'cpu' => 0.20,
                'memory' => 0.50,
                'disk' => 0.15,
                'network' => 0.10,
                'load' => 0.05,
            ],
            'balanced' => [
                'cpu' => 0.30,
                'memory' => 0.30,
                'disk' => 0.20,
                'network' => 0.10,
                'load' => 0.10,
            ],
        ],
    ],
];
```

## Implementation Approach

### Step 1: Database Schema Enhancement
1. Create migration for server maintenance mode and manual overrides
2. Add indexes for efficient active server filtering
3. Run migration: `php artisan migrate`

### Step 2: Update CapacityManager Service
1. Add private score calculation methods for each factor
2. Implement `calculateServerScore()` main method
3. Add caching layer with Redis
4. Implement manual override logic

### Step 3: Implement Individual Factor Calculations
1. Implement `calculateCpuScore()` with normalization
2. Implement `calculateMemoryScore()` with normalization
3. Implement `calculateDiskScore()` with normalization
4. Implement `calculateNetworkScore()` with normalization
5. Implement `calculateLoadScore()` with inversion (low load = high score)

### Step 4: Implement Weighted Aggregation
1. Add configurable weight system
2. Validate weights sum to 1.0
3. Apply weights to individual scores
4. Scale result to 0-100 range

### Step 5: Implement Server Selection Logic
1. Update `selectOptimalServer()` to use scoring
2. Filter servers below threshold
3. Sort by score descending
4. Return highest-scoring server

### Step 6: Add Caching and Performance Optimization
1. Implement Redis caching with TTL
2. Add cache invalidation on metric updates
3. Optimize database queries with eager loading
4. Add performance logging

### Step 7: Configuration Management
1. Add config section to `config/enterprise.php`
2. Support environment variable overrides
3. Create weight profiles for different application types
4. Add validation for custom weights

### Step 8: Integration Testing
1. Unit test individual score calculations
2. Test weighted aggregation logic
3. Test server selection with various scenarios
4. Test caching behavior
5. Test maintenance mode exclusion

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/CapacityManagerScoringTest.php`

```php
<?php

use App\Models\Server;
use App\Models\Organization;
use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\SystemResourceMonitor;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    Cache::flush();
    $this->capacityManager = app(CapacityManager::class);
});

it('calculates CPU score correctly', function () {
    $server = Server::factory()->create([
        'cpu_count' => 8,
    ]);

    // Mock metrics: 6 of 8 cores used = 25% available
    $metrics = [
        'cpu_total' => 8,
        'cpu_used' => 6,
    ];

    $cpuScore = invade($this->capacityManager)->calculateCpuScore($server, $metrics);

    expect($cpuScore)->toBe(0.25); // 2/8 = 0.25
});

it('calculates memory score correctly', function () {
    $server = Server::factory()->create();

    $metrics = [
        'memory_total' => 16384, // 16GB in MB
        'memory_used' => 8192,   // 8GB used
    ];

    $memoryScore = invade($this->capacityManager)->calculateMemoryScore($server, $metrics);

    expect($memoryScore)->toBe(0.5); // 8GB free / 16GB total = 0.5
});

it('calculates disk score correctly', function () {
    $server = Server::factory()->create();

    $metrics = [
        'disk_total' => 1000000, // 1TB in MB
        'disk_used' => 750000,   // 750GB used
    ];

    $diskScore = invade($this->capacityManager)->calculateDiskScore($server, $metrics);

    expect($diskScore)->toBe(0.25); // 250GB free / 1TB total = 0.25
});

it('calculates network score correctly', function () {
    $server = Server::factory()->create();

    $metrics = [
        'network_bandwidth_total' => 10000, // 10Gbps in Mbps
        'network_bandwidth_used' => 2000,   // 2Gbps used
    ];

    $networkScore = invade($this->capacityManager)->calculateNetworkScore($server, $metrics);

    expect($networkScore)->toBe(0.8); // 8Gbps free / 10Gbps total = 0.8
});

it('calculates load score correctly with low load', function () {
    $server = Server::factory()->create(['cpu_count' => 4]);

    $metrics = [
        'cpu_total' => 4,
        'load_average_1min' => 0.5, // Very low load
    ];

    $loadScore = invade($this->capacityManager)->calculateLoadScore($server, $metrics);

    expect($loadScore)->toBeGreaterThan(0.9); // Low load = high score
});

it('calculates load score correctly with high load', function () {
    $server = Server::factory()->create(['cpu_count' => 4]);

    $metrics = [
        'cpu_total' => 4,
        'load_average_1min' => 8.0, // 2x CPU count = max load
    ];

    $loadScore = invade($this->capacityManager)->calculateLoadScore($server, $metrics);

    expect($loadScore)->toBe(0.0); // Very high load = zero score
});

it('calculates overall server score with default weights', function () {
    $server = Server::factory()->create([
        'cpu_count' => 8,
        'ram_total' => 16384,
        'disk_total' => 500000,
    ]);

    // Mock SystemResourceMonitor
    $this->mock(SystemResourceMonitor::class, function ($mock) {
        $mock->shouldReceive('getServerMetrics')
            ->andReturn([
                'cpu_total' => 8,
                'cpu_used' => 4,              // 50% free
                'memory_total' => 16384,
                'memory_used' => 8192,        // 50% free
                'disk_total' => 500000,
                'disk_used' => 250000,        // 50% free
                'network_bandwidth_total' => 1000,
                'network_bandwidth_used' => 500, // 50% free
                'load_average_1min' => 2.0,   // Moderate load
            ]);
    });

    $score = $this->capacityManager->calculateServerScore($server);

    // Expected: (0.5*0.3) + (0.5*0.3) + (0.5*0.2) + (0.5*0.1) + (0.75*0.1) = 0.575 * 100 = 57.5
    expect($score)->toBeBetween(57.0, 58.0);
});

it('excludes servers below minimum threshold', function () {
    $org = Organization::factory()->create();

    $goodServer = Server::factory()->create([
        'organization_id' => $org->id,
        'cpu_count' => 8,
    ]);

    $badServer = Server::factory()->create([
        'organization_id' => $org->id,
        'cpu_count' => 2,
    ]);

    // Mock good metrics for first server, poor for second
    $this->mock(SystemResourceMonitor::class, function ($mock) use ($goodServer, $badServer) {
        $mock->shouldReceive('getServerMetrics')
            ->with($goodServer)
            ->andReturn([
                'cpu_total' => 8,
                'cpu_used' => 2,              // 75% free
                'memory_total' => 16384,
                'memory_used' => 4096,        // 75% free
                'disk_total' => 500000,
                'disk_used' => 100000,        // 80% free
                'network_bandwidth_total' => 1000,
                'network_bandwidth_used' => 100,
                'load_average_1min' => 0.5,
            ]);

        $mock->shouldReceive('getServerMetrics')
            ->with($badServer)
            ->andReturn([
                'cpu_total' => 2,
                'cpu_used' => 1.9,            // 5% free
                'memory_total' => 4096,
                'memory_used' => 3900,        // 5% free
                'disk_total' => 100000,
                'disk_used' => 95000,         // 5% free
                'network_bandwidth_total' => 100,
                'network_bandwidth_used' => 95,
                'load_average_1min' => 4.0,   // High load
            ]);
    });

    $servers = collect([$goodServer, $badServer]);
    $selected = $this->capacityManager->selectOptimalServer($servers);

    expect($selected)->toBe($goodServer);
});

it('respects manual score override', function () {
    $server = Server::factory()->create([
        'cpu_count' => 8,
        'manual_score_override' => 95, // Manual override
    ]);

    $score = $this->capacityManager->calculateServerScore($server);

    expect($score)->toBe(95.0);
});

it('excludes servers in maintenance mode', function () {
    $server = Server::factory()->create([
        'maintenance_mode' => true,
    ]);

    $score = $this->capacityManager->calculateServerScore($server);

    expect($score)->toBe(0.0);
});

it('caches server scores for performance', function () {
    $server = Server::factory()->create();

    $this->mock(SystemResourceMonitor::class, function ($mock) {
        $mock->shouldReceive('getServerMetrics')
            ->once() // Should only be called once due to caching
            ->andReturn([
                'cpu_total' => 8,
                'cpu_used' => 4,
                'memory_total' => 16384,
                'memory_used' => 8192,
                'disk_total' => 500000,
                'disk_used' => 250000,
                'network_bandwidth_total' => 1000,
                'network_bandwidth_used' => 500,
                'load_average_1min' => 2.0,
            ]);
    });

    // First call - should hit resource monitor
    $score1 = $this->capacityManager->calculateServerScore($server);

    // Second call - should use cache
    $score2 = $this->capacityManager->calculateServerScore($server);

    expect($score1)->toBe($score2);
});

it('uses custom weights when provided', function () {
    $server = Server::factory()->create();

    $this->mock(SystemResourceMonitor::class, function ($mock) {
        $mock->shouldReceive('getServerMetrics')
            ->andReturn([
                'cpu_total' => 8,
                'cpu_used' => 4,              // 50% free
                'memory_total' => 16384,
                'memory_used' => 8192,        // 50% free
                'disk_total' => 500000,
                'disk_used' => 250000,        // 50% free
                'network_bandwidth_total' => 1000,
                'network_bandwidth_used' => 500,
                'load_average_1min' => 2.0,
            ]);
    });

    // CPU-intensive profile
    $customWeights = [
        'cpu' => 0.50,
        'memory' => 0.20,
        'disk' => 0.15,
        'network' => 0.10,
        'load' => 0.05,
    ];

    $score = $this->capacityManager->calculateServerScore($server, $customWeights);

    // With higher CPU weight, score should be different
    expect($score)->toBeGreaterThan(0);
});
```

### Integration Tests

**File:** `tests/Feature/Services/CapacityManagerIntegrationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use App\Services\Enterprise\CapacityManager;
use Illuminate\Support\Facades\Cache;

it('selects optimal server from organization pool', function () {
    $org = Organization::factory()->create();

    // Create servers with varying capacity
    $servers = collect([
        Server::factory()->create([
            'organization_id' => $org->id,
            'name' => 'High-End Server',
            'cpu_count' => 16,
            'ram_total' => 65536,
        ]),
        Server::factory()->create([
            'organization_id' => $org->id,
            'name' => 'Mid-Range Server',
            'cpu_count' => 8,
            'ram_total' => 32768,
        ]),
        Server::factory()->create([
            'organization_id' => $org->id,
            'name' => 'Low-End Server',
            'cpu_count' => 4,
            'ram_total' => 16384,
        ]),
    ]);

    // Simulate high-end server being heavily utilized
    // Mid-range server should be selected

    $capacityManager = app(CapacityManager::class);
    $selected = $capacityManager->selectOptimalServer($servers);

    expect($selected)->not->toBeNull();
    expect($selected->organization_id)->toBe($org->id);
});

it('handles server with no metrics gracefully', function () {
    $server = Server::factory()->create();

    $capacityManager = app(CapacityManager::class);
    $score = $capacityManager->calculateServerScore($server);

    expect($score)->toBe(0.0);
});

it('clears score cache correctly', function () {
    $server = Server::factory()->create();

    $capacityManager = app(CapacityManager::class);

    // Calculate and cache score
    $capacityManager->calculateServerScore($server);

    $cacheKey = "server_score:{$server->id}";
    expect(Cache::has($cacheKey))->toBeTrue();

    // Clear cache
    $capacityManager->clearScoreCache($server);

    expect(Cache::has($cacheKey))->toBeFalse();
});
```

## Definition of Done

- [ ] Server scoring method implemented in CapacityManager
- [ ] Weighted algorithm calculates scores using 5 factors
- [ ] CPU score calculation (30% weight) implemented
- [ ] Memory score calculation (30% weight) implemented
- [ ] Disk score calculation (20% weight) implemented
- [ ] Network score calculation (10% weight) implemented
- [ ] Load score calculation (10% weight) implemented
- [ ] Each metric normalized to 0-1 range
- [ ] Final score scaled to 0-100
- [ ] Minimum score threshold enforced
- [ ] Servers below threshold excluded
- [ ] Edge case handling (zero resources, missing metrics)
- [ ] Custom weight support implemented
- [ ] Application-specific weight profiles in config
- [ ] Integration with SystemResourceMonitor
- [ ] Server maintenance mode exclusion
- [ ] Manual score override support
- [ ] Redis caching for performance
- [ ] Cache invalidation logic
- [ ] Configuration file section added
- [ ] Environment variable support
- [ ] Unit tests written (15+ tests, >95% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Performance verified (< 50ms for 100 servers)
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Documentation updated (method PHPDocs)
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 26 (CapacityManager service foundation)
- **Integrates with:** Task 25 (SystemResourceMonitor provides metrics)
- **Integrates with:** Task 22 (server_resource_metrics table)
- **Used by:** Task 32-41 (Enhanced deployment strategies)
- **Visualized by:** Task 29 (ResourceDashboard.vue)
- **Visualized by:** Task 30 (CapacityPlanner.vue)
