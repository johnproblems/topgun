---
name: Implement server auto-registration with SSH key setup and Docker verification
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:38Z
github: https://github.com/johnproblems/topgun/issues/129
depends_on: [18]
parallel: false
conflicts_with: []
---

# Task: Implement server auto-registration with SSH key setup and Docker verification

## Description

Implement automated server registration that seamlessly integrates freshly provisioned cloud infrastructure with Coolify's server management system. This task transforms raw cloud instances into fully configured Coolify-managed servers through automated SSH key deployment, Docker installation verification, health checks, and database registration.

**The Post-Provisioning Gap:**

After Terraform successfully provisions cloud infrastructure (Task 18), the servers exist but remain disconnected from Coolify:
1. **No SSH Access**: Coolify can't connect without SSH keys deployed
2. **Unknown Docker Status**: Don't know if Docker is installed, running, and accessible
3. **Missing Registration**: Server isn't in Coolify's database for deployment targeting
4. **No Health Monitoring**: Can't verify server is ready to accept deployments
5. **Manual Intervention**: Admin must manually add servers via UI

This creates a workflow gap where infrastructure automation stops at provisioning, requiring manual completion steps. For every server provisioned, someone must:
- Copy SSH keys to the server
- Verify Docker installation and permissions
- Manually register the server in Coolify UI
- Run health checks to ensure readiness

**The Auto-Registration Solution:**

ServerRegistrationJob automates the complete post-provisioning workflow:

1. **Output Parsing**: Extracts IP addresses and instance IDs from Terraform outputs
2. **SSH Key Deployment**: Securely deploys Coolify's SSH public key to new servers
3. **Docker Verification**: Checks Docker daemon status and validates connectivity
4. **Health Validation**: Runs comprehensive health checks (disk space, network, permissions)
5. **Database Registration**: Creates Server model record linked to TerraformDeployment
6. **Coolify Integration**: Configures server for immediate deployment availability
7. **Monitoring Setup**: Initializes resource monitoring and capacity tracking

**Workflow Integration:**

```
Terraform Apply Completes (Task 18)
  ↓
TerraformDeploymentJob→completeDeployment()
  ↓
ServerRegistrationJob dispatched (10s delay)
  ↓
Parse Terraform outputs → [IP: 1.2.3.4, Instance ID: i-abc123]
  ↓
Wait for SSH accessibility (retry up to 5 minutes)
  ↓
Deploy SSH key → ssh-copy-id or cloud-init integration
  ↓
Verify Docker → docker version, docker ps (check daemon)
  ↓
Run health checks → disk space >10GB, network connectivity, Docker socket permissions
  ↓
Create Server model → Link to organization, deployment, set ready status
  ↓
Broadcast ServerRegistered event → Real-time UI updates
  ↓
Server ready for application deployments
```

**Integration Architecture:**

**Depends On:**
- **Task 18 (TerraformDeploymentJob)**: Dispatches this job after successful provisioning
- **Task 14 (TerraformService)**: Reads outputs for server metadata
- **Existing Server Model**: Creates and links new server records

**Uses:**
- **Existing SSH Management**: Coolify's SSH key infrastructure (`bootstrap/helpers/ssh.php`)
- **ExecuteRemoteCommand Trait**: For running commands on remote servers
- **Docker Verification Logic**: Similar to existing `ServerCheckJob`

**Why This Task is Critical:**

Auto-registration eliminates the manual bottleneck between infrastructure provisioning and deployment readiness. Without it, the Terraform integration only gets halfway to the goal—infrastructure exists but can't be used. This job completes the automation loop, delivering fully operational servers from a single "provision" button click.

It also provides immediate feedback when infrastructure is misconfigured (missing Docker, network issues, permission problems), catching problems early rather than during first deployment attempt. This saves debugging time and prevents half-configured servers from cluttering the system.

## Acceptance Criteria

- [ ] ServerRegistrationJob implements ShouldQueue for async execution
- [ ] Dispatches to 'server-management' queue with appropriate timeout
- [ ] Parses Terraform outputs to extract server IP addresses and instance IDs
- [ ] Waits for SSH accessibility with exponential backoff (max 5 minutes)
- [ ] Deploys Coolify SSH public key to new server via ssh-copy-id
- [ ] Verifies Docker daemon is installed and running
- [ ] Validates Docker socket is accessible with correct permissions
- [ ] Runs health checks: disk space, memory, network connectivity
- [ ] Creates Server model record with organization linkage
- [ ] Links Server to TerraformDeployment via foreign key
- [ ] Sets server status to 'ready' only after all validations pass
- [ ] Broadcasts ServerRegistered event for real-time UI updates
- [ ] Implements comprehensive error handling with descriptive messages
- [ ] Supports automatic retry logic (3 attempts, exponential backoff)
- [ ] Updates deployment status on registration failure
- [ ] Integrates with existing ExecuteRemoteCommand trait
- [ ] Horizon tags for monitoring and filtering

## Technical Details

### File Paths

**Job:**
- `/home/topgun/topgun/app/Jobs/Enterprise/ServerRegistrationJob.php` (new)

**Events:**
- `/home/topgun/topgun/app/Events/Enterprise/ServerRegistered.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/ServerRegistrationFailed.php` (new)

**Helpers:**
- `/home/topgun/topgun/bootstrap/helpers/ssh.php` (existing - enhance if needed)

**Artisan Command:**
- `/home/topgun/topgun/app/Console/Commands/RegisterServer.php` (new - for manual registration)

### Database Schema (Existing - No Changes Needed)

The job writes to the existing `servers` table with new fields added in Task 12:

```php
// Fields written by ServerRegistrationJob
'terraform_deployment_id' => BIGINT // Foreign key to terraform_deployments
'ip_address' => STRING // Extracted from Terraform outputs
'instance_id' => STRING // Cloud provider instance identifier
'status' => 'reachable|unreachable|ready|error'
'docker_version' => STRING // Detected Docker version
'health_check_status' => JSONB // Health check results
```

### ServerRegistrationJob Implementation

**File:** `app/Jobs/Enterprise/ServerRegistrationJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Events\Enterprise\ServerRegistered;
use App\Events\Enterprise\ServerRegistrationFailed;
use App\Models\Server;
use App\Models\TerraformDeployment;
use App\Traits\ExecuteRemoteCommand;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class ServerRegistrationJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    use ExecuteRemoteCommand;

    public int $tries = 3;
    public int $timeout = 600; // 10 minutes
    public int $backoff = 30; // Wait 30 seconds before retry

    private const SSH_WAIT_MAX_ATTEMPTS = 30; // 5 minutes with 10s intervals
    private const MIN_DISK_SPACE_GB = 10;
    private const MIN_MEMORY_MB = 512;

    /**
     * Create a new job instance
     *
     * @param int $deploymentId
     * @param string|null $sshKeyName Custom SSH key to use (optional)
     */
    public function __construct(
        public int $deploymentId,
        public ?string $sshKeyName = null
    ) {
        $this->onQueue('server-management');
    }

    /**
     * Execute the job
     *
     * @return void
     * @throws \Exception
     */
    public function handle(): void
    {
        $deployment = TerraformDeployment::with(['organization', 'cloudProviderCredential'])
            ->findOrFail($this->deploymentId);

        Log::info('Starting server auto-registration', [
            'deployment_id' => $deployment->id,
            'organization_id' => $deployment->organization_id,
            'attempt' => $this->attempts(),
        ]);

        try {
            // Step 1: Parse Terraform outputs
            $serverMetadata = $this->parseServerMetadata($deployment);

            // Step 2: Wait for SSH accessibility
            $this->waitForSshAccessibility($serverMetadata['ip']);

            // Step 3: Deploy SSH key
            $this->deploySshKey($serverMetadata['ip'], $deployment);

            // Step 4: Verify Docker installation
            $dockerInfo = $this->verifyDocker($serverMetadata['ip']);

            // Step 5: Run health checks
            $healthStatus = $this->runHealthChecks($serverMetadata['ip']);

            // Step 6: Register server in database
            $server = $this->registerServer($deployment, $serverMetadata, $dockerInfo, $healthStatus);

            // Step 7: Finalize and broadcast success
            $this->completeRegistration($server, $deployment);

        } catch (Throwable $e) {
            $this->handleFailure($deployment, $e);
            throw $e; // Re-throw for retry logic
        }
    }

    /**
     * Parse server metadata from Terraform outputs
     *
     * @param TerraformDeployment $deployment
     * @return array Server metadata
     * @throws \Exception
     */
    private function parseServerMetadata(TerraformDeployment $deployment): array
    {
        $outputs = $deployment->output_data ?? [];

        if (empty($outputs)) {
            throw new \Exception('No Terraform outputs available for server registration');
        }

        // Extract IP address (try common output names)
        $ip = $outputs['server_ip']
            ?? $outputs['instance_ip']
            ?? $outputs['public_ip']
            ?? $outputs['ipv4_address']
            ?? null;

        if (!$ip) {
            throw new \Exception('Server IP address not found in Terraform outputs');
        }

        // Extract instance ID
        $instanceId = $outputs['instance_id']
            ?? $outputs['server_id']
            ?? $outputs['resource_id']
            ?? null;

        // Extract additional metadata
        $metadata = [
            'ip' => $ip,
            'instance_id' => $instanceId,
            'provider' => $deployment->cloud_provider,
            'region' => $deployment->region,
            'hostname' => $outputs['hostname'] ?? null,
            'private_ip' => $outputs['private_ip'] ?? null,
        ];

        Log::info('Parsed server metadata from Terraform outputs', $metadata);

        return $metadata;
    }

    /**
     * Wait for SSH to become accessible on the server
     *
     * @param string $ip
     * @return void
     * @throws \Exception
     */
    private function waitForSshAccessibility(string $ip): void
    {
        Log::info('Waiting for SSH accessibility', ['ip' => $ip]);

        for ($attempt = 1; $attempt <= self::SSH_WAIT_MAX_ATTEMPTS; $attempt++) {
            try {
                // Test SSH connection with timeout
                $result = instant_remote_process([
                    'echo "SSH test successful"'
                ], $ip, throwError: false);

                if ($result->getExitCode() === 0) {
                    Log::info('SSH is accessible', [
                        'ip' => $ip,
                        'attempts' => $attempt,
                    ]);
                    return;
                }
            } catch (\Exception $e) {
                // SSH not ready yet, continue waiting
            }

            if ($attempt < self::SSH_WAIT_MAX_ATTEMPTS) {
                Log::debug('SSH not yet accessible, retrying...', [
                    'ip' => $ip,
                    'attempt' => $attempt,
                    'max_attempts' => self::SSH_WAIT_MAX_ATTEMPTS,
                ]);

                sleep(10); // Wait 10 seconds between attempts
            }
        }

        throw new \Exception(
            "SSH failed to become accessible after " .
            self::SSH_WAIT_MAX_ATTEMPTS * 10 . " seconds"
        );
    }

    /**
     * Deploy Coolify SSH key to the new server
     *
     * @param string $ip
     * @param TerraformDeployment $deployment
     * @return void
     * @throws \Exception
     */
    private function deploySshKey(string $ip, TerraformDeployment $deployment): void
    {
        Log::info('Deploying SSH key to server', ['ip' => $ip]);

        // Get Coolify's SSH public key
        $sshKeyPath = $this->sshKeyName
            ? "/home/coolify/.ssh/{$this->sshKeyName}.pub"
            : '/home/coolify/.ssh/id_ed25519.pub';

        if (!file_exists($sshKeyPath)) {
            throw new \Exception("SSH public key not found: {$sshKeyPath}");
        }

        $publicKey = trim(file_get_contents($sshKeyPath));

        // Deploy key to server's authorized_keys
        $commands = [
            'mkdir -p ~/.ssh',
            'chmod 700 ~/.ssh',
            'touch ~/.ssh/authorized_keys',
            'chmod 600 ~/.ssh/authorized_keys',
            sprintf('grep -qF "%s" ~/.ssh/authorized_keys || echo "%s" >> ~/.ssh/authorized_keys', $publicKey, $publicKey),
        ];

        // Use cloud provider's initial SSH method (typically root or ubuntu with cloud-init key)
        $initialSshUser = $this->getInitialSshUser($deployment->cloud_provider);

        try {
            foreach ($commands as $command) {
                instant_remote_process(
                    [$command],
                    $ip,
                    user: $initialSshUser,
                    throwError: true
                );
            }

            Log::info('SSH key deployed successfully', ['ip' => $ip]);

        } catch (\Exception $e) {
            throw new \Exception("Failed to deploy SSH key: {$e->getMessage()}");
        }
    }

    /**
     * Verify Docker is installed and running
     *
     * @param string $ip
     * @return array Docker information
     * @throws \Exception
     */
    private function verifyDocker(string $ip): array
    {
        Log::info('Verifying Docker installation', ['ip' => $ip]);

        // Check Docker version
        try {
            $versionResult = instant_remote_process(
                ['docker --version'],
                $ip,
                throwError: true
            );

            $versionOutput = trim($versionResult->getOutput());

            // Parse version from output (e.g., "Docker version 24.0.7, build afdd53b")
            preg_match('/Docker version ([\d.]+)/', $versionOutput, $matches);
            $dockerVersion = $matches[1] ?? 'unknown';

        } catch (\Exception $e) {
            throw new \Exception("Docker is not installed or not accessible: {$e->getMessage()}");
        }

        // Check Docker daemon is running
        try {
            instant_remote_process(
                ['docker ps'],
                $ip,
                throwError: true
            );
        } catch (\Exception $e) {
            throw new \Exception("Docker daemon is not running: {$e->getMessage()}");
        }

        // Check Docker socket permissions
        try {
            $socketCheck = instant_remote_process(
                ['test -w /var/run/docker.sock && echo "writable" || echo "not writable"'],
                $ip,
                throwError: false
            );

            $socketStatus = trim($socketCheck->getOutput());

            if ($socketStatus !== 'writable') {
                Log::warning('Docker socket is not writable by current user', ['ip' => $ip]);
            }
        } catch (\Exception $e) {
            // Non-fatal - log and continue
            Log::warning('Failed to check Docker socket permissions', [
                'ip' => $ip,
                'error' => $e->getMessage(),
            ]);
        }

        Log::info('Docker verification successful', [
            'ip' => $ip,
            'docker_version' => $dockerVersion,
        ]);

        return [
            'version' => $dockerVersion,
            'daemon_running' => true,
            'socket_accessible' => true,
        ];
    }

    /**
     * Run comprehensive health checks
     *
     * @param string $ip
     * @return array Health check results
     */
    private function runHealthChecks(string $ip): array
    {
        Log::info('Running server health checks', ['ip' => $ip]);

        $healthStatus = [
            'disk_space_ok' => false,
            'memory_ok' => false,
            'network_ok' => false,
            'overall_status' => 'unhealthy',
        ];

        // Check disk space
        try {
            $diskResult = instant_remote_process(
                ['df -BG / | tail -1 | awk \'{print $4}\' | sed \'s/G//\''],
                $ip,
                throwError: false
            );

            $availableGb = (int) trim($diskResult->getOutput());

            if ($availableGb >= self::MIN_DISK_SPACE_GB) {
                $healthStatus['disk_space_ok'] = true;
                $healthStatus['disk_available_gb'] = $availableGb;
            } else {
                $healthStatus['disk_error'] = "Insufficient disk space: {$availableGb}GB (minimum: " . self::MIN_DISK_SPACE_GB . "GB)";
            }
        } catch (\Exception $e) {
            $healthStatus['disk_error'] = "Failed to check disk space: {$e->getMessage()}";
        }

        // Check available memory
        try {
            $memResult = instant_remote_process(
                ['free -m | grep Mem | awk \'{print $7}\''],
                $ip,
                throwError: false
            );

            $availableMb = (int) trim($memResult->getOutput());

            if ($availableMb >= self::MIN_MEMORY_MB) {
                $healthStatus['memory_ok'] = true;
                $healthStatus['memory_available_mb'] = $availableMb;
            } else {
                $healthStatus['memory_error'] = "Insufficient memory: {$availableMb}MB (minimum: " . self::MIN_MEMORY_MB . "MB)";
            }
        } catch (\Exception $e) {
            $healthStatus['memory_error'] = "Failed to check memory: {$e->getMessage()}";
        }

        // Check network connectivity (can reach internet)
        try {
            $networkResult = instant_remote_process(
                ['ping -c 1 -W 2 8.8.8.8 > /dev/null 2>&1 && echo "ok" || echo "failed"'],
                $ip,
                throwError: false
            );

            $networkStatus = trim($networkResult->getOutput());
            $healthStatus['network_ok'] = ($networkStatus === 'ok');

            if ($networkStatus !== 'ok') {
                $healthStatus['network_error'] = 'Server cannot reach internet';
            }
        } catch (\Exception $e) {
            $healthStatus['network_error'] = "Failed to check network: {$e->getMessage()}";
        }

        // Determine overall status
        if ($healthStatus['disk_space_ok'] && $healthStatus['memory_ok'] && $healthStatus['network_ok']) {
            $healthStatus['overall_status'] = 'healthy';
        }

        Log::info('Health checks completed', [
            'ip' => $ip,
            'status' => $healthStatus['overall_status'],
        ]);

        return $healthStatus;
    }

    /**
     * Register server in database
     *
     * @param TerraformDeployment $deployment
     * @param array $metadata
     * @param array $dockerInfo
     * @param array $healthStatus
     * @return Server
     */
    private function registerServer(
        TerraformDeployment $deployment,
        array $metadata,
        array $dockerInfo,
        array $healthStatus
    ): Server {
        Log::info('Registering server in database', [
            'deployment_id' => $deployment->id,
            'ip' => $metadata['ip'],
        ]);

        // Determine server name
        $serverName = $deployment->name
            ?? "{$deployment->cloud_provider}-{$metadata['instance_id']}"
            ?? "server-{$metadata['ip']}";

        // Create Server model
        $server = Server::create([
            'uuid' => (string) new \Visus\Cuid2\Cuid2(),
            'name' => $serverName,
            'description' => "Auto-registered from Terraform deployment {$deployment->id}",
            'ip' => $metadata['ip'],
            'user' => 'root', // Default user, can be customized
            'port' => 22,
            'team_id' => $deployment->organization->currentTeam?->id, // Maintain backward compatibility
            'private_key_id' => $this->getPrivateKeyId(),
            'terraform_deployment_id' => $deployment->id,

            // Metadata from provisioning
            'instance_id' => $metadata['instance_id'],
            'provider' => $metadata['provider'],
            'region' => $metadata['region'],

            // Docker information
            'docker_version' => $dockerInfo['version'],

            // Health check results
            'health_check_status' => $healthStatus,

            // Status
            'status' => $healthStatus['overall_status'] === 'healthy' ? 'ready' : 'error',
            'is_reachable' => true,
            'is_usable' => $healthStatus['overall_status'] === 'healthy',

            // Additional metadata
            'validation_logs' => [
                'registered_at' => now()->toIso8601String(),
                'docker_verified' => $dockerInfo,
                'health_checks' => $healthStatus,
            ],
        ]);

        Log::info('Server registered successfully', [
            'server_id' => $server->id,
            'server_name' => $server->name,
            'ip' => $server->ip,
        ]);

        return $server;
    }

    /**
     * Complete registration and broadcast success
     *
     * @param Server $server
     * @param TerraformDeployment $deployment
     * @return void
     */
    private function completeRegistration(Server $server, TerraformDeployment $deployment): void
    {
        // Update deployment with server reference
        $deployment->update([
            'server_id' => $server->id,
            'registration_completed_at' => now(),
        ]);

        // Broadcast success event
        broadcast(new ServerRegistered($server, $deployment))->toOthers();

        Log::info('Server registration completed successfully', [
            'server_id' => $server->id,
            'deployment_id' => $deployment->id,
            'duration_seconds' => now()->diffInSeconds($deployment->started_at),
        ]);
    }

    /**
     * Handle registration failure
     *
     * @param TerraformDeployment $deployment
     * @param Throwable $exception
     * @return void
     */
    private function handleFailure(TerraformDeployment $deployment, Throwable $exception): void
    {
        $errorMessage = sprintf(
            "Server registration failed: %s in %s:%d",
            $exception->getMessage(),
            $exception->getFile(),
            $exception->getLine()
        );

        $deployment->update([
            'registration_status' => 'failed',
            'registration_error' => $errorMessage,
        ]);

        // Broadcast failure event
        broadcast(new ServerRegistrationFailed($deployment, $exception->getMessage()))
            ->toOthers();

        Log::error('Server registration failed', [
            'deployment_id' => $deployment->id,
            'attempt' => $this->attempts(),
            'error' => $exception->getMessage(),
            'trace' => $exception->getTraceAsString(),
        ]);
    }

    /**
     * Get initial SSH user for cloud provider
     *
     * @param string $provider
     * @return string
     */
    private function getInitialSshUser(string $provider): string
    {
        return match ($provider) {
            'aws' => 'ubuntu', // Ubuntu AMI default
            'digitalocean' => 'root',
            'hetzner' => 'root',
            'gcp' => 'ubuntu',
            'azure' => 'azureuser',
            default => 'root',
        };
    }

    /**
     * Get private key ID for SSH authentication
     *
     * @return int|null
     */
    private function getPrivateKeyId(): ?int
    {
        // Get default private key from Coolify's settings
        // This would typically be the server's main SSH key
        $defaultKey = \App\Models\PrivateKey::where('is_git_related', false)
            ->first();

        return $defaultKey?->id;
    }

    /**
     * Handle job failure after all retries exhausted
     *
     * @param Throwable $exception
     * @return void
     */
    public function failed(Throwable $exception): void
    {
        $deployment = TerraformDeployment::find($this->deploymentId);

        if ($deployment) {
            $deployment->update([
                'registration_status' => 'failed',
                'registration_error' => 'Permanent failure after ' . $this->tries . ' attempts: ' . $exception->getMessage(),
            ]);

            Log::error('Server registration job failed permanently', [
                'deployment_id' => $deployment->id,
                'attempts' => $this->tries,
                'error' => $exception->getMessage(),
            ]);
        }
    }

    /**
     * Get Horizon tags for filtering
     *
     * @return array<int, string>
     */
    public function tags(): array
    {
        $deployment = TerraformDeployment::find($this->deploymentId);

        $tags = ['server-registration', 'infrastructure'];

        if ($deployment) {
            $tags[] = "organization:{$deployment->organization_id}";
            $tags[] = "deployment:{$deployment->id}";
            $tags[] = "provider:{$deployment->cloud_provider}";
        }

        return $tags;
    }
}
```

### WebSocket Events

**File:** `app/Events/Enterprise/ServerRegistered.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Server;
use App\Models\TerraformDeployment;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ServerRegistered implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public Server $server,
        public TerraformDeployment $deployment
    ) {}

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->deployment->organization_id}.servers");
    }

    public function broadcastWith(): array
    {
        return [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'ip_address' => $this->server->ip,
            'status' => $this->server->status,
            'deployment_id' => $this->deployment->id,
            'docker_version' => $this->server->docker_version,
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

**File:** `app/Events/Enterprise/ServerRegistrationFailed.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\TerraformDeployment;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ServerRegistrationFailed implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public TerraformDeployment $deployment,
        public string $errorMessage
    ) {}

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->deployment->organization_id}.servers");
    }

    public function broadcastWith(): array
    {
        return [
            'deployment_id' => $this->deployment->id,
            'status' => 'registration_failed',
            'error' => $this->errorMessage,
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

### Artisan Command for Manual Registration

**File:** `app/Console/Commands/RegisterServer.php`

```php
<?php

namespace App\Console\Commands;

use App\Jobs\Enterprise\ServerRegistrationJob;
use App\Models\TerraformDeployment;
use Illuminate\Console\Command;

class RegisterServer extends Command
{
    protected $signature = 'server:register
                            {deployment : Terraform deployment ID}
                            {--sync : Run synchronously instead of queuing}
                            {--ssh-key= : Custom SSH key name to use}';

    protected $description = 'Register server from Terraform deployment';

    public function handle(): int
    {
        $deploymentId = $this->argument('deployment');
        $sync = $this->option('sync');
        $sshKey = $this->option('ssh-key');

        $deployment = TerraformDeployment::find($deploymentId);

        if (!$deployment) {
            $this->error("Deployment {$deploymentId} not found");
            return self::FAILURE;
        }

        if ($deployment->status !== 'completed') {
            $this->error("Deployment must be completed before registration (current status: {$deployment->status})");
            return self::FAILURE;
        }

        $this->info("Registering server from deployment: {$deployment->id}");
        $this->info("Provider: {$deployment->cloud_provider}");

        $job = new ServerRegistrationJob($deployment->id, $sshKey);

        if ($sync) {
            $this->warn('Running synchronously - this may take several minutes...');

            try {
                $job->handle();

                $this->info('✓ Server registration completed successfully');
                return self::SUCCESS;
            } catch (\Exception $e) {
                $this->error("✗ Registration failed: {$e->getMessage()}");
                return self::FAILURE;
            }
        }

        // Queue the job
        dispatch($job);

        $this->info('✓ Registration job dispatched to queue');
        $this->info('Monitor progress in Horizon or check deployment status');

        return self::SUCCESS;
    }
}
```

## Implementation Approach

### Step 1: Create Job Class
1. Create ServerRegistrationJob implementing ShouldQueue
2. Configure queue name, retries, timeout, backoff
3. Add constructor with deployment ID and optional SSH key parameter
4. Import ExecuteRemoteCommand trait

### Step 2: Implement Output Parsing
1. Create parseServerMetadata() method
2. Extract IP address from Terraform outputs
3. Extract instance ID and other metadata
4. Handle various output naming conventions
5. Validate required fields are present

### Step 3: Implement SSH Accessibility Check
1. Create waitForSshAccessibility() method
2. Implement retry loop with exponential backoff
3. Use instant_remote_process() for SSH testing
4. Set maximum wait time (5 minutes)
5. Log progress at each attempt

### Step 4: Implement SSH Key Deployment
1. Create deploySshKey() method
2. Read Coolify's public SSH key from filesystem
3. Determine initial SSH user based on cloud provider
4. Deploy key to server's ~/.ssh/authorized_keys
5. Set correct file permissions (700 for .ssh, 600 for authorized_keys)

### Step 5: Implement Docker Verification
1. Create verifyDocker() method
2. Check Docker version via `docker --version`
3. Verify daemon running via `docker ps`
4. Check Docker socket permissions
5. Return Docker information for database storage

### Step 6: Implement Health Checks
1. Create runHealthChecks() method
2. Check disk space (minimum 10GB required)
3. Check available memory (minimum 512MB)
4. Test network connectivity (ping 8.8.8.8)
5. Return comprehensive health status

### Step 7: Implement Server Registration
1. Create registerServer() method
2. Generate server name from deployment metadata
3. Create Server model with all extracted data
4. Link to TerraformDeployment via foreign key
5. Set status based on health check results

### Step 8: Create WebSocket Events
1. ServerRegistered for successful registration
2. ServerRegistrationFailed for errors
3. Broadcast to organization-specific channels
4. Include relevant metadata in broadcasts

### Step 9: Build Artisan Command
1. Create server:register command
2. Add --sync flag for immediate execution
3. Add --ssh-key flag for custom key selection
4. Implement validation and error handling

### Step 10: Integration Testing
1. Test full registration flow
2. Test SSH wait and retry logic
3. Test error handling for missing Docker
4. Test health check failures
5. Test WebSocket broadcasting

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Jobs/ServerRegistrationJobTest.php`

```php
<?php

use App\Jobs\Enterprise\ServerRegistrationJob;
use App\Models\Server;
use App\Models\TerraformDeployment;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;

it('dispatches to server-management queue', function () {
    Queue::fake();

    $deployment = TerraformDeployment::factory()->create();

    ServerRegistrationJob::dispatch($deployment->id);

    Queue::assertPushedOn('server-management', ServerRegistrationJob::class);
});

it('parses server metadata from Terraform outputs', function () {
    $deployment = TerraformDeployment::factory()->create([
        'output_data' => [
            'server_ip' => '1.2.3.4',
            'instance_id' => 'i-abc123',
            'hostname' => 'web-server-01',
        ],
    ]);

    $job = new ServerRegistrationJob($deployment->id);
    $metadata = invade($job)->parseServerMetadata($deployment);

    expect($metadata)
        ->toHaveKey('ip', '1.2.3.4')
        ->toHaveKey('instance_id', 'i-abc123')
        ->toHaveKey('hostname', 'web-server-01');
});

it('throws exception when IP address is missing', function () {
    $deployment = TerraformDeployment::factory()->create([
        'output_data' => ['instance_id' => 'i-abc123'], // Missing IP
    ]);

    $job = new ServerRegistrationJob($deployment->id);

    expect(fn() => invade($job)->parseServerMetadata($deployment))
        ->toThrow(\Exception::class, 'Server IP address not found');
});

it('registers server successfully', function () {
    $deployment = TerraformDeployment::factory()->create([
        'output_data' => [
            'server_ip' => '1.2.3.4',
            'instance_id' => 'i-abc123',
        ],
    ]);

    $metadata = [
        'ip' => '1.2.3.4',
        'instance_id' => 'i-abc123',
        'provider' => 'aws',
        'region' => 'us-east-1',
    ];

    $dockerInfo = [
        'version' => '24.0.7',
        'daemon_running' => true,
    ];

    $healthStatus = [
        'disk_space_ok' => true,
        'memory_ok' => true,
        'network_ok' => true,
        'overall_status' => 'healthy',
    ];

    $job = new ServerRegistrationJob($deployment->id);
    $server = invade($job)->registerServer($deployment, $metadata, $dockerInfo, $healthStatus);

    expect($server)
        ->toBeInstanceOf(Server::class)
        ->ip->toBe('1.2.3.4')
        ->instance_id->toBe('i-abc123')
        ->status->toBe('ready')
        ->docker_version->toBe('24.0.7');
});

it('broadcasts ServerRegistered event on success', function () {
    Event::fake([ServerRegistered::class]);

    // Mock successful execution
    $deployment = TerraformDeployment::factory()->create([
        'output_data' => ['server_ip' => '1.2.3.4', 'instance_id' => 'i-123'],
    ]);

    // Would need to mock SSH and Docker checks in real test
    // For unit test, we can test event broadcasting directly

    $server = Server::factory()->create();
    broadcast(new \App\Events\Enterprise\ServerRegistered($server, $deployment));

    Event::assertDispatched(ServerRegistered::class);
});

it('has correct Horizon tags', function () {
    $deployment = TerraformDeployment::factory()->create([
        'cloud_provider' => 'aws',
    ]);

    $job = new ServerRegistrationJob($deployment->id);
    $tags = $job->tags();

    expect($tags)->toContain('server-registration');
    expect($tags)->toContain("organization:{$deployment->organization_id}");
    expect($tags)->toContain("deployment:{$deployment->id}");
    expect($tags)->toContain("provider:aws");
});
```

### Integration Tests

**File:** `tests/Feature/ServerAutoRegistrationTest.php`

```php
<?php

use App\Jobs\Enterprise\ServerRegistrationJob;
use App\Models\Server;
use App\Models\TerraformDeployment;
use Illuminate\Support\Facades\Queue;

it('registers server end-to-end', function () {
    // This test would require actual server or sophisticated mocking
    // Skipped in CI, run manually with real infrastructure
})->skip('Requires real server infrastructure');

it('queues job after Terraform completion', function () {
    Queue::fake();

    $deployment = TerraformDeployment::factory()->create([
        'status' => 'completed',
        'output_data' => [
            'server_ip' => '1.2.3.4',
            'instance_id' => 'i-abc123',
        ],
    ]);

    // Simulate TerraformDeploymentJob completion
    ServerRegistrationJob::dispatch($deployment->id);

    Queue::assertPushed(ServerRegistrationJob::class, function ($job) use ($deployment) {
        return $job->deploymentId === $deployment->id;
    });
});
```

## Definition of Done

- [ ] ServerRegistrationJob created implementing ShouldQueue
- [ ] Dispatches to 'server-management' queue
- [ ] Parses Terraform outputs for IP and instance ID
- [ ] Waits for SSH accessibility with retry logic
- [ ] Deploys Coolify SSH public key to server
- [ ] Verifies Docker daemon installation and status
- [ ] Validates Docker socket permissions
- [ ] Runs comprehensive health checks
- [ ] Creates Server model with complete metadata
- [ ] Links Server to TerraformDeployment
- [ ] Sets server status based on health checks
- [ ] ServerRegistered event created and broadcasts
- [ ] ServerRegistrationFailed event created
- [ ] Events broadcast to organization channels
- [ ] server:register Artisan command created
- [ ] Command supports --sync and --ssh-key flags
- [ ] Implements retry logic (3 attempts, exponential backoff)
- [ ] ExecuteRemoteCommand trait integration working
- [ ] Horizon tags implemented
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written
- [ ] Error handling comprehensive
- [ ] Documentation added to methods
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Manual testing with real provisioned servers
- [ ] Code reviewed and approved
