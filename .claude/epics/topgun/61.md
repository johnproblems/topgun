---
name: Add comprehensive API tests with rate limiting validation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:15Z
github: https://github.com/johnproblems/topgun/issues/169
depends_on: [52, 53, 54, 55, 56]
parallel: false
conflicts_with: []
---

# Task: Add comprehensive API tests with rate limiting validation

## Description

Create a comprehensive test suite for the Coolify Enterprise API system that validates organization-scoped access, tiered rate limiting, authentication mechanisms, and all enterprise feature endpoints. This test suite ensures the API layer properly enforces multi-tenant security, respects license-based rate limits, and provides correct responses across all enterprise functionality.

The Coolify Enterprise API introduces organization-scoped access control and tiered rate limiting based on license tiers (Starter, Professional, Enterprise). This testing task validates that:

1. **Organization Scoping Works Correctly**: API requests can only access resources within the authenticated organization's scope
2. **Rate Limiting Enforces License Tiers**: Different license tiers have different rate limits (Starter: 100/min, Pro: 500/min, Enterprise: 2000/min)
3. **API Authentication is Secure**: Sanctum tokens are properly scoped with organization context
4. **Cross-Tenant Leakage is Prevented**: Organizations cannot access each other's resources via API
5. **Rate Limit Headers are Accurate**: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers reflect actual state
6. **New Enterprise Endpoints Function**: Organization management, resource monitoring, infrastructure provisioning APIs work correctly

**Integration Context:**
- **Depends on Task 52**: Extended Sanctum tokens with organization context
- **Depends on Task 53**: ApiOrganizationScope middleware implementation
- **Depends on Task 54**: Tiered rate limiting middleware with Redis
- **Depends on Task 55**: Rate limit response headers
- **Depends on Task 56**: New enterprise API endpoints

**Why this task is critical:** API security is the foundation of multi-tenant systems. Inadequate testing could expose organization data leakage vulnerabilities, allow rate limit bypasses, or permit unauthorized access. Comprehensive API testing validates the security architecture and ensures the enterprise platform is production-ready. This test suite will serve as continuous validation during development and prevent regressions in security-critical functionality.

**Testing Philosophy**: This test suite uses **black-box API testing** where tests interact only with HTTP endpoints (not internal services), validating the complete request/response cycle including middleware, authentication, authorization, and rate limiting. This approach mirrors real-world API usage and catches integration issues that unit tests miss.

## Acceptance Criteria

### Organization Scoping Tests
- [ ] API requests can only access resources within the authenticated organization
- [ ] Cross-organization resource access returns 403 Forbidden
- [ ] Organization context is correctly extracted from Sanctum token
- [ ] Child organization API requests respect parent organization permissions
- [ ] Organization switching via API token is prevented

### Rate Limiting Tests
- [ ] Starter tier enforces 100 requests/minute limit
- [ ] Professional tier enforces 500 requests/minute limit
- [ ] Enterprise tier enforces 2000 requests/minute limit
- [ ] Rate limiting uses Redis for distributed tracking
- [ ] Rate limit headers are accurate and updated on each request
- [ ] 429 Too Many Requests response returned when limit exceeded
- [ ] Rate limit resets correctly after time window expires

### Authentication & Authorization
- [ ] Valid Sanctum token grants access to organization resources
- [ ] Invalid/expired tokens return 401 Unauthorized
- [ ] Tokens without organization scope return 403 Forbidden
- [ ] Token abilities are respected (read-only vs read-write)
- [ ] API token revocation immediately prevents access

### Enterprise Endpoint Coverage
- [ ] Organization management endpoints tested (list, show, create, update, delete)
- [ ] Resource monitoring endpoints tested (metrics, capacity, usage)
- [ ] Infrastructure provisioning endpoints tested (Terraform operations)
- [ ] White-label branding endpoints tested (CSS, logos, themes)
- [ ] Payment & billing endpoints tested (subscriptions, invoices)

### Performance & Edge Cases
- [ ] Concurrent requests from same organization handled correctly
- [ ] High-volume requests don't cause rate limit calculation errors
- [ ] Invalid request payloads return proper validation errors
- [ ] Large response payloads are paginated correctly
- [ ] API remains responsive under load (< 200ms p95)

## Technical Details

### File Paths

**Test Files:**
- `/home/topgun/topgun/tests/Feature/Api/V1/OrganizationScopingTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/RateLimitingTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/AuthenticationTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/Enterprise/OrganizationApiTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/Enterprise/ResourceMonitoringApiTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/Enterprise/InfrastructureApiTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/Enterprise/WhiteLabelApiTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/V1/Enterprise/BillingApiTest.php` (new)

**Testing Traits:**
- `/home/topgun/topgun/tests/Traits/InteractsWithApi.php` (new - API testing helpers)
- `/home/topgun/topgun/tests/Traits/AssertsRateLimiting.php` (new - rate limit assertions)

**Configuration:**
- `/home/topgun/topgun/phpunit.xml` - Add API test suite configuration
- `/home/topgun/topgun/tests/Datasets/RateLimitTiers.php` (new - Pest datasets)

### API Testing Architecture

All tests follow the **Pest BDD (Behavior-Driven Development)** style and use Laravel's HTTP testing capabilities:

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Models\EnterpriseLicense;
use Laravel\Sanctum\Sanctum;

// Test naming pattern: it('describes expected behavior', function () { ... })

it('restricts API access to authenticated organization resources only', function () {
    // Arrange: Create two organizations with resources
    $orgA = Organization::factory()->create(['name' => 'Company A']);
    $orgB = Organization::factory()->create(['name' => 'Company B']);

    $userA = User::factory()->create();
    $orgA->users()->attach($userA, ['role' => 'admin']);

    $serverA = Server::factory()->create(['organization_id' => $orgA->id]);
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // Act: User A attempts to access Server B via API
    Sanctum::actingAs($userA, ['*'], 'api');

    $response = $this->getJson("/api/v1/servers/{$serverB->id}");

    // Assert: Access denied with 403 Forbidden
    $response->assertForbidden();
    $response->assertJson([
        'message' => 'This resource does not belong to your organization.',
    ]);
});

it('enforces rate limits based on license tier', function (string $tier, int $limit) {
    // Arrange: Create organization with specific license tier
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'tier' => $tier,
        'rate_limit_per_minute' => $limit,
    ]);

    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Sanctum::actingAs($user, ['*'], 'api');

    // Act: Make requests up to the limit
    for ($i = 0; $i < $limit; $i++) {
        $response = $this->getJson('/api/v1/organizations');

        if ($i < $limit - 1) {
            $response->assertOk();
            $response->assertHeader('X-RateLimit-Remaining', (string)($limit - $i - 1));
        }
    }

    // Final request should hit rate limit
    $response = $this->getJson('/api/v1/organizations');

    // Assert: 429 Too Many Requests with proper headers
    $response->assertStatus(429);
    $response->assertHeader('X-RateLimit-Limit', (string)$limit);
    $response->assertHeader('X-RateLimit-Remaining', '0');
    $response->assertHeader('Retry-After');

})->with([
    ['starter', 100],
    ['professional', 500],
    ['enterprise', 2000],
]);
```

### Testing Trait: InteractsWithApi

**File:** `tests/Traits/InteractsWithApi.php`

```php
<?php

namespace Tests\Traits;

use App\Models\Organization;
use App\Models\User;
use App\Models\EnterpriseLicense;
use Laravel\Sanctum\Sanctum;

trait InteractsWithApi
{
    /**
     * Create an organization with a user and authenticate as them
     *
     * @param string $tier License tier (starter, professional, enterprise)
     * @param array $abilities Token abilities (default: ['*'])
     * @return array ['organization' => Organization, 'user' => User, 'license' => EnterpriseLicense]
     */
    protected function createAuthenticatedOrganization(
        string $tier = 'professional',
        array $abilities = ['*']
    ): array {
        $organization = Organization::factory()->create();

        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => $tier,
            'rate_limit_per_minute' => match($tier) {
                'starter' => 100,
                'professional' => 500,
                'enterprise' => 2000,
                default => 100,
            },
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Authenticate with Sanctum
        Sanctum::actingAs($user, $abilities, 'api');

        return [
            'organization' => $organization,
            'user' => $user,
            'license' => $license,
        ];
    }

    /**
     * Assert API response has correct rate limit headers
     *
     * @param \Illuminate\Testing\TestResponse $response
     * @param int $limit Expected rate limit
     * @param int|null $remaining Expected remaining requests (null to skip)
     */
    protected function assertRateLimitHeaders($response, int $limit, ?int $remaining = null): void
    {
        $response->assertHeader('X-RateLimit-Limit', (string)$limit);

        if ($remaining !== null) {
            $response->assertHeader('X-RateLimit-Remaining', (string)$remaining);
        }

        $response->assertHeader('X-RateLimit-Reset');
    }

    /**
     * Make multiple API requests and return the last response
     *
     * @param string $method HTTP method
     * @param string $uri Request URI
     * @param int $count Number of requests
     * @param array $data Request data
     * @return \Illuminate\Testing\TestResponse
     */
    protected function makeMultipleRequests(
        string $method,
        string $uri,
        int $count,
        array $data = []
    ) {
        $response = null;

        for ($i = 0; $i < $count; $i++) {
            $response = $this->{$method . 'Json'}($uri, $data);
        }

        return $response;
    }

    /**
     * Create a Sanctum token with specific organization and abilities
     *
     * @param User $user
     * @param Organization $organization
     * @param array $abilities
     * @return string Token string
     */
    protected function createOrganizationToken(
        User $user,
        Organization $organization,
        array $abilities = ['*']
    ): string {
        return $user->createToken('api-token', $abilities, [
            'organization_id' => $organization->id,
        ])->plainTextToken;
    }
}
```

### Testing Trait: AssertsRateLimiting

**File:** `tests/Traits/AssertsRateLimiting.php`

```php
<?php

namespace Tests\Traits;

use Illuminate\Support\Facades\Redis;
use Illuminate\Testing\TestResponse;

trait AssertsRateLimiting
{
    /**
     * Assert that rate limiting is being tracked in Redis
     *
     * @param string $key Rate limit key
     * @param int $expectedCount Expected request count
     */
    protected function assertRateLimitTracking(string $key, int $expectedCount): void
    {
        $actualCount = Redis::get($key);

        expect($actualCount)->toBe((string)$expectedCount);
    }

    /**
     * Assert that rate limit has been exceeded
     *
     * @param TestResponse $response
     */
    protected function assertRateLimitExceeded(TestResponse $response): void
    {
        $response->assertStatus(429);
        $response->assertJsonStructure([
            'message',
            'retry_after',
        ]);
        $response->assertHeader('X-RateLimit-Remaining', '0');
        $response->assertHeader('Retry-After');
    }

    /**
     * Clear all rate limit tracking in Redis
     */
    protected function clearRateLimits(): void
    {
        $keys = Redis::keys('rate_limit:*');

        if (count($keys) > 0) {
            Redis::del(...$keys);
        }
    }

    /**
     * Simulate time passing to reset rate limit window
     *
     * @param int $seconds Seconds to advance
     */
    protected function advanceRateLimitWindow(int $seconds = 60): void
    {
        // In testing, we can manipulate Redis TTL or use Carbon::setTestNow()
        // This implementation uses Carbon for simplicity
        \Carbon\Carbon::setTestNow(now()->addSeconds($seconds));

        // Clear expired keys
        $this->clearRateLimits();
    }
}
```

### Complete Test Example: Organization Scoping

**File:** `tests/Feature/Api/V1/OrganizationScopingTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Models\Server;
use App\Models\Application;
use Laravel\Sanctum\Sanctum;
use Tests\Traits\InteractsWithApi;

uses(InteractsWithApi::class);

beforeEach(function () {
    // Ensure clean state for each test
    $this->artisan('cache:clear');
});

it('allows access to resources within authenticated organization', function () {
    ['organization' => $org, 'user' => $user] = $this->createAuthenticatedOrganization();

    $server = Server::factory()->create(['organization_id' => $org->id]);

    $response = $this->getJson("/api/v1/servers/{$server->id}");

    $response->assertOk();
    $response->assertJson([
        'data' => [
            'id' => $server->id,
            'organization_id' => $org->id,
        ],
    ]);
});

it('blocks access to resources from different organization', function () {
    ['organization' => $orgA, 'user' => $userA] = $this->createAuthenticatedOrganization();

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);

    // UserA attempts to access ServerB
    $response = $this->getJson("/api/v1/servers/{$serverB->id}");

    $response->assertForbidden();
    $response->assertJson([
        'message' => 'This resource does not belong to your organization.',
    ]);
});

it('filters list endpoints by organization automatically', function () {
    ['organization' => $orgA, 'user' => $userA] = $this->createAuthenticatedOrganization();

    $orgB = Organization::factory()->create();

    // Create servers for both organizations
    Server::factory()->count(3)->create(['organization_id' => $orgA->id]);
    Server::factory()->count(5)->create(['organization_id' => $orgB->id]);

    $response = $this->getJson('/api/v1/servers');

    $response->assertOk();
    $response->assertJsonCount(3, 'data'); // Only orgA's servers

    // Verify all returned servers belong to orgA
    $response->assertJson([
        'data' => [
            ['organization_id' => $orgA->id],
            ['organization_id' => $orgA->id],
            ['organization_id' => $orgA->id],
        ],
    ]);
});

it('prevents cross-organization resource access via relationship traversal', function () {
    ['organization' => $orgA, 'user' => $userA] = $this->createAuthenticatedOrganization();

    $orgB = Organization::factory()->create();
    $serverB = Server::factory()->create(['organization_id' => $orgB->id]);
    $appB = Application::factory()->create(['server_id' => $serverB->id]);

    // Attempt to access application through server relationship
    $response = $this->getJson("/api/v1/applications/{$appB->id}");

    $response->assertForbidden();
});

it('respects child organization hierarchy permissions', function () {
    $parentOrg = Organization::factory()->create();
    $childOrg = Organization::factory()->create(['parent_id' => $parentOrg->id]);

    $user = User::factory()->create();
    $parentOrg->users()->attach($user, ['role' => 'admin']);

    Sanctum::actingAs($user, ['*'], 'api');

    // Parent org admin should access child org resources
    $childServer = Server::factory()->create(['organization_id' => $childOrg->id]);

    $response = $this->getJson("/api/v1/servers/{$childServer->id}");

    $response->assertOk();
    $response->assertJson([
        'data' => [
            'id' => $childServer->id,
            'organization_id' => $childOrg->id,
        ],
    ]);
});
```

### Complete Test Example: Rate Limiting

**File:** `tests/Feature/Api/V1/RateLimitingTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\EnterpriseLicense;
use Tests\Traits\InteractsWithApi;
use Tests\Traits\AssertsRateLimiting;
use Illuminate\Support\Facades\Redis;

uses(InteractsWithApi::class);
uses(AssertsRateLimiting::class);

beforeEach(function () {
    // Clear Redis rate limit tracking
    $this->clearRateLimits();

    // Reset test time
    \Carbon\Carbon::setTestNow();
});

afterEach(function () {
    $this->clearRateLimits();
    \Carbon\Carbon::setTestNow();
});

it('enforces starter tier rate limit of 100 requests per minute', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('starter');

    // Make 99 requests (should all succeed)
    for ($i = 0; $i < 99; $i++) {
        $response = $this->getJson('/api/v1/organizations');
        $response->assertOk();
    }

    // 100th request should succeed
    $response = $this->getJson('/api/v1/organizations');
    $response->assertOk();
    $this->assertRateLimitHeaders($response, 100, 0);

    // 101st request should be rate limited
    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitExceeded($response);
});

it('enforces professional tier rate limit of 500 requests per minute', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('professional');

    // Make 500 requests
    $response = $this->makeMultipleRequests('get', '/api/v1/organizations', 500);

    $response->assertOk();
    $this->assertRateLimitHeaders($response, 500, 0);

    // 501st request should be rate limited
    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitExceeded($response);
});

it('enforces enterprise tier rate limit of 2000 requests per minute', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('enterprise');

    // Make 2000 requests (chunked for performance)
    for ($i = 0; $i < 2000; $i += 100) {
        $this->makeMultipleRequests('get', '/api/v1/organizations', 100);
    }

    // Verify last request has correct headers
    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitHeaders($response, 2000, 0);

    // 2001st request should be rate limited
    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitExceeded($response);
});

it('resets rate limit after time window expires', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('starter');

    // Exhaust rate limit
    $this->makeMultipleRequests('get', '/api/v1/organizations', 100);

    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitExceeded($response);

    // Advance time by 61 seconds (past the 1-minute window)
    $this->advanceRateLimitWindow(61);

    // New request should succeed
    $response = $this->getJson('/api/v1/organizations');
    $response->assertOk();
    $this->assertRateLimitHeaders($response, 100, 99);
});

it('tracks rate limits per organization independently', function () {
    ['organization' => $orgA] = $this->createAuthenticatedOrganization('starter');

    // Exhaust orgA rate limit
    $this->makeMultipleRequests('get', '/api/v1/organizations', 100);
    $response = $this->getJson('/api/v1/organizations');
    $this->assertRateLimitExceeded($response);

    // Create and authenticate as orgB
    ['organization' => $orgB] = $this->createAuthenticatedOrganization('starter');

    // OrgB should have full rate limit available
    $response = $this->getJson('/api/v1/organizations');
    $response->assertOk();
    $this->assertRateLimitHeaders($response, 100, 99);
});

it('includes accurate rate limit headers on every response', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('professional');

    $response = $this->getJson('/api/v1/organizations');

    $response->assertOk();
    $response->assertHeader('X-RateLimit-Limit', '500');
    $response->assertHeader('X-RateLimit-Remaining', '499');
    $response->assertHeader('X-RateLimit-Reset');

    // Verify reset timestamp is in the future
    $resetTimestamp = $response->headers->get('X-RateLimit-Reset');
    expect($resetTimestamp)->toBeGreaterThan(time());
});

it('returns retry-after header when rate limited', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('starter');

    // Exhaust rate limit
    $this->makeMultipleRequests('get', '/api/v1/organizations', 100);

    $response = $this->getJson('/api/v1/organizations');

    $response->assertStatus(429);
    $response->assertHeader('Retry-After');

    $retryAfter = (int)$response->headers->get('Retry-After');
    expect($retryAfter)->toBeLessThanOrEqual(60); // Should be within 1 minute
});

it('uses redis for distributed rate limit tracking', function () {
    ['organization' => $org, 'user' => $user] = $this->createAuthenticatedOrganization('starter');

    // Make a request
    $this->getJson('/api/v1/organizations');

    // Verify Redis tracking key exists
    $rateLimitKey = "rate_limit:api:{$org->id}:" . now()->format('YmdHi');

    $this->assertRateLimitTracking($rateLimitKey, 1);

    // Make another request
    $this->getJson('/api/v1/organizations');

    $this->assertRateLimitTracking($rateLimitKey, 2);
});
```

### Complete Test Example: Authentication

**File:** `tests/Feature/Api/V1/AuthenticationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use Laravel\Sanctum\Sanctum;
use Laravel\Sanctum\PersonalAccessToken;

it('allows authenticated requests with valid sanctum token', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Sanctum::actingAs($user, ['*'], 'api');

    $response = $this->getJson('/api/v1/organizations');

    $response->assertOk();
});

it('rejects unauthenticated requests', function () {
    $response = $this->getJson('/api/v1/organizations');

    $response->assertStatus(401);
    $response->assertJson([
        'message' => 'Unauthenticated.',
    ]);
});

it('rejects requests with invalid token', function () {
    $response = $this->withHeader('Authorization', 'Bearer invalid-token-here')
        ->getJson('/api/v1/organizations');

    $response->assertStatus(401);
});

it('respects token abilities for read-only access', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Create token with read-only abilities
    Sanctum::actingAs($user, ['read'], 'api');

    // GET request should work
    $response = $this->getJson('/api/v1/organizations');
    $response->assertOk();

    // POST request should fail
    $response = $this->postJson('/api/v1/organizations', [
        'name' => 'New Organization',
        'slug' => 'new-org',
    ]);

    $response->assertForbidden();
    $response->assertJson([
        'message' => 'Your token does not have the required abilities.',
    ]);
});

it('embeds organization context in sanctum token', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Create token with organization metadata
    $token = $user->createToken('api-token', ['*'], [
        'organization_id' => $organization->id,
    ]);

    // Verify organization context is embedded
    $tokenModel = PersonalAccessToken::findToken($token->plainTextToken);

    expect($tokenModel->metadata)->toHaveKey('organization_id', $organization->id);
});

it('immediately denies access when token is revoked', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $token = $user->createToken('api-token', ['*']);

    // Initial request succeeds
    $response = $this->withHeader('Authorization', "Bearer {$token->plainTextToken}")
        ->getJson('/api/v1/organizations');

    $response->assertOk();

    // Revoke token
    $user->tokens()->delete();

    // Subsequent request fails
    $response = $this->withHeader('Authorization', "Bearer {$token->plainTextToken}")
        ->getJson('/api/v1/organizations');

    $response->assertStatus(401);
});
```

### Enterprise Endpoint Tests: Organizations

**File:** `tests/Feature/Api/V1/Enterprise/OrganizationApiTest.php`

```php
<?php

use App\Models\Organization;
use Tests\Traits\InteractsWithApi;

uses(InteractsWithApi::class);

it('lists organizations for authenticated user', function () {
    ['organization' => $org, 'user' => $user] = $this->createAuthenticatedOrganization();

    // Create additional organizations
    Organization::factory()->count(3)->create();

    $response = $this->getJson('/api/v1/organizations');

    $response->assertOk();
    $response->assertJsonCount(1, 'data'); // Only user's organization
    $response->assertJson([
        'data' => [
            ['id' => $org->id],
        ],
    ]);
});

it('shows organization details', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    $response = $this->getJson("/api/v1/organizations/{$org->id}");

    $response->assertOk();
    $response->assertJson([
        'data' => [
            'id' => $org->id,
            'name' => $org->name,
            'slug' => $org->slug,
        ],
    ]);
});

it('creates new organization', function () {
    ['user' => $user] = $this->createAuthenticatedOrganization();

    $response = $this->postJson('/api/v1/organizations', [
        'name' => 'New Company',
        'slug' => 'new-company',
        'description' => 'A new organization',
    ]);

    $response->assertCreated();
    $response->assertJson([
        'data' => [
            'name' => 'New Company',
            'slug' => 'new-company',
        ],
    ]);

    $this->assertDatabaseHas('organizations', [
        'name' => 'New Company',
        'slug' => 'new-company',
    ]);
});

it('updates organization details', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    $response = $this->putJson("/api/v1/organizations/{$org->id}", [
        'name' => 'Updated Name',
        'description' => 'Updated description',
    ]);

    $response->assertOk();
    $response->assertJson([
        'data' => [
            'id' => $org->id,
            'name' => 'Updated Name',
            'description' => 'Updated description',
        ],
    ]);
});

it('deletes organization', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    $response = $this->deleteJson("/api/v1/organizations/{$org->id}");

    $response->assertNoContent();

    $this->assertSoftDeleted('organizations', [
        'id' => $org->id,
    ]);
});

it('validates organization creation payload', function () {
    ['user' => $user] = $this->createAuthenticatedOrganization();

    $response = $this->postJson('/api/v1/organizations', [
        'name' => '', // Invalid: empty name
        'slug' => 'invalid slug', // Invalid: spaces not allowed
    ]);

    $response->assertStatus(422);
    $response->assertJsonValidationErrors(['name', 'slug']);
});
```

### Performance and Edge Case Tests

**File:** `tests/Feature/Api/V1/PerformanceTest.php`

```php
<?php

use App\Models\Server;
use Tests\Traits\InteractsWithApi;

uses(InteractsWithApi::class);

it('handles concurrent requests from same organization', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    Server::factory()->count(10)->create(['organization_id' => $org->id]);

    // Simulate concurrent requests
    $responses = [];
    for ($i = 0; $i < 5; $i++) {
        $responses[] = $this->getJson('/api/v1/servers');
    }

    // All should succeed
    foreach ($responses as $response) {
        $response->assertOk();
        $response->assertJsonCount(10, 'data');
    }
});

it('paginates large result sets correctly', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    Server::factory()->count(150)->create(['organization_id' => $org->id]);

    // First page
    $response = $this->getJson('/api/v1/servers?page=1&per_page=50');

    $response->assertOk();
    $response->assertJsonCount(50, 'data');
    $response->assertJson([
        'meta' => [
            'current_page' => 1,
            'total' => 150,
            'per_page' => 50,
        ],
    ]);

    // Second page
    $response = $this->getJson('/api/v1/servers?page=2&per_page=50');

    $response->assertOk();
    $response->assertJsonCount(50, 'data');
});

it('maintains response time under load', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    Server::factory()->count(100)->create(['organization_id' => $org->id]);

    $startTime = microtime(true);

    $response = $this->getJson('/api/v1/servers');

    $endTime = microtime(true);
    $responseTime = ($endTime - $startTime) * 1000; // Convert to milliseconds

    $response->assertOk();

    // Assert response time is under 200ms
    expect($responseTime)->toBeLessThan(200);
});

it('handles invalid json payloads gracefully', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    $response = $this->postJson('/api/v1/organizations',
        'invalid json string'
    );

    $response->assertStatus(400);
    $response->assertJson([
        'message' => 'Invalid JSON payload.',
    ]);
});
```

## Implementation Approach

### Step 1: Set Up Test Infrastructure
1. Create `tests/Feature/Api/V1/` directory structure
2. Create testing traits: `InteractsWithApi` and `AssertsRateLimiting`
3. Configure PHPunit.xml for API test suite
4. Create Pest datasets for rate limit tiers

### Step 2: Implement Organization Scoping Tests
1. Write tests for single organization resource access
2. Write tests for cross-organization access prevention
3. Write tests for list endpoint filtering
4. Write tests for hierarchical organization access
5. Run tests: `php artisan test --filter=OrganizationScopingTest`

### Step 3: Implement Rate Limiting Tests
1. Write tests for each license tier (starter, professional, enterprise)
2. Write tests for rate limit reset behavior
3. Write tests for independent organization tracking
4. Write tests for accurate header values
5. Write tests for Redis tracking verification
6. Run tests: `php artisan test --filter=RateLimitingTest`

### Step 4: Implement Authentication Tests
1. Write tests for valid/invalid token handling
2. Write tests for token abilities (read vs read-write)
3. Write tests for token revocation
4. Write tests for organization context embedding
5. Run tests: `php artisan test --filter=AuthenticationTest`

### Step 5: Implement Enterprise Endpoint Tests
1. Write tests for organization CRUD operations
2. Write tests for resource monitoring endpoints
3. Write tests for infrastructure provisioning endpoints
4. Write tests for white-label endpoints
5. Write tests for billing endpoints
6. Run each test file individually

### Step 6: Implement Performance & Edge Case Tests
1. Write concurrent request handling tests
2. Write pagination tests for large datasets
3. Write response time benchmark tests
4. Write invalid payload handling tests
5. Run tests: `php artisan test --filter=PerformanceTest`

### Step 7: Continuous Integration Setup
1. Update `.github/workflows/tests.yml` (or similar) with API test suite
2. Configure parallel test execution for speed
3. Add code coverage reporting for API tests
4. Set quality gates (minimum 85% coverage for API layer)

### Step 8: Documentation and Review
1. Document test coverage report
2. Create API testing guidelines for future development
3. Code review with focus on edge cases
4. Update TESTING.md with API testing instructions

## Test Strategy

### Test Coverage Goals

**Functional Coverage:**
- 100% endpoint coverage for all new enterprise API routes
- 100% authentication and authorization path coverage
- 100% rate limiting logic coverage
- 100% organization scoping middleware coverage

**Non-Functional Coverage:**
- Performance benchmarks for high-volume requests
- Concurrent request handling validation
- Edge case and error condition coverage
- Security vulnerability validation (OWASP API Security Top 10)

### Testing Approach

**Black-Box API Testing:**
- All tests interact via HTTP endpoints only
- No direct service or database manipulation during test execution (only setup/teardown)
- Validates complete request/response cycle including all middleware

**Pest Framework Usage:**
- BDD-style test descriptions: `it('describes expected behavior')`
- Datasets for parameterized testing (license tiers, abilities, etc.)
- Testing traits for reusable test helpers
- Descriptive test names for documentation value

**Test Isolation:**
- Each test has its own database transaction (rolled back after test)
- Redis cleared before/after each test
- No test interdependencies (order-independent execution)
- Factory-based test data (no seeders)

### Performance Testing

**Load Testing:**
```php
it('handles 1000 concurrent API requests without errors', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization('enterprise');

    $startTime = microtime(true);

    // Simulate 1000 requests (in batches for practicality)
    for ($batch = 0; $batch < 10; $batch++) {
        $responses = [];

        for ($i = 0; $i < 100; $i++) {
            $responses[] = $this->getJson('/api/v1/organizations');
        }

        // All responses should succeed
        foreach ($responses as $response) {
            $response->assertOk();
        }
    }

    $endTime = microtime(true);
    $totalTime = ($endTime - $startTime);

    // Should complete in under 10 seconds
    expect($totalTime)->toBeLessThan(10);
});
```

**Memory Usage Testing:**
```php
it('maintains reasonable memory usage for large result sets', function () {
    ['organization' => $org] = $this->createAuthenticatedOrganization();

    Server::factory()->count(1000)->create(['organization_id' => $org->id]);

    $memoryBefore = memory_get_usage(true);

    $response = $this->getJson('/api/v1/servers?per_page=100');

    $memoryAfter = memory_get_usage(true);
    $memoryUsed = ($memoryAfter - $memoryBefore) / 1024 / 1024; // MB

    $response->assertOk();

    // Should use less than 50MB
    expect($memoryUsed)->toBeLessThan(50);
});
```

## Definition of Done

### Test Implementation
- [ ] All test files created in `tests/Feature/Api/V1/` directory
- [ ] InteractsWithApi trait implemented and used across tests
- [ ] AssertsRateLimiting trait implemented for rate limit validation
- [ ] OrganizationScopingTest.php complete with 10+ test cases
- [ ] RateLimitingTest.php complete with tier-based tests
- [ ] AuthenticationTest.php complete with token validation tests
- [ ] OrganizationApiTest.php complete with CRUD operation tests
- [ ] ResourceMonitoringApiTest.php complete (if endpoints exist)
- [ ] InfrastructureApiTest.php complete (if endpoints exist)
- [ ] WhiteLabelApiTest.php complete (if endpoints exist)
- [ ] BillingApiTest.php complete (if endpoints exist)
- [ ] PerformanceTest.php complete with load and edge case tests

### Test Quality
- [ ] All tests pass: `php artisan test --testsuite=api`
- [ ] No flaky tests (100% pass rate over 10 consecutive runs)
- [ ] Test coverage for API layer > 90%
- [ ] All edge cases covered (invalid tokens, expired limits, malformed requests)
- [ ] Performance benchmarks met (< 200ms p95 response time)

### Documentation
- [ ] Test coverage report generated and reviewed
- [ ] API testing guidelines documented
- [ ] Example test patterns documented for future reference
- [ ] TESTING.md updated with API test instructions

### Integration
- [ ] CI/CD pipeline includes API test suite
- [ ] Parallel test execution configured for speed
- [ ] Quality gates configured (coverage thresholds)
- [ ] Test results published to dashboard/reports

### Code Quality
- [ ] Laravel Pint formatting applied to test files
- [ ] PHPStan level 5 passing for test files
- [ ] No deprecated testing methods used
- [ ] Reusable test helpers extracted to traits

### Review & Validation
- [ ] Code review completed with security focus
- [ ] Manual API testing performed for critical paths
- [ ] Rate limiting validated with actual HTTP clients
- [ ] Organization scoping verified across all endpoints

### Security Validation
- [ ] Cross-tenant data leakage tests passing
- [ ] Authentication bypass attempts blocked
- [ ] Rate limit bypass attempts blocked
- [ ] SQL injection vulnerability tests passing
- [ ] XSS vulnerability tests passing (if applicable)

## Related Tasks

**Direct Dependencies:**
- **Task 52**: Extended Sanctum tokens with organization context (authentication layer)
- **Task 53**: ApiOrganizationScope middleware (organization scoping enforcement)
- **Task 54**: Tiered rate limiting middleware with Redis (rate limit enforcement)
- **Task 55**: Rate limit headers in responses (header validation)
- **Task 56**: New enterprise API endpoints (endpoint coverage)

**Indirect Dependencies:**
- **Task 1**: Enterprise licensing system (license tier validation)
- **Tasks 12-21**: Terraform infrastructure endpoints (infrastructure API tests)
- **Tasks 22-31**: Resource monitoring endpoints (monitoring API tests)
- **Tasks 42-51**: Payment/billing endpoints (billing API tests)

**Enables Future Work:**
- Continuous API security validation during development
- Automated regression testing for API changes
- Performance benchmarking for API optimization
- Documentation generation from test examples
