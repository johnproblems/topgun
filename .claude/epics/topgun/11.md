---
name: Add comprehensive tests for branding service, components, and cache invalidation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:29Z
github: https://github.com/johnproblems/topgun/issues/121
depends_on: [2, 3, 4, 5, 6, 7, 8, 9, 10]
parallel: false
conflicts_with: []
---

# Task: Add comprehensive tests for branding service, components, and cache invalidation

## Description

This task implements a **comprehensive testing suite** for the entire white-label branding system (Tasks 2-10), ensuring reliability, performance, and correctness across all components. The test suite validates backend services, Vue.js components, caching mechanisms, and end-to-end user workflows, providing confidence that the white-label system works flawlessly under all conditions.

**Testing Scope Coverage:**

The white-label branding system is a complex, multi-layered feature spanning backend services, caching infrastructure, frontend components, background jobs, and asset generation. This test task validates all layers:

1. **Backend Services (Tasks 2-3, 7, 9-10)**
   - WhiteLabelService - CSS compilation, configuration management
   - BrandingCacheService - Redis caching, invalidation, statistics
   - FaviconGeneratorService - Multi-size favicon generation
   - DynamicAssetController - HTTP responses, caching headers
   - BrandingCacheWarmerJob - Background cache warming

2. **Frontend Components (Tasks 4-6, 8)**
   - LogoUploader.vue - File uploads, image optimization
   - BrandingManager.vue - Configuration management
   - ThemeCustomizer.vue - Live color preview
   - BrandingPreview.vue - Real-time branding visualization

3. **Infrastructure & Integration (Task 3)**
   - Redis cache layer - Performance, invalidation
   - Model observers - Automatic cache invalidation
   - Artisan commands - Manual cache management
   - Event listeners - Event-driven workflows

4. **End-to-End Workflows**
   - Upload logo → compile CSS → cache → serve → invalidate → refresh
   - Update colors → preview → save → cache invalidation
   - Multi-organization isolation and performance

**Why Comprehensive Testing is Critical:**

White-label branding is a **customer-facing, first-impression feature**. When organizations customize their Coolify instance, they expect:
- **Instant visual changes** when they update branding
- **Zero latency** when users access their branded platform
- **Perfect isolation** between organizations (no cache leakage)
- **Reliable cache invalidation** (no stale branding after updates)
- **Graceful degradation** if services fail (fallback to defaults)

A single bug in this system creates a terrible user experience:
- Stale colors after updating (cache not invalidated)
- Slow page loads (cache not working)
- Organization A sees Organization B's branding (cache key collision)
- Broken CSS after uploading invalid logo (error handling missing)
- Email branding doesn't match UI branding (inconsistent state)

**This test suite prevents these failures** by validating every code path, edge case, and integration point. Without comprehensive tests, the white-label system becomes fragile and unreliable—exactly the opposite of what enterprise customers expect.

**Test Coverage Goals:**

- **Unit Tests:** > 90% code coverage for all services and utilities
- **Integration Tests:** All critical workflows validated end-to-end
- **Browser Tests:** User-facing workflows tested in real browser
- **Performance Tests:** Cache performance, CSS compilation benchmarks
- **Security Tests:** Organization isolation, cache key security
- **Regression Tests:** Common bug scenarios prevented

**Strategic Testing Approach:**

This task creates **reusable testing infrastructure** that benefits the entire enterprise transformation:

1. **Testing Traits** - Reusable test helpers for branding, caching, organizations
2. **Factory States** - Predefined test data scenarios (valid branding, invalid colors, missing logos)
3. **Mock Services** - Fake external dependencies (Redis, file storage)
4. **Assertion Helpers** - Custom assertions for branding-specific validations
5. **Performance Benchmarks** - Baseline metrics for future regression detection

These patterns establish best practices for testing other enterprise features (Terraform, payments, resource monitoring), creating a culture of quality and reliability across the codebase.

**Real-World Test Scenarios:**

The test suite validates scenarios derived from production issues:

- Organization updates primary color from red to blue, expects immediate visual change
- High-traffic organization has CSS cached, low-traffic org generates on-demand
- Admin uploads 10MB logo, system optimizes to < 500KB before storing
- Cache warming job runs at 2 AM, pre-compiles CSS for 1000+ organizations
- Organization deletes white-label config, falls back to Coolify defaults
- Redis crashes, system continues serving (degraded but functional)
- Concurrent requests for same organization CSS don't trigger duplicate compilations

**Testing Philosophy:**

This task follows Laravel's testing best practices combined with Coolify's existing patterns:

- **Pest for expressiveness** - Readable, intention-revealing tests
- **Factories for realism** - Tests use realistic data, not hardcoded strings
- **Feature over unit** - Validate user journeys, not just isolated methods
- **Fast feedback** - Tests run in < 30 seconds for rapid development
- **Clear failures** - When tests fail, error messages clearly indicate what broke

By the end of this task, **the white-label branding system will have the most comprehensive test coverage in the entire Coolify codebase**, serving as a reference implementation for future enterprise features.

## Acceptance Criteria

- [ ] Unit tests cover all service classes (WhiteLabelService, BrandingCacheService, FaviconGeneratorService)
- [ ] Integration tests validate complete branding workflows (upload → compile → cache → serve)
- [ ] Vue component tests written using Vitest for all components (LogoUploader, BrandingManager, ThemeCustomizer, BrandingPreview)
- [ ] Dusk browser tests cover end-to-end user workflows
- [ ] Cache invalidation tested thoroughly (model updates, manual commands, automatic warming)
- [ ] Performance benchmarks validate cache performance (< 50ms cached, < 500ms compilation)
- [ ] Multi-organization isolation tests prevent cross-tenant cache leakage
- [ ] Error handling tested for all failure scenarios (invalid logos, missing configs, Redis failures)
- [ ] Testing traits created for reusability (BrandingTestTrait, CacheTestTrait)
- [ ] Factory states defined for common test scenarios
- [ ] All tests passing with > 90% code coverage for branding system
- [ ] Test documentation written explaining testing approach and patterns
- [ ] Performance regression tests establish baseline metrics
- [ ] License feature flag integration tested (branding enabled/disabled per tier)
- [ ] Email branding variable injection tested

## Technical Details

### File Paths

**Testing Traits:**
- `/home/topgun/topgun/tests/Traits/BrandingTestTrait.php` (new)
- `/home/topgun/topgun/tests/Traits/CacheTestTrait.php` (new)
- `/home/topgun/topgun/tests/Traits/VueComponentTestTrait.php` (new)

**Unit Tests:**
- `/home/topgun/topgun/tests/Unit/Services/WhiteLabelServiceTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/BrandingCacheServiceTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/FaviconGeneratorServiceTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Controllers/DynamicAssetControllerTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Jobs/BrandingCacheWarmerJobTest.php` (new)

**Integration Tests:**
- `/home/topgun/topgun/tests/Feature/Enterprise/WhiteLabelWorkflowTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Enterprise/BrandingCacheIntegrationTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Enterprise/DynamicAssetGenerationTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Enterprise/EmailBrandingTest.php` (new)

**Vue Component Tests:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/WhiteLabel/__tests__/LogoUploader.test.js` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/WhiteLabel/__tests__/BrandingManager.test.js` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/WhiteLabel/__tests__/ThemeCustomizer.test.js` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/WhiteLabel/__tests__/BrandingPreview.test.js` (new)

**Browser Tests:**
- `/home/topgun/topgun/tests/Browser/Enterprise/WhiteLabelBrandingTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/BrandingCacheTest.php` (new)

**Performance Tests:**
- `/home/topgun/topgun/tests/Performance/BrandingPerformanceTest.php` (new)

**Factory Enhancements:**
- `/home/topgun/topgun/database/factories/WhiteLabelConfigFactory.php` (enhance with states)

### Testing Infrastructure

#### BrandingTestTrait

Provides reusable helpers for branding-related tests:

```php
<?php

namespace Tests\Traits;

use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;

trait BrandingTestTrait
{
    /**
     * Create organization with valid white-label configuration
     */
    protected function createBrandedOrganization(array $overrides = []): Organization
    {
        $organization = Organization::factory()->create();

        WhiteLabelConfig::factory()->create(array_merge([
            'organization_id' => $organization->id,
            'platform_name' => 'Acme Platform',
            'primary_color' => '#3b82f6',
            'secondary_color' => '#8b5cf6',
            'accent_color' => '#10b981',
            'font_family' => 'Inter, sans-serif',
        ], $overrides));

        return $organization->fresh('whiteLabelConfig');
    }

    /**
     * Create fake logo file for testing
     */
    protected function createFakeLogo(string $filename = 'logo.png', int $width = 512, int $height = 512): UploadedFile
    {
        Storage::fake('public');

        $image = imagecreatetruecolor($width, $height);
        imagesavealpha($image, true);

        $backgroundColor = imagecolorallocatealpha($image, 255, 255, 255, 127);
        imagefill($image, 0, 0, $backgroundColor);

        $logoColor = imagecolorallocate($image, 59, 130, 246); // Primary blue
        imagefilledrectangle($image, 100, 100, 412, 412, $logoColor);

        ob_start();
        imagepng($image);
        $imageData = ob_get_clean();
        imagedestroy($image);

        $file = tmpfile();
        $path = stream_get_meta_data($file)['uri'];
        file_put_contents($path, $imageData);

        return new UploadedFile($path, $filename, 'image/png', null, true);
    }

    /**
     * Assert CSS contains expected branding variables
     */
    protected function assertCssContainsBranding(string $css, WhiteLabelConfig $config): void
    {
        expect($css)
            ->toContain("--color-primary: {$config->primary_color}")
            ->toContain("--color-secondary: {$config->secondary_color}")
            ->toContain("--color-accent: {$config->accent_color}")
            ->toContain("--font-family-primary: {$config->font_family}");
    }

    /**
     * Assert organization cache is warm
     */
    protected function assertCacheIsWarm(Organization $organization): void
    {
        $cacheService = app(\App\Contracts\BrandingCacheServiceInterface::class);
        $cachedCss = $cacheService->get($organization->slug);

        expect($cachedCss)->not->toBeNull();
        expect($cachedCss)->toBeString();
        expect(strlen($cachedCss))->toBeGreaterThan(100);
    }

    /**
     * Assert organization cache is invalidated
     */
    protected function assertCacheIsInvalidated(Organization $organization): void
    {
        $cacheService = app(\App\Contracts\BrandingCacheServiceInterface::class);
        $cachedCss = $cacheService->get($organization->slug);

        expect($cachedCss)->toBeNull();
    }

    /**
     * Get organization branding CSS
     */
    protected function getBrandingCss(Organization $organization): string
    {
        $response = $this->get("/branding/{$organization->slug}/styles.css");
        $response->assertOk();

        return $response->getContent();
    }

    /**
     * Assert favicon files exist for organization
     */
    protected function assertFaviconsExist(Organization $organization, array $sizes = [16, 32, 180, 192, 512]): void
    {
        foreach ($sizes as $size) {
            $path = "favicons/{$organization->id}/favicon-{$size}x{$size}.png";
            expect(Storage::disk('public')->exists($path))->toBeTrue(
                "Expected favicon to exist: {$path}"
            );
        }
    }

    /**
     * Create organization with invalid branding config (for testing error handling)
     */
    protected function createOrganizationWithInvalidBranding(): Organization
    {
        $organization = Organization::factory()->create();

        WhiteLabelConfig::factory()->create([
            'organization_id' => $organization->id,
            'primary_color' => 'invalid-color', // Invalid hex
            'logo_url' => 'https://nonexistent.example.com/logo.png',
        ]);

        return $organization->fresh('whiteLabelConfig');
    }
}
```

#### CacheTestTrait

```php
<?php

namespace Tests\Traits;

use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Cache;

trait CacheTestTrait
{
    /**
     * Clear all Redis branding caches
     */
    protected function clearBrandingCaches(): void
    {
        $keys = Redis::keys('branding:*');
        if (count($keys) > 0) {
            Redis::del($keys);
        }
    }

    /**
     * Assert cache key exists with expected value
     */
    protected function assertCacheHas(string $key, ?string $expectedValue = null): void
    {
        $value = Cache::get($key);
        expect($value)->not->toBeNull("Expected cache key to exist: {$key}");

        if ($expectedValue !== null) {
            expect($value)->toBe($expectedValue);
        }
    }

    /**
     * Assert cache key does not exist
     */
    protected function assertCacheMissing(string $key): void
    {
        expect(Cache::has($key))->toBeFalse("Expected cache key to not exist: {$key}");
    }

    /**
     * Get cache statistics for branding
     */
    protected function getBrandingCacheStats(): array
    {
        $cacheService = app(\App\Contracts\BrandingCacheServiceInterface::class);
        return $cacheService->getStats();
    }

    /**
     * Assert cache hit rate meets threshold
     */
    protected function assertCacheHitRate(float $minimumRate): void
    {
        $stats = $this->getBrandingCacheStats();
        $hitRate = $stats['hit_rate'] ?? 0.0;

        expect($hitRate)->toBeGreaterThanOrEqual($minimumRate,
            "Cache hit rate ({$hitRate}%) below minimum ({$minimumRate}%)"
        );
    }

    /**
     * Warm cache for testing
     */
    protected function warmCacheForOrganization(\App\Models\Organization $organization): void
    {
        $this->artisan('branding:warm-cache', [
            'organization' => $organization->slug,
            '--sync' => true,
        ])->assertSuccessful();
    }
}
```

#### Enhanced WhiteLabelConfigFactory States

```php
<?php

namespace Database\Factories;

use App\Models\WhiteLabelConfig;
use App\Models\Organization;
use Illuminate\Database\Eloquent\Factories\Factory;

class WhiteLabelConfigFactory extends Factory
{
    protected $model = WhiteLabelConfig::class;

    public function definition(): array
    {
        return [
            'organization_id' => Organization::factory(),
            'platform_name' => $this->faker->company . ' Platform',
            'primary_color' => $this->faker->hexColor(),
            'secondary_color' => $this->faker->hexColor(),
            'accent_color' => $this->faker->hexColor(),
            'font_family' => $this->faker->randomElement([
                'Inter, sans-serif',
                'Roboto, sans-serif',
                'Open Sans, sans-serif',
                'Lato, sans-serif',
            ]),
            'logo_url' => null,
            'favicon_url' => null,
            'custom_css' => null,
        ];
    }

    /**
     * State: Fully configured with all branding assets
     */
    public function complete(): static
    {
        return $this->state(fn (array $attributes) => [
            'logo_url' => 'logos/' . $this->faker->uuid() . '.png',
            'favicon_url' => 'favicons/' . $this->faker->uuid() . '.png',
            'custom_css' => '.custom-class { color: ' . $this->faker->hexColor() . '; }',
        ]);
    }

    /**
     * State: Minimal configuration (only required fields)
     */
    public function minimal(): static
    {
        return $this->state(fn (array $attributes) => [
            'platform_name' => $attributes['organization_id'] ?? Organization::factory(),
            'logo_url' => null,
            'favicon_url' => null,
            'custom_css' => null,
        ]);
    }

    /**
     * State: Invalid configuration for testing error handling
     */
    public function invalid(): static
    {
        return $this->state(fn (array $attributes) => [
            'primary_color' => 'not-a-color',
            'secondary_color' => '#ZZZZZZ',
            'logo_url' => 'https://nonexistent.example.com/logo.png',
        ]);
    }

    /**
     * State: Dark theme colors
     */
    public function darkTheme(): static
    {
        return $this->state(fn (array $attributes) => [
            'primary_color' => '#1f2937',
            'secondary_color' => '#374151',
            'accent_color' => '#6366f1',
        ]);
    }

    /**
     * State: Light theme colors
     */
    public function lightTheme(): static
    {
        return $this->state(fn (array $attributes) => [
            'primary_color' => '#f3f4f6',
            'secondary_color' => '#e5e7eb',
            'accent_color' => '#3b82f6',
        ]);
    }
}
```

### Unit Test Examples

#### WhiteLabelServiceTest

```php
<?php

namespace Tests\Unit\Services;

use App\Contracts\WhiteLabelServiceInterface;
use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use App\Services\Enterprise\WhiteLabelService;
use Illuminate\Support\Facades\Storage;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;

uses(TestCase::class, BrandingTestTrait::class);

beforeEach(function () {
    Storage::fake('public');
    $this->service = app(WhiteLabelServiceInterface::class);
});

it('generates valid CSS from organization configuration', function () {
    $organization = $this->createBrandedOrganization([
        'primary_color' => '#ff0000',
        'secondary_color' => '#00ff00',
        'accent_color' => '#0000ff',
    ]);

    $css = $this->service->generateCSS($organization);

    expect($css)
        ->toBeString()
        ->toContain('--color-primary: #ff0000')
        ->toContain('--color-secondary: #00ff00')
        ->toContain('--color-accent: #0000ff')
        ->toContain(':root {');
});

it('compiles SASS variables correctly', function () {
    $organization = $this->createBrandedOrganization();

    $css = $this->service->generateCSS($organization);

    // Verify SASS functions worked (lighten, darken)
    expect($css)
        ->toContain('--color-primary-light:')
        ->toContain('--color-primary-dark:');
});

it('includes font family in generated CSS', function () {
    $organization = $this->createBrandedOrganization([
        'font_family' => 'Roboto, sans-serif',
    ]);

    $css = $this->service->generateCSS($organization);

    expect($css)->toContain('--font-family-primary: Roboto, sans-serif');
});

it('generates CSS for both light and dark modes', function () {
    $organization = $this->createBrandedOrganization();

    $css = $this->service->generateCSS($organization);

    expect($css)
        ->toContain(':root {') // Light mode
        ->toContain('@media (prefers-color-scheme: dark)'); // Dark mode
});

it('falls back to default theme if configuration is missing', function () {
    $organization = Organization::factory()->create();
    // No WhiteLabelConfig

    $css = $this->service->generateCSS($organization);

    $defaultPrimary = config('enterprise.white_label.default_theme.primary_color');
    expect($css)->toContain("--color-primary: {$defaultPrimary}");
});

it('validates color format before compilation', function () {
    $organization = $this->createOrganizationWithInvalidBranding();

    expect(fn () => $this->service->generateCSS($organization))
        ->toThrow(\InvalidArgumentException::class, 'Invalid color format');
});

it('merges custom CSS with generated CSS', function () {
    $customCss = '.custom-btn { background: red; }';
    $organization = $this->createBrandedOrganization([
        'custom_css' => $customCss,
    ]);

    $css = $this->service->generateCSS($organization);

    expect($css)
        ->toContain('.custom-btn { background: red; }')
        ->toContain('--color-primary:'); // Generated CSS also present
});

it('generates branding configuration array', function () {
    $organization = $this->createBrandedOrganization();

    $config = $this->service->getBrandingConfig($organization);

    expect($config)
        ->toBeArray()
        ->toHaveKeys(['platform_name', 'primary_color', 'secondary_color', 'logo_url', 'favicon_url']);
});

it('generates email branding variables', function () {
    $organization = $this->createBrandedOrganization([
        'platform_name' => 'Acme Corp',
    ]);

    $emailVars = $this->service->getEmailBrandingVars($organization);

    expect($emailVars)
        ->toHaveKey('platform_name', 'Acme Corp')
        ->toHaveKey('logo_url')
        ->toHaveKey('primary_color');
});
```

#### BrandingCacheServiceTest

```php
<?php

namespace Tests\Unit\Services;

use App\Contracts\BrandingCacheServiceInterface;
use App\Models\Organization;
use Illuminate\Support\Facades\Redis;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;
use Tests\Traits\CacheTestTrait;

uses(TestCase::class, BrandingTestTrait::class, CacheTestTrait::class);

beforeEach(function () {
    $this->clearBrandingCaches();
    $this->cacheService = app(BrandingCacheServiceInterface::class);
});

afterEach(function () {
    $this->clearBrandingCaches();
});

it('caches CSS successfully', function () {
    $css = ':root { --color-primary: #ff0000; }';

    $result = $this->cacheService->put('test-org', $css);

    expect($result)->toBeTrue();

    $cached = $this->cacheService->get('test-org');
    expect($cached)->toBe($css);
});

it('returns null for cache miss', function () {
    $result = $this->cacheService->get('non-existent-org');

    expect($result)->toBeNull();
});

it('invalidates cache for specific organization', function () {
    $organization = Organization::factory()->create(['slug' => 'test-org']);

    $this->cacheService->put('test-org', 'test-css');
    $this->cacheService->invalidate($organization);

    expect($this->cacheService->get('test-org'))->toBeNull();
});

it('flushes all branding caches', function () {
    $this->cacheService->put('org-1', 'css-1');
    $this->cacheService->put('org-2', 'css-2');
    $this->cacheService->put('org-3', 'css-3');

    $count = $this->cacheService->flush();

    expect($count)->toBe(3);
    expect($this->cacheService->get('org-1'))->toBeNull();
    expect($this->cacheService->get('org-2'))->toBeNull();
});

it('tracks cache hit statistics', function () {
    $this->cacheService->get('org-1'); // Miss
    $this->cacheService->put('org-1', 'css');
    $this->cacheService->get('org-1'); // Hit
    $this->cacheService->get('org-1'); // Hit

    $stats = $this->cacheService->getStats();

    expect($stats['hits'])->toBe(2);
    expect($stats['misses'])->toBe(1);
});

it('calculates hit rate correctly', function () {
    // 3 hits, 2 misses = 60% hit rate
    $this->cacheService->get('org-1'); // Miss
    $this->cacheService->put('org-1', 'css');
    $this->cacheService->get('org-1'); // Hit
    $this->cacheService->get('org-1'); // Hit
    $this->cacheService->get('org-2'); // Miss
    $this->cacheService->get('org-1'); // Hit

    $stats = $this->cacheService->getStats();

    expect($stats['hit_rate'])->toBe(60.0);
});

it('respects TTL configuration', function () {
    config(['enterprise.white_label.cache_ttl' => 2]);
    $this->cacheService->put('test-org', 'test-css');

    // Immediately available
    expect($this->cacheService->get('test-org'))->toBe('test-css');

    // After TTL expires
    sleep(3);
    expect($this->cacheService->get('test-org'))->toBeNull();
})->skip('Skipped to avoid slow tests in CI');

it('handles Redis connection failures gracefully', function () {
    // Simulate Redis failure
    Redis::shouldReceive('get')->andThrow(new \Exception('Redis connection failed'));

    $result = $this->cacheService->get('test-org');

    expect($result)->toBeNull(); // Graceful degradation
});

it('increments invalidation counter', function () {
    $organization = Organization::factory()->create();

    $this->cacheService->put($organization->slug, 'css');
    $this->cacheService->invalidate($organization);

    $stats = $this->cacheService->getStats();
    expect($stats['invalidations'])->toBe(1);
});
```

#### FaviconGeneratorServiceTest

```php
<?php

namespace Tests\Unit\Services;

use App\Services\Enterprise\FaviconGeneratorService;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;

uses(TestCase::class, BrandingTestTrait::class);

beforeEach(function () {
    Storage::fake('public');
    $this->service = app(FaviconGeneratorService::class);
});

it('generates favicons in all required sizes', function () {
    $logo = $this->createFakeLogo();
    $organizationId = 123;

    $sizes = [16, 32, 180, 192, 512];
    $paths = $this->service->generateFavicons($logo, $organizationId, $sizes);

    expect($paths)->toBeArray()->toHaveCount(5);

    foreach ($sizes as $size) {
        $expectedPath = "favicons/{$organizationId}/favicon-{$size}x{$size}.png";
        expect($paths[$size])->toBe($expectedPath);
        expect(Storage::disk('public')->exists($expectedPath))->toBeTrue();
    }
});

it('generates correctly sized favicon images', function () {
    $logo = $this->createFakeLogo('logo.png', 512, 512);
    $organizationId = 456;

    $paths = $this->service->generateFavicons($logo, $organizationId, [32]);

    $faviconPath = Storage::disk('public')->path($paths[32]);
    $imageInfo = getimagesize($faviconPath);

    expect($imageInfo[0])->toBe(32); // Width
    expect($imageInfo[1])->toBe(32); // Height
});

it('preserves transparency in PNG favicons', function () {
    $logo = $this->createFakeLogo();
    $organizationId = 789;

    $paths = $this->service->generateFavicons($logo, $organizationId, [32]);

    $faviconPath = Storage::disk('public')->path($paths[32]);
    $image = imagecreatefrompng($faviconPath);

    // Check that image supports alpha channel
    expect(imagecolorsforindex($image, imagecolorallocatealpha($image, 0, 0, 0, 127))['alpha'])
        ->toBeLessThanOrEqual(127);

    imagedestroy($image);
});

it('optimizes favicon file size', function () {
    $logo = $this->createFakeLogo('logo.png', 2048, 2048); // Large logo
    $organizationId = 111;

    $paths = $this->service->generateFavicons($logo, $organizationId, [192]);

    $faviconSize = Storage::disk('public')->size($paths[192]);

    // Favicon should be < 50KB
    expect($faviconSize)->toBeLessThan(50 * 1024);
});

it('returns favicon URLs for organization', function () {
    $logo = $this->createFakeLogo();
    $organizationId = 222;

    $paths = $this->service->generateFavicons($logo, $organizationId);
    $urls = $this->service->getFaviconUrls($organizationId);

    expect($urls)->toBeArray()->toHaveKeys([16, 32, 180, 192, 512]);

    foreach ($urls as $size => $url) {
        expect($url)->toStartWith('/storage/favicons/');
        expect($url)->toContain("favicon-{$size}x{$size}.png");
    }
});

it('handles non-square logos by cropping to center', function () {
    $logo = $this->createFakeLogo('wide-logo.png', 1024, 512); // Wide rectangle
    $organizationId = 333;

    $paths = $this->service->generateFavicons($logo, $organizationId, [64]);

    $faviconPath = Storage::disk('public')->path($paths[64]);
    $imageInfo = getimagesize($faviconPath);

    // Should be square
    expect($imageInfo[0])->toBe(64);
    expect($imageInfo[1])->toBe(64);
});

it('rejects invalid image formats', function () {
    Storage::fake('public');

    $invalidFile = UploadedFile::fake()->create('document.pdf', 100);
    $organizationId = 444;

    expect(fn () => $this->service->generateFavicons($invalidFile, $organizationId))
        ->toThrow(\InvalidArgumentException::class, 'Invalid image format');
});
```

### Integration Test Examples

#### WhiteLabelWorkflowTest

```php
<?php

namespace Tests\Feature\Enterprise;

use App\Events\Enterprise\WhiteLabelConfigUpdated;
use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Models\Organization;
use App\Models\User;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\Storage;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;
use Tests\Traits\CacheTestTrait;

uses(TestCase::class, BrandingTestTrait::class, CacheTestTrait::class);

beforeEach(function () {
    Storage::fake('public');
    $this->clearBrandingCaches();
});

it('completes full branding workflow: upload logo → compile CSS → cache → serve', function () {
    $organization = Organization::factory()->create();
    $admin = User::factory()->create();
    $admin->organizations()->attach($organization, ['role' => 'admin']);

    // Step 1: Upload logo
    $logo = $this->createFakeLogo();
    $this->actingAs($admin)
        ->post("/organizations/{$organization->id}/branding/logo", [
            'logo' => $logo,
        ])
        ->assertRedirect()
        ->assertSessionHas('success');

    // Verify logo stored
    $organization->refresh();
    expect($organization->whiteLabelConfig->logo_url)->not->toBeNull();

    // Step 2: Update branding configuration
    $this->actingAs($admin)
        ->put("/organizations/{$organization->id}/branding", [
            'platform_name' => 'Test Platform',
            'primary_color' => '#ff0000',
            'secondary_color' => '#00ff00',
            'accent_color' => '#0000ff',
            'font_family' => 'Roboto, sans-serif',
        ])
        ->assertRedirect();

    $organization->refresh();
    $config = $organization->whiteLabelConfig;

    expect($config->platform_name)->toBe('Test Platform');
    expect($config->primary_color)->toBe('#ff0000');

    // Step 3: Request CSS (should trigger compilation and caching)
    $response = $this->get("/branding/{$organization->slug}/styles.css");

    $response->assertOk()
        ->assertHeader('Content-Type', 'text/css; charset=UTF-8')
        ->assertHeader('X-Cache', 'MISS'); // First request

    $css = $response->getContent();
    $this->assertCssContainsBranding($css, $config);

    // Step 4: Second request should hit cache
    $response = $this->get("/branding/{$organization->slug}/styles.css");

    $response->assertOk()
        ->assertHeader('X-Cache', 'HIT');

    // Step 5: Update configuration should invalidate cache
    $this->actingAs($admin)
        ->put("/organizations/{$organization->id}/branding", [
            'primary_color' => '#0000ff', // Changed
            'secondary_color' => '#00ff00',
            'accent_color' => '#ff0000',
        ]);

    // Cache should be invalidated
    $this->assertCacheIsInvalidated($organization);

    // Step 6: Next request should recompile
    $response = $this->get("/branding/{$organization->slug}/styles.css");
    $response->assertHeader('X-Cache', 'MISS');
});

it('isolates branding between multiple organizations', function () {
    $org1 = $this->createBrandedOrganization(['primary_color' => '#ff0000']);
    $org2 = $this->createBrandedOrganization(['primary_color' => '#00ff00']);

    // Warm both caches
    $this->warmCacheForOrganization($org1);
    $this->warmCacheForOrganization($org2);

    // Request CSS for org1
    $css1 = $this->getBrandingCss($org1);
    expect($css1)->toContain('#ff0000')->not->toContain('#00ff00');

    // Request CSS for org2
    $css2 = $this->getBrandingCss($org2);
    expect($css2)->toContain('#00ff00')->not->toContain('#ff0000');

    // Verify caches are separate
    $this->assertCacheIsWarm($org1);
    $this->assertCacheIsWarm($org2);
});

it('falls back to default branding when configuration is deleted', function () {
    $organization = $this->createBrandedOrganization();

    // Get branded CSS
    $brandedCss = $this->getBrandingCss($organization);
    expect($brandedCss)->toContain($organization->whiteLabelConfig->primary_color);

    // Delete branding configuration
    $organization->whiteLabelConfig->delete();

    // Should serve default Coolify branding
    $defaultCss = $this->getBrandingCss($organization);
    $defaultPrimary = config('enterprise.white_label.default_theme.primary_color');
    expect($defaultCss)->toContain($defaultPrimary);
});

it('triggers cache warming job when branding is updated', function () {
    Queue::fake();
    Event::fake([WhiteLabelConfigUpdated::class]);

    $organization = $this->createBrandedOrganization();
    $admin = User::factory()->create();
    $admin->organizations()->attach($organization, ['role' => 'admin']);

    $this->actingAs($admin)
        ->put("/organizations/{$organization->id}/branding", [
            'primary_color' => '#123456',
        ]);

    Event::assertDispatched(WhiteLabelConfigUpdated::class);
    Queue::assertPushed(BrandingCacheWarmerJob::class);
});
```

#### BrandingCacheIntegrationTest

```php
<?php

namespace Tests\Feature\Enterprise;

use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\Artisan;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;
use Tests\Traits\CacheTestTrait;

uses(TestCase::class, BrandingTestTrait::class, CacheTestTrait::class);

beforeEach(function () {
    $this->clearBrandingCaches();
});

it('automatically invalidates cache when WhiteLabelConfig is updated', function () {
    $organization = $this->createBrandedOrganization();

    // Warm cache
    $this->warmCacheForOrganization($organization);
    $this->assertCacheIsWarm($organization);

    // Update configuration
    $organization->whiteLabelConfig->update(['primary_color' => '#123456']);

    // Cache should be automatically invalidated
    $this->assertCacheIsInvalidated($organization);
});

it('automatically invalidates cache when WhiteLabelConfig is deleted', function () {
    $organization = $this->createBrandedOrganization();

    $this->warmCacheForOrganization($organization);
    $this->assertCacheIsWarm($organization);

    // Delete configuration
    $organization->whiteLabelConfig->delete();

    // Cache should be invalidated
    $this->assertCacheIsInvalidated($organization);
});

it('clears cache via artisan command for specific organization', function () {
    $organization = $this->createBrandedOrganization();

    $this->warmCacheForOrganization($organization);
    $this->assertCacheIsWarm($organization);

    Artisan::call('branding:clear-cache', ['organization' => $organization->slug]);

    $this->assertCacheIsInvalidated($organization);
});

it('clears all branding caches via artisan command', function () {
    $org1 = $this->createBrandedOrganization();
    $org2 = $this->createBrandedOrganization();
    $org3 = $this->createBrandedOrganization();

    $this->warmCacheForOrganization($org1);
    $this->warmCacheForOrganization($org2);
    $this->warmCacheForOrganization($org3);

    Artisan::call('branding:clear-cache');

    $this->assertCacheIsInvalidated($org1);
    $this->assertCacheIsInvalidated($org2);
    $this->assertCacheIsInvalidated($org3);
});

it('warms cache for all organizations via artisan command', function () {
    $organizations = collect([
        $this->createBrandedOrganization(),
        $this->createBrandedOrganization(),
        $this->createBrandedOrganization(),
    ]);

    Artisan::call('branding:warm-cache', ['--sync' => true]);

    foreach ($organizations as $org) {
        $this->assertCacheIsWarm($org);
    }
});

it('tracks cache statistics accurately', function () {
    $this->clearBrandingCaches(); // Reset stats
    $organization = $this->createBrandedOrganization();

    // Generate 3 cache misses, 7 hits (70% hit rate)
    $this->get("/branding/{$organization->slug}/styles.css"); // Miss
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit

    $this->clearBrandingCaches();

    $this->get("/branding/{$organization->slug}/styles.css"); // Miss
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit

    $this->clearBrandingCaches();

    $this->get("/branding/{$organization->slug}/styles.css"); // Miss
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit
    $this->get("/branding/{$organization->slug}/styles.css"); // Hit

    $stats = $this->getBrandingCacheStats();

    expect($stats['hits'])->toBeGreaterThanOrEqual(7);
    expect($stats['misses'])->toBeGreaterThanOrEqual(3);
    expect($stats['hit_rate'])->toBeGreaterThanOrEqual(50.0);
});
```

### Vue Component Test Examples

#### LogoUploader.test.js

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import LogoUploader from '../LogoUploader.vue';

describe('LogoUploader.vue', () => {
    let wrapper;

    beforeEach(() => {
        wrapper = mount(LogoUploader, {
            props: {
                organizationId: 123,
                currentLogoUrl: null,
                maxFileSize: 5 * 1024 * 1024, // 5MB
            },
        });
    });

    it('renders upload area', () => {
        expect(wrapper.find('.logo-uploader').exists()).toBe(true);
        expect(wrapper.text()).toContain('Drag and drop');
    });

    it('accepts image file via input', async () => {
        const file = new File(['logo content'], 'logo.png', { type: 'image/png' });
        const input = wrapper.find('input[type="file"]');

        await input.setValue([file]);

        expect(wrapper.vm.selectedFile).toBe(file);
    });

    it('validates file type', async () => {
        const invalidFile = new File(['pdf content'], 'document.pdf', { type: 'application/pdf' });
        const input = wrapper.find('input[type="file"]');

        await input.setValue([invalidFile]);

        expect(wrapper.vm.error).toContain('Invalid file type');
        expect(wrapper.vm.selectedFile).toBeNull();
    });

    it('validates file size', async () => {
        const largeFile = new File(['x'.repeat(10 * 1024 * 1024)], 'huge.png', { type: 'image/png' });
        const input = wrapper.find('input[type="file"]');

        await input.setValue([largeFile]);

        expect(wrapper.vm.error).toContain('File size exceeds');
        expect(wrapper.vm.selectedFile).toBeNull();
    });

    it('shows preview after file selection', async () => {
        const file = new File(['logo'], 'logo.png', { type: 'image/png' });
        wrapper.vm.handleFileSelect({ target: { files: [file] } });

        await wrapper.vm.$nextTick();

        expect(wrapper.vm.previewUrl).toBeTruthy();
        expect(wrapper.find('.logo-preview').exists()).toBe(true);
    });

    it('uploads file when submit button clicked', async () => {
        const file = new File(['logo'], 'logo.png', { type: 'image/png' });
        const uploadSpy = vi.spyOn(wrapper.vm, 'uploadLogo');

        wrapper.vm.selectedFile = file;
        await wrapper.vm.$nextTick();

        await wrapper.find('button[type="submit"]').trigger('click');

        expect(uploadSpy).toHaveBeenCalled();
    });

    it('displays current logo if provided', () => {
        wrapper = mount(LogoUploader, {
            props: {
                organizationId: 123,
                currentLogoUrl: '/storage/logos/existing.png',
            },
        });

        expect(wrapper.find('img[alt="Current logo"]').exists()).toBe(true);
        expect(wrapper.find('img').attributes('src')).toBe('/storage/logos/existing.png');
    });

    it('clears selected file', async () => {
        const file = new File(['logo'], 'logo.png', { type: 'image/png' });
        wrapper.vm.selectedFile = file;

        await wrapper.vm.$nextTick();

        await wrapper.find('button.clear-button').trigger('click');

        expect(wrapper.vm.selectedFile).toBeNull();
        expect(wrapper.vm.previewUrl).toBeNull();
    });
});
```

#### BrandingManager.test.js

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import BrandingManager from '../BrandingManager.vue';

describe('BrandingManager.vue', () => {
    let wrapper;

    const mockOrganization = {
        id: 123,
        name: 'Test Organization',
        slug: 'test-org',
    };

    const mockBrandingConfig = {
        platform_name: 'Test Platform',
        primary_color: '#3b82f6',
        secondary_color: '#8b5cf6',
        accent_color: '#10b981',
        font_family: 'Inter, sans-serif',
        logo_url: null,
    };

    beforeEach(() => {
        wrapper = mount(BrandingManager, {
            props: {
                organization: mockOrganization,
                brandingConfig: mockBrandingConfig,
            },
        });
    });

    it('renders all configuration tabs', () => {
        expect(wrapper.find('[data-tab="colors"]').exists()).toBe(true);
        expect(wrapper.find('[data-tab="fonts"]').exists()).toBe(true);
        expect(wrapper.find('[data-tab="logos"]').exists()).toBe(true);
        expect(wrapper.find('[data-tab="advanced"]').exists()).toBe(true);
    });

    it('displays current branding values in form', () => {
        expect(wrapper.find('input[name="platform_name"]').element.value).toBe('Test Platform');
        expect(wrapper.find('input[name="primary_color"]').element.value).toBe('#3b82f6');
    });

    it('validates color input format', async () => {
        const colorInput = wrapper.find('input[name="primary_color"]');

        await colorInput.setValue('invalid-color');
        await wrapper.vm.$nextTick();

        expect(wrapper.vm.errors.primary_color).toContain('Invalid color format');
    });

    it('updates form when branding config changes', async () => {
        await wrapper.setProps({
            brandingConfig: {
                ...mockBrandingConfig,
                primary_color: '#ff0000',
            },
        });

        expect(wrapper.find('input[name="primary_color"]').element.value).toBe('#ff0000');
    });

    it('submits form data correctly', async () => {
        const submitSpy = vi.spyOn(wrapper.vm, 'submitBrandingConfig');

        await wrapper.find('input[name="platform_name"]').setValue('Updated Platform');
        await wrapper.find('form').trigger('submit');

        expect(submitSpy).toHaveBeenCalled();
        expect(wrapper.vm.form.platform_name).toBe('Updated Platform');
    });

    it('shows loading state during submission', async () => {
        wrapper.vm.isSubmitting = true;
        await wrapper.vm.$nextTick();

        expect(wrapper.find('button[type="submit"]').attributes('disabled')).toBeDefined();
        expect(wrapper.find('.loading-spinner').exists()).toBe(true);
    });

    it('displays success message after save', async () => {
        wrapper.vm.handleSuccess();
        await wrapper.vm.$nextTick();

        expect(wrapper.find('.success-message').exists()).toBe(true);
        expect(wrapper.text()).toContain('Branding updated successfully');
    });

    it('switches between tabs', async () {
        await wrapper.find('[data-tab="fonts"]').trigger('click');

        expect(wrapper.vm.activeTab).toBe('fonts');
        expect(wrapper.find('.fonts-panel').isVisible()).toBe(true);
        expect(wrapper.find('.colors-panel').isVisible()).toBe(false);
    });
});
```

### Browser Test Examples (Dusk)

```php
<?php

namespace Tests\Browser\Enterprise;

use App\Models\Organization;
use App\Models\User;
use Laravel\Dusk\Browser;
use Tests\DuskTestCase;
use Tests\Traits\BrandingTestTrait;

uses(DuskTestCase::class, BrandingTestTrait::class);

it('completes end-to-end branding workflow', function () {
    $organization = Organization::factory()->create();
    $admin = User::factory()->create();
    $admin->organizations()->attach($organization, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($admin, $organization) {
        $browser->loginAs($admin)
            ->visit("/organizations/{$organization->id}/branding")
            ->assertSee('White-Label Branding');

        // Upload logo
        $logo = $this->createFakeLogo();
        $browser->attach('logo', $logo->getRealPath())
            ->pause(1000)
            ->assertSee('Logo uploaded successfully');

        // Update colors
        $browser->type('primary_color', '#ff0000')
            ->type('secondary_color', '#00ff00')
            ->type('platform_name', 'My Custom Platform')
            ->press('Save Changes')
            ->pause(2000)
            ->assertSee('Branding updated successfully');

        // Verify live preview updated
        $browser->assertPresent('.branding-preview')
            ->waitFor('.preview-header')
            ->assertCssPropertyValue('.preview-header', 'background-color', 'rgb(255, 0, 0)');
    });
});

it('shows real-time color preview', function () {
    $organization = $this->createBrandedOrganization();
    $admin = User::factory()->create();
    $admin->organizations()->attach($organization, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($admin, $organization) {
        $browser->loginAs($admin)
            ->visit("/organizations/{$organization->id}/branding")
            ->click('[data-tab="colors"]');

        // Change primary color and verify preview updates
        $browser->type('primary_color', '#ff0000')
            ->pause(500) // Wait for debounce
            ->waitFor('.branding-preview')
            ->assertCssPropertyValue('.preview-button', 'background-color', 'rgb(255, 0, 0)');

        // Change to different color
        $browser->clear('primary_color')
            ->type('primary_color', '#0000ff')
            ->pause(500)
            ->assertCssPropertyValue('.preview-button', 'background-color', 'rgb(0, 0, 255)');
    });
});

it('validates uploaded logo dimensions and format', function () {
    $organization = Organization::factory()->create();
    $admin = User::factory()->create();
    $admin->organizations()->attach($organization, ['role' => 'admin']);

    $this->browse(function (Browser $browser) use ($admin, $organization) {
        $browser->loginAs($admin)
            ->visit("/organizations/{$organization->id}/branding");

        // Upload invalid file (PDF instead of image)
        $invalidFile = tmpfile();
        fwrite($invalidFile, 'PDF content');
        $invalidPath = stream_get_meta_data($invalidFile)['uri'];

        $browser->attach('logo', $invalidPath)
            ->pause(500)
            ->assertSee('Invalid file type');
    });
});
```

### Performance Test Examples

```php
<?php

namespace Tests\Performance;

use App\Models\Organization;
use Tests\TestCase;
use Tests\Traits\BrandingTestTrait;
use Tests\Traits\CacheTestTrait;

uses(TestCase::class, BrandingTestTrait::class, CacheTestTrait::class);

it('cached CSS requests complete in under 50ms', function () {
    $organization = $this->createBrandedOrganization();

    // Warm cache
    $this->warmCacheForOrganization($organization);

    // Measure cached request time
    $start = microtime(true);
    $response = $this->get("/branding/{$organization->slug}/styles.css");
    $duration = (microtime(true) - $start) * 1000; // Convert to ms

    $response->assertOk()->assertHeader('X-Cache', 'HIT');
    expect($duration)->toBeLessThan(50);
});

it('CSS compilation completes in under 500ms', function () {
    $organization = $this->createBrandedOrganization();
    $this->clearBrandingCaches();

    // Measure compilation time (cold cache)
    $start = microtime(true);
    $response = $this->get("/branding/{$organization->slug}/styles.css");
    $duration = (microtime(true) - $start) * 1000;

    $response->assertOk()->assertHeader('X-Cache', 'MISS');
    expect($duration)->toBeLessThan(500);
});

it('handles 100 concurrent requests efficiently', function () {
    $organization = $this->createBrandedOrganization();
    $this->warmCacheForOrganization($organization);

    $start = microtime(true);

    $promises = [];
    for ($i = 0; $i < 100; $i++) {
        $promises[] = $this->getAsync("/branding/{$organization->slug}/styles.css");
    }

    // Wait for all requests
    foreach ($promises as $promise) {
        $promise->wait();
    }

    $totalDuration = (microtime(true) - $start) * 1000;
    $avgDuration = $totalDuration / 100;

    expect($avgDuration)->toBeLessThan(100);
})->skip('Requires async HTTP client');

it('cache warming processes 100 organizations in under 60 seconds', function () {
    $organizations = collect();
    for ($i = 0; $i < 100; $i++) {
        $organizations->push($this->createBrandedOrganization());
    }

    $start = microtime(true);
    $this->artisan('branding:warm-cache', ['--sync' => true])->assertSuccessful();
    $duration = microtime(true) - $start;

    expect($duration)->toBeLessThan(60);

    foreach ($organizations as $org) {
        $this->assertCacheIsWarm($org);
    }
})->skip('Slow test, run only for performance regression checks');
```

## Implementation Approach

### Step 1: Create Testing Infrastructure
1. Create `BrandingTestTrait` with reusable helpers
2. Create `CacheTestTrait` for cache-related assertions
3. Enhance `WhiteLabelConfigFactory` with states (complete, minimal, invalid, darkTheme, lightTheme)
4. Create custom assertion methods

### Step 2: Write Unit Tests for Services
1. Create `WhiteLabelServiceTest.php` - Test CSS generation, SASS compilation, configuration retrieval
2. Create `BrandingCacheServiceTest.php` - Test caching, invalidation, statistics
3. Create `FaviconGeneratorServiceTest.php` - Test favicon generation, sizing, optimization
4. Achieve > 90% code coverage for each service

### Step 3: Write Unit Tests for Controllers and Jobs
1. Create `DynamicAssetControllerTest.php` - Test HTTP responses, headers, caching
2. Create `BrandingCacheWarmerJobTest.php` - Test job execution, error handling, retry logic
3. Test all edge cases and error scenarios

### Step 4: Write Integration Tests
1. Create `WhiteLabelWorkflowTest.php` - Test complete workflows end-to-end
2. Create `BrandingCacheIntegrationTest.php` - Test cache invalidation, automatic warming
3. Create `EmailBrandingTest.php` - Test email variable injection
4. Create `DynamicAssetGenerationTest.php` - Test asset serving with real Redis

### Step 5: Write Vue Component Tests
1. Set up Vitest testing environment
2. Create tests for `LogoUploader.vue` - File validation, preview, upload
3. Create tests for `BrandingManager.vue` - Form submission, validation, tab switching
4. Create tests for `ThemeCustomizer.vue` - Color picker, live preview
5. Create tests for `BrandingPreview.vue` - Real-time updates

### Step 6: Write Browser Tests (Dusk)
1. Create `WhiteLabelBrandingTest.php` - End-to-end user workflows
2. Test logo upload with real file interactions
3. Test live color preview in browser
4. Test multi-organization isolation in browser

### Step 7: Write Performance Tests
1. Create `BrandingPerformanceTest.php`
2. Benchmark cached CSS requests (target: < 50ms)
3. Benchmark CSS compilation (target: < 500ms)
4. Benchmark cache warming for multiple organizations

### Step 8: Document Testing Patterns
1. Create testing guide documentation
2. Document custom assertions and helpers
3. Document factory states and usage
4. Document performance benchmarks

### Step 9: Run Full Test Suite
1. Run all tests: `php artisan test`
2. Generate coverage report
3. Verify > 90% coverage for branding system
4. Fix any failing tests

### Step 10: CI/CD Integration
1. Update CI pipeline to run branding tests
2. Add code coverage reporting
3. Set up quality gates (coverage thresholds)
4. Configure test parallelization for speed

## Test Strategy

### Unit Test Coverage

**Target: > 90% code coverage**

**Services to Test:**
- WhiteLabelService (15+ tests)
- BrandingCacheService (12+ tests)
- FaviconGeneratorService (10+ tests)

**Test Categories:**
- Happy path scenarios
- Edge cases (missing data, invalid input)
- Error handling (exceptions, failures)
- Integration with dependencies (Redis, Storage)

### Integration Test Coverage

**Target: All critical workflows validated**

**Workflows to Test:**
- Upload logo → compile CSS → cache → serve
- Update colors → invalidate cache → recompile
- Delete configuration → fallback to defaults
- Multi-organization isolation
- Cache warming automation

### Vue Component Test Coverage

**Target: All components tested**

**Components to Test:**
- LogoUploader.vue (file handling, validation)
- BrandingManager.vue (form management, tabs)
- ThemeCustomizer.vue (color picker, preview)
- BrandingPreview.vue (real-time updates)

### Browser Test Coverage

**Target: All user journeys validated**

**Workflows to Test:**
- End-to-end branding setup
- Live color preview interaction
- Logo upload with drag-and-drop
- Form validation and error messages

### Performance Test Coverage

**Target: All performance benchmarks validated**

**Metrics to Test:**
- Cached CSS response time (< 50ms)
- CSS compilation time (< 500ms)
- Cache warming speed (< 0.6s per organization)
- Concurrent request handling

## Definition of Done

- [ ] BrandingTestTrait created with reusable helpers
- [ ] CacheTestTrait created with cache assertions
- [ ] VueComponentTestTrait created for Vue testing
- [ ] WhiteLabelConfigFactory enhanced with states (complete, minimal, invalid, darkTheme, lightTheme)
- [ ] WhiteLabelServiceTest.php written (15+ tests)
- [ ] BrandingCacheServiceTest.php written (12+ tests)
- [ ] FaviconGeneratorServiceTest.php written (10+ tests)
- [ ] DynamicAssetControllerTest.php written (8+ tests)
- [ ] BrandingCacheWarmerJobTest.php written (8+ tests)
- [ ] WhiteLabelWorkflowTest.php written (6+ integration tests)
- [ ] BrandingCacheIntegrationTest.php written (8+ integration tests)
- [ ] EmailBrandingTest.php written (5+ tests)
- [ ] DynamicAssetGenerationTest.php written (5+ tests)
- [ ] LogoUploader.test.js written (8+ component tests)
- [ ] BrandingManager.test.js written (8+ component tests)
- [ ] ThemeCustomizer.test.js written (6+ component tests)
- [ ] BrandingPreview.test.js written (5+ component tests)
- [ ] WhiteLabelBrandingTest.php Dusk test written (3+ browser tests)
- [ ] BrandingCacheTest.php Dusk test written (2+ browser tests)
- [ ] BrandingPerformanceTest.php written (4+ performance tests)
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] All Vue component tests passing
- [ ] All browser tests passing
- [ ] All performance benchmarks met
- [ ] Code coverage > 90% for branding system
- [ ] Test documentation written
- [ ] Custom assertions documented
- [ ] Factory states documented
- [ ] Testing guide created
- [ ] CI/CD pipeline updated
- [ ] Code coverage reporting configured
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved
- [ ] Performance regression baselines established

## Related Tasks

- **Depends on:** Task 2 (DynamicAssetController - needs implementation to test)
- **Depends on:** Task 3 (BrandingCacheService - needs implementation to test)
- **Depends on:** Task 4 (LogoUploader.vue - needs component to test)
- **Depends on:** Task 5 (BrandingManager.vue - needs component to test)
- **Depends on:** Task 6 (ThemeCustomizer.vue - needs component to test)
- **Depends on:** Task 7 (FaviconGeneratorService - needs implementation to test)
- **Depends on:** Task 8 (BrandingPreview.vue - needs component to test)
- **Depends on:** Task 9 (Email branding - needs implementation to test)
- **Depends on:** Task 10 (BrandingCacheWarmerJob - needs implementation to test)
- **Blocks:** All future white-label enhancements (testing patterns established)
- **Informs:** Task 76 (Enterprise service unit tests - reuse testing patterns)
- **Informs:** Task 79 (Vue component browser tests - reuse Dusk patterns)
