---
name: Add comprehensive payment tests with gateway mocking
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:06Z
github: https://github.com/johnproblems/topgun/issues/159
depends_on: [44, 45, 46, 47, 48]
parallel: false
conflicts_with: []
---

# Task: Add comprehensive payment tests with gateway mocking

## Description

Create a comprehensive test suite for the entire payment processing system, covering payment gateway integrations (Stripe, PayPal), subscription lifecycle management, webhook handling, and usage-based billing calculations. This task ensures the payment system—handling real money and sensitive customer data—is rock-solid, reliable, and fully covered by automated tests that prevent costly production bugs.

**The Payment Testing Challenge:**

Payment systems are uniquely difficult to test because they integrate with external APIs that:
1. **Charge real money** - Production mistakes can cause actual financial losses
2. **Rate limit aggressively** - Payment APIs have strict rate limits (Stripe: 100 req/sec)
3. **Require secrets** - API keys cannot be committed to version control
4. **Return nondeterministic results** - Network failures, fraud detection, card declines
5. **Have complex state machines** - Subscriptions have 10+ states (active, past_due, canceled, etc.)
6. **Use webhooks for async updates** - Payment completion happens out-of-band

Testing against live APIs is slow, expensive, unreliable, and risky. Mock testing is fast and safe but risks divergence from real gateway behavior. The solution is a **hybrid approach**:

**Gateway Mocking Strategy:**

1. **Unit Tests (100% Mocked)** - Test service layer logic with fully mocked gateway responses
2. **Integration Tests (Sandbox Mode)** - Test against gateway test/sandbox environments with real HTTP calls but test cards
3. **WebhookSimulator** - Replay captured webhook payloads for comprehensive webhook testing
4. **PaymentTestingTrait** - Reusable helpers for common payment scenarios (successful payment, declined card, subscription created, etc.)

**Test Coverage Targets:**

- **Service Layer (PaymentService):** 95%+ coverage
- **Gateway Implementations (Stripe, PayPal):** 90%+ coverage
- **Webhook Handlers:** 100% coverage (all event types tested)
- **Subscription Lifecycle:** 100% coverage (all state transitions)
- **Billing Calculations:** 100% coverage (all pricing edge cases)
- **API Endpoints:** 90%+ coverage with authorization testing
- **Error Handling:** 100% coverage (network failures, API errors, invalid data)

**Key Test Scenarios:**

1. **Payment Success Flows**
   - Credit card payment (Stripe)
   - PayPal payment
   - ACH bank transfer
   - Subscription creation with trial period
   - Subscription renewal

2. **Payment Failure Flows**
   - Declined card (insufficient funds, fraud detection)
   - Invalid card number/CVV
   - Expired card
   - Network timeout
   - Gateway API error (500, 503)

3. **Webhook Scenarios**
   - Payment succeeded (charge.succeeded)
   - Payment failed (charge.failed)
   - Subscription created (customer.subscription.created)
   - Subscription updated (customer.subscription.updated)
   - Subscription canceled (customer.subscription.deleted)
   - Invoice payment succeeded
   - Invoice payment failed (triggers dunning)

4. **Subscription Lifecycle**
   - Create subscription with trial period → trial ends → first payment
   - Active subscription → payment fails → retry → eventual cancellation
   - Active subscription → user cancels → end of billing period
   - Active subscription → upgrade plan → proration
   - Active subscription → downgrade plan → schedule change for end of period

5. **Usage-Based Billing**
   - Calculate overage charges based on resource usage
   - Prorate plan changes mid-cycle
   - Apply credits and discounts
   - Handle refunds and adjustments

6. **Security & Authorization**
   - Only organization admins can manage payment methods
   - API tokens scoped to organization
   - Webhook HMAC signature validation
   - PCI compliance (never store raw card data)

**Integration Architecture:**

**Depends On:**
- **Task 44 (Stripe Integration):** Stripe payment gateway implementation
- **Task 45 (PayPal Integration):** PayPal payment gateway implementation
- **Task 46 (PaymentService):** Core payment service layer
- **Task 47 (Webhook System):** Webhook handling infrastructure
- **Task 48 (Subscription Management):** Subscription lifecycle logic

**Test Infrastructure:**
- **PaymentTestingTrait:** Common test helpers (create test customer, simulate payment, etc.)
- **WebhookSimulator:** Replay captured webhook events
- **GatewayMockFactory:** Create mock gateway clients with configurable responses
- **DatabaseTransactions:** All payment tests use database transactions for isolation

**Why This Task is Critical:**

Payment bugs in production are catastrophic:
- **Lost revenue** - Failing to capture payments costs money
- **Customer frustration** - Incorrect charges lead to chargebacks and support tickets
- **PCI compliance violations** - Storing card data incorrectly risks massive fines
- **Fraud exposure** - Inadequate validation enables fraudulent transactions
- **Legal liability** - Incorrect billing can violate consumer protection laws

Comprehensive testing prevents these disasters by catching bugs in development. The test suite serves as executable documentation of payment behavior, regression protection during refactoring, and confidence that the payment system works correctly under all scenarios.

This isn't just about preventing bugs—it's about **protecting revenue, customer trust, and legal compliance**. Every dollar processed through the payment system depends on this test suite working correctly.

## Acceptance Criteria

- [ ] PaymentTestingTrait created with common payment test helpers
- [ ] WebhookSimulator created for replaying webhook events
- [ ] GatewayMockFactory created for configurable mock responses
- [ ] Unit tests for PaymentService (>95% coverage)
- [ ] Unit tests for StripeGateway (>90% coverage)
- [ ] Unit tests for PayPalGateway (>90% coverage)
- [ ] Unit tests for SubscriptionManager (>95% coverage)
- [ ] Unit tests for billing calculations (100% coverage)
- [ ] Integration tests for payment success flows (5+ scenarios)
- [ ] Integration tests for payment failure flows (5+ scenarios)
- [ ] Integration tests for webhook handling (10+ event types)
- [ ] Integration tests for subscription lifecycle (8+ state transitions)
- [ ] API tests with organization scoping and authorization
- [ ] Tests for HMAC webhook signature validation
- [ ] Tests for concurrent payment scenarios (race conditions)
- [ ] Tests for refund processing and reversal
- [ ] Performance tests for high-volume payment processing
- [ ] Security tests for PCI compliance (no raw card data stored)

## Technical Details

### File Paths

**Test Traits:**
- `/home/topgun/topgun/tests/Traits/PaymentTestingTrait.php` (new)
- `/home/topgun/topgun/tests/Traits/OrganizationTestingTrait.php` (existing - Task 72)

**Test Utilities:**
- `/home/topgun/topgun/tests/Utilities/WebhookSimulator.php` (new)
- `/home/topgun/topgun/tests/Utilities/GatewayMockFactory.php` (new)

**Unit Tests:**
- `/home/topgun/topgun/tests/Unit/Services/PaymentServiceTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/StripeGatewayTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/PayPalGatewayTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/SubscriptionManagerTest.php` (new)
- `/home/topgun/topgun/tests/Unit/Services/BillingCalculatorTest.php` (new)

**Integration Tests:**
- `/home/topgun/topgun/tests/Feature/Payment/PaymentFlowsTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Payment/WebhookHandlingTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Payment/SubscriptionLifecycleTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Payment/BillingTest.php` (new)

**API Tests:**
- `/home/topgun/topgun/tests/Feature/Api/PaymentApiTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/SubscriptionApiTest.php` (new)

**Browser Tests:**
- `/home/topgun/topgun/tests/Browser/Payment/PaymentFlowTest.php` (new)

### PaymentTestingTrait Implementation

**File:** `tests/Traits/PaymentTestingTrait.php`

```php
<?php

namespace Tests\Traits;

use App\Models\Organization;
use App\Models\OrganizationSubscription;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use App\Models\User;
use Illuminate\Support\Str;

trait PaymentTestingTrait
{
    /**
     * Create a test organization with admin user
     *
     * @return array{organization: Organization, user: User}
     */
    protected function createTestOrganizationWithUser(): array
    {
        $organization = Organization::factory()->create([
            'name' => 'Test Organization',
            'slug' => 'test-org-' . Str::random(8),
        ]);

        $user = User::factory()->create([
            'email' => 'admin@test-org.local',
        ]);

        $organization->users()->attach($user, [
            'role' => 'admin',
            'permissions' => ['manage_billing', 'manage_subscriptions'],
        ]);

        return [
            'organization' => $organization,
            'user' => $user,
        ];
    }

    /**
     * Create a test payment method
     *
     * @param Organization $organization
     * @param string $gateway
     * @return PaymentMethod
     */
    protected function createTestPaymentMethod(
        Organization $organization,
        string $gateway = 'stripe'
    ): PaymentMethod {
        return PaymentMethod::factory()->create([
            'organization_id' => $organization->id,
            'gateway' => $gateway,
            'gateway_payment_method_id' => $gateway === 'stripe'
                ? 'pm_' . Str::random(24)
                : 'ba_' . Str::random(24),
            'type' => 'card',
            'brand' => 'visa',
            'last4' => '4242',
            'exp_month' => 12,
            'exp_year' => date('Y') + 2,
            'is_default' => true,
        ]);
    }

    /**
     * Create a test subscription
     *
     * @param Organization $organization
     * @param string $status
     * @return OrganizationSubscription
     */
    protected function createTestSubscription(
        Organization $organization,
        string $status = 'active'
    ): OrganizationSubscription {
        return OrganizationSubscription::factory()->create([
            'organization_id' => $organization->id,
            'plan_id' => 'pro_monthly',
            'status' => $status,
            'gateway' => 'stripe',
            'gateway_subscription_id' => 'sub_' . Str::random(24),
            'current_period_start' => now(),
            'current_period_end' => now()->addMonth(),
            'price' => 9900, // $99.00
            'currency' => 'usd',
        ]);
    }

    /**
     * Simulate a successful payment
     *
     * @param Organization $organization
     * @param int $amount Amount in cents
     * @param string $gateway
     * @return PaymentTransaction
     */
    protected function simulateSuccessfulPayment(
        Organization $organization,
        int $amount = 9900,
        string $gateway = 'stripe'
    ): PaymentTransaction {
        return PaymentTransaction::factory()->create([
            'organization_id' => $organization->id,
            'gateway' => $gateway,
            'gateway_transaction_id' => $gateway === 'stripe'
                ? 'ch_' . Str::random(24)
                : 'PAY-' . Str::random(17),
            'type' => 'payment',
            'amount' => $amount,
            'currency' => 'usd',
            'status' => 'succeeded',
            'metadata' => [
                'description' => 'Test payment',
            ],
        ]);
    }

    /**
     * Simulate a failed payment
     *
     * @param Organization $organization
     * @param string $failureReason
     * @return PaymentTransaction
     */
    protected function simulateFailedPayment(
        Organization $organization,
        string $failureReason = 'card_declined'
    ): PaymentTransaction {
        return PaymentTransaction::factory()->create([
            'organization_id' => $organization->id,
            'gateway' => 'stripe',
            'gateway_transaction_id' => 'ch_' . Str::random(24),
            'type' => 'payment',
            'amount' => 9900,
            'currency' => 'usd',
            'status' => 'failed',
            'error_code' => $failureReason,
            'error_message' => match($failureReason) {
                'card_declined' => 'Your card was declined.',
                'insufficient_funds' => 'Your card has insufficient funds.',
                'expired_card' => 'Your card has expired.',
                default => 'Payment failed.',
            },
        ]);
    }

    /**
     * Get test card data for Stripe
     *
     * @param string $scenario
     * @return array
     */
    protected function getTestCard(string $scenario = 'success'): array
    {
        return match($scenario) {
            'success' => [
                'number' => '4242424242424242',
                'exp_month' => 12,
                'exp_year' => date('Y') + 2,
                'cvc' => '123',
            ],
            'declined' => [
                'number' => '4000000000000002',
                'exp_month' => 12,
                'exp_year' => date('Y') + 2,
                'cvc' => '123',
            ],
            'insufficient_funds' => [
                'number' => '4000000000009995',
                'exp_month' => 12,
                'exp_year' => date('Y') + 2,
                'cvc' => '123',
            ],
            'expired' => [
                'number' => '4000000000000069',
                'exp_month' => 1,
                'exp_year' => date('Y') - 1,
                'cvc' => '123',
            ],
            '3ds_required' => [
                'number' => '4000002500003155',
                'exp_month' => 12,
                'exp_year' => date('Y') + 2,
                'cvc' => '123',
            ],
            default => throw new \InvalidArgumentException("Unknown test card scenario: {$scenario}"),
        };
    }

    /**
     * Assert payment transaction was created
     *
     * @param Organization $organization
     * @param int $amount
     * @param string $status
     * @return void
     */
    protected function assertPaymentTransactionCreated(
        Organization $organization,
        int $amount,
        string $status = 'succeeded'
    ): void {
        $this->assertDatabaseHas('payment_transactions', [
            'organization_id' => $organization->id,
            'amount' => $amount,
            'status' => $status,
        ]);
    }

    /**
     * Assert subscription has status
     *
     * @param OrganizationSubscription $subscription
     * @param string $status
     * @return void
     */
    protected function assertSubscriptionStatus(
        OrganizationSubscription $subscription,
        string $status
    ): void {
        $subscription->refresh();

        expect($subscription->status)->toBe($status);
    }

    /**
     * Assert subscription was canceled
     *
     * @param OrganizationSubscription $subscription
     * @return void
     */
    protected function assertSubscriptionCanceled(
        OrganizationSubscription $subscription
    ): void {
        $subscription->refresh();

        expect($subscription->status)->toBeIn(['canceled', 'canceling']);
        expect($subscription->canceled_at)->not->toBeNull();
    }

    /**
     * Mock Stripe API client
     *
     * @return \Mockery\MockInterface
     */
    protected function mockStripeClient(): \Mockery\MockInterface
    {
        return \Mockery::mock(\Stripe\StripeClient::class);
    }

    /**
     * Mock PayPal API client
     *
     * @return \Mockery\MockInterface
     */
    protected function mockPayPalClient(): \Mockery\MockInterface
    {
        return \Mockery::mock(\PayPalCheckoutSdk\Core\PayPalHttpClient::class);
    }
}
```

### WebhookSimulator Implementation

**File:** `tests/Utilities/WebhookSimulator.php`

```php
<?php

namespace Tests\Utilities;

use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class WebhookSimulator
{
    /**
     * Load webhook payload from fixtures
     *
     * @param string $gateway 'stripe' or 'paypal'
     * @param string $eventType Event name (e.g., 'charge.succeeded')
     * @return array
     */
    public static function loadPayload(string $gateway, string $eventType): array
    {
        $path = base_path("tests/Fixtures/Webhooks/{$gateway}/{$eventType}.json");

        if (!File::exists($path)) {
            throw new \RuntimeException("Webhook fixture not found: {$path}");
        }

        $content = File::get($path);
        return json_decode($content, true);
    }

    /**
     * Create Stripe webhook payload
     *
     * @param string $eventType
     * @param array $data
     * @return array
     */
    public static function createStripeWebhook(string $eventType, array $data = []): array
    {
        return [
            'id' => 'evt_' . Str::random(24),
            'object' => 'event',
            'api_version' => '2023-10-16',
            'created' => time(),
            'type' => $eventType,
            'data' => [
                'object' => $data,
            ],
            'livemode' => false,
            'pending_webhooks' => 1,
            'request' => [
                'id' => 'req_' . Str::random(16),
                'idempotency_key' => Str::random(32),
            ],
        ];
    }

    /**
     * Create PayPal webhook payload
     *
     * @param string $eventType
     * @param array $resource
     * @return array
     */
    public static function createPayPalWebhook(string $eventType, array $resource = []): array
    {
        return [
            'id' => 'WH-' . Str::random(17),
            'event_version' => '1.0',
            'create_time' => now()->toIso8601String(),
            'resource_type' => 'sale',
            'resource_version' => '2.0',
            'event_type' => $eventType,
            'summary' => ucfirst(str_replace('.', ' ', $eventType)),
            'resource' => $resource,
        ];
    }

    /**
     * Generate HMAC signature for Stripe webhook
     *
     * @param string $payload
     * @param string $secret
     * @param int $timestamp
     * @return string
     */
    public static function generateStripeSignature(
        string $payload,
        string $secret,
        ?int $timestamp = null
    ): string {
        $timestamp = $timestamp ?? time();
        $signedPayload = "{$timestamp}.{$payload}";
        $signature = hash_hmac('sha256', $signedPayload, $secret);

        return "t={$timestamp},v1={$signature}";
    }

    /**
     * Generate HMAC signature for PayPal webhook
     *
     * @param array $headers
     * @param string $payload
     * @param string $webhookId
     * @param string $certUrl
     * @return bool
     */
    public static function verifyPayPalSignature(
        array $headers,
        string $payload,
        string $webhookId
    ): bool {
        // PayPal webhook verification is complex (requires cert validation)
        // For testing, we'll mock this
        return true;
    }

    /**
     * Simulate webhook request
     *
     * @param string $url
     * @param array $payload
     * @param array $headers
     * @return \Illuminate\Testing\TestResponse
     */
    public static function sendWebhook(
        \Illuminate\Foundation\Testing\TestCase $test,
        string $url,
        array $payload,
        array $headers = []
    ): \Illuminate\Testing\TestResponse {
        return $test->postJson($url, $payload, $headers);
    }
}
```

### GatewayMockFactory Implementation

**File:** `tests/Utilities/GatewayMockFactory.php`

```php
<?php

namespace Tests\Utilities;

use Mockery;

class GatewayMockFactory
{
    /**
     * Create a mock Stripe client
     *
     * @param array $responses Configured responses for methods
     * @return Mockery\MockInterface
     */
    public static function createStripeMock(array $responses = []): Mockery\MockInterface
    {
        $stripe = Mockery::mock(\Stripe\StripeClient::class);

        // Mock charges
        if (isset($responses['charges.create'])) {
            $chargesMock = Mockery::mock();
            $chargesMock->shouldReceive('create')
                ->andReturn($responses['charges.create']);
            $stripe->charges = $chargesMock;
        }

        // Mock payment methods
        if (isset($responses['paymentMethods.attach'])) {
            $pmMock = Mockery::mock();
            $pmMock->shouldReceive('attach')
                ->andReturn($responses['paymentMethods.attach']);
            $stripe->paymentMethods = $pmMock;
        }

        // Mock subscriptions
        if (isset($responses['subscriptions.create'])) {
            $subMock = Mockery::mock();
            $subMock->shouldReceive('create')
                ->andReturn($responses['subscriptions.create']);
            $subMock->shouldReceive('update')
                ->andReturn($responses['subscriptions.update'] ?? $responses['subscriptions.create']);
            $subMock->shouldReceive('cancel')
                ->andReturn($responses['subscriptions.cancel'] ?? ['status' => 'canceled']);
            $stripe->subscriptions = $subMock;
        }

        return $stripe;
    }

    /**
     * Create a mock PayPal client
     *
     * @param array $responses
     * @return Mockery\MockInterface
     */
    public static function createPayPalMock(array $responses = []): Mockery\MockInterface
    {
        $paypal = Mockery::mock(\PayPalCheckoutSdk\Core\PayPalHttpClient::class);

        if (isset($responses['order.create'])) {
            $paypal->shouldReceive('execute')
                ->andReturn($responses['order.create']);
        }

        return $paypal;
    }

    /**
     * Create a successful Stripe charge response
     *
     * @param int $amount
     * @return array
     */
    public static function createSuccessfulCharge(int $amount = 9900): array
    {
        return [
            'id' => 'ch_' . \Str::random(24),
            'object' => 'charge',
            'amount' => $amount,
            'currency' => 'usd',
            'status' => 'succeeded',
            'paid' => true,
            'captured' => true,
            'payment_method' => 'pm_' . \Str::random(24),
            'created' => time(),
        ];
    }

    /**
     * Create a failed Stripe charge response
     *
     * @param string $failureCode
     * @return array
     */
    public static function createFailedCharge(string $failureCode = 'card_declined'): array
    {
        return [
            'id' => 'ch_' . \Str::random(24),
            'object' => 'charge',
            'amount' => 9900,
            'currency' => 'usd',
            'status' => 'failed',
            'paid' => false,
            'failure_code' => $failureCode,
            'failure_message' => match($failureCode) {
                'card_declined' => 'Your card was declined.',
                'insufficient_funds' => 'Your card has insufficient funds.',
                'expired_card' => 'Your card has expired.',
                default => 'Payment failed.',
            },
            'created' => time(),
        ];
    }

    /**
     * Create a Stripe subscription response
     *
     * @param string $status
     * @return array
     */
    public static function createSubscription(string $status = 'active'): array
    {
        return [
            'id' => 'sub_' . \Str::random(24),
            'object' => 'subscription',
            'status' => $status,
            'customer' => 'cus_' . \Str::random(14),
            'items' => [
                'object' => 'list',
                'data' => [
                    [
                        'id' => 'si_' . \Str::random(24),
                        'price' => [
                            'id' => 'price_' . \Str::random(24),
                            'unit_amount' => 9900,
                            'currency' => 'usd',
                        ],
                    ],
                ],
            ],
            'current_period_start' => time(),
            'current_period_end' => strtotime('+1 month'),
            'created' => time(),
        ];
    }
}
```

### Example Unit Test

**File:** `tests/Unit/Services/PaymentServiceTest.php`

```php
<?php

use App\Services\Payment\PaymentService;
use App\Services\Payment\Gateways\StripeGateway;
use App\Models\Organization;
use App\Models\PaymentMethod;
use Tests\Traits\PaymentTestingTrait;
use Tests\Utilities\GatewayMockFactory;

uses(PaymentTestingTrait::class);

beforeEach(function () {
    $this->organization = Organization::factory()->create();
    $this->paymentMethod = $this->createTestPaymentMethod($this->organization);
});

it('processes a successful payment', function () {
    $stripeMock = GatewayMockFactory::createStripeMock([
        'charges.create' => GatewayMockFactory::createSuccessfulCharge(9900),
    ]);

    $gateway = new StripeGateway($stripeMock);
    $service = new PaymentService($gateway);

    $transaction = $service->processPayment(
        $this->organization,
        $this->paymentMethod,
        9900,
        'usd',
        'Test payment'
    );

    expect($transaction)->not->toBeNull()
        ->status->toBe('succeeded')
        ->amount->toBe(9900);

    $this->assertPaymentTransactionCreated($this->organization, 9900, 'succeeded');
});

it('handles payment failures gracefully', function () {
    $stripeMock = GatewayMockFactory::createStripeMock([
        'charges.create' => GatewayMockFactory::createFailedCharge('card_declined'),
    ]);

    $gateway = new StripeGateway($stripeMock);
    $service = new PaymentService($gateway);

    expect(fn() => $service->processPayment(
        $this->organization,
        $this->paymentMethod,
        9900,
        'usd',
        'Test payment'
    ))->toThrow(\App\Exceptions\PaymentFailedException::class);
});

it('creates a subscription successfully', function () {
    $stripeMock = GatewayMockFactory::createStripeMock([
        'subscriptions.create' => GatewayMockFactory::createSubscription('active'),
    ]);

    $gateway = new StripeGateway($stripeMock);
    $service = new PaymentService($gateway);

    $subscription = $service->createSubscription(
        $this->organization,
        $this->paymentMethod,
        'pro_monthly',
        9900
    );

    expect($subscription)->not->toBeNull()
        ->status->toBe('active')
        ->price->toBe(9900);

    $this->assertDatabaseHas('organization_subscriptions', [
        'organization_id' => $this->organization->id,
        'status' => 'active',
        'price' => 9900,
    ]);
});

it('cancels a subscription', function () {
    $subscription = $this->createTestSubscription($this->organization, 'active');

    $stripeMock = GatewayMockFactory::createStripeMock([
        'subscriptions.cancel' => ['status' => 'canceled'],
    ]);

    $gateway = new StripeGateway($stripeMock);
    $service = new PaymentService($gateway);

    $service->cancelSubscription($subscription);

    $this->assertSubscriptionCanceled($subscription);
});

it('calculates prorated amount correctly', function () {
    $subscription = $this->createTestSubscription($this->organization, 'active');

    // Mock current time to 15 days into billing period (50% through)
    $this->travelTo($subscription->current_period_start->addDays(15));

    $service = app(PaymentService::class);
    $proratedAmount = $service->calculateProration(
        $subscription,
        14900 // New plan: $149/month
    );

    // Should charge ~$25 for remaining 15 days at new rate
    // Should credit ~$24.50 for remaining 15 days at old rate
    // Net: ~$0.50 difference
    expect($proratedAmount)->toBeBetween(0, 100);
});
```

### Example Integration Test

**File:** `tests/Feature/Payment/PaymentFlowsTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use Tests\Traits\PaymentTestingTrait;

uses(PaymentTestingTrait::class);

it('completes end-to-end payment flow', function () {
    $data = $this->createTestOrganizationWithUser();
    $organization = $data['organization'];
    $user = $data['user'];

    // Step 1: Add payment method
    $this->actingAs($user)
        ->postJson(route('api.payment-methods.store', $organization), [
            'gateway' => 'stripe',
            'token' => 'tok_visa', // Stripe test token
        ])
        ->assertCreated()
        ->assertJsonPath('data.last4', '4242');

    // Step 2: Create subscription
    $this->actingAs($user)
        ->postJson(route('api.subscriptions.store', $organization), [
            'plan_id' => 'pro_monthly',
            'payment_method_id' => $organization->paymentMethods()->first()->id,
        ])
        ->assertCreated()
        ->assertJsonPath('data.status', 'active');

    // Verify subscription in database
    $this->assertDatabaseHas('organization_subscriptions', [
        'organization_id' => $organization->id,
        'plan_id' => 'pro_monthly',
        'status' => 'active',
    ]);

    // Verify payment transaction was created
    $this->assertDatabaseHas('payment_transactions', [
        'organization_id' => $organization->id,
        'type' => 'subscription_payment',
        'status' => 'succeeded',
    ]);
});

it('handles payment method deletion correctly', function () {
    $data = $this->createTestOrganizationWithUser();
    $organization = $data['organization'];
    $user = $data['user'];

    $paymentMethod = $this->createTestPaymentMethod($organization);

    $this->actingAs($user)
        ->deleteJson(route('api.payment-methods.destroy', [
            'organization' => $organization,
            'paymentMethod' => $paymentMethod,
        ]))
        ->assertNoContent();

    $this->assertSoftDeleted('payment_methods', [
        'id' => $paymentMethod->id,
    ]);
});

it('prevents unauthorized access to payment methods', function () {
    $org1 = Organization::factory()->create();
    $org2 = Organization::factory()->create();

    $user1 = User::factory()->create();
    $org1->users()->attach($user1, ['role' => 'admin']);

    $paymentMethod2 = $this->createTestPaymentMethod($org2);

    // User from org1 should not access org2's payment methods
    $this->actingAs($user1)
        ->getJson(route('api.payment-methods.show', [
            'organization' => $org2,
            'paymentMethod' => $paymentMethod2,
        ]))
        ->assertForbidden();
});
```

### Example Webhook Test

**File:** `tests/Feature/Payment/WebhookHandlingTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\OrganizationSubscription;
use Tests\Utilities\WebhookSimulator;

it('handles Stripe charge.succeeded webhook', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'gateway_subscription_id' => 'sub_test123',
    ]);

    $payload = WebhookSimulator::createStripeWebhook('charge.succeeded', [
        'id' => 'ch_test123',
        'amount' => 9900,
        'currency' => 'usd',
        'customer' => 'cus_test123',
        'subscription' => 'sub_test123',
    ]);

    $signature = WebhookSimulator::generateStripeSignature(
        json_encode($payload),
        config('payment.stripe.webhook_secret')
    );

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $signature,
    ])
        ->assertOk();

    // Verify payment transaction was created
    $this->assertDatabaseHas('payment_transactions', [
        'organization_id' => $organization->id,
        'gateway_transaction_id' => 'ch_test123',
        'amount' => 9900,
        'status' => 'succeeded',
    ]);
});

it('handles Stripe customer.subscription.deleted webhook', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'gateway_subscription_id' => 'sub_test123',
        'status' => 'active',
    ]);

    $payload = WebhookSimulator::createStripeWebhook('customer.subscription.deleted', [
        'id' => 'sub_test123',
        'status' => 'canceled',
    ]);

    $signature = WebhookSimulator::generateStripeSignature(
        json_encode($payload),
        config('payment.stripe.webhook_secret')
    );

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $signature,
    ])
        ->assertOk();

    // Verify subscription was canceled
    $subscription->refresh();
    expect($subscription->status)->toBe('canceled');
    expect($subscription->canceled_at)->not->toBeNull();
});

it('rejects webhook with invalid signature', function () {
    $payload = WebhookSimulator::createStripeWebhook('charge.succeeded', []);

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => 'invalid_signature',
    ])
        ->assertUnauthorized();
});

it('handles duplicate webhook events idempotently', function () {
    $organization = Organization::factory()->create();

    $payload = WebhookSimulator::createStripeWebhook('charge.succeeded', [
        'id' => 'ch_duplicate_test',
        'amount' => 9900,
        'metadata' => ['organization_id' => $organization->id],
    ]);

    $signature = WebhookSimulator::generateStripeSignature(
        json_encode($payload),
        config('payment.stripe.webhook_secret')
    );

    // Send webhook twice
    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $signature,
    ])->assertOk();

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $signature,
    ])->assertOk();

    // Verify only one transaction was created
    $count = \App\Models\PaymentTransaction::where('gateway_transaction_id', 'ch_duplicate_test')->count();
    expect($count)->toBe(1);
});
```

## Implementation Approach

### Step 1: Create Test Infrastructure
1. Create PaymentTestingTrait with common helpers
2. Create WebhookSimulator for webhook testing
3. Create GatewayMockFactory for mock gateway clients
4. Set up test database with payment tables

### Step 2: Write Unit Tests for Services
1. PaymentServiceTest - Test service layer logic
2. StripeGatewayTest - Test Stripe integration
3. PayPalGatewayTest - Test PayPal integration
4. SubscriptionManagerTest - Test subscription lifecycle
5. BillingCalculatorTest - Test usage calculations

### Step 3: Write Integration Tests
1. PaymentFlowsTest - End-to-end payment scenarios
2. WebhookHandlingTest - All webhook event types
3. SubscriptionLifecycleTest - All subscription states
4. BillingTest - Usage-based billing calculations

### Step 4: Write API Tests
1. PaymentApiTest - Payment endpoints with auth
2. SubscriptionApiTest - Subscription endpoints
3. Test organization scoping
4. Test rate limiting

### Step 5: Create Webhook Fixtures
1. Capture real webhook payloads from Stripe/PayPal test mode
2. Store in tests/Fixtures/Webhooks/
3. Create fixtures for all event types
4. Document event schema

### Step 6: Write Browser Tests (Dusk)
1. PaymentFlowTest - UI payment workflow
2. Test payment method management
3. Test subscription creation
4. Test cancellation flow

### Step 7: Add Performance Tests
1. Test high-volume payment processing
2. Test concurrent subscription updates
3. Test webhook processing under load
4. Benchmark billing calculations

### Step 8: Security Testing
1. Test HMAC signature validation
2. Test organization isolation
3. Verify no raw card data stored
4. Test SQL injection prevention
5. Test XSS in payment fields

### Step 9: Edge Case Testing
1. Network timeout scenarios
2. Partial payment failures
3. Race condition handling
4. Duplicate transaction prevention
5. Refund edge cases

### Step 10: Documentation
1. Document test data generation
2. Document mock usage patterns
3. Create testing best practices guide
4. Document webhook testing workflow

## Test Strategy

### Unit Tests Coverage

**PaymentService Tests:**
- Process payment (success)
- Process payment (failure - declined card)
- Process payment (failure - network error)
- Create subscription
- Update subscription
- Cancel subscription
- Process refund
- Calculate proration
- Validate payment amount

**Gateway Tests (Stripe/PayPal):**
- Create charge
- Capture charge
- Refund charge
- Create customer
- Attach payment method
- Create subscription
- Update subscription
- Cancel subscription
- Parse webhook event
- Validate webhook signature

**Subscription Manager Tests:**
- Create subscription with trial
- Trial expiration handling
- Subscription renewal
- Plan upgrade with proration
- Plan downgrade scheduling
- Cancellation handling
- Dunning workflow
- Payment retry logic

**Billing Calculator Tests:**
- Calculate monthly price
- Calculate usage overage
- Prorate plan change
- Apply discounts
- Calculate taxes
- Generate invoice
- Refund calculations

### Integration Tests Coverage

**Payment Flows:**
- Complete payment with new card
- Complete payment with saved card
- Failed payment handling
- 3D Secure flow
- ACH payment flow
- PayPal payment flow

**Subscription Lifecycle:**
- Create → Active
- Active → Past Due → Retry → Active
- Active → Past Due → Retry → Canceled
- Active → User Cancel → End of Period
- Active → Upgrade → Proration
- Active → Downgrade → Schedule Change

**Webhook Handling:**
- charge.succeeded
- charge.failed
- payment_intent.succeeded
- payment_intent.payment_failed
- customer.subscription.created
- customer.subscription.updated
- customer.subscription.deleted
- invoice.payment_succeeded
- invoice.payment_failed
- customer.updated

### API Tests Coverage

- Create payment method (authorized)
- Create payment method (unauthorized - wrong org)
- Delete payment method
- List payment methods
- Create subscription
- Update subscription
- Cancel subscription
- List transactions
- Webhook endpoints (signature validation)

## Definition of Done

- [ ] PaymentTestingTrait created and documented
- [ ] WebhookSimulator created with all helper methods
- [ ] GatewayMockFactory created for Stripe and PayPal
- [ ] PaymentServiceTest written (>95% coverage)
- [ ] StripeGatewayTest written (>90% coverage)
- [ ] PayPalGatewayTest written (>90% coverage)
- [ ] SubscriptionManagerTest written (>95% coverage)
- [ ] BillingCalculatorTest written (100% coverage)
- [ ] PaymentFlowsTest written (5+ scenarios)
- [ ] WebhookHandlingTest written (10+ event types)
- [ ] SubscriptionLifecycleTest written (8+ state transitions)
- [ ] BillingTest written (usage calculations)
- [ ] PaymentApiTest written with authorization tests
- [ ] SubscriptionApiTest written
- [ ] Webhook signature validation tests
- [ ] Concurrent payment tests
- [ ] Refund processing tests
- [ ] Performance tests for payment processing
- [ ] Security tests (PCI compliance verification)
- [ ] Browser tests for payment UI (Dusk)
- [ ] Webhook fixtures created for all event types
- [ ] Test documentation written
- [ ] All tests passing (100% success rate)
- [ ] Code coverage report generated (>90%)
- [ ] PHPStan level 5 passing for test code
- [ ] Pest formatting applied
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 44 (Stripe Integration)
- **Depends on:** Task 45 (PayPal Integration)
- **Depends on:** Task 46 (PaymentService)
- **Depends on:** Task 47 (Webhook System)
- **Depends on:** Task 48 (Subscription Management)
- **Complements:** Task 72 (OrganizationTestingTrait)
- **Complements:** Task 76 (Enterprise Service Tests)
- **Complements:** Task 78 (API Tests)
