---
name: Implement DomainRegistrarInterface and factory pattern
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:16Z
github: https://github.com/johnproblems/topgun/issues/171
depends_on: [62]
parallel: false
conflicts_with: []
---

# Task: Implement DomainRegistrarInterface and factory pattern

## Description

This task creates the foundational architecture for multi-registrar domain management in the Coolify Enterprise platform. By implementing a unified interface and factory pattern, organizations can seamlessly manage domains across multiple registrars (Namecheap, GoDaddy, Route53, Cloudflare, etc.) without vendor lock-in. This flexible architecture enables the platform to:

1. **Unified Domain Operations** - Single API for domain registration, renewal, transfer, and DNS management regardless of underlying registrar
2. **Multi-Registrar Support** - Organizations can use different registrars for different domains based on pricing, features, or existing accounts
3. **Easy Extensibility** - Adding new registrar integrations requires minimal changes to existing code
4. **Testability** - Mock registrars for testing without making real API calls or incurring costs
5. **Graceful Degradation** - Handle registrar API failures without breaking the entire domain management system

The interface defines standardized methods that all registrars must implement:
- `checkAvailability(string $domain): bool` - Check if domain is available for registration
- `registerDomain(string $domain, array $contactInfo, int $years): DomainRegistration` - Register a new domain
- `renewDomain(string $domain, int $years): DomainRenewal` - Renew existing domain registration
- `transferDomain(string $domain, string $authCode): DomainTransfer` - Transfer domain from another registrar
- `updateNameservers(string $domain, array $nameservers): bool` - Update domain nameservers
- `getDomainInfo(string $domain): DomainInfo` - Get domain registration details
- `listDomains(Organization $organization): Collection` - List all domains for organization
- `setAutoRenew(string $domain, bool $enabled): bool` - Enable/disable automatic renewal

The factory pattern enables runtime selection of the appropriate registrar implementation based on:
- Organization's default registrar preference
- Per-domain registrar assignment
- Registrar-specific features required for the operation
- Fallback registrar if primary is unavailable

**Integration Points:**
- Used by `DomainRegistrarService` (Task 66) for high-level domain operations
- Configured via `OrganizationDomain` model with registrar credentials
- Powers `DomainManager.vue` (Task 70) frontend component
- Integrated with DNS management (Task 67) for automated record creation
- Used by Let's Encrypt integration (Task 68) for domain validation

**Why this task is important:** The interface and factory pattern establish the architectural foundation for all domain management features. Without this flexible abstraction layer, the system would be tightly coupled to a single registrar, making it impossible to offer multi-registrar support or swap registrars without major code rewrites. This pattern also enables comprehensive testing with mock registrars, preventing expensive real API calls during development and CI/CD pipelines.

**Key Features:**
- **Registrar-Agnostic Interface** - Standardized method signatures across all registrars
- **Factory Pattern** - Runtime registrar selection based on configuration
- **DTO Response Objects** - Consistent data structures regardless of registrar API format
- **Exception Hierarchy** - Standardized error handling for network failures, validation errors, registrar-specific errors
- **Credential Management** - Secure storage and retrieval of registrar API credentials
- **Rate Limiting Support** - Built-in support for registrar API rate limits

## Acceptance Criteria

- [ ] DomainRegistrarInterface created with all required method signatures
- [ ] DomainRegistrarFactory implemented with registrar selection logic
- [ ] DTO classes created for all domain operations (DomainInfo, DomainRegistration, DomainRenewal, DomainTransfer)
- [ ] Exception hierarchy implemented (RegistrarException, DomainNotAvailableException, RegistrarAuthException, etc.)
- [ ] MockRegistrar implementation created for testing purposes
- [ ] Factory can select registrar based on organization preference
- [ ] Factory can select registrar based on per-domain assignment
- [ ] Factory throws appropriate exception if registrar not found or not configured
- [ ] Interface supports domain availability checking across all registrars
- [ ] Interface supports domain registration with contact information
- [ ] Interface supports domain renewal with configurable years
- [ ] Interface supports domain transfer with auth codes
- [ ] Interface supports nameserver updates
- [ ] Credentials retrieved securely from database with decryption
- [ ] All methods documented with PHPDoc including exceptions

## Technical Details

### File Paths

**Core Interface and Factory:**
- `/home/topgun/topgun/app/Contracts/DomainRegistrarInterface.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrarFactory.php` (new)

**Data Transfer Objects (DTOs):**
- `/home/topgun/topgun/app/DataTransferObjects/Domain/DomainInfo.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/Domain/DomainRegistration.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/Domain/DomainRenewal.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/Domain/DomainTransfer.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/Domain/ContactInfo.php` (new)

**Exceptions:**
- `/home/topgun/topgun/app/Exceptions/Domain/RegistrarException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Domain/DomainNotAvailableException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Domain/RegistrarAuthException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Domain/RegistrarRateLimitException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Domain/InvalidDomainException.php` (new)

**Mock Implementation (for testing):**
- `/home/topgun/topgun/app/Services/Enterprise/Registrars/MockRegistrar.php` (new)

**Service Provider:**
- `/home/topgun/topgun/app/Providers/EnterpriseServiceProvider.php` (modify - register factory)

### Database Schema Reference

This task uses the `organization_domains` table created in Task 62:

```sql
-- Reference only - table created in Task 62
CREATE TABLE organization_domains (
    id BIGINT UNSIGNED PRIMARY KEY,
    organization_id BIGINT UNSIGNED NOT NULL,
    domain VARCHAR(255) NOT NULL,
    registrar VARCHAR(50) NOT NULL, -- 'namecheap', 'route53', 'godaddy', 'cloudflare'
    registrar_domain_id VARCHAR(255), -- External registrar's domain ID
    status VARCHAR(50) NOT NULL, -- 'pending', 'active', 'expired', 'cancelled'
    registered_at TIMESTAMP,
    expires_at TIMESTAMP,
    auto_renew BOOLEAN DEFAULT true,
    nameservers JSON,
    contact_info JSON,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,

    INDEX idx_organization_id (organization_id),
    INDEX idx_domain (domain),
    INDEX idx_registrar (registrar),
    INDEX idx_status (status),
    UNIQUE KEY unique_domain (domain)
);
```

### DomainRegistrarInterface Implementation

**File:** `app/Contracts/DomainRegistrarInterface.php`

```php
<?php

namespace App\Contracts;

use App\DataTransferObjects\Domain\ContactInfo;
use App\DataTransferObjects\Domain\DomainInfo;
use App\DataTransferObjects\Domain\DomainRegistration;
use App\DataTransferObjects\Domain\DomainRenewal;
use App\DataTransferObjects\Domain\DomainTransfer;
use App\Models\Organization;
use Illuminate\Support\Collection;

/**
 * Interface for domain registrar implementations
 *
 * All domain registrars (Namecheap, Route53, GoDaddy, Cloudflare, etc.) must implement
 * this interface to ensure consistent behavior across different providers.
 */
interface DomainRegistrarInterface
{
    /**
     * Check if a domain is available for registration
     *
     * @param string $domain Fully qualified domain name (e.g., 'example.com')
     * @return bool True if domain is available, false if taken
     * @throws \App\Exceptions\Domain\InvalidDomainException If domain format is invalid
     * @throws \App\Exceptions\Domain\RegistrarException If API call fails
     */
    public function checkAvailability(string $domain): bool;

    /**
     * Register a new domain
     *
     * @param string $domain Fully qualified domain name
     * @param ContactInfo $contactInfo Registrant contact information
     * @param int $years Number of years to register (1-10)
     * @return DomainRegistration Registration details including confirmation and expiry
     * @throws \App\Exceptions\Domain\DomainNotAvailableException If domain is not available
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     * @throws \App\Exceptions\Domain\RegistrarException If registration fails
     */
    public function registerDomain(string $domain, ContactInfo $contactInfo, int $years = 1): DomainRegistration;

    /**
     * Renew an existing domain registration
     *
     * @param string $domain Fully qualified domain name
     * @param int $years Number of years to renew (1-10)
     * @return DomainRenewal Renewal details including new expiry date
     * @throws \App\Exceptions\Domain\RegistrarException If renewal fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function renewDomain(string $domain, int $years = 1): DomainRenewal;

    /**
     * Transfer a domain from another registrar
     *
     * @param string $domain Fully qualified domain name
     * @param string $authCode Authorization code from current registrar
     * @return DomainTransfer Transfer details including status and expected completion
     * @throws \App\Exceptions\Domain\RegistrarException If transfer initiation fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function transferDomain(string $domain, string $authCode): DomainTransfer;

    /**
     * Update domain nameservers
     *
     * @param string $domain Fully qualified domain name
     * @param array $nameservers Array of nameserver hostnames (e.g., ['ns1.example.com', 'ns2.example.com'])
     * @return bool True if update successful
     * @throws \App\Exceptions\Domain\RegistrarException If update fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function updateNameservers(string $domain, array $nameservers): bool;

    /**
     * Get detailed information about a domain
     *
     * @param string $domain Fully qualified domain name
     * @return DomainInfo Domain registration details including status, dates, nameservers
     * @throws \App\Exceptions\Domain\RegistrarException If domain not found or API call fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function getDomainInfo(string $domain): DomainInfo;

    /**
     * List all domains for an organization
     *
     * @param Organization $organization Organization to list domains for
     * @return Collection<DomainInfo> Collection of domain information objects
     * @throws \App\Exceptions\Domain\RegistrarException If API call fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function listDomains(Organization $organization): Collection;

    /**
     * Enable or disable automatic renewal for a domain
     *
     * @param string $domain Fully qualified domain name
     * @param bool $enabled True to enable auto-renewal, false to disable
     * @return bool True if update successful
     * @throws \App\Exceptions\Domain\RegistrarException If update fails
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function setAutoRenew(string $domain, bool $enabled): bool;

    /**
     * Get the authorization code for domain transfer
     *
     * @param string $domain Fully qualified domain name
     * @return string Authorization/EPP code for transferring domain
     * @throws \App\Exceptions\Domain\RegistrarException If unable to retrieve auth code
     * @throws \App\Exceptions\Domain\RegistrarAuthException If API credentials are invalid
     */
    public function getAuthCode(string $domain): string;

    /**
     * Validate registrar API credentials
     *
     * @return bool True if credentials are valid and working
     * @throws \App\Exceptions\Domain\RegistrarAuthException If credentials are invalid
     */
    public function validateCredentials(): bool;

    /**
     * Get registrar identifier (e.g., 'namecheap', 'route53', 'godaddy')
     *
     * @return string Registrar identifier
     */
    public function getName(): string;

    /**
     * Get registrar display name (e.g., 'Namecheap', 'Amazon Route 53', 'GoDaddy')
     *
     * @return string Human-readable registrar name
     */
    public function getDisplayName(): string;

    /**
     * Check if registrar supports a specific TLD
     *
     * @param string $tld Top-level domain (e.g., 'com', 'net', 'io')
     * @return bool True if TLD is supported
     */
    public function supportsTld(string $tld): bool;
}
```

### DomainRegistrarFactory Implementation

**File:** `app/Services/Enterprise/DomainRegistrarFactory.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\DomainRegistrarInterface;
use App\Exceptions\Domain\RegistrarException;
use App\Models\Organization;
use App\Models\Enterprise\OrganizationDomain;
use Illuminate\Support\Facades\Log;

/**
 * Factory for creating domain registrar instances
 *
 * Selects the appropriate registrar implementation based on:
 * - Organization's default registrar preference
 * - Per-domain registrar assignment
 * - Fallback to default if not specified
 */
class DomainRegistrarFactory
{
    /**
     * Map of registrar identifiers to implementation classes
     */
    private array $registrars = [];

    /**
     * Default registrar to use if none specified
     */
    private string $defaultRegistrar = 'namecheap';

    /**
     * Register a registrar implementation
     *
     * @param string $name Registrar identifier (e.g., 'namecheap')
     * @param string $className Fully qualified class name
     * @return void
     */
    public function register(string $name, string $className): void
    {
        if (!is_subclass_of($className, DomainRegistrarInterface::class)) {
            throw new \InvalidArgumentException(
                "Registrar class must implement DomainRegistrarInterface: {$className}"
            );
        }

        $this->registrars[$name] = $className;

        Log::debug("Registered domain registrar: {$name}", [
            'class' => $className,
        ]);
    }

    /**
     * Create a registrar instance for an organization
     *
     * @param Organization $organization Organization to create registrar for
     * @param string|null $registrarName Override registrar (optional)
     * @return DomainRegistrarInterface Configured registrar instance
     * @throws RegistrarException If registrar not found or not configured
     */
    public function make(Organization $organization, ?string $registrarName = null): DomainRegistrarInterface
    {
        // Determine which registrar to use
        $registrarName = $registrarName
            ?? $organization->default_domain_registrar
            ?? $this->defaultRegistrar;

        // Check if registrar is registered
        if (!isset($this->registrars[$registrarName])) {
            throw new RegistrarException(
                "Domain registrar not found: {$registrarName}. Available: " . implode(', ', array_keys($this->registrars))
            );
        }

        $className = $this->registrars[$registrarName];

        // Get registrar credentials from organization settings
        $credentials = $this->getRegistrarCredentials($organization, $registrarName);

        if (empty($credentials)) {
            throw new RegistrarException(
                "No credentials configured for registrar: {$registrarName}. Please configure credentials in organization settings."
            );
        }

        // Create and configure registrar instance
        $registrar = new $className($credentials);

        Log::info("Created domain registrar instance", [
            'organization_id' => $organization->id,
            'registrar' => $registrarName,
            'class' => $className,
        ]);

        return $registrar;
    }

    /**
     * Create a registrar instance for a specific domain
     *
     * Uses the registrar assigned to the domain in the database
     *
     * @param OrganizationDomain $domain Domain to create registrar for
     * @return DomainRegistrarInterface Configured registrar instance
     * @throws RegistrarException If registrar not found or not configured
     */
    public function makeForDomain(OrganizationDomain $domain): DomainRegistrarInterface
    {
        return $this->make($domain->organization, $domain->registrar);
    }

    /**
     * Get list of all registered registrars
     *
     * @return array Array of registrar identifiers
     */
    public function getAvailableRegistrars(): array
    {
        return array_keys($this->registrars);
    }

    /**
     * Check if a registrar is registered
     *
     * @param string $registrarName Registrar identifier
     * @return bool True if registrar is registered
     */
    public function hasRegistrar(string $registrarName): bool
    {
        return isset($this->registrars[$registrarName]);
    }

    /**
     * Set the default registrar
     *
     * @param string $registrarName Registrar identifier
     * @return void
     * @throws RegistrarException If registrar not found
     */
    public function setDefaultRegistrar(string $registrarName): void
    {
        if (!$this->hasRegistrar($registrarName)) {
            throw new RegistrarException("Cannot set default to unregistered registrar: {$registrarName}");
        }

        $this->defaultRegistrar = $registrarName;

        Log::info("Default domain registrar changed", [
            'registrar' => $registrarName,
        ]);
    }

    /**
     * Get registrar credentials from organization settings
     *
     * @param Organization $organization Organization to get credentials for
     * @param string $registrarName Registrar identifier
     * @return array Decrypted credentials array
     */
    private function getRegistrarCredentials(Organization $organization, string $registrarName): array
    {
        // Get credentials from organization's domain settings
        // These are stored encrypted in the organization_settings JSON column
        $settings = $organization->settings ?? [];
        $domainSettings = $settings['domain_management'] ?? [];
        $credentials = $domainSettings['registrars'][$registrarName] ?? [];

        if (empty($credentials)) {
            Log::warning("No credentials found for domain registrar", [
                'organization_id' => $organization->id,
                'registrar' => $registrarName,
            ]);

            return [];
        }

        // Decrypt credentials if encrypted
        if (isset($credentials['encrypted']) && $credentials['encrypted'] === true) {
            $credentials = $this->decryptCredentials($credentials);
        }

        return $credentials;
    }

    /**
     * Decrypt registrar credentials
     *
     * @param array $encryptedCredentials Encrypted credentials
     * @return array Decrypted credentials
     */
    private function decryptCredentials(array $encryptedCredentials): array
    {
        $decrypted = [];

        foreach ($encryptedCredentials as $key => $value) {
            if ($key === 'encrypted') {
                continue; // Skip the encrypted flag
            }

            if (is_string($value)) {
                try {
                    $decrypted[$key] = decrypt($value);
                } catch (\Exception $e) {
                    Log::error("Failed to decrypt credential", [
                        'key' => $key,
                        'error' => $e->getMessage(),
                    ]);

                    $decrypted[$key] = $value; // Use as-is if decryption fails
                }
            } else {
                $decrypted[$key] = $value;
            }
        }

        return $decrypted;
    }

    /**
     * Validate that an organization has valid credentials for a registrar
     *
     * @param Organization $organization Organization to check
     * @param string $registrarName Registrar identifier
     * @return bool True if credentials are valid
     */
    public function hasValidCredentials(Organization $organization, string $registrarName): bool
    {
        $credentials = $this->getRegistrarCredentials($organization, $registrarName);

        if (empty($credentials)) {
            return false;
        }

        try {
            $registrar = $this->make($organization, $registrarName);
            return $registrar->validateCredentials();
        } catch (RegistrarException $e) {
            Log::warning("Registrar credential validation failed", [
                'organization_id' => $organization->id,
                'registrar' => $registrarName,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }
}
```

### Data Transfer Objects (DTOs)

**File:** `app/DataTransferObjects/Domain/DomainInfo.php`

```php
<?php

namespace App\DataTransferObjects\Domain;

use Carbon\Carbon;

/**
 * Domain information data transfer object
 *
 * Represents domain registration details from any registrar
 */
class DomainInfo
{
    public function __construct(
        public readonly string $domain,
        public readonly string $status,
        public readonly ?Carbon $registeredAt = null,
        public readonly ?Carbon $expiresAt = null,
        public readonly bool $autoRenew = false,
        public readonly array $nameservers = [],
        public readonly ?ContactInfo $registrant = null,
        public readonly ?string $registrarDomainId = null,
        public readonly array $metadata = []
    ) {}

    /**
     * Create from array (useful for API responses)
     */
    public static function fromArray(array $data): self
    {
        return new self(
            domain: $data['domain'],
            status: $data['status'],
            registeredAt: isset($data['registered_at']) ? Carbon::parse($data['registered_at']) : null,
            expiresAt: isset($data['expires_at']) ? Carbon::parse($data['expires_at']) : null,
            autoRenew: $data['auto_renew'] ?? false,
            nameservers: $data['nameservers'] ?? [],
            registrant: isset($data['registrant']) ? ContactInfo::fromArray($data['registrant']) : null,
            registrarDomainId: $data['registrar_domain_id'] ?? null,
            metadata: $data['metadata'] ?? []
        );
    }

    /**
     * Convert to array
     */
    public function toArray(): array
    {
        return [
            'domain' => $this->domain,
            'status' => $this->status,
            'registered_at' => $this->registeredAt?->toIso8601String(),
            'expires_at' => $this->expiresAt?->toIso8601String(),
            'auto_renew' => $this->autoRenew,
            'nameservers' => $this->nameservers,
            'registrant' => $this->registrant?->toArray(),
            'registrar_domain_id' => $this->registrarDomainId,
            'metadata' => $this->metadata,
        ];
    }

    /**
     * Check if domain is active
     */
    public function isActive(): bool
    {
        return $this->status === 'active';
    }

    /**
     * Check if domain is expired
     */
    public function isExpired(): bool
    {
        return $this->expiresAt && $this->expiresAt->isPast();
    }

    /**
     * Get days until expiration
     */
    public function daysUntilExpiry(): ?int
    {
        return $this->expiresAt ? now()->diffInDays($this->expiresAt, false) : null;
    }
}
```

**File:** `app/DataTransferObjects/Domain/DomainRegistration.php`

```php
<?php

namespace App\DataTransferObjects\Domain;

use Carbon\Carbon;

/**
 * Domain registration result data transfer object
 */
class DomainRegistration
{
    public function __construct(
        public readonly string $domain,
        public readonly bool $success,
        public readonly string $confirmationId,
        public readonly Carbon $expiresAt,
        public readonly float $cost,
        public readonly string $currency = 'USD',
        public readonly array $metadata = []
    ) {}

    public static function fromArray(array $data): self
    {
        return new self(
            domain: $data['domain'],
            success: $data['success'],
            confirmationId: $data['confirmation_id'],
            expiresAt: Carbon::parse($data['expires_at']),
            cost: (float) $data['cost'],
            currency: $data['currency'] ?? 'USD',
            metadata: $data['metadata'] ?? []
        );
    }

    public function toArray(): array
    {
        return [
            'domain' => $this->domain,
            'success' => $this->success,
            'confirmation_id' => $this->confirmationId,
            'expires_at' => $this->expiresAt->toIso8601String(),
            'cost' => $this->cost,
            'currency' => $this->currency,
            'metadata' => $this->metadata,
        ];
    }
}
```

**File:** `app/DataTransferObjects/Domain/ContactInfo.php`

```php
<?php

namespace App\DataTransferObjects\Domain;

/**
 * Contact information for domain registration
 */
class ContactInfo
{
    public function __construct(
        public readonly string $firstName,
        public readonly string $lastName,
        public readonly string $email,
        public readonly string $phone,
        public readonly string $organization,
        public readonly string $address1,
        public readonly ?string $address2 = null,
        public readonly string $city,
        public readonly string $state,
        public readonly string $postalCode,
        public readonly string $country
    ) {}

    public static function fromArray(array $data): self
    {
        return new self(
            firstName: $data['first_name'],
            lastName: $data['last_name'],
            email: $data['email'],
            phone: $data['phone'],
            organization: $data['organization'],
            address1: $data['address1'],
            address2: $data['address2'] ?? null,
            city: $data['city'],
            state: $data['state'],
            postalCode: $data['postal_code'],
            country: $data['country']
        );
    }

    public function toArray(): array
    {
        return [
            'first_name' => $this->firstName,
            'last_name' => $this->lastName,
            'email' => $this->email,
            'phone' => $this->phone,
            'organization' => $this->organization,
            'address1' => $this->address1,
            'address2' => $this->address2,
            'city' => $this->city,
            'state' => $this->state,
            'postal_code' => $this->postalCode,
            'country' => $this->country,
        ];
    }
}
```

### Exception Hierarchy

**File:** `app/Exceptions/Domain/RegistrarException.php`

```php
<?php

namespace App\Exceptions\Domain;

use Exception;

/**
 * Base exception for domain registrar errors
 */
class RegistrarException extends Exception
{
    public function __construct(
        string $message = "",
        int $code = 0,
        ?\Throwable $previous = null,
        public readonly ?string $registrar = null,
        public readonly ?string $domain = null,
        public readonly array $context = []
    ) {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Create exception with context
     */
    public static function withContext(
        string $message,
        ?string $registrar = null,
        ?string $domain = null,
        array $context = []
    ): self {
        return new self($message, 0, null, $registrar, $domain, $context);
    }
}
```

**File:** `app/Exceptions/Domain/DomainNotAvailableException.php`

```php
<?php

namespace App\Exceptions\Domain;

/**
 * Exception thrown when attempting to register an unavailable domain
 */
class DomainNotAvailableException extends RegistrarException
{
    public function __construct(string $domain, ?string $registrar = null)
    {
        parent::__construct(
            message: "Domain is not available for registration: {$domain}",
            registrar: $registrar,
            domain: $domain
        );
    }
}
```

**File:** `app/Exceptions/Domain/RegistrarAuthException.php`

```php
<?php

namespace App\Exceptions\Domain;

/**
 * Exception thrown when registrar API authentication fails
 */
class RegistrarAuthException extends RegistrarException
{
    public function __construct(string $registrar, string $reason = 'Invalid credentials')
    {
        parent::__construct(
            message: "Authentication failed for registrar {$registrar}: {$reason}",
            registrar: $registrar
        );
    }
}
```

### Mock Registrar Implementation (for testing)

**File:** `app/Services/Enterprise/Registrars/MockRegistrar.php`

```php
<?php

namespace App\Services\Enterprise\Registrars;

use App\Contracts\DomainRegistrarInterface;
use App\DataTransferObjects\Domain\ContactInfo;
use App\DataTransferObjects\Domain\DomainInfo;
use App\DataTransferObjects\Domain\DomainRegistration;
use App\DataTransferObjects\Domain\DomainRenewal;
use App\DataTransferObjects\Domain\DomainTransfer;
use App\Exceptions\Domain\DomainNotAvailableException;
use App\Exceptions\Domain\RegistrarException;
use App\Models\Organization;
use Carbon\Carbon;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;

/**
 * Mock registrar for testing
 *
 * Simulates registrar operations without making real API calls
 */
class MockRegistrar implements DomainRegistrarInterface
{
    private array $registeredDomains = [];
    private array $unavailableDomains = ['google.com', 'facebook.com', 'amazon.com'];

    public function __construct(private array $credentials = [])
    {
    }

    public function checkAvailability(string $domain): bool
    {
        return !in_array($domain, $this->unavailableDomains)
            && !isset($this->registeredDomains[$domain]);
    }

    public function registerDomain(string $domain, ContactInfo $contactInfo, int $years = 1): DomainRegistration
    {
        if (!$this->checkAvailability($domain)) {
            throw new DomainNotAvailableException($domain, 'mock');
        }

        $expiresAt = now()->addYears($years);

        $this->registeredDomains[$domain] = [
            'contact' => $contactInfo,
            'expires_at' => $expiresAt,
            'auto_renew' => false,
            'nameservers' => [],
        ];

        return new DomainRegistration(
            domain: $domain,
            success: true,
            confirmationId: 'MOCK-' . Str::upper(Str::random(10)),
            expiresAt: $expiresAt,
            cost: 12.99 * $years,
            currency: 'USD'
        );
    }

    public function renewDomain(string $domain, int $years = 1): DomainRenewal
    {
        if (!isset($this->registeredDomains[$domain])) {
            throw new RegistrarException("Domain not found: {$domain}", registrar: 'mock', domain: $domain);
        }

        $currentExpiry = $this->registeredDomains[$domain]['expires_at'];
        $newExpiry = $currentExpiry->addYears($years);

        $this->registeredDomains[$domain]['expires_at'] = $newExpiry;

        return new DomainRenewal(
            domain: $domain,
            success: true,
            confirmationId: 'MOCK-REN-' . Str::upper(Str::random(10)),
            expiresAt: $newExpiry,
            cost: 12.99 * $years,
            currency: 'USD'
        );
    }

    public function transferDomain(string $domain, string $authCode): DomainTransfer
    {
        return new DomainTransfer(
            domain: $domain,
            success: true,
            transferId: 'MOCK-TRX-' . Str::upper(Str::random(10)),
            status: 'pending',
            estimatedCompletionAt: now()->addDays(5)
        );
    }

    public function updateNameservers(string $domain, array $nameservers): bool
    {
        if (!isset($this->registeredDomains[$domain])) {
            throw new RegistrarException("Domain not found: {$domain}", registrar: 'mock', domain: $domain);
        }

        $this->registeredDomains[$domain]['nameservers'] = $nameservers;

        return true;
    }

    public function getDomainInfo(string $domain): DomainInfo
    {
        if (!isset($this->registeredDomains[$domain])) {
            throw new RegistrarException("Domain not found: {$domain}", registrar: 'mock', domain: $domain);
        }

        $data = $this->registeredDomains[$domain];

        return new DomainInfo(
            domain: $domain,
            status: 'active',
            registeredAt: now()->subYears(1),
            expiresAt: $data['expires_at'],
            autoRenew: $data['auto_renew'],
            nameservers: $data['nameservers'],
            registrant: $data['contact'],
            registrarDomainId: 'MOCK-' . md5($domain)
        );
    }

    public function listDomains(Organization $organization): Collection
    {
        return collect(array_keys($this->registeredDomains))
            ->map(fn($domain) => $this->getDomainInfo($domain));
    }

    public function setAutoRenew(string $domain, bool $enabled): bool
    {
        if (!isset($this->registeredDomains[$domain])) {
            throw new RegistrarException("Domain not found: {$domain}", registrar: 'mock', domain: $domain);
        }

        $this->registeredDomains[$domain]['auto_renew'] = $enabled;

        return true;
    }

    public function getAuthCode(string $domain): string
    {
        if (!isset($this->registeredDomains[$domain])) {
            throw new RegistrarException("Domain not found: {$domain}", registrar: 'mock', domain: $domain);
        }

        return 'MOCK-AUTH-' . Str::upper(Str::random(16));
    }

    public function validateCredentials(): bool
    {
        return isset($this->credentials['api_key']) && !empty($this->credentials['api_key']);
    }

    public function getName(): string
    {
        return 'mock';
    }

    public function getDisplayName(): string
    {
        return 'Mock Registrar (Testing)';
    }

    public function supportsTld(string $tld): bool
    {
        // Mock registrar supports all common TLDs
        return in_array($tld, ['com', 'net', 'org', 'io', 'dev', 'app']);
    }

    /**
     * Helper method for testing - add domain to unavailable list
     */
    public function markAsUnavailable(string $domain): void
    {
        $this->unavailableDomains[] = $domain;
    }

    /**
     * Helper method for testing - reset state
     */
    public function reset(): void
    {
        $this->registeredDomains = [];
        $this->unavailableDomains = ['google.com', 'facebook.com', 'amazon.com'];
    }
}
```

### Service Provider Registration

**File:** `app/Providers/EnterpriseServiceProvider.php` (modification)

```php
<?php

namespace App\Providers;

use App\Services\Enterprise\DomainRegistrarFactory;
use App\Services\Enterprise\Registrars\MockRegistrar;
use Illuminate\Support\ServiceProvider;

class EnterpriseServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Register DomainRegistrarFactory as singleton
        $this->app->singleton(DomainRegistrarFactory::class, function ($app) {
            $factory = new DomainRegistrarFactory();

            // Register available registrar implementations
            $factory->register('mock', MockRegistrar::class);

            // Future registrars will be registered here:
            // $factory->register('namecheap', NamecheapRegistrar::class);
            // $factory->register('route53', Route53Registrar::class);
            // $factory->register('godaddy', GoDaddyRegistrar::class);
            // $factory->register('cloudflare', CloudflareRegistrar::class);

            // Set default registrar from config
            $defaultRegistrar = config('enterprise.domain_management.default_registrar', 'namecheap');

            if ($factory->hasRegistrar($defaultRegistrar)) {
                $factory->setDefaultRegistrar($defaultRegistrar);
            }

            return $factory;
        });
    }

    public function boot(): void
    {
        //
    }
}
```

## Implementation Approach

### Step 1: Create Interface and DTOs
1. Create `DomainRegistrarInterface` with all method signatures
2. Create DTO classes for domain operations (DomainInfo, DomainRegistration, etc.)
3. Create ContactInfo DTO for registration contact data
4. Ensure all DTOs have `fromArray()` and `toArray()` methods

### Step 2: Create Exception Hierarchy
1. Create base `RegistrarException`
2. Create specialized exceptions (DomainNotAvailableException, RegistrarAuthException, etc.)
3. Add context properties to exceptions (registrar, domain, metadata)
4. Implement helpful exception messages

### Step 3: Implement Factory Pattern
1. Create `DomainRegistrarFactory` class
2. Implement registrar registration mechanism
3. Add `make()` method with organization-based selection
4. Add `makeForDomain()` method for per-domain registrars
5. Implement credential retrieval and decryption
6. Add validation methods

### Step 4: Create Mock Registrar
1. Implement `MockRegistrar` class for testing
2. Add in-memory domain storage
3. Implement all interface methods with mock behavior
4. Add testing helper methods (markAsUnavailable, reset)
5. Ensure predictable behavior for tests

### Step 5: Register in Service Provider
1. Update `EnterpriseServiceProvider`
2. Register factory as singleton
3. Register MockRegistrar implementation
4. Add configuration for default registrar
5. Prepare for future registrar implementations

### Step 6: Add Configuration
1. Create config/enterprise.php if not exists
2. Add domain_management section
3. Configure default registrar
4. Add supported TLDs configuration
5. Document configuration options

### Step 7: Update Organization Model
1. Add `default_domain_registrar` to settings JSON
2. Add accessor methods for registrar credentials
3. Add validation for registrar configuration
4. Document credential storage format

### Step 8: Testing
1. Unit tests for factory pattern
2. Unit tests for MockRegistrar
3. Test credential retrieval and decryption
4. Test exception handling
5. Integration tests with organization context

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Enterprise/DomainRegistrarFactoryTest.php`

```php
<?php

use App\Services\Enterprise\DomainRegistrarFactory;
use App\Services\Enterprise\Registrars\MockRegistrar;
use App\Exceptions\Domain\RegistrarException;
use App\Models\Organization;

beforeEach(function () {
    $this->factory = new DomainRegistrarFactory();
    $this->factory->register('mock', MockRegistrar::class);
});

it('registers a registrar implementation', function () {
    expect($this->factory->hasRegistrar('mock'))->toBeTrue();
    expect($this->factory->getAvailableRegistrars())->toContain('mock');
});

it('throws exception for unregistered registrar', function () {
    $organization = Organization::factory()->create();

    expect(fn() => $this->factory->make($organization, 'nonexistent'))
        ->toThrow(RegistrarException::class, 'Domain registrar not found');
});

it('creates registrar instance for organization', function () {
    $organization = Organization::factory()->create([
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => [
                        'api_key' => 'test-key',
                        'api_user' => 'test-user',
                    ],
                ],
            ],
        ],
    ]);

    $registrar = $this->factory->make($organization, 'mock');

    expect($registrar)->toBeInstanceOf(MockRegistrar::class);
    expect($registrar->getName())->toBe('mock');
});

it('uses organization default registrar when not specified', function () {
    $organization = Organization::factory()->create([
        'default_domain_registrar' => 'mock',
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => ['api_key' => 'test-key'],
                ],
            ],
        ],
    ]);

    $registrar = $this->factory->make($organization);

    expect($registrar->getName())->toBe('mock');
});

it('sets and uses default registrar', function () {
    $this->factory->setDefaultRegistrar('mock');

    $organization = Organization::factory()->create([
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => ['api_key' => 'test-key'],
                ],
            ],
        ],
    ]);

    $registrar = $this->factory->make($organization);

    expect($registrar->getName())->toBe('mock');
});

it('throws exception when credentials missing', function () {
    $organization = Organization::factory()->create();

    expect(fn() => $this->factory->make($organization, 'mock'))
        ->toThrow(RegistrarException::class, 'No credentials configured');
});

it('validates organization has valid credentials', function () {
    $organization = Organization::factory()->create([
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => ['api_key' => 'valid-key'],
                ],
            ],
        ],
    ]);

    expect($this->factory->hasValidCredentials($organization, 'mock'))->toBeTrue();
});
```

**File:** `tests/Unit/Enterprise/MockRegistrarTest.php`

```php
<?php

use App\Services\Enterprise\Registrars\MockRegistrar;
use App\DataTransferObjects\Domain\ContactInfo;
use App\Exceptions\Domain\DomainNotAvailableException;
use App\Exceptions\Domain\RegistrarException;
use App\Models\Organization;

beforeEach(function () {
    $this->registrar = new MockRegistrar(['api_key' => 'test-key']);
});

it('checks domain availability correctly', function () {
    expect($this->registrar->checkAvailability('example.com'))->toBeTrue();
    expect($this->registrar->checkAvailability('google.com'))->toBeFalse();
});

it('registers a domain successfully', function () {
    $contact = new ContactInfo(
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        organization: 'Test Org',
        address1: '123 Main St',
        city: 'New York',
        state: 'NY',
        postalCode: '10001',
        country: 'US'
    );

    $registration = $this->registrar->registerDomain('example.com', $contact, 2);

    expect($registration->success)->toBeTrue();
    expect($registration->domain)->toBe('example.com');
    expect($registration->expiresAt->year)->toBe(now()->addYears(2)->year);
    expect($registration->cost)->toBe(25.98); // 12.99 * 2
});

it('throws exception when registering unavailable domain', function () {
    $contact = new ContactInfo(
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        organization: 'Test Org',
        address1: '123 Main St',
        city: 'New York',
        state: 'NY',
        postalCode: '10001',
        country: 'US'
    );

    expect(fn() => $this->registrar->registerDomain('google.com', $contact))
        ->toThrow(DomainNotAvailableException::class);
});

it('renews a domain successfully', function () {
    // First register a domain
    $contact = new ContactInfo(
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        organization: 'Test Org',
        address1: '123 Main St',
        city: 'New York',
        state: 'NY',
        postalCode: '10001',
        country: 'US'
    );

    $this->registrar->registerDomain('example.com', $contact);

    // Then renew it
    $renewal = $this->registrar->renewDomain('example.com', 1);

    expect($renewal->success)->toBeTrue();
    expect($renewal->domain)->toBe('example.com');
});

it('updates nameservers successfully', function () {
    $contact = new ContactInfo(
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        organization: 'Test Org',
        address1: '123 Main St',
        city: 'New York',
        state: 'NY',
        postalCode: '10001',
        country: 'US'
    );

    $this->registrar->registerDomain('example.com', $contact);

    $result = $this->registrar->updateNameservers('example.com', [
        'ns1.example.com',
        'ns2.example.com',
    ]);

    expect($result)->toBeTrue();

    $info = $this->registrar->getDomainInfo('example.com');
    expect($info->nameservers)->toBe(['ns1.example.com', 'ns2.example.com']);
});

it('gets domain information', function () {
    $contact = new ContactInfo(
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+1234567890',
        organization: 'Test Org',
        address1: '123 Main St',
        city: 'New York',
        state: 'NY',
        postalCode: '10001',
        country: 'US'
    );

    $this->registrar->registerDomain('example.com', $contact);

    $info = $this->registrar->getDomainInfo('example.com');

    expect($info->domain)->toBe('example.com');
    expect($info->status)->toBe('active');
    expect($info->isActive())->toBeTrue();
});

it('validates credentials correctly', function () {
    expect($this->registrar->validateCredentials())->toBeTrue();

    $invalidRegistrar = new MockRegistrar([]);
    expect($invalidRegistrar->validateCredentials())->toBeFalse();
});

it('supports common TLDs', function () {
    expect($this->registrar->supportsTld('com'))->toBeTrue();
    expect($this->registrar->supportsTld('net'))->toBeTrue();
    expect($this->registrar->supportsTld('xyz'))->toBeFalse();
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/DomainRegistrarIntegrationTest.php`

```php
<?php

use App\Services\Enterprise\DomainRegistrarFactory;
use App\Services\Enterprise\Registrars\MockRegistrar;
use App\Models\Organization;
use App\Models\Enterprise\OrganizationDomain;
use App\DataTransferObjects\Domain\ContactInfo;

it('integrates factory and registrar for domain registration', function () {
    $factory = app(DomainRegistrarFactory::class);
    $factory->register('mock', MockRegistrar::class);

    $organization = Organization::factory()->create([
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => ['api_key' => 'test-key'],
                ],
            ],
        ],
    ]);

    $registrar = $factory->make($organization, 'mock');

    $contact = new ContactInfo(
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
        phone: '+1234567890',
        organization: $organization->name,
        address1: '123 Test St',
        city: 'Test City',
        state: 'TS',
        postalCode: '12345',
        country: 'US'
    );

    $registration = $registrar->registerDomain('test-domain.com', $contact);

    expect($registration->success)->toBeTrue();

    // Verify we can retrieve domain info
    $info = $registrar->getDomainInfo('test-domain.com');
    expect($info->domain)->toBe('test-domain.com');
});

it('creates registrar for specific domain', function () {
    $factory = app(DomainRegistrarFactory::class);
    $factory->register('mock', MockRegistrar::class);

    $organization = Organization::factory()->create([
        'settings' => [
            'domain_management' => [
                'registrars' => [
                    'mock' => ['api_key' => 'test-key'],
                ],
            ],
        ],
    ]);

    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
        'registrar' => 'mock',
    ]);

    $registrar = $factory->makeForDomain($domain);

    expect($registrar->getName())->toBe('mock');
});
```

## Definition of Done

- [ ] DomainRegistrarInterface created with all method signatures
- [ ] PHPDoc documentation complete for all interface methods
- [ ] DomainRegistrarFactory implemented with registration mechanism
- [ ] Factory supports organization-based registrar selection
- [ ] Factory supports per-domain registrar selection
- [ ] DomainInfo DTO created with all properties
- [ ] DomainRegistration DTO created
- [ ] DomainRenewal DTO created
- [ ] DomainTransfer DTO created
- [ ] ContactInfo DTO created
- [ ] All DTOs have fromArray() and toArray() methods
- [ ] RegistrarException base exception created
- [ ] DomainNotAvailableException created
- [ ] RegistrarAuthException created
- [ ] RegistrarRateLimitException created
- [ ] InvalidDomainException created
- [ ] MockRegistrar implementation complete
- [ ] MockRegistrar implements all interface methods
- [ ] MockRegistrar has testing helper methods
- [ ] Factory registered in EnterpriseServiceProvider
- [ ] Configuration added to config/enterprise.php
- [ ] Unit tests written for factory (>90% coverage)
- [ ] Unit tests written for MockRegistrar (>90% coverage)
- [ ] Integration tests written
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing (`./vendor/bin/phpstan`)
- [ ] All tests passing (`php artisan test --filter=DomainRegistrar`)
- [ ] Documentation updated
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 62 (Database schema for organization_domains)
- **Used by:** Task 64 (Namecheap API integration)
- **Used by:** Task 65 (Route53 API integration)
- **Used by:** Task 66 (DomainRegistrarService)
- **Used by:** Task 67 (DnsManagementService)
- **Used by:** Task 70 (DomainManager.vue component)
- **Tested by:** Task 71 (Domain management tests)
