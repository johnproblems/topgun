---
name: Write integration tests for complete workflows
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:29Z
github: https://github.com/johnproblems/topgun/issues/184
depends_on: [76]
parallel: false
conflicts_with: []
---

# Task: Write integration tests for complete workflows

## Description

Create comprehensive end-to-end integration tests that verify complete user workflows across the Coolify Enterprise Transformation features. These tests validate that all enterprise components—organization hierarchy, licensing, white-label branding, Terraform provisioning, resource monitoring, enhanced deployments, payment processing, and API systems—work together seamlessly in realistic production scenarios.

**The Integration Testing Challenge:**

Unit tests verify individual components in isolation (e.g., "Does `TerraformService::provisionInfrastructure()` work?"), but they don't guarantee that components integrate correctly. Integration bugs manifest when:
- Service A passes data in format X, but Service B expects format Y
- Database transactions commit in the wrong order during multi-step workflows
- Cache invalidation fails to propagate across related services
- WebSocket events broadcast to wrong channels
- Background jobs don't chain correctly
- Organization scoping leaks data between tenants

**Real-World Workflow Examples:**

1. **New Organization Onboarding Flow:**
   ```
   User registers → Organization created → License assigned →
   White-label configured → Email sent with branded template →
   User receives branded login page
   ```

2. **Infrastructure Provisioning + Deployment Flow:**
   ```
   User requests infrastructure → Terraform provisioning queued →
   Cloud resources created → Server auto-registered →
   SSH keys deployed → Application deployed →
   Resource quotas updated → Organization billed for usage
   ```

3. **Multi-Tenant Isolation Flow:**
   ```
   Org A user creates resource → Org B user cannot see resource →
   Org A admin deletes org → All Org A resources cascade deleted →
   Org B resources unaffected
   ```

4. **Payment + License Activation Flow:**
   ```
   User selects plan → Payment processed → Webhook received →
   License activated → Feature flags enabled →
   API rate limits updated → User immediately accesses features
   ```

**Integration Test Coverage:**

This task creates **workflow-based integration tests** that:
- Test **happy paths**: All components work together successfully
- Test **error scenarios**: System recovers gracefully from failures
- Test **edge cases**: Boundary conditions and race conditions
- Test **security**: Organization data isolation and authorization
- Test **performance**: Workflows complete within acceptable timeframes

**Why This Task Is Critical:**

Integration tests provide confidence that the platform actually works end-to-end. They catch the bugs that slip through unit tests—the integration issues that only surface when components interact. These tests serve as:
- **Regression prevention**: Ensure new features don't break existing workflows
- **Documentation**: Demonstrate how features should work together
- **Deployment validation**: Verify production deployments are healthy
- **Architecture validation**: Prove the service layer pattern works

Without comprehensive integration tests, every deployment becomes a gamble. With them, deployments become routine.

## Acceptance Criteria

- [ ] Complete organization onboarding workflow test (register → license → branding → login)
- [ ] Complete infrastructure provisioning workflow test (provision → register → verify → deploy)
- [ ] Complete deployment lifecycle workflow test (create → deploy → monitor → rollback)
- [ ] Complete payment processing workflow test (select plan → pay → activate → access features)
- [ ] Complete white-label workflow test (upload logo → generate CSS → apply branding → view site)
- [ ] Multi-tenant isolation tests across all features (organizations cannot access each other's data)
- [ ] Cross-service integration tests (TerraformService → CapacityManager → DeploymentService)
- [ ] Background job chaining tests (job A completes → triggers job B → updates DB → broadcasts event)
- [ ] WebSocket broadcasting integration tests (service updates → event dispatched → frontend receives update)
- [ ] Cache consistency tests (data updated → cache invalidated → fresh data served)
- [ ] API workflow tests (create token → make requests → hit rate limits → receive headers)
- [ ] Error recovery workflow tests (service fails → transaction rolls back → user sees error)
- [ ] Organization hierarchy tests (top-level org → sub-orgs → resource sharing → quota enforcement)
- [ ] License enforcement tests (feature disabled → user blocked → license upgraded → access granted)
- [ ] Database transaction tests (multi-step workflow → ensure atomicity → verify consistency)

## Technical Details

### File Paths

**Integration Test Files:**
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/OrganizationOnboardingWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/InfrastructureProvisioningWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/DeploymentLifecycleWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/PaymentProcessingWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/WhiteLabelBrandingWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/MultiTenantIsolationWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/CrossServiceIntegrationWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/BackgroundJobChainingWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/CacheConsistencyWorkflowTest.php`
- `/home/topgun/topgun/tests/Feature/Enterprise/Workflows/ApiIntegrationWorkflowTest.php`

**Test Traits (from Task 72-75):**
- `/home/topgun/topgun/tests/Traits/Enterprise/OrganizationTestingTrait.php` (existing)
- `/home/topgun/topgun/tests/Traits/Enterprise/LicenseTestingTrait.php` (existing)
- `/home/topgun/topgun/tests/Traits/Enterprise/TerraformTestingTrait.php` (existing)
- `/home/topgun/topgun/tests/Traits/Enterprise/PaymentTestingTrait.php` (existing)

**Test Utilities:**
- `/home/topgun/topgun/tests/Utilities/Enterprise/WorkflowTestCase.php` (base class for workflow tests)
- `/home/topgun/topgun/tests/Utilities/Enterprise/MockExternalServices.php` (helper for mocking Terraform, payment gateways)

### Workflow Test Base Class

**File:** `tests/Utilities/Enterprise/WorkflowTestCase.php`

```php
<?php

namespace Tests\Utilities\Enterprise;

use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\Storage;
use Tests\TestCase;
use Tests\Traits\Enterprise\OrganizationTestingTrait;
use Tests\Traits\Enterprise\LicenseTestingTrait;
use Tests\Traits\Enterprise\TerraformTestingTrait;
use Tests\Traits\Enterprise\PaymentTestingTrait;

abstract class WorkflowTestCase extends TestCase
{
    use OrganizationTestingTrait;
    use LicenseTestingTrait;
    use TerraformTestingTrait;
    use PaymentTestingTrait;

    protected bool $seed = true;

    /**
     * Set up the test environment with fakes and mocks
     */
    protected function setUp(): void
    {
        parent::setUp();

        // Fake external dependencies by default
        Queue::fake();
        Storage::fake('public');
        Storage::fake('s3');
        Cache::fake();

        // Reset event listeners between tests
        Event::fake();
    }

    /**
     * Assert that a workflow step completed successfully
     *
     * @param string $stepName
     * @param callable $assertion
     * @param string|null $failureMessage
     * @return void
     */
    protected function assertWorkflowStep(string $stepName, callable $assertion, ?string $failureMessage = null): void
    {
        try {
            $assertion();
            $this->assertTrue(true, "✓ {$stepName}");
        } catch (\Throwable $e) {
            $message = $failureMessage ?? "✗ {$stepName}: {$e->getMessage()}";
            $this->fail($message);
        }
    }

    /**
     * Assert that a workflow completes within a time limit
     *
     * @param callable $workflow
     * @param int $maxSeconds
     * @return void
     */
    protected function assertWorkflowPerformance(callable $workflow, int $maxSeconds): void
    {
        $start = microtime(true);
        $workflow();
        $duration = microtime(true) - $start;

        $this->assertLessThan(
            $maxSeconds,
            $duration,
            "Workflow took {$duration}s, expected < {$maxSeconds}s"
        );
    }

    /**
     * Simulate time passing (for scheduled jobs, cache expiry, etc.)
     *
     * @param int $seconds
     * @return void
     */
    protected function travelForward(int $seconds): void
    {
        $this->travel($seconds)->seconds();
    }

    /**
     * Assert that multiple events were dispatched in order
     *
     * @param array $eventClasses
     * @return void
     */
    protected function assertEventsDispatchedInOrder(array $eventClasses): void
    {
        foreach ($eventClasses as $index => $eventClass) {
            Event::assertDispatched($eventClass, function ($event) use ($index) {
                // Events are dispatched in chronological order
                return true;
            });
        }
    }

    /**
     * Assert multi-tenant data isolation
     *
     * @param string $modelClass
     * @param int $orgAId
     * @param int $orgBId
     * @return void
     */
    protected function assertOrganizationDataIsolation(string $modelClass, int $orgAId, int $orgBId): void
    {
        $orgACount = $modelClass::where('organization_id', $orgAId)->count();
        $orgBCount = $modelClass::where('organization_id', $orgBId)->count();

        $this->assertGreaterThan(0, $orgACount, "Org A should have {$modelClass} records");
        $this->assertEquals(0, $orgBCount, "Org B should NOT see Org A's {$modelClass} records");
    }
}
```

### Organization Onboarding Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/OrganizationOnboardingWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise\Workflows;

use App\Events\Enterprise\WhiteLabelConfigUpdated;
use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Models\Organization;
use App\Models\EnterpriseLicense;
use App\Models\User;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Queue;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test the complete organization onboarding workflow:
 * User registration → Organization creation → License assignment →
 * White-label configuration → Branded email delivery → Branded login
 */
class OrganizationOnboardingWorkflowTest extends WorkflowTestCase
{
    public function test_complete_organization_onboarding_workflow(): void
    {
        Mail::fake();
        Event::fake();
        Queue::fake();

        // Step 1: User registers and creates organization
        $this->assertWorkflowStep('User registers', function () {
            $user = User::factory()->create([
                'email' => 'admin@acme-corp.com',
                'name' => 'Alice Admin',
            ]);

            $organization = Organization::factory()->create([
                'name' => 'Acme Corporation',
                'slug' => 'acme-corp',
            ]);

            $organization->users()->attach($user, ['role' => 'owner']);

            $this->assertDatabaseHas('organizations', [
                'slug' => 'acme-corp',
            ]);

            $this->assertDatabaseHas('organization_users', [
                'user_id' => $user->id,
                'organization_id' => $organization->id,
                'role' => 'owner',
            ]);

            // Store for next steps
            $this->user = $user;
            $this->organization = $organization;
        });

        // Step 2: License automatically assigned to organization
        $this->assertWorkflowStep('License assigned', function () {
            $license = EnterpriseLicense::factory()->create([
                'organization_id' => $this->organization->id,
                'license_tier' => 'professional',
                'status' => 'active',
                'max_users' => 50,
                'max_servers' => 20,
                'max_deployments_per_month' => 500,
                'features' => [
                    'white_label' => true,
                    'custom_domains' => true,
                    'terraform_provisioning' => true,
                    'advanced_deployments' => true,
                ],
            ]);

            $this->assertDatabaseHas('enterprise_licenses', [
                'organization_id' => $this->organization->id,
                'license_tier' => 'professional',
                'status' => 'active',
            ]);

            // Verify feature flags are accessible
            $this->assertTrue($license->hasFeature('white_label'));
            $this->assertTrue($license->hasFeature('terraform_provisioning'));
        });

        // Step 3: White-label branding configured
        $this->assertWorkflowStep('White-label configured', function () {
            $config = WhiteLabelConfig::factory()->create([
                'organization_id' => $this->organization->id,
                'platform_name' => 'Acme Cloud',
                'primary_color' => '#0066cc',
                'secondary_color' => '#ff6600',
                'primary_logo_path' => 'branding/1/logos/acme-logo.png',
            ]);

            $this->assertDatabaseHas('white_label_configs', [
                'organization_id' => $this->organization->id,
                'platform_name' => 'Acme Cloud',
            ]);

            // Verify cache warming job was dispatched
            Queue::assertPushed(BrandingCacheWarmerJob::class, function ($job) {
                return $job->organizationId === $this->organization->id;
            });

            // Verify event was dispatched
            Event::assertDispatched(WhiteLabelConfigUpdated::class, function ($event) {
                return $event->organization->id === $this->organization->id;
            });

            $this->config = $config;
        });

        // Step 4: Welcome email sent with branded template
        $this->assertWorkflowStep('Branded welcome email sent', function () {
            // Simulate sending welcome email
            Mail::to($this->user)->send(new \App\Mail\Enterprise\WelcomeToOrganization(
                $this->user,
                $this->organization
            ));

            Mail::assertSent(\App\Mail\Enterprise\WelcomeToOrganization::class, function ($mail) {
                return $mail->hasTo($this->user->email) &&
                       $mail->organization->id === $this->organization->id;
            });
        });

        // Step 5: User logs in and sees branded interface
        $this->assertWorkflowStep('User sees branded login page', function () {
            $response = $this->actingAs($this->user)
                ->get("/organizations/{$this->organization->slug}/dashboard");

            // Verify response contains branded CSS link
            $response->assertSee("/branding/{$this->organization->slug}/styles.css", false);

            // Verify custom platform name appears
            $response->assertSee('Acme Cloud');

            // Verify no "Coolify" branding visible
            $response->assertDontSee('Coolify');
        });

        // Workflow completed successfully
        $this->assertTrue(true, '✓ Complete onboarding workflow succeeded');
    }

    public function test_onboarding_workflow_with_free_tier_restrictions(): void
    {
        // Test that free tier organizations have appropriate restrictions
        $user = User::factory()->create();
        $organization = $this->createOrganization(tier: 'free');
        $organization->users()->attach($user, ['role' => 'owner']);

        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'license_tier' => 'free',
            'features' => [
                'white_label' => false,
                'terraform_provisioning' => false,
            ],
        ]);

        // Verify white-label access is denied
        $response = $this->actingAs($user)
            ->get("/organizations/{$organization->slug}/branding");

        $response->assertForbidden();

        // Verify Terraform access is denied
        $response = $this->actingAs($user)
            ->get("/organizations/{$organization->slug}/infrastructure");

        $response->assertForbidden();
    }

    public function test_onboarding_workflow_performance(): void
    {
        // Entire onboarding flow should complete in < 5 seconds
        $this->assertWorkflowPerformance(function () {
            $user = User::factory()->create();
            $org = Organization::factory()->create();
            $org->users()->attach($user, ['role' => 'owner']);

            EnterpriseLicense::factory()->create([
                'organization_id' => $org->id,
            ]);

            WhiteLabelConfig::factory()->create([
                'organization_id' => $org->id,
            ]);

            $this->actingAs($user)->get("/organizations/{$org->slug}/dashboard");
        }, maxSeconds: 5);
    }
}
```

### Infrastructure Provisioning Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/InfrastructureProvisioningWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise\Workflows;

use App\Events\Enterprise\TerraformProvisioningCompleted;
use App\Jobs\Enterprise\ServerRegistrationJob;
use App\Jobs\Enterprise\TerraformDeploymentJob;
use App\Models\CloudProviderCredential;
use App\Models\Organization;
use App\Models\Server;
use App\Models\TerraformDeployment;
use App\Models\User;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Process;
use Illuminate\Support\Facades\Queue;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test the complete infrastructure provisioning workflow:
 * User requests infrastructure → Terraform provisioning →
 * Cloud resources created → Server registered → SSH keys deployed
 */
class InfrastructureProvisioningWorkflowTest extends WorkflowTestCase
{
    public function test_complete_infrastructure_provisioning_workflow(): void
    {
        Queue::fake();
        Event::fake();
        Process::fake();

        $user = User::factory()->create();
        $organization = $this->createOrganization();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Step 1: User adds cloud provider credentials
        $this->assertWorkflowStep('Cloud credentials added', function () use ($organization) {
            $credential = CloudProviderCredential::factory()->create([
                'organization_id' => $organization->id,
                'provider' => 'aws',
                'credentials' => $this->encryptCredentials([
                    'access_key_id' => 'AKIAIOSFODNN7EXAMPLE',
                    'secret_access_key' => 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
                    'region' => 'us-east-1',
                ]),
            ]);

            $this->assertDatabaseHas('cloud_provider_credentials', [
                'organization_id' => $organization->id,
                'provider' => 'aws',
            ]);

            $this->credential = $credential;
        });

        // Step 2: User initiates infrastructure provisioning
        $this->assertWorkflowStep('Provisioning initiated', function () use ($organization, $user) {
            $response = $this->actingAs($user)
                ->post("/api/organizations/{$organization->id}/infrastructure/provision", [
                    'cloud_provider_credential_id' => $this->credential->id,
                    'instance_type' => 't3.medium',
                    'region' => 'us-east-1',
                    'name' => 'Production Server 1',
                    'auto_register_server' => true,
                ]);

            $response->assertCreated();

            $this->deployment = TerraformDeployment::where('organization_id', $organization->id)->first();

            $this->assertNotNull($this->deployment);
            $this->assertEquals('pending', $this->deployment->status);

            // Verify job was dispatched
            Queue::assertPushed(TerraformDeploymentJob::class, function ($job) {
                return $job->deploymentId === $this->deployment->id;
            });
        });

        // Step 3: Terraform provisioning job executes
        $this->assertWorkflowStep('Terraform execution', function () {
            // Mock Terraform CLI responses
            Process::fake([
                'terraform version*' => Process::result('{"terraform_version": "1.5.7"}'),
                'terraform init*' => Process::result('Terraform initialized'),
                'terraform plan*' => Process::result('Plan: 3 to add, 0 to change, 0 to destroy'),
                'terraform apply*' => Process::result('Apply complete! Resources: 3 added'),
                'terraform output*' => Process::result(json_encode([
                    'server_ip' => ['value' => '54.123.45.67'],
                    'instance_id' => ['value' => 'i-1234567890abcdef0'],
                ])),
            ]);

            // Execute job synchronously for testing
            $job = new TerraformDeploymentJob($this->deployment->id);
            $job->handle(
                app(\App\Contracts\TerraformServiceInterface::class),
                app(\App\Contracts\TerraformStateManagerInterface::class)
            );

            // Verify deployment completed
            $this->deployment->refresh();
            $this->assertEquals('completed', $this->deployment->status);
            $this->assertEquals(100, $this->deployment->progress_percentage);

            // Verify outputs were parsed
            $this->assertArrayHasKey('server_ip', $this->deployment->output_data);
            $this->assertEquals('54.123.45.67', $this->deployment->output_data['server_ip']);

            // Verify event was dispatched
            Event::assertDispatched(TerraformProvisioningCompleted::class);
        });

        // Step 4: Server auto-registration job executes
        $this->assertWorkflowStep('Server registration', function () use ($organization) {
            Queue::assertPushed(ServerRegistrationJob::class, function ($job) {
                return $job->deploymentId === $this->deployment->id;
            });

            // Execute registration job
            $registrationJob = new ServerRegistrationJob($this->deployment->id);
            $registrationJob->handle(app(\App\Services\Enterprise\ServerRegistrationService::class));

            // Verify server was created
            $server = Server::where('organization_id', $organization->id)
                ->where('terraform_deployment_id', $this->deployment->id)
                ->first();

            $this->assertNotNull($server);
            $this->assertEquals('54.123.45.67', $server->ip);
            $this->assertEquals('i-1234567890abcdef0', $server->cloud_instance_id);
            $this->assertEquals('running', $server->status);
        });

        // Step 5: Organization resource usage updated
        $this->assertWorkflowStep('Resource usage updated', function () use ($organization) {
            $organization->refresh();

            // Verify server count incremented
            $this->assertEquals(1, $organization->servers()->count());

            // Verify quota tracking
            $usage = $organization->resourceUsage;
            $this->assertEquals(1, $usage->servers_count);
        });

        $this->assertTrue(true, '✓ Complete infrastructure provisioning workflow succeeded');
    }

    public function test_provisioning_workflow_with_rollback_on_failure(): void
    {
        Queue::fake();
        Process::fake();

        $organization = $this->createOrganization();
        $credential = CloudProviderCredential::factory()->create([
            'organization_id' => $organization->id,
        ]);

        $deployment = TerraformDeployment::factory()->create([
            'organization_id' => $organization->id,
            'cloud_provider_credential_id' => $credential->id,
        ]);

        // Mock Terraform failure during apply
        Process::fake([
            'terraform init*' => Process::result('Initialized'),
            'terraform plan*' => Process::result('Plan: 3 to add'),
            'terraform apply*' => Process::result('Error: Authentication failed', 1),
            'terraform destroy*' => Process::result('Destroy complete'),
        ]);

        // Execute job with auto-rollback enabled
        $job = new TerraformDeploymentJob($deployment->id, autoRollbackOnFailure: true);

        try {
            $job->handle(
                app(\App\Contracts\TerraformServiceInterface::class),
                app(\App\Contracts\TerraformStateManagerInterface::class)
            );
        } catch (\Exception $e) {
            // Expected to fail
        }

        $deployment->refresh();

        // Verify rollback executed
        $this->assertEquals('rolled_back', $deployment->status);

        // Verify no server was registered
        $this->assertEquals(0, $organization->servers()->count());
    }

    public function test_provisioning_workflow_respects_organization_quotas(): void
    {
        $organization = $this->createOrganization();

        // Create license with server quota
        $license = $this->createLicense($organization, [
            'max_servers' => 2,
        ]);

        // Create 2 servers (at quota limit)
        Server::factory()->count(2)->create([
            'organization_id' => $organization->id,
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        $credential = CloudProviderCredential::factory()->create([
            'organization_id' => $organization->id,
        ]);

        // Attempt to provision 3rd server (exceeds quota)
        $response = $this->actingAs($user)
            ->post("/api/organizations/{$organization->id}/infrastructure/provision", [
                'cloud_provider_credential_id' => $credential->id,
                'instance_type' => 't3.medium',
            ]);

        // Should be rejected due to quota
        $response->assertStatus(422);
        $response->assertJsonFragment([
            'message' => 'Server quota exceeded',
        ]);
    }
}
```

### Multi-Tenant Isolation Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/MultiTenantIsolationWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise\Workflows;

use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use App\Models\User;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\DB;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test multi-tenant data isolation across all enterprise features
 */
class MultiTenantIsolationWorkflowTest extends WorkflowTestCase
{
    public function test_organizations_cannot_access_each_others_data(): void
    {
        // Create two separate organizations with data
        $orgA = $this->createOrganization(['name' => 'Organization A']);
        $orgB = $this->createOrganization(['name' => 'Organization B']);

        $userA = User::factory()->create();
        $userB = User::factory()->create();

        $orgA->users()->attach($userA, ['role' => 'owner']);
        $orgB->users()->attach($userB, ['role' => 'owner']);

        // Create org-specific data
        $this->assertWorkflowStep('Create org-specific resources', function () use ($orgA, $orgB) {
            // Org A resources
            Server::factory()->count(3)->create(['organization_id' => $orgA->id]);
            Application::factory()->count(5)->create(['organization_id' => $orgA->id]);
            WhiteLabelConfig::factory()->create(['organization_id' => $orgA->id]);

            // Org B resources
            Server::factory()->count(2)->create(['organization_id' => $orgB->id]);
            Application::factory()->count(3)->create(['organization_id' => $orgB->id]);
            WhiteLabelConfig::factory()->create(['organization_id' => $orgB->id]);
        });

        // Test Server isolation
        $this->assertWorkflowStep('Server data isolation', function () use ($userA, $userB, $orgA, $orgB) {
            // User A should see only Org A servers
            $response = $this->actingAs($userA)->get("/api/organizations/{$orgA->id}/servers");
            $response->assertOk();
            $response->assertJsonCount(3, 'data');

            // User B should not see Org A servers
            $response = $this->actingAs($userB)->get("/api/organizations/{$orgA->id}/servers");
            $response->assertForbidden();

            // User B should see only Org B servers
            $response = $this->actingAs($userB)->get("/api/organizations/{$orgB->id}/servers");
            $response->assertOk();
            $response->assertJsonCount(2, 'data');
        });

        // Test Application isolation
        $this->assertWorkflowStep('Application data isolation', function () use ($userA, $userB, $orgA, $orgB) {
            $response = $this->actingAs($userA)->get("/api/organizations/{$orgA->id}/applications");
            $response->assertOk();
            $response->assertJsonCount(5, 'data');

            $response = $this->actingAs($userB)->get("/api/organizations/{$orgA->id}/applications");
            $response->assertForbidden();
        });

        // Test direct model queries respect organization scoping
        $this->assertWorkflowStep('Model scoping isolation', function () use ($orgA, $orgB) {
            $this->assertOrganizationDataIsolation(Server::class, $orgA->id, $orgB->id);
            $this->assertOrganizationDataIsolation(Application::class, $orgA->id, $orgB->id);
        });

        // Test database-level isolation
        $this->assertWorkflowStep('Database-level isolation', function () use ($orgA, $orgB) {
            // Verify no cross-organization foreign keys exist
            $crossOrgServers = Server::where('organization_id', $orgA->id)
                ->whereHas('applications', function ($query) use ($orgB) {
                    $query->where('organization_id', $orgB->id);
                })
                ->count();

            $this->assertEquals(0, $crossOrgServers, 'No cross-organization relationships should exist');
        });

        $this->assertTrue(true, '✓ Multi-tenant isolation verified');
    }

    public function test_organization_deletion_cascades_correctly(): void
    {
        $organization = $this->createOrganization();

        // Create comprehensive data structure
        $servers = Server::factory()->count(3)->create(['organization_id' => $organization->id]);
        $applications = Application::factory()->count(5)->create(['organization_id' => $organization->id]);
        WhiteLabelConfig::factory()->create(['organization_id' => $organization->id]);

        $initialServerCount = Server::count();
        $initialAppCount = Application::count();

        // Delete organization
        $organization->delete();

        // Verify all related data was cascade deleted
        $this->assertEquals(0, Server::where('organization_id', $organization->id)->count());
        $this->assertEquals(0, Application::where('organization_id', $organization->id)->count());
        $this->assertEquals(0, WhiteLabelConfig::where('organization_id', $organization->id)->count());

        // Verify expected number of records were deleted
        $this->assertEquals($initialServerCount - 3, Server::count());
        $this->assertEquals($initialAppCount - 5, Application::count());
    }

    public function test_organization_soft_delete_preserves_data_for_recovery(): void
    {
        $organization = $this->createOrganization();

        Server::factory()->count(2)->create(['organization_id' => $organization->id]);

        // Soft delete organization
        $organization->delete();

        // Data should still exist in database (soft deleted)
        $this->assertEquals(2, Server::withTrashed()->where('organization_id', $organization->id)->count());

        // But not visible in normal queries
        $this->assertEquals(0, Server::where('organization_id', $organization->id)->count());

        // Restore organization
        $organization->restore();

        // Data should be visible again
        $this->assertEquals(2, Server::where('organization_id', $organization->id)->count());
    }

    public function test_api_tokens_respect_organization_scoping(): void
    {
        $orgA = $this->createOrganization();
        $orgB = $this->createOrganization();

        $userA = User::factory()->create();
        $orgA->users()->attach($userA, ['role' => 'admin']);

        // Create API token scoped to Org A
        $token = $userA->createToken('api-token', [
            'organization:' . $orgA->id . ':read',
            'organization:' . $orgA->id . ':write',
        ]);

        Server::factory()->create(['organization_id' => $orgA->id, 'name' => 'Org A Server']);
        Server::factory()->create(['organization_id' => $orgB->id, 'name' => 'Org B Server']);

        // Token should allow access to Org A
        $response = $this->withToken($token->plainTextToken)
            ->get("/api/organizations/{$orgA->id}/servers");
        $response->assertOk();

        // Token should deny access to Org B
        $response = $this->withToken($token->plainTextToken)
            ->get("/api/organizations/{$orgB->id}/servers");
        $response->assertForbidden();
    }

    public function test_websocket_channels_respect_organization_boundaries(): void
    {
        Event::fake();

        $orgA = $this->createOrganization();
        $orgB = $this->createOrganization();

        $deployment = TerraformDeployment::factory()->create([
            'organization_id' => $orgA->id,
        ]);

        // Dispatch event
        event(new \App\Events\Enterprise\TerraformProvisioningProgress(
            $deployment,
            'Progress update',
            50
        ));

        // Verify event broadcasts to Org A channel only
        Event::assertDispatched(\App\Events\Enterprise\TerraformProvisioningProgress::class, function ($event) use ($orgA) {
            return $event->broadcastOn()->name === "organization.{$orgA->id}.terraform";
        });
    }
}
```

### Cross-Service Integration Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/CrossServiceIntegrationWorkflowTest.php`

```php
<?php

namespace Tests\Feature/Enterprise/Workflows;

use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use App\Services\Enterprise\CapacityManager;
use App\Services\Enterprise\EnhancedDeploymentService;
use App\Services\Enterprise\TerraformService;
use Illuminate\Support\Facades\Process;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test integration between multiple enterprise services
 */
class CrossServiceIntegrationWorkflowTest extends WorkflowTestCase
{
    public function test_terraform_to_capacity_to_deployment_integration(): void
    {
        Process::fake();

        $organization = $this->createOrganization();

        // Step 1: Provision infrastructure via TerraformService
        $this->assertWorkflowStep('Infrastructure provisioned', function () use ($organization) {
            $terraformService = app(TerraformService::class);

            $credential = $this->mockCloudCredential($organization, 'aws');
            $config = [
                'instance_type' => 't3.medium',
                'region' => 'us-east-1',
                'name' => 'Auto-provisioned Server',
            ];

            // Mock successful Terraform execution
            $this->mockTerraformSuccess([
                'server_ip' => '52.1.2.3',
                'instance_id' => 'i-abc123',
            ]);

            $deployment = $terraformService->provisionInfrastructure($credential, $config);

            $this->assertEquals('completed', $deployment->status);
            $this->server = Server::factory()->create([
                'organization_id' => $organization->id,
                'ip' => $deployment->output_data['server_ip'],
                'terraform_deployment_id' => $deployment->id,
            ]);
        });

        // Step 2: CapacityManager evaluates server for deployment
        $this->assertWorkflowStep('Server capacity evaluated', function () use ($organization) {
            $capacityManager = app(CapacityManager::class);

            $servers = Server::where('organization_id', $organization->id)->get();

            // Check if server can handle deployment
            $canHandle = $capacityManager->canServerHandleDeployment(
                $this->server,
                ['cpu' => 2, 'memory' => 4096, 'disk' => 20000]
            );

            $this->assertTrue($canHandle, 'Newly provisioned server should have capacity');

            // Select optimal server
            $optimalServer = $capacityManager->selectOptimalServer($servers, [
                'cpu' => 2,
                'memory' => 4096,
            ]);

            $this->assertEquals($this->server->id, $optimalServer->id);
        });

        // Step 3: EnhancedDeploymentService deploys application
        $this->assertWorkflowStep('Application deployed', function () use ($organization) {
            $deploymentService = app(EnhancedDeploymentService::class);

            $application = Application::factory()->create([
                'organization_id' => $organization->id,
                'name' => 'Test Application',
            ]);

            // Deploy with rolling strategy
            $deployment = $deploymentService->deployWithStrategy(
                $application,
                'rolling',
                ['server_id' => $this->server->id]
            );

            $this->assertEquals('success', $deployment->status);

            // Verify server was selected by capacity manager
            $this->assertEquals($this->server->id, $deployment->server_id);
        });

        // Step 4: Verify resource metrics updated
        $this->assertWorkflowStep('Resource metrics updated', function () {
            $this->server->refresh();

            // Verify server load increased
            $this->assertGreaterThan(0, $this->server->current_cpu_usage);
            $this->assertGreaterThan(0, $this->server->current_memory_usage);
        });

        $this->assertTrue(true, '✓ Cross-service integration workflow succeeded');
    }

    public function test_whitelabel_service_integrates_with_cache_and_email(): void
    {
        $organization = $this->createOrganization();
        $whiteLabelConfig = WhiteLabelConfig::factory()->create([
            'organization_id' => $organization->id,
            'platform_name' => 'Custom Cloud',
            'primary_color' => '#1a73e8',
        ]);

        // WhiteLabelService generates CSS
        $whiteLabelService = app(\App\Services\Enterprise\WhiteLabelService::class);
        $css = $whiteLabelService->generateCSS($organization);

        $this->assertStringContainsString('--color-primary: #1a73e8', $css);

        // BrandingCacheService caches CSS
        $cacheService = app(\App\Contracts\BrandingCacheServiceInterface::class);
        $cacheService->setCachedCSS($organization, $css);

        $cachedCss = $cacheService->getCachedCSS($organization);
        $this->assertEquals($css, $cachedCss);

        // Email service uses branding variables
        $emailVars = $whiteLabelService->getEmailBrandingVars($organization);

        $this->assertArrayHasKey('platform_name', $emailVars);
        $this->assertEquals('Custom Cloud', $emailVars['platform_name']);
        $this->assertArrayHasKey('primary_color', $emailVars);
    }

    public function test_licensing_service_integrates_with_quota_enforcement(): void
    {
        $organization = $this->createOrganization();

        // Create license with quotas
        $license = $this->createLicense($organization, [
            'max_servers' => 5,
            'max_deployments_per_month' => 100,
            'features' => [
                'terraform_provisioning' => true,
                'advanced_deployments' => false,
            ],
        ]);

        $licensingService = app(\App\Services\Enterprise\LicensingService::class);

        // Verify quota enforcement
        $this->assertTrue($licensingService->canAddServer($organization));

        // Create 5 servers (at limit)
        Server::factory()->count(5)->create(['organization_id' => $organization->id]);

        $this->assertFalse($licensingService->canAddServer($organization));

        // Verify feature flag enforcement
        $this->assertTrue($licensingService->hasFeature($organization, 'terraform_provisioning'));
        $this->assertFalse($licensingService->hasFeature($organization, 'advanced_deployments'));
    }
}
```

### Background Job Chaining Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/BackgroundJobChainingWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise\Workflows;

use App\Jobs\Enterprise\BrandingCacheWarmerJob;
use App\Jobs\Enterprise\ServerRegistrationJob;
use App\Jobs\Enterprise\TerraformDeploymentJob;
use App\Models\TerraformDeployment;
use Illuminate\Support\Facades\Queue;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test that background jobs chain correctly and update database state
 */
class BackgroundJobChainingWorkflowTest extends WorkflowTestCase
{
    public function test_terraform_job_triggers_server_registration_job(): void
    {
        Queue::fake();
        Process::fake();

        $organization = $this->createOrganization();
        $credential = $this->mockCloudCredential($organization, 'aws');

        $deployment = TerraformDeployment::factory()->create([
            'organization_id' => $organization->id,
            'cloud_provider_credential_id' => $credential->id,
            'auto_register_server' => true,
        ]);

        // Mock successful Terraform execution
        $this->mockTerraformSuccess(['server_ip' => '1.2.3.4']);

        // Execute TerraformDeploymentJob
        $job = new TerraformDeploymentJob($deployment->id);
        $job->handle(
            app(\App\Contracts\TerraformServiceInterface::class),
            app(\App\Contracts\TerraformStateManagerInterface::class)
        );

        // Verify ServerRegistrationJob was dispatched
        Queue::assertPushed(ServerRegistrationJob::class, function ($job) use ($deployment) {
            return $job->deploymentId === $deployment->id;
        });

        $deployment->refresh();
        $this->assertEquals('completed', $deployment->status);
    }

    public function test_whitelabel_update_triggers_cache_warming_job(): void
    {
        Queue::fake();

        $organization = $this->createOrganization();
        $config = WhiteLabelConfig::factory()->create([
            'organization_id' => $organization->id,
        ]);

        // Update white-label config
        $config->update(['primary_color' => '#ff0000']);

        // Verify event dispatched
        Event::assertDispatched(\App\Events\Enterprise\WhiteLabelConfigUpdated::class);

        // Verify BrandingCacheWarmerJob was dispatched
        Queue::assertPushed(BrandingCacheWarmerJob::class, function ($job) use ($organization) {
            return $job->organizationId === $organization->id;
        });
    }

    public function test_job_failure_does_not_break_chain_with_retry(): void
    {
        Queue::fake();

        $deployment = TerraformDeployment::factory()->create();

        // First attempt fails
        $job = new TerraformDeploymentJob($deployment->id);
        $job->tries = 3;

        // Simulate failure
        try {
            throw new \Exception('Terraform apply failed');
        } catch (\Exception $e) {
            $job->failed($e);
        }

        $deployment->refresh();
        $this->assertEquals('failed', $deployment->status);

        // Verify job can be retried
        $this->assertLessThan(3, $job->attempts());
    }
}
```

### Cache Consistency Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/CacheConsistencyWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise\Workflows;

use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use App\Services\Enterprise\BrandingCacheService;
use App\Services\Enterprise\WhiteLabelService;
use Illuminate\Support\Facades\Cache;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test cache consistency across service updates
 */
class CacheConsistencyWorkflowTest extends WorkflowTestCase
{
    public function test_cache_invalidates_on_whitelabel_update(): void
    {
        Cache::flush();

        $organization = $this->createOrganization();
        $whiteLabelService = app(WhiteLabelService::class);
        $cacheService = app(BrandingCacheService::class);

        // Create initial config and cache it
        $config = WhiteLabelConfig::factory()->create([
            'organization_id' => $organization->id,
            'primary_color' => '#0000ff',
        ]);

        $css = $whiteLabelService->generateCSS($organization);
        $cacheService->setCachedCSS($organization, $css);

        $this->assertStringContainsString('--color-primary: #0000ff', $cacheService->getCachedCSS($organization));

        // Update config
        $config->update(['primary_color' => '#ff0000']);

        // Trigger cache warming
        event(new \App\Events\Enterprise\WhiteLabelConfigUpdated($organization));

        // Re-warm cache
        $newCss = $whiteLabelService->generateCSS($organization);
        $cacheService->setCachedCSS($organization, $newCss);

        // Verify new CSS is cached
        $cachedCss = $cacheService->getCachedCSS($organization);
        $this->assertStringContainsString('--color-primary: #ff0000', $cachedCss);
        $this->assertStringNotContainsString('--color-primary: #0000ff', $cachedCss);
    }

    public function test_multiple_cache_layers_stay_consistent(): void
    {
        Cache::flush();

        $organization = $this->createOrganization();
        $config = WhiteLabelConfig::factory()->create([
            'organization_id' => $organization->id,
            'platform_name' => 'Test Platform',
        ]);

        $whiteLabelService = app(WhiteLabelService::class);

        // Populate all cache layers
        $css = $whiteLabelService->generateCSS($organization);
        $emailVars = $whiteLabelService->getEmailBrandingVars($organization);
        $faviconUrls = $whiteLabelService->getFaviconUrls($organization);

        Cache::put("branding:{$organization->id}:css", $css, 3600);
        Cache::put("email_branding:{$organization->id}", $emailVars, 3600);
        Cache::put("favicon_urls:{$organization->id}", $faviconUrls, 3600);

        // Verify all caches populated
        $this->assertTrue(Cache::has("branding:{$organization->id}:css"));
        $this->assertTrue(Cache::has("email_branding:{$organization->id}"));
        $this->assertTrue(Cache::has("favicon_urls:{$organization->id}"));

        // Update config
        $config->update(['platform_name' => 'Updated Platform']);

        // Clear all branding caches
        $cacheService = app(BrandingCacheService::class);
        $cacheService->clearBrandingCache($organization);

        // Verify all caches cleared
        $this->assertFalse(Cache::has("branding:{$organization->id}:css"));
        $this->assertFalse(Cache::has("email_branding:{$organization->id}"));
        $this->assertFalse(Cache::has("favicon_urls:{$organization->id}"));
    }
}
```

### API Integration Workflow Test

**File:** `tests/Feature/Enterprise/Workflows/ApiIntegrationWorkflowTest.php`

```php
<?php

namespace Tests\Feature\Enterprise/Workflows;

use App\Models\Organization;
use App\Models\Server;
use App\Models\User;
use Illuminate\Support\Facades\RateLimiter;
use Tests\Utilities\Enterprise\WorkflowTestCase;

/**
 * Test API workflows with rate limiting and organization scoping
 */
class ApiIntegrationWorkflowTest extends WorkflowTestCase
{
    public function test_api_token_creation_and_usage_workflow(): void
    {
        $organization = $this->createOrganization();
        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Step 1: Create API token
        $token = $user->createToken('test-api-token', [
            "organization:{$organization->id}:read",
            "organization:{$organization->id}:write",
        ]);

        $this->assertNotNull($token->plainTextToken);

        // Step 2: Use token to access API
        Server::factory()->count(3)->create(['organization_id' => $organization->id]);

        $response = $this->withToken($token->plainTextToken)
            ->get("/api/organizations/{$organization->id}/servers");

        $response->assertOk();
        $response->assertJsonCount(3, 'data');

        // Step 3: Verify rate limit headers present
        $response->assertHeader('X-RateLimit-Limit');
        $response->assertHeader('X-RateLimit-Remaining');

        // Step 4: Test write operations
        $response = $this->withToken($token->plainTextToken)
            ->post("/api/organizations/{$organization->id}/servers", [
                'name' => 'API Created Server',
                'ip' => '192.168.1.100',
            ]);

        $response->assertCreated();

        // Verify server created
        $this->assertDatabaseHas('servers', [
            'organization_id' => $organization->id,
            'name' => 'API Created Server',
        ]);
    }

    public function test_api_rate_limiting_workflow(): void
    {
        RateLimiter::clear('api');

        $organization = $this->createOrganization();
        $license = $this->createLicense($organization, [
            'license_tier' => 'professional',
            'api_rate_limit_per_minute' => 100,
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        $token = $user->createToken('rate-limit-test')->plainTextToken;

        // Make requests until rate limit hit
        for ($i = 0; $i < 100; $i++) {
            $response = $this->withToken($token)
                ->get("/api/organizations/{$organization->id}/servers");

            $response->assertOk();
        }

        // 101st request should be rate limited
        $response = $this->withToken($token)
            ->get("/api/organizations/{$organization->id}/servers");

        $response->assertStatus(429); // Too Many Requests
        $response->assertHeader('Retry-After');
    }

    public function test_api_organization_scoping_enforcement(): void
    {
        $orgA = $this->createOrganization(['name' => 'Org A']);
        $orgB = $this->createOrganization(['name' => 'Org B']);

        $userA = User::factory()->create();
        $orgA->users()->attach($userA, ['role' => 'admin']);

        $tokenA = $userA->createToken('org-a-token', [
            "organization:{$orgA->id}:read",
        ])->plainTextToken;

        Server::factory()->create(['organization_id' => $orgA->id, 'name' => 'Org A Server']);
        Server::factory()->create(['organization_id' => $orgB->id, 'name' => 'Org B Server']);

        // Token scoped to Org A should access Org A
        $response = $this->withToken($tokenA)
            ->get("/api/organizations/{$orgA->id}/servers");

        $response->assertOk();
        $response->assertJsonFragment(['name' => 'Org A Server']);
        $response->assertJsonMissing(['name' => 'Org B Server']);

        // Token scoped to Org A should NOT access Org B
        $response = $this->withToken($tokenA)
            ->get("/api/organizations/{$orgB->id}/servers");

        $response->assertForbidden();
    }
}
```

## Implementation Approach

### Step 1: Create Workflow Test Infrastructure
1. Create `WorkflowTestCase` base class in `tests/Utilities/Enterprise/`
2. Add workflow assertion helpers (`assertWorkflowStep`, `assertWorkflowPerformance`)
3. Create `MockExternalServices` helper for Terraform/payment gateways
4. Set up test database with enterprise schema

### Step 2: Implement Organization Onboarding Tests
1. Create `OrganizationOnboardingWorkflowTest`
2. Test complete registration → license → branding → login flow
3. Test free tier restrictions
4. Test performance benchmarks

### Step 3: Implement Infrastructure Provisioning Tests
1. Create `InfrastructureProvisioningWorkflowTest`
2. Test Terraform → server registration → deployment flow
3. Test rollback on failure scenarios
4. Test quota enforcement

### Step 4: Implement Multi-Tenant Isolation Tests
1. Create `MultiTenantIsolationWorkflowTest`
2. Test data isolation across all models
3. Test cascade deletion
4. Test API token scoping
5. Test WebSocket channel isolation

### Step 5: Implement Cross-Service Integration Tests
1. Create `CrossServiceIntegrationWorkflowTest`
2. Test TerraformService → CapacityManager → DeploymentService
3. Test WhiteLabelService → CacheService → EmailService
4. Test LicensingService → quota enforcement

### Step 6: Implement Background Job Tests
1. Create `BackgroundJobChainingWorkflowTest`
2. Test job chaining (Terraform → registration)
3. Test event-triggered jobs
4. Test retry logic

### Step 7: Implement Cache Consistency Tests
1. Create `CacheConsistencyWorkflowTest`
2. Test cache invalidation on updates
3. Test multi-layer cache consistency
4. Test cache warming

### Step 8: Implement API Integration Tests
1. Create `ApiIntegrationWorkflowTest`
2. Test token creation and usage
3. Test rate limiting
4. Test organization scoping

### Step 9: Add Payment Workflow Tests
1. Create `PaymentProcessingWorkflowTest`
2. Test payment → license activation flow
3. Test webhook handling
4. Test subscription lifecycle

### Step 10: CI/CD Integration
1. Configure test suite to run on every PR
2. Set up parallel test execution
3. Add code coverage reporting
4. Create test result dashboard

## Test Strategy

### Test Execution Strategy

**Parallel Execution:**
```bash
# Run all workflow tests in parallel
php artisan test --parallel --testsuite=Workflows

# Run specific workflow
php artisan test tests/Feature/Enterprise/Workflows/OrganizationOnboardingWorkflowTest.php
```

**Coverage Requirements:**
- **Overall coverage:** > 90% for enterprise features
- **Workflow coverage:** 100% of happy paths, 80% of error paths
- **Critical paths:** 100% coverage (onboarding, provisioning, payment)

**Performance Benchmarks:**
- Organization onboarding workflow: < 5 seconds
- Infrastructure provisioning (mocked): < 10 seconds
- Multi-tenant isolation checks: < 2 seconds
- API workflow tests: < 1 second

### Test Data Management

**Database Transactions:**
All workflow tests run in transactions and roll back after completion:

```php
use Illuminate\Foundation\Testing\RefreshDatabase;

class OrganizationOnboardingWorkflowTest extends WorkflowTestCase
{
    use RefreshDatabase;
}
```

**Factory Usage:**
Use factories consistently for test data creation:

```php
$organization = Organization::factory()->create([
    'name' => 'Test Organization',
    'slug' => 'test-org',
]);
```

**Mock External Services:**
Always mock external services (Terraform, payment gateways, DNS providers):

```php
protected function mockTerraformSuccess(array $outputs): void
{
    Process::fake([
        'terraform init*' => Process::result('Initialized'),
        'terraform plan*' => Process::result('Plan: 3 to add'),
        'terraform apply*' => Process::result('Apply complete'),
        'terraform output*' => Process::result(json_encode($outputs)),
    ]);
}
```

## Definition of Done

- [ ] WorkflowTestCase base class created with helper methods
- [ ] MockExternalServices utility created
- [ ] OrganizationOnboardingWorkflowTest implemented with 3+ scenarios
- [ ] InfrastructureProvisioningWorkflowTest implemented with 3+ scenarios
- [ ] DeploymentLifecycleWorkflowTest implemented
- [ ] PaymentProcessingWorkflowTest implemented
- [ ] WhiteLabelBrandingWorkflowTest implemented
- [ ] MultiTenantIsolationWorkflowTest implemented with comprehensive coverage
- [ ] CrossServiceIntegrationWorkflowTest implemented
- [ ] BackgroundJobChainingWorkflowTest implemented
- [ ] CacheConsistencyWorkflowTest implemented
- [ ] ApiIntegrationWorkflowTest implemented
- [ ] All workflow tests pass consistently
- [ ] Test coverage > 90% for enterprise features
- [ ] All happy path workflows covered
- [ ] All critical error scenarios covered
- [ ] Performance benchmarks met for all workflows
- [ ] Database transaction rollback working correctly
- [ ] External services properly mocked
- [ ] Multi-tenant isolation verified across all features
- [ ] CI/CD pipeline configured to run workflow tests
- [ ] Parallel test execution configured
- [ ] Code coverage reporting integrated
- [ ] Test documentation complete
- [ ] All tests follow PSR-12 coding standards
- [ ] PHPStan level 5 passing for test code
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 76 (Unit tests for all enterprise services)
- **Uses:** Task 72 (OrganizationTestingTrait)
- **Uses:** Task 73 (LicenseTestingTrait)
- **Uses:** Task 74 (TerraformTestingTrait)
- **Uses:** Task 75 (PaymentTestingTrait)
- **Validates:** All enterprise feature tasks (Tasks 2-75)
- **Required for:** Production deployment confidence
- **Required for:** Regression prevention
- **Required for:** CI/CD quality gates
