---
name: Build TerraformService with provisionInfrastructure, destroyInfrastructure, getStatus methods
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:32Z
github: https://github.com/johnproblems/topgun/issues/124
depends_on: [13]
parallel: false
conflicts_with: []
---

# Task: Build TerraformService with provisionInfrastructure, destroyInfrastructure, getStatus methods

## Description

Implement the core `TerraformService` that orchestrates infrastructure provisioning and lifecycle management by wrapping Terraform CLI commands. This service acts as the execution engine for the Terraform integration system, handling the complex workflow of infrastructure provisioning, state management, output parsing, and error recovery across multiple cloud providers.

The service provides a clean PHP interface to Terraform's command-line operations using Symfony Process, enabling Coolify to programmatically create, update, and destroy cloud infrastructure. It abstracts the complexity of Terraform execution while maintaining full visibility into the provisioning process through detailed logging, progress tracking, and state persistence.

**Core Responsibilities:**

1. **Infrastructure Provisioning**: Execute `terraform init`, `plan`, and `apply` workflows with proper error handling
2. **State Management**: Encrypt, store, and retrieve Terraform state files in the database with S3 backup
3. **Output Parsing**: Extract infrastructure details (IP addresses, instance IDs) from Terraform JSON output
4. **Lifecycle Management**: Support infrastructure updates, scaling, and destruction with rollback capability
5. **Progress Tracking**: Real-time status updates for long-running provisioning operations
6. **Error Recovery**: Automatic retry logic, partial failure handling, and state recovery

**Integration Points:**

- **CloudProviderCredential Model**: Retrieves encrypted API credentials for cloud provider authentication
- **TerraformDeployment Model**: Persists deployment state, outputs, and metadata
- **TerraformDeploymentJob**: Async job wrapper for long-running provisioning operations
- **Server Model**: Links provisioned infrastructure to Coolify server registry
- **Terraform Templates**: Loads modular HCL templates for different cloud providers (Tasks 15-16)

**Why This Task Is Critical:**

Terraform integration is the cornerstone of automated infrastructure management. Without this service, Coolify cannot provision cloud resources programmatically, forcing users to manually create servers before deployment. This service enables "infrastructure as code" capabilities, allowing organizations to provision entire environments on-demand, scale dynamically, and manage infrastructure lifecycle through a unified platform. It transforms Coolify from a deployment tool into a comprehensive cloud orchestration platform.

## Acceptance Criteria

- [ ] TerraformService class implements TerraformServiceInterface with all required methods
- [ ] `provisionInfrastructure()` method executes complete Terraform workflow (init → plan → apply)
- [ ] `destroyInfrastructure()` method safely tears down infrastructure with state cleanup
- [ ] `getStatus()` method queries deployment state and returns structured status information
- [ ] `validateTemplate()` method validates Terraform HCL syntax before execution
- [ ] State file encryption using AES-256 with separate encryption key
- [ ] State file database storage with automatic S3 backup after each apply
- [ ] Terraform output parsing with JSON format extraction
- [ ] Error handling with detailed error messages and automatic retry logic
- [ ] Progress tracking with status updates broadcast via events
- [ ] Rollback capability on failed deployments with state restoration
- [ ] Support for multiple Terraform versions with version detection
- [ ] Integration with CloudProviderCredential for secure credential injection
- [ ] Comprehensive logging for debugging and audit trails
- [ ] Unit tests covering all public methods with >90% coverage

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/TerraformService.php` (implementation)
- `/home/topgun/topgun/app/Contracts/TerraformServiceInterface.php` (interface)

**Configuration:**
- `/home/topgun/topgun/config/terraform.php` (Terraform settings)

**Terraform Templates:**
- `/home/topgun/topgun/storage/app/terraform/templates/{provider}/` (HCL templates)
- `/home/topgun/topgun/storage/app/terraform/workspaces/{deployment_uuid}/` (working directories)

**Models:**
- `/home/topgun/topgun/app/Models/CloudProviderCredential.php` (existing)
- `/home/topgun/topgun/app/Models/TerraformDeployment.php` (existing)

### Service Interface

**File:** `app/Contracts/TerraformServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\CloudProviderCredential;
use App\Models\TerraformDeployment;
use App\DTOs\TerraformProvisioningResult;

interface TerraformServiceInterface
{
    /**
     * Provision infrastructure using Terraform
     *
     * @param CloudProviderCredential $credential
     * @param array $config Infrastructure configuration
     * @return TerraformDeployment
     * @throws \App\Exceptions\TerraformException
     */
    public function provisionInfrastructure(
        CloudProviderCredential $credential,
        array $config
    ): TerraformDeployment;

    /**
     * Destroy infrastructure and cleanup resources
     *
     * @param TerraformDeployment $deployment
     * @param bool $force Force destruction even if errors occur
     * @return bool
     * @throws \App\Exceptions\TerraformException
     */
    public function destroyInfrastructure(
        TerraformDeployment $deployment,
        bool $force = false
    ): bool;

    /**
     * Get deployment status and current state
     *
     * @param TerraformDeployment $deployment
     * @return array Status information
     */
    public function getStatus(TerraformDeployment $deployment): array;

    /**
     * Validate Terraform template syntax
     *
     * @param string $templatePath Absolute path to .tf file
     * @return array Validation result with errors
     */
    public function validateTemplate(string $templatePath): array;

    /**
     * Update existing infrastructure with new configuration
     *
     * @param TerraformDeployment $deployment
     * @param array $newConfig Updated infrastructure config
     * @return TerraformDeployment
     */
    public function updateInfrastructure(
        TerraformDeployment $deployment,
        array $newConfig
    ): TerraformDeployment;

    /**
     * Generate Terraform plan without applying changes
     *
     * @param CloudProviderCredential $credential
     * @param array $config
     * @return string Plan output
     */
    public function generatePlan(
        CloudProviderCredential $credential,
        array $config
    ): string;

    /**
     * Refresh Terraform state from cloud provider
     *
     * @param TerraformDeployment $deployment
     * @return bool
     */
    public function refreshState(TerraformDeployment $deployment): bool;

    /**
     * Extract outputs from Terraform state
     *
     * @param TerraformDeployment $deployment
     * @return array Parsed outputs
     */
    public function extractOutputs(TerraformDeployment $deployment): array;
}
```

### Service Implementation

**File:** `app/Services/Enterprise/TerraformService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\TerraformServiceInterface;
use App\Models\CloudProviderCredential;
use App\Models\TerraformDeployment;
use App\Exceptions\TerraformException;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Crypt;
use Symfony\Component\Process\Process;
use Symfony\Component\Process\Exception\ProcessFailedException;

class TerraformService implements TerraformServiceInterface
{
    private const TERRAFORM_BINARY = '/usr/local/bin/terraform';
    private const STATE_ENCRYPTION_KEY = 'terraform_state_encryption_key';
    private const MAX_RETRY_ATTEMPTS = 3;
    private const COMMAND_TIMEOUT = 1800; // 30 minutes

    /**
     * Provision infrastructure using Terraform
     */
    public function provisionInfrastructure(
        CloudProviderCredential $credential,
        array $config
    ): TerraformDeployment {
        Log::info('Starting Terraform provisioning', [
            'provider' => $credential->provider,
            'organization_id' => $credential->organization_id,
        ]);

        // Create deployment record
        $deployment = TerraformDeployment::create([
            'uuid' => (string) new \Visus\Cuid2\Cuid2(),
            'organization_id' => $credential->organization_id,
            'cloud_provider_credential_id' => $credential->id,
            'name' => $config['name'] ?? 'Infrastructure Deployment',
            'provider' => $credential->provider,
            'region' => $config['region'] ?? $credential->region,
            'status' => 'pending',
            'infrastructure_config' => $config,
            'terraform_version' => $this->getTerraformVersion(),
            'started_at' => now(),
        ]);

        try {
            // Step 1: Prepare workspace
            $workspaceDir = $this->prepareWorkspace($deployment, $credential, $config);

            // Step 2: Terraform init
            $deployment->update(['status' => 'initializing']);
            $this->runTerraformInit($workspaceDir);

            // Step 3: Terraform plan
            $deployment->update(['status' => 'planning']);
            $planOutput = $this->runTerraformPlan($workspaceDir);
            $deployment->update(['plan_output' => $planOutput]);

            // Step 4: Terraform apply
            $deployment->update(['status' => 'applying']);
            $applyOutput = $this->runTerraformApply($workspaceDir);
            $deployment->update(['apply_output' => $applyOutput]);

            // Step 5: Extract outputs and state
            $outputs = $this->extractTerraformOutputs($workspaceDir);
            $stateFile = $this->getStateFile($workspaceDir);

            // Step 6: Encrypt and store state
            $encryptedState = $this->encryptStateFile($stateFile);
            $deployment->update([
                'status' => 'completed',
                'outputs' => $outputs,
                'state_file' => $encryptedState,
                'state_file_checksum' => hash('sha256', $stateFile),
                'state_last_updated_at' => now(),
                'completed_at' => now(),
            ]);

            // Step 7: Backup state to S3
            $this->backupStateToS3($deployment, $stateFile);

            // Step 8: Extract resource identifiers for future cleanup
            $resourceIds = $this->extractResourceIdentifiers($stateFile);
            $deployment->update(['resource_identifiers' => $resourceIds]);

            Log::info('Terraform provisioning completed successfully', [
                'deployment_id' => $deployment->id,
                'outputs' => $outputs,
            ]);

            return $deployment->fresh();

        } catch (\Exception $e) {
            Log::error('Terraform provisioning failed', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            $deployment->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
                'completed_at' => now(),
            ]);

            throw new TerraformException(
                "Terraform provisioning failed: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        } finally {
            // Cleanup workspace if configured
            if (config('terraform.cleanup_workspaces', false)) {
                $this->cleanupWorkspace($workspaceDir ?? null);
            }
        }
    }

    /**
     * Destroy infrastructure and cleanup resources
     */
    public function destroyInfrastructure(
        TerraformDeployment $deployment,
        bool $force = false
    ): bool {
        Log::info('Starting infrastructure destruction', [
            'deployment_id' => $deployment->id,
            'force' => $force,
        ]);

        try {
            $deployment->update([
                'status' => 'destroying',
                'started_at' => now(),
            ]);

            // Restore workspace with state
            $workspaceDir = $this->restoreWorkspace($deployment);

            // Run terraform destroy
            $this->runTerraformDestroy($workspaceDir, $force);

            $deployment->update([
                'status' => 'destroyed',
                'destroyed_at' => now(),
                'completed_at' => now(),
            ]);

            // Remove state backup
            $this->removeStateBackup($deployment);

            Log::info('Infrastructure destroyed successfully', [
                'deployment_id' => $deployment->id,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Infrastructure destruction failed', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            $deployment->update([
                'status' => 'failed',
                'error_message' => "Destruction failed: {$e->getMessage()}",
            ]);

            if ($force) {
                // Force cleanup even on error
                $this->forceCleanupResources($deployment);
                return true;
            }

            throw new TerraformException(
                "Infrastructure destruction failed: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Get deployment status and current state
     */
    public function getStatus(TerraformDeployment $deployment): array
    {
        $status = [
            'id' => $deployment->id,
            'uuid' => $deployment->uuid,
            'status' => $deployment->status,
            'provider' => $deployment->provider,
            'region' => $deployment->region,
            'started_at' => $deployment->started_at?->toIso8601String(),
            'completed_at' => $deployment->completed_at?->toIso8601String(),
            'duration_seconds' => $this->calculateDuration($deployment),
            'outputs' => $deployment->outputs ?? [],
            'error_message' => $deployment->error_message,
        ];

        // Add detailed resource information if state exists
        if ($deployment->state_file) {
            $stateFile = $this->decryptStateFile($deployment->state_file);
            $stateData = json_decode($stateFile, true);

            $status['resources'] = [
                'count' => count($stateData['resources'] ?? []),
                'list' => $this->formatResourceList($stateData['resources'] ?? []),
            ];
        }

        return $status;
    }

    /**
     * Validate Terraform template syntax
     */
    public function validateTemplate(string $templatePath): array
    {
        if (!file_exists($templatePath)) {
            return [
                'valid' => false,
                'errors' => ["Template file not found: {$templatePath}"],
            ];
        }

        $workspaceDir = dirname($templatePath);

        try {
            // Run terraform validate
            $process = new Process(
                [self::TERRAFORM_BINARY, 'validate', '-json'],
                $workspaceDir,
                null,
                null,
                60
            );

            $process->run();
            $output = json_decode($process->getOutput(), true);

            return [
                'valid' => $output['valid'] ?? false,
                'errors' => $output['diagnostics'] ?? [],
                'format_version' => $output['format_version'] ?? null,
            ];

        } catch (\Exception $e) {
            return [
                'valid' => false,
                'errors' => [$e->getMessage()],
            ];
        }
    }

    /**
     * Update existing infrastructure
     */
    public function updateInfrastructure(
        TerraformDeployment $deployment,
        array $newConfig
    ): TerraformDeployment {
        Log::info('Updating infrastructure', [
            'deployment_id' => $deployment->id,
        ]);

        try {
            // Update config
            $deployment->update([
                'infrastructure_config' => array_merge(
                    $deployment->infrastructure_config,
                    $newConfig
                ),
                'status' => 'updating',
            ]);

            // Restore workspace
            $workspaceDir = $this->restoreWorkspace($deployment);

            // Update Terraform variables
            $this->updateTerraformVariables($workspaceDir, $newConfig);

            // Run plan and apply
            $planOutput = $this->runTerraformPlan($workspaceDir);
            $applyOutput = $this->runTerraformApply($workspaceDir);

            // Update deployment record
            $outputs = $this->extractTerraformOutputs($workspaceDir);
            $stateFile = $this->getStateFile($workspaceDir);

            $deployment->update([
                'status' => 'completed',
                'outputs' => $outputs,
                'state_file' => $this->encryptStateFile($stateFile),
                'state_last_updated_at' => now(),
                'plan_output' => $planOutput,
                'apply_output' => $applyOutput,
            ]);

            $this->backupStateToS3($deployment, $stateFile);

            return $deployment->fresh();

        } catch (\Exception $e) {
            $deployment->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
            ]);

            throw new TerraformException(
                "Infrastructure update failed: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Generate Terraform plan without applying
     */
    public function generatePlan(
        CloudProviderCredential $credential,
        array $config
    ): string {
        $workspaceDir = $this->prepareTemporaryWorkspace($credential, $config);

        try {
            $this->runTerraformInit($workspaceDir);
            return $this->runTerraformPlan($workspaceDir);
        } finally {
            $this->cleanupWorkspace($workspaceDir);
        }
    }

    /**
     * Refresh Terraform state from cloud provider
     */
    public function refreshState(TerraformDeployment $deployment): bool
    {
        try {
            $workspaceDir = $this->restoreWorkspace($deployment);

            $process = new Process(
                [self::TERRAFORM_BINARY, 'refresh', '-auto-approve'],
                $workspaceDir,
                $this->getEnvironmentVariables($deployment->cloudProviderCredential),
                null,
                self::COMMAND_TIMEOUT
            );

            $process->mustRun();

            // Update state file
            $stateFile = $this->getStateFile($workspaceDir);
            $deployment->update([
                'state_file' => $this->encryptStateFile($stateFile),
                'state_last_updated_at' => now(),
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('State refresh failed', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Extract outputs from Terraform state
     */
    public function extractOutputs(TerraformDeployment $deployment): array
    {
        if (!$deployment->state_file) {
            return [];
        }

        $stateFile = $this->decryptStateFile($deployment->state_file);
        $stateData = json_decode($stateFile, true);

        $outputs = [];
        foreach ($stateData['outputs'] ?? [] as $key => $output) {
            $outputs[$key] = $output['value'] ?? null;
        }

        return $outputs;
    }

    // Private helper methods

    private function prepareWorkspace(
        TerraformDeployment $deployment,
        CloudProviderCredential $credential,
        array $config
    ): string {
        $workspaceDir = storage_path("app/terraform/workspaces/{$deployment->uuid}");

        if (!is_dir($workspaceDir)) {
            mkdir($workspaceDir, 0755, true);
        }

        // Copy template files
        $templateDir = storage_path("app/terraform/templates/{$credential->provider}");
        $this->copyTemplateFiles($templateDir, $workspaceDir);

        // Generate variables file
        $this->generateTerraformVariables($workspaceDir, $credential, $config);

        return $workspaceDir;
    }

    private function runTerraformInit(string $workspaceDir): void
    {
        $process = new Process(
            [self::TERRAFORM_BINARY, 'init', '-no-color'],
            $workspaceDir,
            null,
            null,
            300
        );

        $process->mustRun();

        Log::info('Terraform init completed', [
            'workspace' => $workspaceDir,
        ]);
    }

    private function runTerraformPlan(string $workspaceDir): string
    {
        $process = new Process(
            [self::TERRAFORM_BINARY, 'plan', '-no-color', '-out=tfplan'],
            $workspaceDir,
            null,
            null,
            600
        );

        $process->mustRun();

        return $process->getOutput();
    }

    private function runTerraformApply(string $workspaceDir): string
    {
        $process = new Process(
            [self::TERRAFORM_BINARY, 'apply', '-no-color', '-auto-approve', 'tfplan'],
            $workspaceDir,
            null,
            null,
            self::COMMAND_TIMEOUT
        );

        $process->mustRun();

        return $process->getOutput();
    }

    private function runTerraformDestroy(string $workspaceDir, bool $force): void
    {
        $args = [self::TERRAFORM_BINARY, 'destroy', '-no-color', '-auto-approve'];

        if ($force) {
            $args[] = '-force';
        }

        $process = new Process(
            $args,
            $workspaceDir,
            null,
            null,
            self::COMMAND_TIMEOUT
        );

        $process->mustRun();
    }

    private function extractTerraformOutputs(string $workspaceDir): array
    {
        $process = new Process(
            [self::TERRAFORM_BINARY, 'output', '-json'],
            $workspaceDir,
            null,
            null,
            60
        );

        $process->run();

        if (!$process->isSuccessful()) {
            return [];
        }

        $outputs = json_decode($process->getOutput(), true);
        $result = [];

        foreach ($outputs as $key => $output) {
            $result[$key] = $output['value'] ?? null;
        }

        return $result;
    }

    private function getStateFile(string $workspaceDir): string
    {
        $stateFilePath = "{$workspaceDir}/terraform.tfstate";

        if (!file_exists($stateFilePath)) {
            throw new TerraformException('State file not found');
        }

        return file_get_contents($stateFilePath);
    }

    private function encryptStateFile(string $stateContent): string
    {
        return Crypt::encryptString($stateContent);
    }

    private function decryptStateFile(string $encryptedState): string
    {
        return Crypt::decryptString($encryptedState);
    }

    private function backupStateToS3(TerraformDeployment $deployment, string $stateContent): void
    {
        if (!config('terraform.s3_backup_enabled', true)) {
            return;
        }

        $s3Path = "terraform/states/{$deployment->organization_id}/{$deployment->uuid}.tfstate";

        Storage::disk('s3')->put($s3Path, $stateContent);

        Log::info('State backed up to S3', [
            'deployment_id' => $deployment->id,
            's3_path' => $s3Path,
        ]);
    }

    private function getTerraformVersion(): string
    {
        $process = new Process([self::TERRAFORM_BINARY, 'version', '-json']);
        $process->run();

        if ($process->isSuccessful()) {
            $output = json_decode($process->getOutput(), true);
            return $output['terraform_version'] ?? 'unknown';
        }

        return 'unknown';
    }

    private function extractResourceIdentifiers(string $stateContent): array
    {
        $state = json_decode($stateContent, true);
        $identifiers = [];

        foreach ($state['resources'] ?? [] as $resource) {
            $type = $resource['type'] ?? 'unknown';
            $name = $resource['name'] ?? 'unknown';
            $instances = $resource['instances'] ?? [];

            foreach ($instances as $instance) {
                $attributes = $instance['attributes'] ?? [];
                $identifiers[] = [
                    'type' => $type,
                    'name' => $name,
                    'id' => $attributes['id'] ?? null,
                    'provider' => $resource['provider'] ?? null,
                ];
            }
        }

        return $identifiers;
    }

    private function generateTerraformVariables(
        string $workspaceDir,
        CloudProviderCredential $credential,
        array $config
    ): void {
        $variables = array_merge(
            $config,
            $this->getProviderCredentialsAsVariables($credential)
        );

        $tfvarsContent = '';
        foreach ($variables as $key => $value) {
            if (is_string($value)) {
                $tfvarsContent .= "{$key} = \"{$value}\"\n";
            } elseif (is_bool($value)) {
                $tfvarsContent .= "{$key} = " . ($value ? 'true' : 'false') . "\n";
            } elseif (is_numeric($value)) {
                $tfvarsContent .= "{$key} = {$value}\n";
            }
        }

        file_put_contents("{$workspaceDir}/terraform.tfvars", $tfvarsContent);
    }

    private function getProviderCredentialsAsVariables(CloudProviderCredential $credential): array
    {
        return match ($credential->provider) {
            'aws' => [
                'aws_access_key_id' => $credential->credentials['access_key_id'],
                'aws_secret_access_key' => $credential->credentials['secret_access_key'],
                'aws_region' => $credential->credentials['region'],
            ],
            'digitalocean' => [
                'do_token' => $credential->credentials['api_token'],
            ],
            'hetzner' => [
                'hcloud_token' => $credential->credentials['api_token'],
            ],
            default => [],
        };
    }

    private function copyTemplateFiles(string $sourceDir, string $targetDir): void
    {
        if (!is_dir($sourceDir)) {
            throw new TerraformException("Template directory not found: {$sourceDir}");
        }

        $files = glob("{$sourceDir}/*.tf");

        foreach ($files as $file) {
            copy($file, $targetDir . '/' . basename($file));
        }
    }

    private function restoreWorkspace(TerraformDeployment $deployment): string
    {
        $workspaceDir = storage_path("app/terraform/workspaces/{$deployment->uuid}");

        if (!is_dir($workspaceDir)) {
            mkdir($workspaceDir, 0755, true);
        }

        // Restore state file
        if ($deployment->state_file) {
            $stateContent = $this->decryptStateFile($deployment->state_file);
            file_put_contents("{$workspaceDir}/terraform.tfstate", $stateContent);
        }

        // Restore template files
        $this->copyTemplateFiles(
            storage_path("app/terraform/templates/{$deployment->provider}"),
            $workspaceDir
        );

        // Restore variables
        $this->generateTerraformVariables(
            $workspaceDir,
            $deployment->cloudProviderCredential,
            $deployment->infrastructure_config
        );

        return $workspaceDir;
    }

    private function cleanupWorkspace(?string $workspaceDir): void
    {
        if ($workspaceDir && is_dir($workspaceDir)) {
            // Recursive delete
            array_map('unlink', glob("{$workspaceDir}/*"));
            rmdir($workspaceDir);
        }
    }

    private function calculateDuration(TerraformDeployment $deployment): ?int
    {
        if (!$deployment->started_at) {
            return null;
        }

        $end = $deployment->completed_at ?? now();
        return $deployment->started_at->diffInSeconds($end);
    }

    private function formatResourceList(array $resources): array
    {
        return array_map(function ($resource) {
            return [
                'type' => $resource['type'] ?? 'unknown',
                'name' => $resource['name'] ?? 'unknown',
                'provider' => $resource['provider'] ?? 'unknown',
            ];
        }, $resources);
    }

    private function forceCleanupResources(TerraformDeployment $deployment): void
    {
        // Emergency cleanup using cloud provider APIs directly
        Log::warning('Forcing resource cleanup', [
            'deployment_id' => $deployment->id,
        ]);

        // Implementation would use cloud provider SDKs to delete resources
        // based on resource_identifiers
    }

    private function removeStateBackup(TerraformDeployment $deployment): void
    {
        if (!config('terraform.s3_backup_enabled', true)) {
            return;
        }

        $s3Path = "terraform/states/{$deployment->organization_id}/{$deployment->uuid}.tfstate";
        Storage::disk('s3')->delete($s3Path);
    }

    private function getEnvironmentVariables(CloudProviderCredential $credential): array
    {
        return match ($credential->provider) {
            'aws' => [
                'AWS_ACCESS_KEY_ID' => $credential->credentials['access_key_id'],
                'AWS_SECRET_ACCESS_KEY' => $credential->credentials['secret_access_key'],
                'AWS_DEFAULT_REGION' => $credential->credentials['region'],
            ],
            'digitalocean' => [
                'DIGITALOCEAN_TOKEN' => $credential->credentials['api_token'],
            ],
            'hetzner' => [
                'HCLOUD_TOKEN' => $credential->credentials['api_token'],
            ],
            default => [],
        };
    }

    private function prepareTemporaryWorkspace(
        CloudProviderCredential $credential,
        array $config
    ): string {
        $tempDir = storage_path('app/terraform/temp/' . uniqid());
        mkdir($tempDir, 0755, true);

        $this->copyTemplateFiles(
            storage_path("app/terraform/templates/{$credential->provider}"),
            $tempDir
        );

        $this->generateTerraformVariables($tempDir, $credential, $config);

        return $tempDir;
    }

    private function updateTerraformVariables(string $workspaceDir, array $newConfig): void
    {
        $existingVars = $this->parseExistingVariables("{$workspaceDir}/terraform.tfvars");
        $updatedVars = array_merge($existingVars, $newConfig);

        $tfvarsContent = '';
        foreach ($updatedVars as $key => $value) {
            if (is_string($value)) {
                $tfvarsContent .= "{$key} = \"{$value}\"\n";
            } elseif (is_bool($value)) {
                $tfvarsContent .= "{$key} = " . ($value ? 'true' : 'false') . "\n";
            } elseif (is_numeric($value)) {
                $tfvarsContent .= "{$key} = {$value}\n";
            }
        }

        file_put_contents("{$workspaceDir}/terraform.tfvars", $tfvarsContent);
    }

    private function parseExistingVariables(string $tfvarsPath): array
    {
        if (!file_exists($tfvarsPath)) {
            return [];
        }

        $content = file_get_contents($tfvarsPath);
        $variables = [];

        // Simple parser for key = "value" format
        preg_match_all('/(\w+)\s*=\s*"([^"]+)"/', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $variables[$match[1]] = $match[2];
        }

        return $variables;
    }
}
```

### Configuration File

**File:** `config/terraform.php`

```php
<?php

return [
    // Terraform binary path
    'binary_path' => env('TERRAFORM_BINARY_PATH', '/usr/local/bin/terraform'),

    // Command timeout in seconds
    'command_timeout' => env('TERRAFORM_COMMAND_TIMEOUT', 1800),

    // Workspace cleanup
    'cleanup_workspaces' => env('TERRAFORM_CLEANUP_WORKSPACES', false),

    // S3 backup configuration
    's3_backup_enabled' => env('TERRAFORM_S3_BACKUP_ENABLED', true),
    's3_bucket' => env('TERRAFORM_S3_BUCKET', 'coolify-terraform-states'),

    // Retry configuration
    'max_retry_attempts' => env('TERRAFORM_MAX_RETRY_ATTEMPTS', 3),
    'retry_delay_seconds' => env('TERRAFORM_RETRY_DELAY_SECONDS', 10),

    // Template directories
    'templates_path' => storage_path('app/terraform/templates'),
    'workspaces_path' => storage_path('app/terraform/workspaces'),

    // Supported providers
    'supported_providers' => ['aws', 'digitalocean', 'hetzner', 'gcp', 'azure'],
];
```

### Exception Class

**File:** `app/Exceptions/TerraformException.php`

```php
<?php

namespace App\Exceptions;

class TerraformException extends \Exception
{
    public function __construct(
        string $message = "",
        int $code = 0,
        ?\Throwable $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }

    public function report(): void
    {
        \Log::error('Terraform error occurred', [
            'message' => $this->getMessage(),
            'code' => $this->getCode(),
            'file' => $this->getFile(),
            'line' => $this->getLine(),
        ]);
    }
}
```

## Implementation Approach

### Step 1: Create Service Interface
1. Create `app/Contracts/TerraformServiceInterface.php`
2. Define all public method signatures
3. Document each method with PHPDoc blocks

### Step 2: Create Configuration File
1. Create `config/terraform.php` with all settings
2. Add environment variables to `.env.example`
3. Document configuration options

### Step 3: Create Exception Class
1. Create `app/Exceptions/TerraformException.php`
2. Add custom error reporting logic
3. Integrate with Laravel's exception handler

### Step 4: Implement Service Class
1. Create `app/Services/Enterprise/TerraformService.php`
2. Implement `provisionInfrastructure()` method with full workflow
3. Implement `destroyInfrastructure()` with cleanup
4. Add `getStatus()` for state querying
5. Add `validateTemplate()` for syntax checking
6. Implement helper methods for Terraform CLI operations

### Step 5: Add State Management
1. Implement state file encryption/decryption
2. Add S3 backup functionality
3. Implement state restoration for workspace recovery
4. Add state refresh capability

### Step 6: Add Error Handling
1. Implement retry logic for transient failures
2. Add rollback capability on failed deployments
3. Implement force cleanup for emergency situations
4. Add comprehensive logging

### Step 7: Register Service
1. Add service binding in `EnterpriseServiceProvider`
2. Configure singleton binding for service instance
3. Add facade if needed

### Step 8: Testing
1. Unit tests for all public methods
2. Mock Terraform CLI process execution
3. Test state encryption/decryption
4. Test error handling and recovery

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/TerraformServiceTest.php`

```php
<?php

use App\Services\Enterprise\TerraformService;
use App\Models\CloudProviderCredential;
use App\Models\TerraformDeployment;
use App\Models\Organization;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Process;

beforeEach(function () {
    Storage::fake('s3');
    Storage::fake('local');
    $this->service = app(TerraformService::class);
});

it('provisions infrastructure successfully', function () {
    Process::fake([
        'terraform version*' => Process::result('{"terraform_version": "1.5.7"}'),
        'terraform init*' => Process::result('Terraform initialized'),
        'terraform plan*' => Process::result('Plan: 3 to add'),
        'terraform apply*' => Process::result('Apply complete'),
        'terraform output*' => Process::result('{"server_ip": {"value": "1.2.3.4"}}'),
    ]);

    $organization = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->aws()->create([
        'organization_id' => $organization->id,
    ]);

    $config = [
        'name' => 'Test Deployment',
        'instance_type' => 't3.medium',
        'ami' => 'ami-12345678',
        'region' => 'us-east-1',
    ];

    $deployment = $this->service->provisionInfrastructure($credential, $config);

    expect($deployment)
        ->toBeInstanceOf(TerraformDeployment::class)
        ->status->toBe('completed')
        ->outputs->toHaveKey('server_ip');
});

it('handles provisioning failures gracefully', function () {
    Process::fake([
        'terraform init*' => Process::result('Terraform initialized'),
        'terraform plan*' => Process::result('Plan: 3 to add'),
        'terraform apply*' => Process::result('Error: Provider authentication failed', 1),
    ]);

    $credential = CloudProviderCredential::factory()->aws()->create();
    $config = ['name' => 'Test', 'instance_type' => 't3.medium'];

    expect(fn () => $this->service->provisionInfrastructure($credential, $config))
        ->toThrow(\App\Exceptions\TerraformException::class);
});

it('destroys infrastructure successfully', function () {
    Process::fake([
        'terraform destroy*' => Process::result('Destroy complete'),
    ]);

    $deployment = TerraformDeployment::factory()->create([
        'status' => 'completed',
    ]);

    $result = $this->service->destroyInfrastructure($deployment);

    expect($result)->toBeTrue()
        ->and($deployment->fresh()->status)->toBe('destroyed');
});

it('validates terraform templates', function () {
    Process::fake([
        'terraform validate*' => Process::result('{"valid": true, "diagnostics": []}'),
    ]);

    $templatePath = storage_path('app/terraform/templates/aws/main.tf');
    Storage::disk('local')->put('terraform/templates/aws/main.tf', 'resource "aws_instance" "server" {}');

    $result = $this->service->validateTemplate($templatePath);

    expect($result)
        ->toHaveKey('valid')
        ->valid->toBeTrue();
});

it('encrypts and decrypts state files', function () {
    $credential = CloudProviderCredential::factory()->create();
    $config = ['name' => 'Test'];

    Process::fake([
        'terraform*' => Process::result('{"server_ip": {"value": "1.2.3.4"}}'),
    ]);

    $deployment = $this->service->provisionInfrastructure($credential, $config);

    expect($deployment->state_file)->not->toBeNull();

    // Decrypt and verify
    $decrypted = \Crypt::decryptString($deployment->state_file);
    expect($decrypted)->toBeJson();
});

it('backs up state to S3', function () {
    Storage::fake('s3');

    Process::fake([
        'terraform*' => Process::result('{"outputs": {}}'),
    ]);

    $credential = CloudProviderCredential::factory()->create();
    $deployment = $this->service->provisionInfrastructure($credential, ['name' => 'Test']);

    $s3Path = "terraform/states/{$credential->organization_id}/{$deployment->uuid}.tfstate";
    Storage::disk('s3')->assertExists($s3Path);
});

it('extracts terraform outputs correctly', function () {
    $deployment = TerraformDeployment::factory()->create([
        'outputs' => [
            'server_ip' => '1.2.3.4',
            'instance_id' => 'i-12345',
        ],
    ]);

    $outputs = $this->service->extractOutputs($deployment);

    expect($outputs)
        ->toHaveKey('server_ip', '1.2.3.4')
        ->toHaveKey('instance_id', 'i-12345');
});

it('gets deployment status with resource details', function () {
    $deployment = TerraformDeployment::factory()->create([
        'status' => 'completed',
    ]);

    $status = $this->service->getStatus($deployment);

    expect($status)
        ->toHaveKeys(['id', 'status', 'provider', 'duration_seconds'])
        ->status->toBe('completed');
});
```

### Integration Tests

**File:** `tests/Feature/TerraformProvisioningTest.php`

```php
<?php

use App\Services\Enterprise\TerraformService;
use App\Models\CloudProviderCredential;
use App\Models\Organization;

it('completes full provisioning workflow', function () {
    $organization = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->aws()->create([
        'organization_id' => $organization->id,
    ]);

    $service = app(TerraformService::class);

    // Mock Terraform binary responses
    Process::fake([
        'terraform version*' => Process::result('{"terraform_version": "1.5.7"}'),
        'terraform init*' => Process::result('Initialized'),
        'terraform plan*' => Process::result('Plan: 3 to add'),
        'terraform apply*' => Process::result('Apply complete'),
        'terraform output*' => Process::result('{"server_ip": {"value": "1.2.3.4"}}'),
    ]);

    $config = [
        'name' => 'Production Server',
        'instance_type' => 't3.medium',
        'region' => 'us-east-1',
    ];

    // Provision
    $deployment = $service->provisionInfrastructure($credential, $config);

    expect($deployment->status)->toBe('completed')
        ->and($deployment->outputs)->toHaveKey('server_ip');

    // Verify state backup
    $s3Path = "terraform/states/{$organization->id}/{$deployment->uuid}.tfstate";
    Storage::disk('s3')->assertExists($s3Path);

    // Destroy
    Process::fake([
        'terraform destroy*' => Process::result('Destroy complete'),
    ]);

    $result = $service->destroyInfrastructure($deployment);

    expect($result)->toBeTrue()
        ->and($deployment->fresh()->status)->toBe('destroyed');
});
```

## Definition of Done

- [ ] TerraformServiceInterface created with all method signatures
- [ ] TerraformService implementation complete
- [ ] Configuration file created (`config/terraform.php`)
- [ ] TerraformException class created
- [ ] `provisionInfrastructure()` method implemented with full workflow
- [ ] `destroyInfrastructure()` method implemented with cleanup
- [ ] `getStatus()` method implemented with state parsing
- [ ] `validateTemplate()` method implemented
- [ ] `updateInfrastructure()` method implemented
- [ ] `generatePlan()` method implemented
- [ ] `refreshState()` method implemented
- [ ] `extractOutputs()` method implemented
- [ ] State file encryption/decryption working
- [ ] S3 backup functionality implemented
- [ ] Workspace management (create, restore, cleanup) working
- [ ] Error handling and retry logic implemented
- [ ] Rollback capability on failures working
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written (full workflow coverage)
- [ ] Terraform CLI process mocking working in tests
- [ ] PHPDoc blocks complete for all public methods
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing completed with real Terraform binary
- [ ] Documentation updated
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 13 (CloudProviderCredential model)
- **Used by:** Task 18 (TerraformDeploymentJob for async execution)
- **Integrates with:** Task 15 (AWS Terraform templates)
- **Integrates with:** Task 16 (DigitalOcean/Hetzner templates)
- **Used by:** Task 19 (Server auto-registration)
- **Used by:** Task 20 (TerraformManager.vue frontend component)
