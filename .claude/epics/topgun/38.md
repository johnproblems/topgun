---
name: Implement automatic rollback mechanism on health check failures
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:54:31Z
github: https://github.com/johnproblems/topgun/issues/199
depends_on: [33, 34, 35]
parallel: false
conflicts_with: []
---

# Task: Implement automatic rollback mechanism on health check failures

## Description

Implement a comprehensive automatic rollback system that monitors application health during and after deployments, automatically reverting to the previous stable version when health checks fail. This critical safety mechanism protects production environments from broken deployments by continuously validating application health using configurable health check strategies (HTTP endpoints, TCP connections, custom scripts) and orchestrating seamless rollbacks when issues are detected.

Modern deployment strategies (rolling updates, blue-green, canary) require intelligent health validation to ensure applications remain available. This task builds the foundation for production-grade deployment safety by implementing:

1. **Multi-Strategy Health Checking**: HTTP endpoint validation, TCP port checks, custom script execution, container status monitoring
2. **Configurable Health Policies**: Define success criteria (status codes, response times, consecutive successes), failure thresholds (max retries, timeout durations)
3. **Automated Rollback Orchestration**: Trigger rollback on health check failures, coordinate state restoration across deployment strategies, preserve previous deployment artifacts
4. **Health Check Persistence**: Store health check results in database, track health history for post-deployment analysis, generate health trend reports
5. **Real-Time Notifications**: Alert administrators via WebSocket, email, and Slack when health checks fail and rollbacks execute
6. **Deployment History**: Maintain comprehensive deployment and rollback audit trail with state snapshots

**Integration with Existing Coolify Architecture:**
- Extends `ApplicationDeploymentJob` with health check validation phases
- Integrates with existing `Server` SSH execution infrastructure via `ExecuteRemoteCommand` trait
- Uses Coolify's existing notification system for health check failure alerts
- Leverages Docker container inspection for health status validation
- Coordinates with proxy configuration updates (Nginx/Traefik) for traffic management

**Integration with Enterprise Deployment System:**
- Works with `EnhancedDeploymentService` (Task 32) for strategy-aware rollbacks
- Coordinates with `CapacityManager` (Task 26) for resource state restoration
- Uses health check data in deployment decision-making algorithms
- Integrates with resource monitoring for correlation between health and resource usage

**Why this task is critical:** Automatic rollback is the safety net that prevents catastrophic production failures. Without health-based rollbacks, broken deployments can take applications offline for extended periods while administrators manually diagnose and fix issues. Automated rollback restores service within seconds, minimizing downtime and customer impact. This transforms deployments from high-risk operations requiring human supervision into reliable automated processes that self-correct when problems occur.

## Acceptance Criteria

### Core Functionality
- [ ] Health check system supports HTTP endpoint validation with configurable status codes, response time thresholds, and response body validation
- [ ] Health check system supports TCP port connectivity checks for non-HTTP services (databases, Redis, message queues)
- [ ] Health check system supports custom script execution for application-specific validation logic
- [ ] Health check system supports Docker container health status inspection
- [ ] Health checks execute on configurable intervals (default: every 10 seconds for 5 minutes post-deployment)
- [ ] Rollback triggers automatically when health checks fail consecutive threshold (default: 3 consecutive failures)

### Rollback Orchestration
- [ ] Rollback preserves previous deployment artifacts (Docker images, configuration files, environment variables)
- [ ] Rollback restores previous Docker container configuration exactly (image tag, environment, volumes, networks)
- [ ] Rollback coordinates with proxy configuration (Nginx/Traefik) to route traffic back to previous version
- [ ] Rollback executes within 30 seconds of health check failure detection (target: < 60 seconds total downtime)
- [ ] Rollback handles partial failures gracefully (some servers succeed, others fail)

### Deployment Strategy Integration
- [ ] Rolling update rollback reverts servers in reverse order, restoring traffic to old containers first
- [ ] Blue-green rollback switches traffic back to previous environment without destroying new environment
- [ ] Canary rollback immediately stops traffic to canary instances and removes them from load balancer

### Configuration & Policy
- [ ] Health check configuration stored in database per application with sensible defaults
- [ ] Health check policies support: success threshold (consecutive successes), failure threshold (consecutive failures), timeout durations, retry intervals
- [ ] Applications can define multiple health check endpoints with AND/OR logic (all must pass OR any must pass)
- [ ] Health check configuration UI integrated into application settings

### Persistence & Reporting
- [ ] Health check results persisted to database with timestamps, status, response details, execution duration
- [ ] Deployment history tracks rollback events with triggering health check failure details
- [ ] Health check dashboard displays real-time status during deployments with historical trends
- [ ] Administrators can view detailed health check logs for failed deployments

### Notifications & Alerts
- [ ] Real-time WebSocket notifications broadcast health check failures and rollback initiation
- [ ] Email notifications sent to application owners on health check failures and rollback completion
- [ ] Slack/Discord webhook integration for team notifications (optional, configurable per application)

### Error Handling & Edge Cases
- [ ] Rollback system handles cases where previous deployment artifacts are missing (logs warning, prevents rollback)
- [ ] Health checks timeout gracefully without blocking deployment job indefinitely
- [ ] Rollback handles concurrent deployment attempts with proper locking
- [ ] System distinguishes between temporary network issues (retry) vs. persistent failures (rollback)

## Technical Details

### File Paths

**Service Layer (NEW):**
- `app/Services/Enterprise/Deployment/HealthCheckService.php` - Health check execution and validation
- `app/Services/Enterprise/Deployment/RollbackOrchestrator.php` - Rollback coordination across strategies
- `app/Contracts/HealthCheckServiceInterface.php` - Health check service interface
- `app/Contracts/RollbackOrchestratorInterface.php` - Rollback orchestrator interface

**Models (NEW):**
- `app/Models/Enterprise/HealthCheckConfig.php` - Health check configuration per application
- `app/Models/Enterprise/HealthCheckResult.php` - Health check execution results
- `app/Models/Enterprise/DeploymentHistory.php` - Deployment and rollback audit trail
- `app/Models/Enterprise/DeploymentSnapshot.php` - State snapshots for rollback restoration

**Jobs (ENHANCE EXISTING):**
- `app/Jobs/ApplicationDeploymentJob.php` - Enhance with health check validation phase
- `app/Jobs/HealthCheckMonitorJob.php` - NEW: Scheduled health check monitoring post-deployment

**Actions (NEW):**
- `app/Actions/Deployment/ExecuteHealthCheck.php` - Execute individual health check
- `app/Actions/Deployment/ExecuteRollback.php` - Execute rollback for single deployment
- `app/Actions/Deployment/CreateDeploymentSnapshot.php` - Capture deployment state before changes
- `app/Actions/Deployment/RestoreDeploymentSnapshot.php` - Restore previous deployment state

**Database Migrations:**
- `database/migrations/2025_01_XX_create_health_check_configs_table.php`
- `database/migrations/2025_01_XX_create_health_check_results_table.php`
- `database/migrations/2025_01_XX_create_deployment_histories_table.php`
- `database/migrations/2025_01_XX_create_deployment_snapshots_table.php`

**Tests:**
- `tests/Unit/Enterprise/Deployment/HealthCheckServiceTest.php`
- `tests/Unit/Enterprise/Deployment/RollbackOrchestratorTest.php`
- `tests/Feature/Enterprise/Deployment/AutomaticRollbackTest.php`
- `tests/Feature/Enterprise/Deployment/HealthCheckExecutionTest.php`

### Database Schema

**health_check_configs table:**
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('health_check_configs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('application_id')->constrained()->cascadeOnDelete();
            $table->string('name')->nullable(); // User-defined name for this health check
            $table->enum('type', ['http', 'tcp', 'script', 'docker_container'])->default('http');

            // HTTP health check configuration
            $table->string('http_endpoint')->nullable(); // e.g., /health, /api/status
            $table->string('http_method')->default('GET'); // GET, POST, HEAD
            $table->json('http_expected_status_codes')->nullable(); // [200, 204]
            $table->integer('http_timeout_seconds')->default(10);
            $table->text('http_expected_body_contains')->nullable(); // Optional body validation
            $table->json('http_headers')->nullable(); // Custom headers

            // TCP health check configuration
            $table->integer('tcp_port')->nullable();
            $table->integer('tcp_timeout_seconds')->default(5);

            // Script health check configuration
            $table->text('script_command')->nullable(); // Shell command to execute
            $table->integer('script_timeout_seconds')->default(30);
            $table->integer('script_expected_exit_code')->default(0);

            // Docker container health check
            $table->boolean('use_docker_health_status')->default(false);

            // Health check policy
            $table->integer('success_threshold')->default(1); // Consecutive successes needed
            $table->integer('failure_threshold')->default(3); // Consecutive failures before rollback
            $table->integer('check_interval_seconds')->default(10); // Time between checks
            $table->integer('initial_delay_seconds')->default(30); // Wait before first check
            $table->integer('monitoring_duration_seconds')->default(300); // How long to monitor (5 min default)

            // Rollback policy
            $table->boolean('auto_rollback_enabled')->default(true);
            $table->boolean('notify_on_failure')->default(true);
            $table->json('notification_channels')->nullable(); // ['email', 'slack', 'discord']

            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index(['application_id', 'is_active']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('health_check_configs');
    }
};
```

**health_check_results table:**
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('health_check_results', function (Blueprint $table) {
            $table->id();
            $table->foreignId('health_check_config_id')->constrained()->cascadeOnDelete();
            $table->foreignId('deployment_id')->nullable()->constrained('application_deployments')->nullOnDelete();
            $table->foreignId('application_id')->constrained()->cascadeOnDelete();
            $table->foreignId('server_id')->nullable()->constrained()->nullOnDelete();

            $table->enum('status', ['success', 'failure', 'timeout', 'error'])->index();
            $table->text('message')->nullable(); // Error message or success details
            $table->json('response_data')->nullable(); // HTTP response, script output, etc.

            // Performance metrics
            $table->integer('response_time_ms')->nullable();
            $table->integer('http_status_code')->nullable();
            $table->integer('script_exit_code')->nullable();

            // Execution context
            $table->timestamp('executed_at')->index();
            $table->integer('execution_duration_ms')->nullable();
            $table->integer('consecutive_success_count')->default(0);
            $table->integer('consecutive_failure_count')->default(0);

            // Rollback trigger
            $table->boolean('triggered_rollback')->default(false);
            $table->timestamp('rollback_triggered_at')->nullable();

            $table->timestamps();

            $table->index(['application_id', 'executed_at']);
            $table->index(['deployment_id', 'status']);
            $table->index(['health_check_config_id', 'executed_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('health_check_results');
    }
};
```

**deployment_histories table:**
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('deployment_histories', function (Blueprint $table) {
            $table->id();
            $table->foreignId('application_id')->constrained()->cascadeOnDelete();
            $table->foreignId('deployment_id')->nullable()->constrained('application_deployments')->nullOnDelete();
            $table->foreignId('user_id')->nullable()->constrained()->nullOnDelete(); // Who triggered

            $table->enum('event_type', [
                'deployment_started',
                'deployment_completed',
                'deployment_failed',
                'health_check_passed',
                'health_check_failed',
                'rollback_initiated',
                'rollback_completed',
                'rollback_failed'
            ])->index();

            $table->string('deployment_strategy')->nullable(); // rolling, blue-green, canary
            $table->string('git_commit_hash', 40)->nullable();
            $table->string('docker_image_tag')->nullable();

            $table->text('description')->nullable();
            $table->json('metadata')->nullable(); // Additional context (server IDs, health check IDs, etc.)

            $table->enum('status', ['success', 'failure', 'in_progress'])->index();
            $table->timestamp('event_occurred_at')->index();

            $table->timestamps();

            $table->index(['application_id', 'event_occurred_at']);
            $table->index(['event_type', 'status']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('deployment_histories');
    }
};
```

**deployment_snapshots table:**
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('deployment_snapshots', function (Blueprint $table) {
            $table->id();
            $table->foreignId('application_id')->constrained()->cascadeOnDelete();
            $table->foreignId('deployment_id')->nullable()->constrained('application_deployments')->nullOnDelete();
            $table->foreignId('server_id')->nullable()->constrained()->nullOnDelete();

            $table->string('snapshot_type')->default('pre_deployment'); // pre_deployment, rollback_point
            $table->string('docker_image_tag')->nullable();
            $table->string('git_commit_hash', 40)->nullable();

            // Container configuration snapshot
            $table->json('container_config')->nullable(); // Docker container JSON
            $table->json('environment_variables')->nullable();
            $table->json('volume_mounts')->nullable();
            $table->json('network_config')->nullable();

            // Application configuration snapshot
            $table->json('application_settings')->nullable();
            $table->text('dockerfile_content')->nullable();
            $table->text('docker_compose_content')->nullable();

            // Proxy configuration
            $table->text('proxy_config')->nullable(); // Nginx/Traefik config

            // File paths for artifact storage
            $table->string('artifact_storage_path')->nullable(); // S3/local path to full backup

            $table->boolean('is_restorable')->default(true);
            $table->timestamp('snapshot_created_at')->index();
            $table->timestamp('expires_at')->nullable()->index(); // Automatic cleanup after 30 days

            $table->timestamps();

            $table->index(['application_id', 'snapshot_created_at']);
            $table->index(['deployment_id', 'snapshot_type']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('deployment_snapshots');
    }
};
```

### Service Implementations

**HealthCheckService Implementation:**

**File:** `app/Services/Enterprise/Deployment/HealthCheckService.php`

```php
<?php

namespace App\Services\Enterprise\Deployment;

use App\Contracts\HealthCheckServiceInterface;
use App\Models\Application;
use App\Models\Server;
use App\Models\Enterprise\HealthCheckConfig;
use App\Models\Enterprise\HealthCheckResult;
use App\Traits\ExecuteRemoteCommand;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Collection;

class HealthCheckService implements HealthCheckServiceInterface
{
    use ExecuteRemoteCommand;

    private const DEFAULT_HTTP_TIMEOUT = 10;
    private const DEFAULT_TCP_TIMEOUT = 5;
    private const DEFAULT_SCRIPT_TIMEOUT = 30;

    /**
     * Execute all active health checks for an application
     *
     * @param Application $application
     * @param int|null $deploymentId
     * @return Collection Collection of HealthCheckResult
     */
    public function executeHealthChecks(Application $application, ?int $deploymentId = null): Collection
    {
        $configs = $application->healthCheckConfigs()->where('is_active', true)->get();

        if ($configs->isEmpty()) {
            Log::info("No active health checks configured for application: {$application->name}");
            return collect();
        }

        $results = collect();

        foreach ($configs as $config) {
            $result = $this->executeSingleHealthCheck($config, $application, $deploymentId);
            $results->push($result);
        }

        return $results;
    }

    /**
     * Execute a single health check configuration
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @param int|null $deploymentId
     * @return HealthCheckResult
     */
    public function executeSingleHealthCheck(
        HealthCheckConfig $config,
        Application $application,
        ?int $deploymentId = null
    ): HealthCheckResult {
        $startTime = microtime(true);

        try {
            $result = match ($config->type) {
                'http' => $this->executeHttpHealthCheck($config, $application),
                'tcp' => $this->executeTcpHealthCheck($config, $application),
                'script' => $this->executeScriptHealthCheck($config, $application),
                'docker_container' => $this->executeDockerHealthCheck($config, $application),
                default => throw new \InvalidArgumentException("Unsupported health check type: {$config->type}"),
            };

            $executionDuration = (int) ((microtime(true) - $startTime) * 1000);

            return $this->createHealthCheckResult($config, $application, $result, $executionDuration, $deploymentId);
        } catch (\Exception $e) {
            Log::error("Health check failed for application {$application->name}: {$e->getMessage()}");

            return $this->createFailedHealthCheckResult(
                $config,
                $application,
                $e->getMessage(),
                (int) ((microtime(true) - $startTime) * 1000),
                $deploymentId
            );
        }
    }

    /**
     * Execute HTTP health check
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @return array
     */
    private function executeHttpHealthCheck(HealthCheckConfig $config, Application $application): array
    {
        $url = $this->buildHealthCheckUrl($config, $application);
        $timeout = $config->http_timeout_seconds ?? self::DEFAULT_HTTP_TIMEOUT;
        $expectedCodes = $config->http_expected_status_codes ?? [200, 204];

        $startTime = microtime(true);

        $response = Http::timeout($timeout)
            ->withHeaders($config->http_headers ?? [])
            ->send($config->http_method ?? 'GET', $url);

        $responseTime = (int) ((microtime(true) - $startTime) * 1000);

        $statusCode = $response->status();
        $isStatusValid = in_array($statusCode, $expectedCodes);

        // Validate response body if expected body specified
        $isBodyValid = true;
        if ($config->http_expected_body_contains && $isStatusValid) {
            $bodyContains = $config->http_expected_body_contains;
            $isBodyValid = str_contains($response->body(), $bodyContains);
        }

        $success = $isStatusValid && $isBodyValid;

        return [
            'status' => $success ? 'success' : 'failure',
            'message' => $success
                ? "HTTP {$statusCode} OK"
                : "HTTP {$statusCode} - Expected " . implode(',', $expectedCodes),
            'response_data' => [
                'status_code' => $statusCode,
                'response_body' => $response->body(),
                'headers' => $response->headers(),
            ],
            'response_time_ms' => $responseTime,
            'http_status_code' => $statusCode,
        ];
    }

    /**
     * Execute TCP connectivity check
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @return array
     */
    private function executeTcpHealthCheck(HealthCheckConfig $config, Application $application): array
    {
        if (!$config->tcp_port) {
            throw new \InvalidArgumentException('TCP port not configured');
        }

        $server = $application->destination->server;
        $host = $server->ip;
        $port = $config->tcp_port;
        $timeout = $config->tcp_timeout_seconds ?? self::DEFAULT_TCP_TIMEOUT;

        $startTime = microtime(true);

        $errno = 0;
        $errstr = '';
        $socket = @fsockopen($host, $port, $errno, $errstr, $timeout);

        $responseTime = (int) ((microtime(true) - $startTime) * 1000);

        if ($socket) {
            fclose($socket);

            return [
                'status' => 'success',
                'message' => "TCP connection successful to {$host}:{$port}",
                'response_time_ms' => $responseTime,
            ];
        }

        return [
            'status' => 'failure',
            'message' => "TCP connection failed to {$host}:{$port} - {$errstr} (errno: {$errno})",
            'response_time_ms' => $responseTime,
        ];
    }

    /**
     * Execute custom script health check
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @return array
     */
    private function executeScriptHealthCheck(HealthCheckConfig $config, Application $application): array
    {
        if (!$config->script_command) {
            throw new \InvalidArgumentException('Script command not configured');
        }

        $server = $application->destination->server;
        $timeout = $config->script_timeout_seconds ?? self::DEFAULT_SCRIPT_TIMEOUT;

        $startTime = microtime(true);

        $output = $this->executeRemoteCommand(
            $server,
            $config->script_command,
            ['timeout' => $timeout]
        );

        $responseTime = (int) ((microtime(true) - $startTime) * 1000);

        $exitCode = $output['exit_code'] ?? 1;
        $expectedExitCode = $config->script_expected_exit_code ?? 0;

        $success = $exitCode === $expectedExitCode;

        return [
            'status' => $success ? 'success' : 'failure',
            'message' => $success
                ? "Script executed successfully (exit code {$exitCode})"
                : "Script failed (exit code {$exitCode}, expected {$expectedExitCode})",
            'response_data' => [
                'stdout' => $output['stdout'] ?? '',
                'stderr' => $output['stderr'] ?? '',
            ],
            'response_time_ms' => $responseTime,
            'script_exit_code' => $exitCode,
        ];
    }

    /**
     * Execute Docker container health status check
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @return array
     */
    private function executeDockerHealthCheck(HealthCheckConfig $config, Application $application): array
    {
        $server = $application->destination->server;
        $containerName = $application->uuid;

        $startTime = microtime(true);

        // Inspect container health status
        $command = "docker inspect --format='{{.State.Health.Status}}' {$containerName}";

        $output = $this->executeRemoteCommand($server, $command);

        $responseTime = (int) ((microtime(true) - $startTime) * 1000);

        $healthStatus = trim($output['stdout'] ?? '');

        $success = $healthStatus === 'healthy';

        return [
            'status' => $success ? 'success' : 'failure',
            'message' => $success
                ? "Container is healthy"
                : "Container health status: {$healthStatus}",
            'response_data' => [
                'health_status' => $healthStatus,
            ],
            'response_time_ms' => $responseTime,
        ];
    }

    /**
     * Build complete health check URL
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @return string
     */
    private function buildHealthCheckUrl(HealthCheckConfig $config, Application $application): string
    {
        $baseUrl = $application->fqdn ?? $application->destination->server->ip;
        $endpoint = $config->http_endpoint ?? '/health';

        // Ensure proper URL formatting
        if (!str_starts_with($baseUrl, 'http')) {
            $baseUrl = 'http://' . $baseUrl;
        }

        return rtrim($baseUrl, '/') . '/' . ltrim($endpoint, '/');
    }

    /**
     * Create health check result record
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @param array $result
     * @param int $executionDuration
     * @param int|null $deploymentId
     * @return HealthCheckResult
     */
    private function createHealthCheckResult(
        HealthCheckConfig $config,
        Application $application,
        array $result,
        int $executionDuration,
        ?int $deploymentId = null
    ): HealthCheckResult {
        // Get previous result for consecutive count tracking
        $previousResult = HealthCheckResult::where('health_check_config_id', $config->id)
            ->latest('executed_at')
            ->first();

        $consecutiveSuccess = $result['status'] === 'success'
            ? ($previousResult?->consecutive_success_count ?? 0) + 1
            : 0;

        $consecutiveFailure = $result['status'] !== 'success'
            ? ($previousResult?->consecutive_failure_count ?? 0) + 1
            : 0;

        return HealthCheckResult::create([
            'health_check_config_id' => $config->id,
            'deployment_id' => $deploymentId,
            'application_id' => $application->id,
            'server_id' => $application->destination->server->id ?? null,
            'status' => $result['status'],
            'message' => $result['message'] ?? null,
            'response_data' => $result['response_data'] ?? null,
            'response_time_ms' => $result['response_time_ms'] ?? null,
            'http_status_code' => $result['http_status_code'] ?? null,
            'script_exit_code' => $result['script_exit_code'] ?? null,
            'executed_at' => now(),
            'execution_duration_ms' => $executionDuration,
            'consecutive_success_count' => $consecutiveSuccess,
            'consecutive_failure_count' => $consecutiveFailure,
        ]);
    }

    /**
     * Create failed health check result
     *
     * @param HealthCheckConfig $config
     * @param Application $application
     * @param string $errorMessage
     * @param int $executionDuration
     * @param int|null $deploymentId
     * @return HealthCheckResult
     */
    private function createFailedHealthCheckResult(
        HealthCheckConfig $config,
        Application $application,
        string $errorMessage,
        int $executionDuration,
        ?int $deploymentId = null
    ): HealthCheckResult {
        $previousResult = HealthCheckResult::where('health_check_config_id', $config->id)
            ->latest('executed_at')
            ->first();

        $consecutiveFailure = ($previousResult?->consecutive_failure_count ?? 0) + 1;

        return HealthCheckResult::create([
            'health_check_config_id' => $config->id,
            'deployment_id' => $deploymentId,
            'application_id' => $application->id,
            'server_id' => $application->destination->server->id ?? null,
            'status' => 'error',
            'message' => $errorMessage,
            'executed_at' => now(),
            'execution_duration_ms' => $executionDuration,
            'consecutive_success_count' => 0,
            'consecutive_failure_count' => $consecutiveFailure,
        ]);
    }

    /**
     * Check if health checks indicate rollback should be triggered
     *
     * @param Collection $results Collection of HealthCheckResult
     * @return bool
     */
    public function shouldTriggerRollback(Collection $results): bool
    {
        foreach ($results as $result) {
            $config = $result->healthCheckConfig;

            // Check if consecutive failure threshold exceeded
            if ($result->consecutive_failure_count >= $config->failure_threshold) {
                return true;
            }
        }

        return false;
    }

    /**
     * Monitor health checks for a deployment
     *
     * @param Application $application
     * @param int $deploymentId
     * @return bool True if all health checks pass within monitoring duration
     */
    public function monitorDeploymentHealth(Application $application, int $deploymentId): bool
    {
        $configs = $application->healthCheckConfigs()->where('is_active', true)->get();

        if ($configs->isEmpty()) {
            Log::info("No health checks configured, skipping monitoring for deployment {$deploymentId}");
            return true;
        }

        // Use first config for timing (they should have similar settings)
        $monitoringDuration = $configs->first()->monitoring_duration_seconds ?? 300;
        $checkInterval = $configs->first()->check_interval_seconds ?? 10;
        $initialDelay = $configs->first()->initial_delay_seconds ?? 30;

        // Wait for initial delay
        Log::info("Waiting {$initialDelay} seconds before starting health checks for deployment {$deploymentId}");
        sleep($initialDelay);

        $endTime = time() + $monitoringDuration;

        while (time() < $endTime) {
            $results = $this->executeHealthChecks($application, $deploymentId);

            if ($this->shouldTriggerRollback($results)) {
                Log::warning("Health check failure threshold exceeded for deployment {$deploymentId}");
                return false;
            }

            // Check if all health checks have met success threshold
            $allPassed = true;
            foreach ($results as $result) {
                $config = $result->healthCheckConfig;
                if ($result->consecutive_success_count < $config->success_threshold) {
                    $allPassed = false;
                    break;
                }
            }

            if ($allPassed) {
                Log::info("All health checks passed for deployment {$deploymentId}");
                return true;
            }

            // Wait before next check
            sleep($checkInterval);
        }

        Log::warning("Health check monitoring timed out for deployment {$deploymentId}");
        return false;
    }
}
```

**RollbackOrchestrator Implementation:**

**File:** `app/Services/Enterprise/Deployment/RollbackOrchestrator.php`

```php
<?php

namespace App\Services\Enterprise\Deployment;

use App\Contracts\RollbackOrchestratorInterface;
use App\Models\Application;
use App\Models\ApplicationDeploymentQueue;
use App\Models\Enterprise\DeploymentSnapshot;
use App\Models\Enterprise\DeploymentHistory;
use App\Traits\ExecuteRemoteCommand;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Notification;
use App\Notifications\DeploymentRollbackNotification;

class RollbackOrchestrator implements RollbackOrchestratorInterface
{
    use ExecuteRemoteCommand;

    /**
     * Execute rollback for a failed deployment
     *
     * @param ApplicationDeploymentQueue $deployment
     * @param string $reason
     * @return bool
     */
    public function executeRollback(ApplicationDeploymentQueue $deployment, string $reason): bool
    {
        $application = $deployment->application;

        Log::info("Initiating rollback for deployment {$deployment->id} - Reason: {$reason}");

        // Record rollback event
        DeploymentHistory::create([
            'application_id' => $application->id,
            'deployment_id' => $deployment->id,
            'user_id' => $deployment->user_id,
            'event_type' => 'rollback_initiated',
            'deployment_strategy' => $deployment->deployment_strategy ?? 'standard',
            'description' => "Automatic rollback triggered: {$reason}",
            'status' => 'in_progress',
            'event_occurred_at' => now(),
        ]);

        try {
            DB::beginTransaction();

            // Find most recent successful snapshot
            $snapshot = DeploymentSnapshot::where('application_id', $application->id)
                ->where('is_restorable', true)
                ->where('snapshot_type', 'rollback_point')
                ->latest('snapshot_created_at')
                ->first();

            if (!$snapshot) {
                throw new \RuntimeException('No rollback snapshot available for application');
            }

            // Execute strategy-specific rollback
            $success = match ($deployment->deployment_strategy ?? 'standard') {
                'rolling' => $this->rollbackRollingUpdate($application, $snapshot),
                'blue_green' => $this->rollbackBlueGreen($application, $snapshot),
                'canary' => $this->rollbackCanary($application, $snapshot),
                default => $this->rollbackStandard($application, $snapshot),
            };

            if ($success) {
                // Mark deployment as failed
                $deployment->update(['status' => 'failed']);

                // Record successful rollback
                DeploymentHistory::create([
                    'application_id' => $application->id,
                    'deployment_id' => $deployment->id,
                    'user_id' => $deployment->user_id,
                    'event_type' => 'rollback_completed',
                    'description' => "Rollback completed successfully to snapshot {$snapshot->id}",
                    'status' => 'success',
                    'event_occurred_at' => now(),
                    'metadata' => [
                        'snapshot_id' => $snapshot->id,
                        'previous_image_tag' => $snapshot->docker_image_tag,
                    ],
                ]);

                // Send notifications
                $this->notifyRollbackSuccess($application, $deployment, $snapshot);

                DB::commit();

                Log::info("Rollback completed successfully for deployment {$deployment->id}");
                return true;
            }

            throw new \RuntimeException('Rollback execution failed');
        } catch (\Exception $e) {
            DB::rollBack();

            Log::error("Rollback failed for deployment {$deployment->id}: {$e->getMessage()}");

            // Record failed rollback
            DeploymentHistory::create([
                'application_id' => $application->id,
                'deployment_id' => $deployment->id,
                'user_id' => $deployment->user_id,
                'event_type' => 'rollback_failed',
                'description' => "Rollback failed: {$e->getMessage()}",
                'status' => 'failure',
                'event_occurred_at' => now(),
            ]);

            $this->notifyRollbackFailure($application, $deployment, $e->getMessage());

            return false;
        }
    }

    /**
     * Rollback standard deployment
     *
     * @param Application $application
     * @param DeploymentSnapshot $snapshot
     * @return bool
     */
    private function rollbackStandard(Application $application, DeploymentSnapshot $snapshot): bool
    {
        $server = $application->destination->server;
        $containerName = $application->uuid;

        // Stop current container
        $this->executeRemoteCommand($server, "docker stop {$containerName}");
        $this->executeRemoteCommand($server, "docker rm {$containerName}");

        // Recreate container from snapshot configuration
        $containerConfig = $snapshot->container_config;
        $dockerRunCommand = $this->buildDockerRunCommand($containerName, $containerConfig);

        $result = $this->executeRemoteCommand($server, $dockerRunCommand);

        if ($result['exit_code'] !== 0) {
            throw new \RuntimeException("Failed to start rollback container: {$result['stderr']}");
        }

        // Restore proxy configuration if present
        if ($snapshot->proxy_config) {
            $this->restoreProxyConfiguration($server, $snapshot->proxy_config);
        }

        return true;
    }

    /**
     * Rollback rolling update deployment
     *
     * @param Application $application
     * @param DeploymentSnapshot $snapshot
     * @return bool
     */
    private function rollbackRollingUpdate(Application $application, DeploymentSnapshot $snapshot): bool
    {
        // For rolling updates, restore containers on each server in reverse order
        $servers = $application->servers()->get();

        foreach ($servers->reverse() as $server) {
            $containerName = "{$application->uuid}-{$server->id}";

            // Stop new container
            $this->executeRemoteCommand($server, "docker stop {$containerName}");

            // Restore old container (should still exist with different tag)
            $oldContainerName = "{$application->uuid}-{$server->id}-old";
            $renameCommand = "docker rename {$oldContainerName} {$containerName}";
            $this->executeRemoteCommand($server, $renameCommand);

            $startCommand = "docker start {$containerName}";
            $result = $this->executeRemoteCommand($server, $startCommand);

            if ($result['exit_code'] !== 0) {
                throw new \RuntimeException("Failed to restart rollback container on server {$server->id}");
            }

            // Restore to load balancer
            $this->updateLoadBalancer($application, $server, 'add');

            // Wait before next server
            sleep(5);
        }

        return true;
    }

    /**
     * Rollback blue-green deployment
     *
     * @param Application $application
     * @param DeploymentSnapshot $snapshot
     * @return bool
     */
    private function rollbackBlueGreen(Application $application, DeploymentSnapshot $snapshot): bool
    {
        $server = $application->destination->server;

        // Simply switch traffic back to old environment (should still be running)
        $oldEnvironment = $application->getCurrentEnvironment() === 'blue' ? 'green' : 'blue';

        // Update proxy to point to old environment
        $this->switchTrafficToEnvironment($application, $server, $oldEnvironment);

        Log::info("Switched traffic back to {$oldEnvironment} environment for application {$application->id}");

        return true;
    }

    /**
     * Rollback canary deployment
     *
     * @param Application $application
     * @param DeploymentSnapshot $snapshot
     * @return bool
     */
    private function rollbackCanary(Application $application, DeploymentSnapshot $snapshot): bool
    {
        $server = $application->destination->server;
        $canaryContainerName = "{$application->uuid}-canary";

        // Stop and remove canary container
        $this->executeRemoteCommand($server, "docker stop {$canaryContainerName}");
        $this->executeRemoteCommand($server, "docker rm {$canaryContainerName}");

        // Remove canary from load balancer
        $this->updateLoadBalancer($application, $server, 'remove_canary');

        Log::info("Removed canary deployment for application {$application->id}");

        return true;
    }

    /**
     * Build docker run command from snapshot configuration
     *
     * @param string $containerName
     * @param array $config
     * @return string
     */
    private function buildDockerRunCommand(string $containerName, array $config): string
    {
        $command = "docker run -d --name {$containerName}";

        // Add environment variables
        foreach ($config['environment'] ?? [] as $key => $value) {
            $command .= " -e {$key}={$value}";
        }

        // Add volume mounts
        foreach ($config['volumes'] ?? [] as $volume) {
            $command .= " -v {$volume}";
        }

        // Add port mappings
        foreach ($config['ports'] ?? [] as $port) {
            $command .= " -p {$port}";
        }

        // Add network
        if (isset($config['network'])) {
            $command .= " --network {$config['network']}";
        }

        // Add image
        $command .= " {$config['image']}";

        return $command;
    }

    /**
     * Restore proxy configuration
     *
     * @param \App\Models\Server $server
     * @param string $proxyConfig
     * @return void
     */
    private function restoreProxyConfiguration($server, string $proxyConfig): void
    {
        // Write proxy config to appropriate file
        $proxyType = config('coolify.proxy_type', 'nginx');

        $configPath = $proxyType === 'nginx'
            ? '/etc/nginx/sites-enabled/default'
            : '/etc/traefik/traefik.yml';

        $writeCommand = "echo '{$proxyConfig}' > {$configPath}";
        $this->executeRemoteCommand($server, $writeCommand);

        // Reload proxy
        $reloadCommand = $proxyType === 'nginx'
            ? 'nginx -s reload'
            : 'systemctl reload traefik';

        $this->executeRemoteCommand($server, $reloadCommand);
    }

    /**
     * Update load balancer configuration
     *
     * @param Application $application
     * @param \App\Models\Server $server
     * @param string $action
     * @return void
     */
    private function updateLoadBalancer(Application $application, $server, string $action): void
    {
        // Placeholder - integrate with actual load balancer configuration
        // This would interact with Nginx/Traefik upstream configuration

        Log::info("Updated load balancer for application {$application->id}: {$action}");
    }

    /**
     * Switch traffic to specific environment
     *
     * @param Application $application
     * @param \App\Models\Server $server
     * @param string $environment
     * @return void
     */
    private function switchTrafficToEnvironment(Application $application, $server, string $environment): void
    {
        // Update proxy configuration to route to specified environment
        // This is a simplified implementation - actual implementation would
        // depend on proxy type (Nginx/Traefik) and configuration format

        $proxyConfigCommand = "# Update proxy to route to {$environment} environment";
        $this->executeRemoteCommand($server, $proxyConfigCommand);
    }

    /**
     * Send rollback success notifications
     *
     * @param Application $application
     * @param ApplicationDeploymentQueue $deployment
     * @param DeploymentSnapshot $snapshot
     * @return void
     */
    private function notifyRollbackSuccess(
        Application $application,
        ApplicationDeploymentQueue $deployment,
        DeploymentSnapshot $snapshot
    ): void {
        $notification = new DeploymentRollbackNotification(
            $application,
            $deployment,
            'success',
            "Deployment rolled back to version {$snapshot->git_commit_hash}"
        );

        // Notify application owner
        if ($application->user) {
            $application->user->notify($notification);
        }

        // Broadcast to WebSocket
        broadcast(new \App\Events\DeploymentRollbackCompleted($application, $deployment));
    }

    /**
     * Send rollback failure notifications
     *
     * @param Application $application
     * @param ApplicationDeploymentQueue $deployment
     * @param string $errorMessage
     * @return void
     */
    private function notifyRollbackFailure(
        Application $application,
        ApplicationDeploymentQueue $deployment,
        string $errorMessage
    ): void {
        $notification = new DeploymentRollbackNotification(
            $application,
            $deployment,
            'failure',
            "Rollback failed: {$errorMessage}"
        );

        if ($application->user) {
            $application->user->notify($notification);
        }

        broadcast(new \App\Events\DeploymentRollbackFailed($application, $deployment, $errorMessage));
    }
}
```

### Enhanced ApplicationDeploymentJob

**File:** `app/Jobs/ApplicationDeploymentJob.php` (modifications)

```php
// Add to existing ApplicationDeploymentJob class

use App\Services\Enterprise\Deployment\HealthCheckService;
use App\Services\Enterprise\Deployment\RollbackOrchestrator;
use App\Actions\Deployment\CreateDeploymentSnapshot;

/**
 * Execute deployment with health check validation and rollback capability
 */
public function handle(): void
{
    try {
        // Create snapshot before deployment
        $snapshotAction = new CreateDeploymentSnapshot();
        $snapshot = $snapshotAction->execute($this->application);

        // Execute deployment (existing logic)
        $this->executeDeployment();

        // Mark deployment as completed
        $this->deployment->update(['status' => 'completed']);

        // Execute health checks if configured
        if ($this->application->healthCheckConfigs()->where('is_active', true)->exists()) {
            $healthCheckService = app(HealthCheckService::class);

            Log::info("Starting health check monitoring for deployment {$this->deployment->id}");

            $healthPassed = $healthCheckService->monitorDeploymentHealth(
                $this->application,
                $this->deployment->id
            );

            if (!$healthPassed) {
                Log::warning("Health checks failed for deployment {$this->deployment->id}, initiating rollback");

                // Trigger automatic rollback
                $rollbackOrchestrator = app(RollbackOrchestrator::class);
                $rollbackOrchestrator->executeRollback(
                    $this->deployment,
                    'Health check failures exceeded threshold'
                );

                return;
            }

            Log::info("Health checks passed for deployment {$this->deployment->id}");

            // Mark snapshot as rollback point (successful deployment)
            $snapshot->update([
                'snapshot_type' => 'rollback_point',
                'is_restorable' => true,
            ]);
        }

        // Deployment successful
        broadcast(new DeploymentSucceeded($this->application, $this->deployment));
    } catch (\Exception $e) {
        Log::error("Deployment {$this->deployment->id} failed: {$e->getMessage()}");

        $this->deployment->update(['status' => 'failed']);

        // Attempt rollback on catastrophic failure
        $rollbackOrchestrator = app(RollbackOrchestrator::class);
        $rollbackOrchestrator->executeRollback(
            $this->deployment,
            "Deployment exception: {$e->getMessage()}"
        );

        throw $e;
    }
}
```

## Implementation Approach

### Step 1: Database Setup (2-3 hours)
1. Create migrations for all tables: `health_check_configs`, `health_check_results`, `deployment_histories`, `deployment_snapshots`
2. Run migrations: `php artisan migrate`
3. Verify schema with database inspection

### Step 2: Create Models (2-3 hours)
1. Create `HealthCheckConfig` model with relationships to `Application`
2. Create `HealthCheckResult` model with relationships to `HealthCheckConfig`, `Application`, `Deployment`
3. Create `DeploymentHistory` model for audit trail
4. Create `DeploymentSnapshot` model for rollback state storage
5. Add model factories for testing

### Step 3: Implement HealthCheckService (6-8 hours)
1. Create `HealthCheckServiceInterface` in `app/Contracts/`
2. Implement `HealthCheckService` in `app/Services/Enterprise/Deployment/`
3. Add HTTP health check execution with timeout, status code validation, response body validation
4. Add TCP connectivity check with timeout
5. Add custom script execution with exit code validation
6. Add Docker container health status inspection
7. Implement consecutive failure/success tracking
8. Add `shouldTriggerRollback()` logic
9. Add `monitorDeploymentHealth()` for continuous monitoring
10. Register service in `EnterpriseServiceProvider`

### Step 4: Implement RollbackOrchestrator (8-10 hours)
1. Create `RollbackOrchestratorInterface` in `app/Contracts/`
2. Implement `RollbackOrchestrator` in `app/Services/Enterprise/Deployment/`
3. Add `executeRollback()` main orchestration method
4. Implement `rollbackStandard()` for single-server deployments
5. Implement `rollbackRollingUpdate()` with reverse-order server restoration
6. Implement `rollbackBlueGreen()` with traffic switching
7. Implement `rollbackCanary()` with canary removal
8. Add notification system integration
9. Add deployment history event recording
10. Register service in `EnterpriseServiceProvider`

### Step 5: Implement Deployment Snapshot Actions (4-5 hours)
1. Create `CreateDeploymentSnapshot` action in `app/Actions/Deployment/`
2. Capture Docker container configuration (inspect output)
3. Capture environment variables, volumes, networks
4. Capture proxy configuration files
5. Create `RestoreDeploymentSnapshot` action for rollback restoration
6. Add snapshot expiration logic (30-day default)

### Step 6: Enhance ApplicationDeploymentJob (3-4 hours)
1. Add snapshot creation before deployment starts
2. Add health check monitoring after deployment completes
3. Integrate rollback trigger on health check failures
4. Add proper exception handling with rollback on catastrophic errors
5. Update deployment status tracking

### Step 7: Create Notifications and Events (2-3 hours)
1. Create `DeploymentRollbackNotification` for email/Slack notifications
2. Create `DeploymentRollbackCompleted` WebSocket event
3. Create `DeploymentRollbackFailed` WebSocket event
4. Configure notification channels in `Application` model

### Step 8: Add Configuration UI (Optional, 4-5 hours)
1. Add health check configuration section to application settings (Livewire component)
2. Allow users to configure HTTP endpoint, expected status codes, timeout
3. Allow users to configure failure/success thresholds
4. Add health check result visualization dashboard

### Step 9: Comprehensive Testing (8-10 hours)
1. Unit test `HealthCheckService` methods (HTTP, TCP, script, Docker checks)
2. Unit test `RollbackOrchestrator` methods (all rollback strategies)
3. Integration test complete deployment → health check → rollback flow
4. Test rollback with various deployment strategies (rolling, blue-green, canary)
5. Test health check failure threshold triggering
6. Test notification delivery on rollback events
7. Test snapshot creation and restoration
8. Test edge cases (missing snapshots, concurrent deployments, timeout scenarios)

### Step 10: Documentation and Code Review (2-3 hours)
1. Add PHPDoc blocks to all service methods
2. Document health check configuration options
3. Create operational runbook for troubleshooting rollback failures
4. Run Laravel Pint formatting: `./vendor/bin/pint`
5. Run PHPStan analysis: `./vendor/bin/phpstan analyse`
6. Code review with team

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Enterprise/Deployment/HealthCheckServiceTest.php`

```php
<?php

use App\Services\Enterprise\Deployment\HealthCheckService;
use App\Models\Application;
use App\Models\Enterprise\HealthCheckConfig;
use Illuminate\Support\Facades\Http;

beforeEach(function () {
    $this->service = app(HealthCheckService::class);
    $this->application = Application::factory()->create();
});

it('executes HTTP health check successfully', function () {
    Http::fake([
        '*' => Http::response(['status' => 'healthy'], 200),
    ]);

    $config = HealthCheckConfig::factory()->create([
        'application_id' => $this->application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'http_expected_status_codes' => [200],
    ]);

    $result = $this->service->executeSingleHealthCheck($config, $this->application);

    expect($result->status)->toBe('success');
    expect($result->http_status_code)->toBe(200);
});

it('fails HTTP health check on unexpected status code', function () {
    Http::fake([
        '*' => Http::response(['error' => 'unhealthy'], 500),
    ]);

    $config = HealthCheckConfig::factory()->create([
        'application_id' => $this->application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'http_expected_status_codes' => [200],
    ]);

    $result = $this->service->executeSingleHealthCheck($config, $this->application);

    expect($result->status)->toBe('failure');
    expect($result->http_status_code)->toBe(500);
});

it('tracks consecutive failure count', function () {
    Http::fake([
        '*' => Http::response(['error' => 'unhealthy'], 500),
    ]);

    $config = HealthCheckConfig::factory()->create([
        'application_id' => $this->application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'failure_threshold' => 3,
    ]);

    // Execute 3 consecutive failures
    for ($i = 1; $i <= 3; $i++) {
        $result = $this->service->executeSingleHealthCheck($config, $this->application);
        expect($result->consecutive_failure_count)->toBe($i);
    }
});

it('determines rollback should be triggered after threshold', function () {
    $config = HealthCheckConfig::factory()->create([
        'application_id' => $this->application->id,
        'failure_threshold' => 3,
    ]);

    $results = collect([
        \App\Models\Enterprise\HealthCheckResult::factory()->create([
            'health_check_config_id' => $config->id,
            'consecutive_failure_count' => 3,
            'status' => 'failure',
        ]),
    ]);

    $shouldRollback = $this->service->shouldTriggerRollback($results);

    expect($shouldRollback)->toBeTrue();
});

it('validates response body contains expected text', function () {
    Http::fake([
        '*' => Http::response(['status' => 'healthy', 'version' => '1.2.3'], 200),
    ]);

    $config = HealthCheckConfig::factory()->create([
        'application_id' => $this->application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'http_expected_body_contains' => 'healthy',
    ]);

    $result = $this->service->executeSingleHealthCheck($config, $this->application);

    expect($result->status)->toBe('success');
});
```

**File:** `tests/Unit/Enterprise/Deployment/RollbackOrchestratorTest.php`

```php
<?php

use App\Services\Enterprise\Deployment\RollbackOrchestrator;
use App\Models\ApplicationDeploymentQueue;
use App\Models\Application;
use App\Models\Enterprise\DeploymentSnapshot;
use Illuminate\Support\Facades\Notification;

beforeEach(function () {
    $this->orchestrator = app(RollbackOrchestrator::class);
    $this->application = Application::factory()->create();
});

it('executes rollback successfully', function () {
    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $this->application->id,
        'status' => 'in_progress',
    ]);

    $snapshot = DeploymentSnapshot::factory()->create([
        'application_id' => $this->application->id,
        'snapshot_type' => 'rollback_point',
        'is_restorable' => true,
    ]);

    $result = $this->orchestrator->executeRollback($deployment, 'Health check failure');

    expect($result)->toBeTrue();

    $deployment->refresh();
    expect($deployment->status)->toBe('failed');
});

it('creates deployment history on rollback', function () {
    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $this->application->id,
    ]);

    $snapshot = DeploymentSnapshot::factory()->create([
        'application_id' => $this->application->id,
        'is_restorable' => true,
    ]);

    $this->orchestrator->executeRollback($deployment, 'Test rollback');

    $this->assertDatabaseHas('deployment_histories', [
        'application_id' => $this->application->id,
        'event_type' => 'rollback_initiated',
    ]);

    $this->assertDatabaseHas('deployment_histories', [
        'application_id' => $this->application->id,
        'event_type' => 'rollback_completed',
    ]);
});

it('sends notifications on rollback success', function () {
    Notification::fake();

    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $this->application->id,
    ]);

    $snapshot = DeploymentSnapshot::factory()->create([
        'application_id' => $this->application->id,
        'is_restorable' => true,
    ]);

    $this->orchestrator->executeRollback($deployment, 'Health check failure');

    Notification::assertSentTo(
        $this->application->user,
        \App\Notifications\DeploymentRollbackNotification::class
    );
});

it('handles missing snapshot gracefully', function () {
    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $this->application->id,
    ]);

    // No snapshot available
    $result = $this->orchestrator->executeRollback($deployment, 'Test rollback');

    expect($result)->toBeFalse();

    $this->assertDatabaseHas('deployment_histories', [
        'application_id' => $this->application->id,
        'event_type' => 'rollback_failed',
    ]);
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/Deployment/AutomaticRollbackTest.php`

```php
<?php

use App\Models\Application;
use App\Models\ApplicationDeploymentQueue;
use App\Models\Enterprise\HealthCheckConfig;
use App\Models\Enterprise\DeploymentSnapshot;
use App\Services\Enterprise\Deployment\HealthCheckService;
use App\Services\Enterprise\Deployment\RollbackOrchestrator;
use Illuminate\Support\Facades\Http;

it('automatically rolls back deployment on health check failures', function () {
    $application = Application::factory()->create();

    // Create health check configuration
    HealthCheckConfig::factory()->create([
        'application_id' => $application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'http_expected_status_codes' => [200],
        'failure_threshold' => 3,
        'auto_rollback_enabled' => true,
    ]);

    // Create deployment snapshot
    $snapshot = DeploymentSnapshot::factory()->create([
        'application_id' => $application->id,
        'snapshot_type' => 'rollback_point',
        'is_restorable' => true,
    ]);

    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $application->id,
        'status' => 'in_progress',
    ]);

    // Fake failing health checks
    Http::fake([
        '*' => Http::response(['error' => 'unhealthy'], 500),
    ]);

    $healthCheckService = app(HealthCheckService::class);
    $rollbackOrchestrator = app(RollbackOrchestrator::class);

    // Execute 3 failing health checks (reach threshold)
    for ($i = 0; $i < 3; $i++) {
        $results = $healthCheckService->executeHealthChecks($application, $deployment->id);
    }

    // Verify rollback should trigger
    $results = $healthCheckService->executeHealthChecks($application, $deployment->id);
    $shouldRollback = $healthCheckService->shouldTriggerRollback($results);

    expect($shouldRollback)->toBeTrue();

    // Execute rollback
    $rollbackSuccess = $rollbackOrchestrator->executeRollback($deployment, 'Health check failures');

    expect($rollbackSuccess)->toBeTrue();

    // Verify deployment marked as failed
    $deployment->refresh();
    expect($deployment->status)->toBe('failed');

    // Verify rollback history created
    $this->assertDatabaseHas('deployment_histories', [
        'application_id' => $application->id,
        'deployment_id' => $deployment->id,
        'event_type' => 'rollback_completed',
        'status' => 'success',
    ]);
});

it('does not rollback on successful health checks', function () {
    $application = Application::factory()->create();

    HealthCheckConfig::factory()->create([
        'application_id' => $application->id,
        'type' => 'http',
        'http_endpoint' => '/health',
        'http_expected_status_codes' => [200],
        'success_threshold' => 2,
    ]);

    $deployment = ApplicationDeploymentQueue::factory()->create([
        'application_id' => $application->id,
    ]);

    // Fake successful health checks
    Http::fake([
        '*' => Http::response(['status' => 'healthy'], 200),
    ]);

    $healthCheckService = app(HealthCheckService::class);

    // Execute 2 successful checks (meet threshold)
    for ($i = 0; $i < 2; $i++) {
        $results = $healthCheckService->executeHealthChecks($application, $deployment->id);
    }

    $results = $healthCheckService->executeHealthChecks($application, $deployment->id);
    $shouldRollback = $healthCheckService->shouldTriggerRollback($results);

    expect($shouldRollback)->toBeFalse();

    // Deployment should remain successful
    $this->assertDatabaseMissing('deployment_histories', [
        'application_id' => $application->id,
        'event_type' => 'rollback_initiated',
    ]);
});

it('handles TCP health check validation', function () {
    $application = Application::factory()->create();

    $config = HealthCheckConfig::factory()->create([
        'application_id' => $application->id,
        'type' => 'tcp',
        'tcp_port' => 3306,
        'tcp_timeout_seconds' => 5,
    ]);

    $healthCheckService = app(HealthCheckService::class);

    // Note: This would require actual TCP server or mocking
    // For now, test the configuration is properly used
    expect($config->type)->toBe('tcp');
    expect($config->tcp_port)->toBe(3306);
});
```

## Definition of Done

### Implementation Complete
- [ ] Database migrations created for all tables (health_check_configs, health_check_results, deployment_histories, deployment_snapshots)
- [ ] All models created with proper relationships and factories
- [ ] HealthCheckServiceInterface and implementation created
- [ ] RollbackOrchestratorInterface and implementation created
- [ ] HTTP health check execution implemented with status code and body validation
- [ ] TCP health check execution implemented with timeout
- [ ] Custom script health check execution implemented
- [ ] Docker container health status check implemented
- [ ] Consecutive failure/success tracking implemented
- [ ] Rollback orchestration for standard deployments implemented
- [ ] Rollback orchestration for rolling updates implemented
- [ ] Rollback orchestration for blue-green deployments implemented
- [ ] Rollback orchestration for canary deployments implemented
- [ ] Deployment snapshot creation action implemented
- [ ] Deployment snapshot restoration action implemented
- [ ] ApplicationDeploymentJob enhanced with health check integration
- [ ] ApplicationDeploymentJob enhanced with automatic rollback trigger
- [ ] Deployment history tracking implemented for all events
- [ ] WebSocket events for rollback notifications created
- [ ] Email notifications for rollback events created

### Testing Complete
- [ ] Unit tests written for HealthCheckService (10+ tests, >90% coverage)
- [ ] Unit tests written for RollbackOrchestrator (8+ tests, >90% coverage)
- [ ] Integration tests for full deployment → health check → rollback flow (5+ tests)
- [ ] Tests for all health check types (HTTP, TCP, script, Docker)
- [ ] Tests for all rollback strategies (standard, rolling, blue-green, canary)
- [ ] Tests for consecutive failure threshold triggering
- [ ] Tests for notification delivery on rollback events
- [ ] Tests for snapshot creation and restoration
- [ ] Tests for edge cases (missing snapshots, concurrent deployments, timeouts)
- [ ] All tests passing (`php artisan test`)

### Quality & Standards
- [ ] Code follows Laravel 12 coding standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 analysis passes with zero errors
- [ ] All methods have comprehensive PHPDoc blocks
- [ ] Service pattern with interfaces followed consistently
- [ ] Error handling comprehensive with proper logging
- [ ] Database indexes added for performance-critical queries

### Documentation
- [ ] Health check configuration options documented
- [ ] Rollback orchestration flow documented
- [ ] Deployment strategy integration documented
- [ ] Troubleshooting guide for rollback failures created
- [ ] API documentation updated for health check endpoints (if exposed)

### Integration & Deployment
- [ ] Services registered in EnterpriseServiceProvider
- [ ] Migrations run successfully in development environment
- [ ] Manual testing completed with sample applications
- [ ] Rollback tested with actual failing deployments
- [ ] Performance validated (rollback completes within 60 seconds)
- [ ] Code reviewed and approved by team lead

## Related Tasks

**Dependencies (Must be completed first):**
- **Task 33** - Rolling update deployment strategy (provides rollback integration point)
- **Task 34** - Blue-green deployment strategy (provides rollback integration point)
- **Task 35** - Canary deployment strategy (provides rollback integration point)

**Integrates With:**
- **Task 32** - EnhancedDeploymentService (coordinates rollback with deployment strategies)
- **Task 26** - CapacityManager (restores resource state during rollback)
- **Task 24** - ResourceMonitoringJob (correlates health failures with resource issues)

**Enables Future Tasks:**
- **Task 39** - DeploymentManager.vue (UI for configuring health checks)
- **Task 40** - StrategySelector.vue (displays rollback capabilities per strategy)
