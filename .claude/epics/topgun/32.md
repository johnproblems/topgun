---
name: Create EnhancedDeploymentService with deployWithStrategy method
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:50Z
github: https://github.com/johnproblems/topgun/issues/142
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Create EnhancedDeploymentService with deployWithStrategy method

## Description

Build an enterprise-grade deployment service that extends Coolify's existing ApplicationDeploymentJob with support for multiple advanced deployment strategies. This service acts as the orchestration layer for zero-downtime deployments, integrating with CapacityManager for resource validation and TerraformService for dynamic infrastructure provisioning.

## Core Architecture

### Service Structure

Create `app/Services/Enterprise/EnhancedDeploymentService.php` with interface-first design:

```php
interface EnhancedDeploymentServiceInterface
{
    public function deployWithStrategy(
        Application $application,
        string $strategy,
        array $options = []
    ): Deployment;

    public function validateDeploymentRequirements(
        Application $application,
        string $strategy
    ): DeploymentValidationResult;

    public function getAvailableStrategies(Application $application): array;

    public function executeRollback(Deployment $deployment): bool;
}
```

### Strategy Pattern Implementation

```php
class EnhancedDeploymentService implements EnhancedDeploymentServiceInterface
{
    public function __construct(
        protected CapacityManager $capacityManager,
        protected TerraformService $terraformService,
        protected HealthCheckService $healthCheckService,
        protected ProxyManager $proxyManager,
    ) {}

    public function deployWithStrategy(
        Application $application,
        string $strategy,
        array $options = []
    ): Deployment {
        // Validate requirements before deployment
        $validation = $this->validateDeploymentRequirements($application, $strategy);

        if (!$validation->isValid()) {
            throw new InsufficientResourcesException($validation->getErrors());
        }

        // Get strategy executor
        $strategyExecutor = $this->getStrategyExecutor($strategy);

        // Create deployment record
        $deployment = $this->createDeploymentRecord($application, $strategy, $options);

        // Execute deployment with selected strategy
        return $strategyExecutor->execute($application, $deployment, $options);
    }

    protected function getStrategyExecutor(string $strategy): DeploymentStrategyInterface
    {
        return match($strategy) {
            'rolling' => app(RollingUpdateStrategy::class),
            'blue-green' => app(BlueGreenStrategy::class),
            'canary' => app(CanaryStrategy::class),
            'standard' => app(StandardStrategy::class),
            default => throw new InvalidStrategyException("Unknown strategy: {$strategy}")
        };
    }
}
```

## Database Schema

### Deployments Table Enhancement

Add new columns to `application_deployment_queues` table:

```php
Schema::table('application_deployment_queues', function (Blueprint $table) {
    $table->string('strategy')->default('standard')->after('status');
    $table->json('strategy_config')->nullable()->after('strategy');
    $table->string('previous_deployment_uuid')->nullable()->after('deployment_uuid');
    $table->timestamp('rollback_at')->nullable()->after('finished_at');
    $table->json('health_check_results')->nullable()->after('strategy_config');
    $table->integer('successful_instances')->default(0)->after('health_check_results');
    $table->integer('total_instances')->default(1)->after('successful_instances');
});
```

### Deployment States Table (New)

Track deployment state transitions:

```php
Schema::create('deployment_states', function (Blueprint $table) {
    $table->id();
    $table->foreignId('deployment_queue_id')->constrained('application_deployment_queues')->onDelete('cascade');
    $table->string('state'); // 'preparing', 'deploying', 'health_check', 'traffic_switching', 'completed', 'rolling_back', 'failed'
    $table->json('metadata')->nullable();
    $table->timestamp('entered_at');
    $table->timestamp('exited_at')->nullable();
    $table->index(['deployment_queue_id', 'entered_at']);
});
```

## Integration with Existing ApplicationDeploymentJob

### Extension Strategy

Rather than replacing ApplicationDeploymentJob, enhance it:

```php
class ApplicationDeploymentJob implements ShouldQueue
{
    // ... existing properties ...

    protected ?EnhancedDeploymentService $enhancedDeploymentService = null;
    protected ?string $deploymentStrategy = null;

    public function handle(): void
    {
        // Check if enhanced deployment is requested
        if ($this->shouldUseEnhancedDeployment()) {
            $this->executeEnhancedDeployment();
            return;
        }

        // Fall back to standard deployment flow
        $this->executeStandardDeployment();
    }

    protected function shouldUseEnhancedDeployment(): bool
    {
        return $this->application_deployment_queue->strategy !== 'standard'
            && $this->application_deployment_queue->strategy !== null;
    }

    protected function executeEnhancedDeployment(): void
    {
        $this->enhancedDeploymentService = app(EnhancedDeploymentService::class);

        $deployment = $this->enhancedDeploymentService->deployWithStrategy(
            $this->application,
            $this->application_deployment_queue->strategy,
            json_decode($this->application_deployment_queue->strategy_config ?? '{}', true)
        );

        // Update queue status based on deployment result
        $this->updateDeploymentStatus($deployment);
    }
}
```

## Deployment Strategy Base Interface

```php
interface DeploymentStrategyInterface
{
    public function execute(
        Application $application,
        ApplicationDeploymentQueue $deployment,
        array $options
    ): Deployment;

    public function validateRequirements(Application $application): ValidationResult;

    public function estimateResources(Application $application): ResourceEstimate;

    public function supportsRollback(): bool;

    public function getName(): string;

    public function getDescription(): string;
}
```

## Health Check Integration

### Enhanced Health Check System

```php
class HealthCheckService
{
    public function performHealthCheck(
        Application $application,
        string $containerName,
        int $maxAttempts = 30,
        int $intervalSeconds = 10
    ): HealthCheckResult {
        $attempts = 0;
        $healthCheckUrl = $this->buildHealthCheckUrl($application);

        while ($attempts < $maxAttempts) {
            $result = $this->checkContainerHealth($containerName, $healthCheckUrl);

            if ($result->isHealthy()) {
                return $result->setSuccess(true);
            }

            $attempts++;
            sleep($intervalSeconds);
        }

        return HealthCheckResult::failed(
            "Health check failed after {$maxAttempts} attempts"
        );
    }

    protected function checkContainerHealth(string $containerName, string $url): HealthCheckResult
    {
        // Check Docker container status
        $containerStatus = $this->getContainerStatus($containerName);

        if (!$containerStatus->isRunning()) {
            return HealthCheckResult::unhealthy('Container not running');
        }

        // Perform HTTP health check if URL provided
        if ($url) {
            return $this->performHttpHealthCheck($url);
        }

        return HealthCheckResult::healthy('Container running');
    }
}
```

## Proxy Configuration Management

### Nginx/Traefik Integration

```php
class ProxyManager
{
    public function updateProxyConfiguration(
        Application $application,
        array $activeContainers,
        string $strategy = 'replace'
    ): bool {
        $proxyType = $application->destination->server->proxyType();

        return match($proxyType) {
            'nginx' => $this->updateNginxConfiguration($application, $activeContainers, $strategy),
            'traefik' => $this->updateTraefikConfiguration($application, $activeContainers, $strategy),
            'caddy' => $this->updateCaddyConfiguration($application, $activeContainers, $strategy),
            default => throw new UnsupportedProxyException("Proxy type {$proxyType} not supported")
        };
    }

    protected function updateTraefikConfiguration(
        Application $application,
        array $activeContainers,
        string $strategy
    ): bool {
        $labels = $this->generateTraefikLabels($application, $activeContainers, $strategy);

        // For blue-green: switch router to point to new container
        // For canary: create weighted load balancer
        // For rolling: update upstream servers

        return $this->applyTraefikLabels($application, $labels);
    }

    protected function generateTraefikLabels(
        Application $application,
        array $containers,
        string $strategy
    ): array {
        $labels = [];

        if ($strategy === 'canary') {
            // Create weighted services
            foreach ($containers as $index => $container) {
                $weight = $container['weight'] ?? 100;
                $labels["traefik.http.services.{$application->uuid}-{$index}.loadbalancer.server.url"] =
                    "http://{$container['name']}:{$container['port']}";
                $labels["traefik.http.services.{$application->uuid}-{$index}.loadbalancer.weight"] = $weight;
            }
        } elseif ($strategy === 'blue-green') {
            // Single active service
            $activeContainer = $containers[0];
            $labels["traefik.http.services.{$application->uuid}.loadbalancer.server.url"] =
                "http://{$activeContainer['name']}:{$activeContainer['port']}";
        }

        return $labels;
    }
}
```

## Container Orchestration

### Docker Container Management

```php
protected function manageContainers(
    Application $application,
    array $containersConfig
): Collection {
    $managedContainers = collect();

    foreach ($containersConfig as $config) {
        $container = $this->launchContainer($application, $config);

        // Wait for container to be ready
        $this->waitForContainerReady($container, $config['readinessTimeout'] ?? 60);

        $managedContainers->push($container);
    }

    return $managedContainers;
}

protected function launchContainer(Application $application, array $config): Container
{
    $containerName = $config['name'];
    $imageName = $config['image'];

    // Build docker run command with all necessary flags
    $dockerCommand = $this->buildDockerRunCommand(
        $containerName,
        $imageName,
        $application,
        $config
    );

    // Execute on target server
    $result = instant_remote_process(
        [$dockerCommand],
        $application->destination->server
    );

    return new Container([
        'name' => $containerName,
        'id' => $this->extractContainerId($result),
        'application_id' => $application->id,
        'config' => $config,
    ]);
}
```

## Resource Validation & Capacity Integration

### Pre-Deployment Validation

```php
public function validateDeploymentRequirements(
    Application $application,
    string $strategy
): DeploymentValidationResult {
    $result = new DeploymentValidationResult();

    // Estimate resource requirements based on strategy
    $resourceRequirements = $this->estimateStrategyResources($application, $strategy);

    // Check if current servers can handle the deployment
    $availableServers = $application->destination->server;

    $canDeploy = $this->capacityManager->canServerHandleDeployment(
        $availableServers,
        $resourceRequirements
    );

    if (!$canDeploy) {
        $result->addError('Insufficient server capacity for deployment');
        $result->addRecommendation('Consider provisioning additional infrastructure');

        // Check if auto-provisioning is enabled
        if ($application->settings->auto_provision_enabled) {
            $result->setAutoProvisionRecommended(true);
        }
    }

    // Validate strategy-specific requirements
    $strategyValidation = $this->validateStrategySpecificRequirements($application, $strategy);
    $result->merge($strategyValidation);

    return $result;
}

protected function estimateStrategyResources(Application $application, string $strategy): array
{
    $baseRequirements = [
        'cpu' => $application->limits_cpus ?? '1.0',
        'memory' => $application->limits_memory ?? '512M',
        'disk' => $this->estimateDiskRequirement($application),
    ];

    // Multiply based on strategy
    return match($strategy) {
        'blue-green' => [
            'cpu' => $baseRequirements['cpu'] * 2, // Need both blue and green
            'memory' => $baseRequirements['memory'] * 2,
            'disk' => $baseRequirements['disk'] * 2,
            'instances' => 2,
        ],
        'canary' => [
            'cpu' => $baseRequirements['cpu'] * 1.2, // Old + canary instance
            'memory' => $baseRequirements['memory'] * 1.2,
            'disk' => $baseRequirements['disk'] * 1.5,
            'instances' => 2,
        ],
        'rolling' => [
            'cpu' => $baseRequirements['cpu'] * 1.5, // Overlap during rolling
            'memory' => $baseRequirements['memory'] * 1.5,
            'disk' => $baseRequirements['disk'] * 1.5,
            'instances' => 2,
        ],
        default => $baseRequirements,
    };
}
```

## State Management & Logging

### Deployment State Tracking

```php
protected function recordStateTransition(
    ApplicationDeploymentQueue $deployment,
    string $newState,
    array $metadata = []
): void {
    DeploymentState::create([
        'deployment_queue_id' => $deployment->id,
        'state' => $newState,
        'metadata' => $metadata,
        'entered_at' => now(),
    ]);

    // Update latest state in deployment queue
    $deployment->update(['current_state' => $newState]);

    // Log state transition
    $deployment->addLogEntry("Deployment state: {$newState}");

    // Broadcast real-time update
    broadcast(new DeploymentStateChanged($deployment, $newState, $metadata));
}
```

## Acceptance Criteria

- [ ] EnhancedDeploymentService created with interface-first design
- [ ] Strategy pattern implemented for extensible deployment strategies
- [ ] Integration with existing ApplicationDeploymentJob (non-breaking)
- [ ] Database schema migrations for deployment tracking
- [ ] Health check service integrated with container lifecycle
- [ ] Proxy configuration management (Nginx/Traefik/Caddy)
- [ ] Container orchestration helpers for multi-instance management
- [ ] Resource validation integrated with CapacityManager
- [ ] State management and real-time logging
- [ ] Rollback mechanism scaffolding
- [ ] Comprehensive error handling and logging
- [ ] Unit tests for service methods
- [ ] Integration tests with mocked deployments

## Technical Details

- **Size**: L
- **Estimated hours**: 16-24
- **Key Files**:
  - `app/Services/Enterprise/EnhancedDeploymentService.php`
  - `app/Contracts/EnhancedDeploymentServiceInterface.php`
  - `app/Contracts/DeploymentStrategyInterface.php`
  - `app/Services/Enterprise/HealthCheckService.php`
  - `app/Services/Enterprise/ProxyManager.php`
  - `database/migrations/XXXX_add_deployment_strategy_columns.php`
  - `database/migrations/XXXX_create_deployment_states_table.php`
  - `tests/Unit/EnhancedDeploymentServiceTest.php`
  - `tests/Feature/DeploymentStrategyTest.php`

## Dependencies

- [ ] No external dependencies (foundation task)

## Effort Estimate

- **Size**: L
- **Hours**: 16-24
- **Parallel**: true

## Testing Strategy

```php
// Unit test example
it('validates deployment requirements correctly', function () {
    $application = Application::factory()->create();
    $service = app(EnhancedDeploymentService::class);

    $result = $service->validateDeploymentRequirements($application, 'blue-green');

    expect($result)->toBeInstanceOf(DeploymentValidationResult::class);
    expect($result->isValid())->toBe(true);
});

// Integration test example
it('deploys application with rolling update strategy', function () {
    $application = Application::factory()->create();
    $service = app(EnhancedDeploymentService::class);

    $deployment = $service->deployWithStrategy($application, 'rolling', [
        'batch_size' => 2,
        'wait_time' => 10,
    ]);

    expect($deployment->status)->toBe('completed');
    expect($deployment->strategy)->toBe('rolling');
});
```

## Definition of Done

- [ ] Code implemented following Laravel best practices
- [ ] All unit tests written and passing (>90% coverage)
- [ ] Integration tests with ApplicationDeploymentJob
- [ ] Documentation updated in `docs/enterprise/deployment-strategies.md`
- [ ] Code reviewed by senior developer
- [ ] Database migrations tested (up and down)
- [ ] Real-time event broadcasting verified
- [ ] Error scenarios handled gracefully
