---
name: Implement ResourceMonitoringJob for scheduled metric collection
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:43Z
github: https://github.com/johnproblems/topgun/issues/134
depends_on: [23]
parallel: false
conflicts_with: []
---

# Task: Implement ResourceMonitoringJob for scheduled metric collection

## Description

Implement a Laravel queued job that systematically collects resource utilization metrics (CPU, memory, disk, network) from all servers in the organization every 30 seconds. This background worker integrates with the ResourcesCheck action (Task 23) to gather real-time metrics, stores them in the `server_resource_metrics` table for historical analysis, and broadcasts updates to WebSocket channels for live dashboard displays.

**The Monitoring Challenge:**

Enterprise organizations running Coolify across dozens or hundreds of servers need continuous visibility into resource utilization to:
1. **Prevent outages**: Detect servers approaching capacity limits before they fail
2. **Optimize costs**: Identify underutilized servers that can be downsized or consolidated
3. **Capacity planning**: Track historical trends to forecast future resource needs
4. **Real-time dashboards**: Display live metrics in organization dashboards without manual refreshing
5. **Alert triggers**: Feed data to alerting systems (email/Slack when CPU > 90%, disk > 85%, etc.)

Without automated metric collection, administrators must manually SSH into each server, run resource commands, and manually track usage—a workflow that doesn't scale beyond a handful of servers.

**The Solution:**

ResourceMonitoringJob runs continuously in Laravel Horizon, processing all servers in batches to avoid overwhelming the queue. Every 30 seconds, it:
1. Queries active servers from database
2. Calls `ResourcesCheck::handle()` for each server (parallel execution via queue)
3. Stores metrics in `server_resource_metrics` table
4. Broadcasts updates to organization WebSocket channels
5. Triggers alerts for servers exceeding thresholds
6. Updates server status indicators (healthy/warning/critical)

**Key Capabilities:**

1. **Scheduled Execution**: Runs every 30 seconds via Laravel Scheduler
2. **Batch Processing**: Handles thousands of servers efficiently using chunking
3. **Error Recovery**: Gracefully handles offline servers, SSH failures, timeouts
4. **Resource Efficiency**: Queued execution prevents blocking web workers
5. **Real-Time Broadcasting**: Pushes updates to WebSocket channels for live dashboards
6. **Historical Storage**: Maintains 30-day rolling window of metrics
7. **Alert Integration**: Triggers notifications for threshold violations
8. **Performance Optimization**: Uses server tags for targeted monitoring

**Integration Architecture:**

**Triggers:**
- **Scheduled**: Laravel Scheduler via `schedule->job(ResourceMonitoringJob::class)->everyThirtySeconds()`
- **Manual**: Artisan command `php artisan resources:collect {server?}`
- **On-Demand**: API endpoint for forcing immediate collection

**Dependencies:**
- **Task 23 (ResourcesCheck)**: Core logic for SSH-based metric collection
- **Server Model**: Query servers to monitor
- **ServerResourceMetric Model**: Store collected metrics
- **WebSocket (Laravel Reverb)**: Broadcast live updates to organization channels
- **Horizon**: Queue management and job monitoring

**Data Flow:**
1. Scheduler dispatches ResourceMonitoringJob every 30 seconds
2. Job queries all active servers (status != 'offline')
3. For each server, dispatches IndividualServerMonitoringJob to queue
4. IndividualServerMonitoringJob calls ResourcesCheck::handle($server)
5. Metrics stored in server_resource_metrics table
6. TerraformResourceUpdated event broadcast to organization WebSocket channel
7. Vue.js dashboards receive event and update metrics in real-time
8. If metrics exceed thresholds, ServerResourceAlertJob dispatched

**Why This Task is Critical:**

Resource monitoring is the foundation of proactive infrastructure management. Without it, organizations operate blindly—reacting to outages instead of preventing them. This job transforms Coolify Enterprise from a deployment tool into a comprehensive infrastructure observability platform, providing the metrics visibility that enterprise teams demand.

The job also serves as a health check mechanism: if resource collection fails consistently for a server, it indicates SSH connectivity issues, server crashes, or permission problems. By detecting these issues early through automated monitoring, administrators can resolve problems before they impact applications.

## Acceptance Criteria

- [ ] ResourceMonitoringJob implements ShouldQueue interface
- [ ] Job dispatches to 'resource-monitoring' queue for isolation
- [ ] Runs every 30 seconds via Laravel Scheduler
- [ ] Queries all active servers (excluding offline/deleted)
- [ ] Implements chunking for processing large server counts (100 per batch)
- [ ] Dispatches IndividualServerMonitoringJob for each server
- [ ] IndividualServerMonitoringJob calls ResourcesCheck::handle()
- [ ] Stores metrics in server_resource_metrics table
- [ ] Broadcasts updates to organization WebSocket channels
- [ ] Implements comprehensive error handling for offline servers
- [ ] Logs failures with server context
- [ ] Retry logic configured (2 retries with exponential backoff)
- [ ] Timeout configured (60 seconds per job)
- [ ] Horizon tags for filtering and monitoring
- [ ] Performance metrics logged (servers processed, time taken, success rate)
- [ ] Artisan command for manual triggering
- [ ] Optional server ID parameter for targeted monitoring
- [ ] Cleanup old metrics (delete records older than 30 days)
- [ ] Triggers alerts for threshold violations
- [ ] Updates server status field based on metrics

## Technical Details

### File Paths

**Job:**
- `/home/topgun/topgun/app/Jobs/Enterprise/ResourceMonitoringJob.php` (main batch job)
- `/home/topgun/topgun/app/Jobs/Enterprise/IndividualServerMonitoringJob.php` (per-server job)

**Artisan Command:**
- `/home/topgun/topgun/app/Console/Commands/CollectServerResources.php` (new)

**Scheduler:**
- `/home/topgun/topgun/app/Console/Kernel.php` (modify - add schedule)

**Event:**
- `/home/topgun/topgun/app/Events/Enterprise/ServerResourcesUpdated.php` (new)

**Model:**
- `/home/topgun/topgun/app/Models/ServerResourceMetric.php` (Task 23 dependency)

### ResourceMonitoringJob Implementation

**File:** `app/Jobs/Enterprise/ResourceMonitoringJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\Server;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ResourceMonitoringJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 2;
    public int $timeout = 300; // 5 minutes for batch processing
    public int $backoff = 30;

    /**
     * Create a new job instance
     *
     * @param int|null $serverId Specific server to monitor, or null for all
     */
    public function __construct(
        public ?int $serverId = null
    ) {
        $this->onQueue('resource-monitoring');
    }

    /**
     * Execute the job
     *
     * @return void
     */
    public function handle(): void
    {
        $startTime = microtime(true);

        try {
            if ($this->serverId) {
                // Monitor specific server
                $this->monitorServer($this->serverId);
            } else {
                // Monitor all active servers
                $this->monitorAllServers();
            }

            $duration = round((microtime(true) - $startTime) * 1000, 2);

            Log::info('Resource monitoring completed', [
                'server_id' => $this->serverId,
                'duration_ms' => $duration,
                'mode' => $this->serverId ? 'single' : 'all',
            ]);
        } catch (\Exception $e) {
            Log::error('Resource monitoring failed', [
                'server_id' => $this->serverId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            throw $e; // Re-throw to trigger retry logic
        }
    }

    /**
     * Monitor all active servers in batches
     *
     * @return void
     */
    protected function monitorAllServers(): void
    {
        $servers = Server::query()
            ->where('status', '!=', 'offline')
            ->whereNull('deleted_at')
            ->get();

        $successCount = 0;
        $failureCount = 0;

        Log::info("Starting resource monitoring for {$servers->count()} servers");

        // Process servers in chunks to avoid overwhelming the queue
        $servers->chunk(100)->each(function ($chunk) use (&$successCount, &$failureCount) {
            foreach ($chunk as $server) {
                try {
                    // Dispatch individual monitoring job for parallel processing
                    IndividualServerMonitoringJob::dispatch($server);
                    $successCount++;
                } catch (\Exception $e) {
                    $failureCount++;

                    Log::warning("Failed to dispatch monitoring job for server {$server->id}", [
                        'server_id' => $server->id,
                        'server_name' => $server->name,
                        'error' => $e->getMessage(),
                    ]);

                    // Continue processing other servers despite failures
                    continue;
                }
            }
        });

        Log::info('Bulk resource monitoring dispatched', [
            'total' => $servers->count(),
            'dispatched' => $successCount,
            'failed' => $failureCount,
        ]);

        // Cleanup old metrics (older than 30 days)
        $this->cleanupOldMetrics();
    }

    /**
     * Monitor specific server by ID
     *
     * @param int $serverId
     * @return void
     */
    protected function monitorServer(int $serverId): void
    {
        $server = Server::find($serverId);

        if (!$server) {
            Log::warning("Server {$serverId} not found for resource monitoring");
            return;
        }

        if ($server->status === 'offline') {
            Log::info("Skipping offline server {$server->id}");
            return;
        }

        // Dispatch individual monitoring job
        IndividualServerMonitoringJob::dispatch($server);

        Log::info("Resource monitoring dispatched for server {$server->id}", [
            'server_id' => $server->id,
            'server_name' => $server->name,
        ]);
    }

    /**
     * Clean up metrics older than 30 days
     *
     * @return void
     */
    protected function cleanupOldMetrics(): void
    {
        $cutoffDate = now()->subDays(30);

        $deleted = \DB::table('server_resource_metrics')
            ->where('created_at', '<', $cutoffDate)
            ->delete();

        if ($deleted > 0) {
            Log::info("Cleaned up old resource metrics", [
                'deleted_count' => $deleted,
                'cutoff_date' => $cutoffDate->toDateTimeString(),
            ]);
        }
    }

    /**
     * Handle job failure
     *
     * @param \Throwable $exception
     * @return void
     */
    public function failed(\Throwable $exception): void
    {
        Log::error('ResourceMonitoringJob failed permanently', [
            'server_id' => $this->serverId,
            'error' => $exception->getMessage(),
            'trace' => $exception->getTraceAsString(),
        ]);

        // Optional: Send alert to monitoring service
        // report($exception);
    }

    /**
     * Get Horizon tags for filtering
     *
     * @return array<int, string>
     */
    public function tags(): array
    {
        $tags = ['resource-monitoring'];

        if ($this->serverId) {
            $tags[] = "server:{$this->serverId}";
        }

        return $tags;
    }
}
```

### IndividualServerMonitoringJob Implementation

**File:** `app/Jobs/Enterprise/IndividualServerMonitoringJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Actions\Server\ResourcesCheck;
use App\Events\Enterprise\ServerResourcesUpdated;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class IndividualServerMonitoringJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 2;
    public int $timeout = 60; // 60 seconds per server
    public int $backoff = 15;

    /**
     * Create a new job instance
     *
     * @param Server $server
     */
    public function __construct(
        public Server $server
    ) {
        $this->onQueue('resource-monitoring');
    }

    /**
     * Execute the job
     *
     * @param ResourcesCheck $resourcesCheck
     * @return void
     */
    public function handle(ResourcesCheck $resourcesCheck): void
    {
        try {
            // Collect resources via SSH
            $resources = $resourcesCheck->handle($this->server);

            if (!$resources) {
                Log::warning("Failed to collect resources for server {$this->server->id}");
                $this->updateServerStatus('warning');
                return;
            }

            // Store metrics in database
            $metric = ServerResourceMetric::create([
                'server_id' => $this->server->id,
                'cpu_usage' => $resources['cpu_usage'] ?? 0,
                'memory_usage' => $resources['memory_usage'] ?? 0,
                'memory_total' => $resources['memory_total'] ?? 0,
                'disk_usage' => $resources['disk_usage'] ?? 0,
                'disk_total' => $resources['disk_total'] ?? 0,
                'network_rx_bytes' => $resources['network_rx_bytes'] ?? 0,
                'network_tx_bytes' => $resources['network_tx_bytes'] ?? 0,
                'load_average' => $resources['load_average'] ?? '0.00 0.00 0.00',
                'uptime_seconds' => $resources['uptime_seconds'] ?? 0,
            ]);

            // Update server's latest metrics (for quick access)
            $this->server->update([
                'cpu_usage' => $metric->cpu_usage,
                'memory_usage' => $metric->memory_usage,
                'disk_usage' => $metric->disk_usage,
                'last_metrics_at' => now(),
            ]);

            // Determine server health status
            $status = $this->calculateServerStatus($metric);
            $this->updateServerStatus($status);

            // Broadcast to organization WebSocket channel
            broadcast(new ServerResourcesUpdated(
                $this->server,
                $metric,
                $status
            ))->toOthers();

            // Check for threshold violations and trigger alerts
            $this->checkThresholds($metric);

            Log::debug("Resource metrics collected for server {$this->server->id}", [
                'server_id' => $this->server->id,
                'cpu_usage' => $metric->cpu_usage,
                'memory_usage' => $metric->memory_usage,
                'disk_usage' => $metric->disk_usage,
                'status' => $status,
            ]);
        } catch (\Exception $e) {
            Log::error("Failed to collect resources for server {$this->server->id}", [
                'server_id' => $this->server->id,
                'server_name' => $this->server->name,
                'error' => $e->getMessage(),
            ]);

            // Mark server as having metric collection issues
            $this->updateServerStatus('error');

            throw $e; // Re-throw to trigger retry
        }
    }

    /**
     * Calculate server health status based on metrics
     *
     * @param ServerResourceMetric $metric
     * @return string (healthy|warning|critical|error)
     */
    protected function calculateServerStatus(ServerResourceMetric $metric): string
    {
        $cpuPercent = $metric->cpu_usage;
        $memoryPercent = ($metric->memory_total > 0)
            ? ($metric->memory_usage / $metric->memory_total) * 100
            : 0;
        $diskPercent = ($metric->disk_total > 0)
            ? ($metric->disk_usage / $metric->disk_total) * 100
            : 0;

        // Critical: Any resource above 90%
        if ($cpuPercent >= 90 || $memoryPercent >= 90 || $diskPercent >= 90) {
            return 'critical';
        }

        // Warning: Any resource above 75%
        if ($cpuPercent >= 75 || $memoryPercent >= 75 || $diskPercent >= 85) {
            return 'warning';
        }

        // Healthy: All resources below thresholds
        return 'healthy';
    }

    /**
     * Update server's resource_status field
     *
     * @param string $status
     * @return void
     */
    protected function updateServerStatus(string $status): void
    {
        $this->server->update(['resource_status' => $status]);
    }

    /**
     * Check thresholds and trigger alerts if needed
     *
     * @param ServerResourceMetric $metric
     * @return void
     */
    protected function checkThresholds(ServerResourceMetric $metric): void
    {
        $cpuPercent = $metric->cpu_usage;
        $memoryPercent = ($metric->memory_total > 0)
            ? ($metric->memory_usage / $metric->memory_total) * 100
            : 0;
        $diskPercent = ($metric->disk_total > 0)
            ? ($metric->disk_usage / $metric->disk_total) * 100
            : 0;

        $violations = [];

        if ($cpuPercent >= 90) {
            $violations[] = "CPU usage at {$cpuPercent}%";
        }

        if ($memoryPercent >= 90) {
            $violations[] = "Memory usage at {$memoryPercent}%";
        }

        if ($diskPercent >= 85) {
            $violations[] = "Disk usage at {$diskPercent}%";
        }

        if (count($violations) > 0) {
            // Dispatch alert job
            ServerResourceAlertJob::dispatch(
                $this->server,
                $violations
            );

            Log::warning("Server resource threshold violations", [
                'server_id' => $this->server->id,
                'server_name' => $this->server->name,
                'violations' => $violations,
            ]);
        }
    }

    /**
     * Handle job failure
     *
     * @param \Throwable $exception
     * @return void
     */
    public function failed(\Throwable $exception): void
    {
        Log::error('IndividualServerMonitoringJob failed permanently', [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'error' => $exception->getMessage(),
        ]);

        // Mark server with error status
        $this->server->update(['resource_status' => 'error']);
    }

    /**
     * Get Horizon tags for filtering
     *
     * @return array<int, string>
     */
    public function tags(): array
    {
        return [
            'resource-monitoring',
            "server:{$this->server->id}",
            "organization:{$this->server->team()->first()?->id}",
        ];
    }
}
```

### Event for WebSocket Broadcasting

**File:** `app/Events/Enterprise/ServerResourcesUpdated.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Server;
use App\Models\ServerResourceMetric;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ServerResourcesUpdated implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    /**
     * Create a new event instance
     *
     * @param Server $server
     * @param ServerResourceMetric $metric
     * @param string $status
     */
    public function __construct(
        public Server $server,
        public ServerResourceMetric $metric,
        public string $status
    ) {
    }

    /**
     * Get the channels the event should broadcast on
     *
     * @return Channel
     */
    public function broadcastOn(): Channel
    {
        $organizationId = $this->server->team()->first()?->id;

        return new Channel("organization.{$organizationId}");
    }

    /**
     * The event's broadcast name
     *
     * @return string
     */
    public function broadcastAs(): string
    {
        return 'server.resources.updated';
    }

    /**
     * Get the data to broadcast
     *
     * @return array<string, mixed>
     */
    public function broadcastWith(): array
    {
        return [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'metrics' => [
                'cpu_usage' => $this->metric->cpu_usage,
                'memory_usage' => $this->metric->memory_usage,
                'memory_total' => $this->metric->memory_total,
                'disk_usage' => $this->metric->disk_usage,
                'disk_total' => $this->metric->disk_total,
                'network_rx_bytes' => $this->metric->network_rx_bytes,
                'network_tx_bytes' => $this->metric->network_tx_bytes,
                'load_average' => $this->metric->load_average,
                'uptime_seconds' => $this->metric->uptime_seconds,
            ],
            'status' => $this->status,
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

### Artisan Command

**File:** `app/Console/Commands/CollectServerResources.php`

```php
<?php

namespace App\Console\Commands;

use App\Jobs\Enterprise\ResourceMonitoringJob;
use Illuminate\Console\Command;

class CollectServerResources extends Command
{
    protected $signature = 'resources:collect
                            {server? : Server ID to collect resources for (omit for all)}
                            {--sync : Run synchronously instead of queuing}';

    protected $description = 'Collect resource metrics from servers';

    public function handle(): int
    {
        $serverId = $this->argument('server');
        $sync = $this->option('sync');

        if ($serverId) {
            $this->info("Collecting resources for server {$serverId}...");
        } else {
            $this->info('Collecting resources for all active servers...');
        }

        $job = new ResourceMonitoringJob($serverId);

        if ($sync) {
            // Run synchronously for debugging
            $job->handle();
            $this->info('✓ Resource collection completed');
        } else {
            // Dispatch to queue
            dispatch($job);
            $this->info('✓ Resource collection job dispatched to queue');
        }

        return self::SUCCESS;
    }
}
```

### Scheduler Configuration

**File:** `app/Console/Kernel.php` (add to existing schedule() method)

```php
/**
 * Define the application's command schedule
 *
 * @param Schedule $schedule
 * @return void
 */
protected function schedule(Schedule $schedule): void
{
    // ... existing scheduled tasks ...

    // Collect server resources every 30 seconds
    $schedule->job(new ResourceMonitoringJob())
        ->everyThirtySeconds()
        ->name('resource-monitoring')
        ->withoutOverlapping()
        ->onOneServer(); // Important for multi-server setups
}
```

### Queue Configuration

**File:** `config/queue.php` (add resource-monitoring queue)

```php
'connections' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => env('REDIS_QUEUE', 'default'),
        'retry_after' => 90,
        'block_for' => null,
        'after_commit' => false,
    ],

    // Add dedicated queue for resource monitoring
    'resource-monitoring' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => 'resource-monitoring',
        'retry_after' => 90,
        'block_for' => null,
        'after_commit' => true,
    ],
],
```

## Implementation Approach

### Step 1: Create Main Job Class
1. Create `ResourceMonitoringJob` in `app/Jobs/Enterprise/`
2. Implement `ShouldQueue` interface
3. Add constructor accepting optional server_id parameter
4. Configure retry logic and timeout

### Step 2: Implement Batch Processing Logic
1. Create `monitorAllServers()` method
2. Query active servers with status filters
3. Implement chunking (100 servers per batch)
4. Dispatch IndividualServerMonitoringJob for each server
5. Add logging for batch summary

### Step 3: Create Individual Server Job
1. Create `IndividualServerMonitoringJob`
2. Integrate with ResourcesCheck action (Task 23)
3. Store metrics in server_resource_metrics table
4. Update server's latest_metrics fields
5. Calculate health status

### Step 4: Add WebSocket Broadcasting
1. Create ServerResourcesUpdated event
2. Implement ShouldBroadcast interface
3. Configure organization-based channels
4. Broadcast after successful metric collection
5. Include full metric payload

### Step 5: Implement Status Calculation
1. Create `calculateServerStatus()` method
2. Define thresholds (75% warning, 90% critical)
3. Check CPU, memory, disk percentages
4. Return status string (healthy/warning/critical/error)
5. Update server's resource_status field

### Step 6: Add Threshold Alerting
1. Create `checkThresholds()` method
2. Compare metrics against configured limits
3. Collect violations list
4. Dispatch ServerResourceAlertJob for violations
5. Log threshold breaches

### Step 7: Implement Cleanup
1. Create `cleanupOldMetrics()` method
2. Delete metrics older than 30 days
3. Run cleanup after batch processing
4. Log deletion count
5. Prevent unbounded table growth

### Step 8: Create Artisan Command
1. Create CollectServerResources command
2. Add optional server ID argument
3. Implement --sync flag for synchronous execution
4. Provide user-friendly output
5. Return proper exit codes

### Step 9: Scheduler Integration
1. Add everyThirtySeconds() schedule in Kernel.php
2. Configure withoutOverlapping() to prevent concurrent runs
3. Add onOneServer() for multi-server environments
4. Name the scheduled task
5. Test scheduling locally

### Step 10: Testing and Monitoring
1. Unit test job execution logic
2. Test error handling and retry behavior
3. Test WebSocket broadcasting
4. Integration test with real SSH connections
5. Monitor job performance in Horizon
6. Verify metric storage and cleanup

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Jobs/ResourceMonitoringJobTest.php`

```php
<?php

use App\Jobs\Enterprise\ResourceMonitoringJob;
use App\Jobs\Enterprise\IndividualServerMonitoringJob;
use App\Models\Server;
use Illuminate\Support\Facades\Queue;

beforeEach(function () {
    Queue::fake();
});

it('dispatches individual jobs for all active servers', function () {
    $servers = Server::factory(5)->create(['status' => 'running']);
    Server::factory(2)->create(['status' => 'offline']); // Should be skipped

    $job = new ResourceMonitoringJob();
    $job->handle();

    Queue::assertPushed(IndividualServerMonitoringJob::class, 5);
});

it('dispatches job for specific server only', function () {
    $server = Server::factory()->create();

    $job = new ResourceMonitoringJob($server->id);
    $job->handle();

    Queue::assertPushed(IndividualServerMonitoringJob::class, function ($job) use ($server) {
        return $job->server->id === $server->id;
    });
});

it('skips offline servers', function () {
    $server = Server::factory()->create(['status' => 'offline']);

    $job = new ResourceMonitoringJob($server->id);
    $job->handle();

    Queue::assertNotPushed(IndividualServerMonitoringJob::class);
});

it('cleans up old metrics', function () {
    $server = Server::factory()->create();

    // Create old metrics (31 days ago)
    \DB::table('server_resource_metrics')->insert([
        'server_id' => $server->id,
        'cpu_usage' => 50,
        'memory_usage' => 1000,
        'memory_total' => 2000,
        'disk_usage' => 10000,
        'disk_total' => 50000,
        'created_at' => now()->subDays(31),
        'updated_at' => now()->subDays(31),
    ]);

    $job = new ResourceMonitoringJob();
    $job->handle();

    expect(\DB::table('server_resource_metrics')->count())->toBe(0);
});
```

### Integration Tests

**File:** `tests/Feature/Jobs/IndividualServerMonitoringJobTest.php`

```php
<?php

use App\Jobs\Enterprise\IndividualServerMonitoringJob;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use App\Events\Enterprise\ServerResourcesUpdated;
use Illuminate\Support\Facades\Event;

it('collects and stores server metrics', function () {
    Event::fake();

    $server = Server::factory()->create([
        'ip' => '127.0.0.1',
        'status' => 'running',
    ]);

    $job = new IndividualServerMonitoringJob($server);
    $job->handle(app(\App\Actions\Server\ResourcesCheck::class));

    // Verify metric stored
    $this->assertDatabaseHas('server_resource_metrics', [
        'server_id' => $server->id,
    ]);

    // Verify server updated
    $server->refresh();
    expect($server->last_metrics_at)->not->toBeNull();
    expect($server->cpu_usage)->toBeGreaterThanOrEqual(0);

    // Verify broadcast
    Event::assertDispatched(ServerResourcesUpdated::class);
});

it('calculates server status correctly', function () {
    $server = Server::factory()->create();

    // Mock high CPU usage
    $metric = ServerResourceMetric::factory()->create([
        'server_id' => $server->id,
        'cpu_usage' => 95, // Critical
        'memory_usage' => 1000,
        'memory_total' => 4000,
        'disk_usage' => 10000,
        'disk_total' => 50000,
    ]);

    $job = new IndividualServerMonitoringJob($server);
    $status = $job->calculateServerStatus($metric);

    expect($status)->toBe('critical');

    $server->refresh();
    expect($server->resource_status)->toBe('critical');
});

it('triggers alerts for threshold violations', function () {
    Queue::fake();

    $server = Server::factory()->create();

    $metric = ServerResourceMetric::factory()->create([
        'server_id' => $server->id,
        'cpu_usage' => 95,
        'memory_usage' => 3800,
        'memory_total' => 4000,
        'disk_usage' => 45000,
        'disk_total' => 50000,
    ]);

    $job = new IndividualServerMonitoringJob($server);
    $job->handle(app(\App\Actions\Server\ResourcesCheck::class));

    Queue::assertPushed(\App\Jobs\Enterprise\ServerResourceAlertJob::class);
});
```

### Scheduler Tests

**File:** `tests/Feature/Scheduler/ResourceMonitoringSchedulerTest.php`

```php
<?php

use App\Jobs\Enterprise\ResourceMonitoringJob;
use Illuminate\Support\Facades\Queue;

it('schedules resource monitoring job every 30 seconds', function () {
    Queue::fake();

    // Run the scheduler
    $this->artisan('schedule:run')
        ->assertSuccessful();

    Queue::assertPushed(ResourceMonitoringJob::class);
});
```

### Artisan Command Tests

**File:** `tests/Feature/Commands/CollectServerResourcesTest.php`

```php
<?php

use App\Jobs\Enterprise\ResourceMonitoringJob;
use App\Models\Server;
use Illuminate\Support\Facades\Queue;

it('collects resources for all servers', function () {
    Queue::fake();

    Server::factory(3)->create(['status' => 'running']);

    $this->artisan('resources:collect')
        ->assertSuccessful()
        ->expectsOutput('✓ Resource collection job dispatched to queue');

    Queue::assertPushed(ResourceMonitoringJob::class, function ($job) {
        return $job->serverId === null;
    });
});

it('collects resources for specific server', function () {
    Queue::fake();

    $server = Server::factory()->create();

    $this->artisan('resources:collect', ['server' => $server->id])
        ->assertSuccessful()
        ->expectsOutput("Collecting resources for server {$server->id}...");

    Queue::assertPushed(ResourceMonitoringJob::class, function ($job) use ($server) {
        return $job->serverId === $server->id;
    });
});

it('runs synchronously with --sync flag', function () {
    $server = Server::factory()->create();

    $this->artisan('resources:collect', ['server' => $server->id, '--sync' => true])
        ->assertSuccessful()
        ->expectsOutput('✓ Resource collection completed');

    $this->assertDatabaseHas('server_resource_metrics', [
        'server_id' => $server->id,
    ]);
});
```

## Definition of Done

- [ ] ResourceMonitoringJob created implementing ShouldQueue
- [ ] Job dispatches to 'resource-monitoring' queue
- [ ] Queries all active servers excluding offline/deleted
- [ ] Implements chunking for large server counts (100 per batch)
- [ ] IndividualServerMonitoringJob created
- [ ] Integrates with ResourcesCheck action
- [ ] Stores metrics in server_resource_metrics table
- [ ] Updates server's latest metrics fields
- [ ] Calculates health status (healthy/warning/critical/error)
- [ ] Updates server's resource_status field
- [ ] ServerResourcesUpdated event created
- [ ] Event implements ShouldBroadcast interface
- [ ] Broadcasts to organization WebSocket channels
- [ ] Threshold checking implemented
- [ ] ServerResourceAlertJob dispatched for violations
- [ ] Cleanup of old metrics (30+ days) implemented
- [ ] Comprehensive error handling implemented
- [ ] Failed jobs logged with context
- [ ] Retry logic configured (2 retries, exponential backoff)
- [ ] Timeout configured (60 seconds per server job)
- [ ] Horizon tags implemented for filtering
- [ ] Performance metrics logged
- [ ] CollectServerResources Artisan command created
- [ ] Command supports optional server ID parameter
- [ ] Command has --sync flag for synchronous execution
- [ ] Scheduled to run every 30 seconds
- [ ] Scheduler configured with withoutOverlapping()
- [ ] Scheduler configured with onOneServer()
- [ ] Unit tests written (8+ tests, >90% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Scheduler test written
- [ ] Artisan command tests written (3+ tests)
- [ ] Documentation updated with usage examples
- [ ] Code follows Laravel Job best practices
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved
- [ ] Deployed to staging and verified
- [ ] Horizon monitoring configured
- [ ] Performance verified (< 60s per server)
- [ ] WebSocket broadcasting tested

## Related Tasks

- **Depends on:** Task 23 (ResourcesCheck action for metric collection)
- **Integrates with:** Server model for status updates
- **Integrates with:** ServerResourceMetric model for storage
- **Broadcasts to:** Organization WebSocket channels for live dashboards
- **Triggers:** ServerResourceAlertJob for threshold violations
- **Monitored by:** Laravel Horizon for queue management
