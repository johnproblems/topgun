---
name: Build StrategySelector.vue component for visual strategy selection
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:57Z
github: https://github.com/johnproblems/topgun/issues/149
depends_on: [32]
parallel: true
conflicts_with: []
---

# Task: Build StrategySelector.vue component for visual strategy selection

## Description

Create a comprehensive Vue.js 3 component that provides an intuitive, visual interface for selecting deployment strategies when deploying applications. This component serves as the strategic decision-making interface within the enhanced deployment pipeline, enabling users to choose between standard deployment, rolling updates, blue-green deployments, and canary releases with full understanding of each strategy's characteristics, benefits, and tradeoffs.

The StrategySelector transforms complex deployment engineering concepts into an accessible UI that non-technical users can understand while providing advanced configuration options for experienced DevOps engineers. It bridges the gap between Coolify's existing simple deployment mechanism and the new enterprise-grade deployment strategies introduced by the EnhancedDeploymentService.

**Core Functionality:**

1. **Visual Strategy Cards**: Display all available deployment strategies with visual diagrams showing how each strategy works
2. **Strategy Comparison**: Side-by-side comparison of downtime, rollback capability, resource requirements, and complexity
3. **Configuration Wizards**: Strategy-specific configuration forms with real-time validation and intelligent defaults
4. **Prerequisite Validation**: Automatic detection of whether requirements are met (e.g., sufficient capacity for blue-green)
5. **Risk Assessment**: Visual indicators showing deployment risk level based on application criticality and strategy choice
6. **Recommendation Engine**: Intelligent suggestions based on application type, traffic patterns, and available resources
7. **Preview Mode**: Visual simulation showing step-by-step how the deployment will proceed
8. **Historical Context**: Display past deployments with strategy performance metrics

**Strategy Types Supported:**

- **Standard Deployment**: Direct replacement (existing Coolify behavior)
- **Rolling Update**: Gradual instance replacement with configurable batch size
- **Blue-Green Deployment**: Parallel environment with traffic cutover
- **Canary Release**: Progressive traffic shifting with automated rollback

**Integration Architecture:**

**Parent Components:**
- **DeploymentManager.vue (Task 39)**: Embeds StrategySelector as the first step in deployment workflow
- **Application Detail Pages**: Provides strategy selection when triggering new deployments

**Backend Integration:**
- **EnhancedDeploymentService (Task 32)**: Receives strategy configuration from component
- **CapacityManager (Task 26)**: Validates resource availability for chosen strategy
- **TerraformService (Task 14)**: Provisions additional infrastructure if needed for blue-green/canary

**Event Flow:**
```
User opens deployment wizard ‚Üí StrategySelector renders available strategies
‚Üí User selects strategy ‚Üí Configuration form appears ‚Üí User configures parameters
‚Üí Prerequisite validation runs ‚Üí CapacityManager checks resources
‚Üí Risk assessment calculates deployment risk ‚Üí User confirms selection
‚Üí Component emits 'strategy-selected' event with full configuration
‚Üí DeploymentManager proceeds to deployment execution
```

**Why This Task is Critical:**

Deployment strategies are the differentiator between basic PaaS and enterprise-grade platforms. However, their complexity creates a UX barrier‚Äîmost users don't understand terms like "canary deployment" or "blue-green strategy." This component solves that problem by:

1. **Education through visualization**: Animated diagrams show exactly how each strategy works
2. **Risk transparency**: Clear indicators help users make informed decisions
3. **Guided configuration**: Intelligent defaults and validation prevent misconfiguration
4. **Confidence building**: Preview mode lets users understand the deployment before committing

Without this component, advanced deployment strategies would remain unused because users wouldn't understand them or know how to configure them correctly. StrategySelector makes enterprise deployment capabilities accessible to all users while maintaining the power that experienced engineers require.

## Acceptance Criteria

- [ ] Component displays 4 deployment strategy cards with visual diagrams
- [ ] Each strategy card shows: name, description, visual diagram, pros/cons, recommended use cases
- [ ] Strategy selection triggers strategy-specific configuration form
- [ ] Rolling update configuration: batch size (1-100%), health check timeout, inter-batch delay
- [ ] Blue-green configuration: environment naming, cutover validation, rollback window
- [ ] Canary configuration: initial traffic %, increment %, promotion threshold, metrics to monitor
- [ ] Real-time prerequisite validation (e.g., "Blue-green requires 2x capacity")
- [ ] Integration with CapacityManager to check resource availability
- [ ] Visual capacity indicator showing available vs. required resources
- [ ] Risk assessment calculator displaying deployment risk level (Low/Medium/High)
- [ ] Strategy recommendation engine suggesting optimal strategy based on application context
- [ ] Preview mode showing step-by-step deployment simulation
- [ ] Historical deployment data integration showing past strategy performance
- [ ] Responsive design working on desktop and tablet (mobile shows simplified view)
- [ ] Accessibility compliance (ARIA labels, keyboard navigation, screen reader support)
- [ ] Dark mode support matching Coolify's theme system
- [ ] Loading states while fetching capacity data
- [ ] Error handling for validation failures and API errors
- [ ] Help tooltips explaining technical terms

## Technical Details

### Component Location
- **File:** `resources/js/Components/Enterprise/Deployment/StrategySelector.vue`

### Component Structure

```vue
<script setup>
import { ref, computed, watch, onMounted } from 'vue'
import { useForm } from '@inertiajs/vue3'
import { usePage } from '@inertiajs/vue3'
import StrategyCard from './StrategyCard.vue'
import RollingUpdateConfig from './RollingUpdateConfig.vue'
import BlueGreenConfig from './BlueGreenConfig.vue'
import CanaryConfig from './CanaryConfig.vue'
import CapacityIndicator from './CapacityIndicator.vue'
import RiskAssessment from './RiskAssessment.vue'
import DeploymentPreview from './DeploymentPreview.vue'

const props = defineProps({
  application: {
    type: Object,
    required: true,
  },
  servers: {
    type: Array,
    default: () => [],
  },
  currentDeployment: {
    type: Object,
    default: null,
  },
  historicalDeployments: {
    type: Array,
    default: () => [],
  },
  availableCapacity: {
    type: Object,
    default: null,
  },
})

const emit = defineEmits(['strategy-selected', 'cancel'])

// State
const selectedStrategy = ref(null)
const showPreview = ref(false)
const loadingCapacity = ref(false)
const capacityData = ref(props.availableCapacity)

// Deployment strategies definition
const strategies = [
  {
    id: 'standard',
    name: 'Standard Deployment',
    icon: 'üöÄ',
    color: 'blue',
    description: 'Direct replacement of the current version with the new version',
    diagram: 'standard-deployment-diagram',
    downtime: '5-30 seconds',
    complexity: 'Low',
    resourceMultiplier: 1,
    rollbackCapability: 'Manual (slow)',
    pros: [
      'Simple and fast',
      'Minimal resource requirements',
      'Works with single server',
      'No additional configuration needed',
    ],
    cons: [
      'Brief downtime during deployment',
      'All users affected simultaneously',
      'Rollback requires redeployment',
      'Higher risk for critical applications',
    ],
    useCases: [
      'Development and staging environments',
      'Low-traffic applications',
      'Scheduled maintenance windows',
      'Non-critical services',
    ],
    prerequisites: [],
    recommendedFor: ['dev', 'staging', 'low-traffic'],
  },
  {
    id: 'rolling',
    name: 'Rolling Update',
    icon: 'üîÑ',
    color: 'green',
    description: 'Gradual replacement of instances in batches to minimize downtime',
    diagram: 'rolling-deployment-diagram',
    downtime: 'None (zero-downtime)',
    complexity: 'Medium',
    resourceMultiplier: 1,
    rollbackCapability: 'Automatic on failure',
    pros: [
      'Zero-downtime deployment',
      'Gradual rollout reduces risk',
      'Automatic rollback on health check failures',
      'No additional infrastructure required',
    ],
    cons: [
      'Mixed versions running simultaneously',
      'Slower than standard deployment',
      'Requires multiple instances',
      'Database migrations need careful planning',
    ],
    useCases: [
      'Production applications with multiple instances',
      'APIs and microservices',
      'Applications with frequent updates',
      'Services requiring high availability',
    ],
    prerequisites: [
      'At least 2 application instances',
      'Health check endpoint configured',
      'Backward-compatible changes',
    ],
    recommendedFor: ['production', 'high-availability', 'apis'],
  },
  {
    id: 'blue-green',
    name: 'Blue-Green Deployment',
    icon: 'üîµüü¢',
    color: 'purple',
    description: 'Deploy to parallel environment and switch traffic instantly',
    diagram: 'blue-green-deployment-diagram',
    downtime: 'None (instant cutover)',
    complexity: 'High',
    resourceMultiplier: 2,
    rollbackCapability: 'Instant (traffic switch)',
    pros: [
      'Zero-downtime deployment',
      'Instant rollback capability',
      'Full testing before production traffic',
      'No version mixing issues',
    ],
    cons: [
      'Requires double the infrastructure',
      'Database synchronization challenges',
      'More complex configuration',
      'Higher resource costs',
    ],
    useCases: [
      'Mission-critical applications',
      'Large deployments requiring extensive testing',
      'Applications with complex state management',
      'Regulatory compliance requirements',
    ],
    prerequisites: [
      'Capacity for 2x current infrastructure',
      'Load balancer or reverse proxy',
      'Database migration strategy',
      'Monitoring and validation scripts',
    ],
    recommendedFor: ['critical', 'large-scale', 'regulated'],
  },
  {
    id: 'canary',
    name: 'Canary Release',
    icon: 'üê§',
    color: 'yellow',
    description: 'Progressive traffic shifting with automated monitoring and rollback',
    diagram: 'canary-deployment-diagram',
    downtime: 'None (gradual shift)',
    complexity: 'Very High',
    resourceMultiplier: 1.2,
    rollbackCapability: 'Automatic based on metrics',
    pros: [
      'Risk mitigation through gradual rollout',
      'Real-world testing with production traffic',
      'Automatic rollback on metric degradation',
      'Fine-grained control over traffic distribution',
    ],
    cons: [
      'Complex monitoring requirements',
      'Requires metric-based decision making',
      'Slower full rollout',
      'May require feature flags',
    ],
    useCases: [
      'High-risk feature releases',
      'Performance-sensitive applications',
      'A/B testing scenarios',
      'Applications with mature monitoring',
    ],
    prerequisites: [
      'Advanced metrics and monitoring',
      'Traffic routing capability (load balancer)',
      'Automated health checks',
      'Rollback automation configured',
    ],
    recommendedFor: ['high-risk', 'performance-critical', 'mature-monitoring'],
  },
]

// Strategy configuration forms state
const rollingConfig = ref({
  batchSize: 25, // Percentage
  healthCheckTimeout: 60, // Seconds
  interBatchDelay: 30, // Seconds
  maxUnavailable: 1, // Number of instances
})

const blueGreenConfig = ref({
  environmentName: 'green',
  cutoverValidationScript: '',
  rollbackWindow: 3600, // Seconds (1 hour)
  warmupDuration: 300, // Seconds (5 minutes)
  runSmokeTests: true,
})

const canaryConfig = ref({
  initialTrafficPercent: 5,
  incrementPercent: 10,
  incrementInterval: 600, // Seconds (10 minutes)
  promotionThreshold: 90, // Percent
  metricsToMonitor: ['error_rate', 'response_time', 'cpu_usage'],
  errorRateThreshold: 1, // Percentage
  responseTimeThreshold: 500, // Milliseconds
  autoPromote: true,
  autoRollback: true,
})

// Computed properties
const currentStrategy = computed(() => {
  return strategies.find(s => s.id === selectedStrategy.value)
})

const prerequisitesMet = computed(() => {
  if (!currentStrategy.value) return true

  const strategy = currentStrategy.value
  const results = {}

  if (strategy.id === 'rolling') {
    results.multipleInstances = props.servers.length >= 2
    results.healthCheckConfigured = props.application.health_check_url !== null
  }

  if (strategy.id === 'blue-green') {
    results.sufficientCapacity = capacityData.value?.canDoubleCapacity || false
    results.loadBalancerConfigured = props.application.proxy_type !== null
  }

  if (strategy.id === 'canary') {
    results.metricsConfigured = props.application.metrics_enabled || false
    results.trafficRoutingCapable = props.application.proxy_type !== null
    results.monitoringIntegrated = props.application.monitoring_provider !== null
  }

  return Object.values(results).every(Boolean)
})

const deploymentRisk = computed(() => {
  if (!selectedStrategy.value) return 'unknown'

  const strategy = currentStrategy.value
  const appCriticality = props.application.criticality || 'medium' // low, medium, high

  const riskMatrix = {
    standard: { low: 'low', medium: 'medium', high: 'high' },
    rolling: { low: 'low', medium: 'low', high: 'medium' },
    'blue-green': { low: 'low', medium: 'low', high: 'low' },
    canary: { low: 'low', medium: 'low', high: 'low' },
  }

  return riskMatrix[strategy.id]?.[appCriticality] || 'medium'
})

const recommendedStrategy = computed(() => {
  const appType = props.application.type // 'web', 'api', 'worker', etc.
  const environment = props.application.environment // 'development', 'staging', 'production'
  const traffic = props.application.estimated_traffic || 'low' // 'low', 'medium', 'high'

  // Recommendation logic
  if (environment === 'development' || environment === 'staging') {
    return 'standard'
  }

  if (environment === 'production') {
    if (props.application.criticality === 'high' && capacityData.value?.canDoubleCapacity) {
      return 'blue-green'
    }

    if (props.application.metrics_enabled && appType === 'api') {
      return 'canary'
    }

    if (props.servers.length >= 2) {
      return 'rolling'
    }
  }

  return 'standard'
})

const canProceed = computed(() => {
  return selectedStrategy.value && prerequisitesMet.value
})

// Methods
const selectStrategy = (strategyId) => {
  selectedStrategy.value = strategyId

  // Fetch capacity data if needed for resource-heavy strategies
  if (['blue-green', 'canary'].includes(strategyId) && !capacityData.value) {
    fetchCapacityData()
  }
}

const fetchCapacityData = async () => {
  loadingCapacity.value = true

  try {
    const response = await axios.get(route('api.capacity.check', {
      application: props.application.id,
      strategy: selectedStrategy.value,
    }))

    capacityData.value = response.data
  } catch (error) {
    console.error('Failed to fetch capacity data:', error)
  } finally {
    loadingCapacity.value = false
  }
}

const confirmStrategy = () => {
  const strategyConfig = {
    strategy: selectedStrategy.value,
    config: getStrategyConfig(),
  }

  emit('strategy-selected', strategyConfig)
}

const getStrategyConfig = () => {
  switch (selectedStrategy.value) {
    case 'rolling':
      return { ...rollingConfig.value }
    case 'blue-green':
      return { ...blueGreenConfig.value }
    case 'canary':
      return { ...canaryConfig.value }
    default:
      return {}
  }
}

const togglePreview = () => {
  showPreview.value = !showPreview.value
}

const cancel = () => {
  emit('cancel')
}

// Lifecycle
onMounted(() => {
  // Pre-select recommended strategy
  if (recommendedStrategy.value) {
    selectStrategy(recommendedStrategy.value)
  }
})
</script>

<template>
  <div class="strategy-selector">
    <!-- Header -->
    <div class="header">
      <div>
        <h2 class="text-2xl font-bold">Select Deployment Strategy</h2>
        <p class="text-gray-600 dark:text-gray-400 mt-1">
          Choose how to deploy {{ application.name }}
        </p>
      </div>

      <div v-if="selectedStrategy" class="header-actions">
        <button
          type="button"
          class="btn btn-secondary"
          @click="togglePreview"
        >
          {{ showPreview ? 'Hide' : 'Show' }} Preview
        </button>
      </div>
    </div>

    <!-- Recommendation Banner -->
    <div v-if="recommendedStrategy && !selectedStrategy" class="recommendation-banner">
      <div class="recommendation-icon">üí°</div>
      <div class="recommendation-content">
        <h3 class="font-semibold">Recommended Strategy</h3>
        <p>
          Based on your application type and environment, we recommend
          <strong>{{ strategies.find(s => s.id === recommendedStrategy)?.name }}</strong>.
        </p>
      </div>
      <button
        class="btn btn-primary btn-sm"
        @click="selectStrategy(recommendedStrategy)"
      >
        Use Recommended
      </button>
    </div>

    <!-- Strategy Cards Grid -->
    <div v-if="!selectedStrategy" class="strategies-grid">
      <StrategyCard
        v-for="strategy in strategies"
        :key="strategy.id"
        :strategy="strategy"
        :is-recommended="strategy.id === recommendedStrategy"
        :application="application"
        @select="selectStrategy(strategy.id)"
      />
    </div>

    <!-- Selected Strategy Configuration -->
    <div v-else class="strategy-configuration">
      <!-- Strategy Summary -->
      <div class="strategy-summary">
        <div class="strategy-header">
          <div class="strategy-icon" :class="`bg-${currentStrategy.color}-100`">
            {{ currentStrategy.icon }}
          </div>
          <div>
            <h3 class="text-xl font-semibold">{{ currentStrategy.name }}</h3>
            <p class="text-gray-600 dark:text-gray-400">
              {{ currentStrategy.description }}
            </p>
          </div>
          <button
            type="button"
            class="btn btn-secondary btn-sm ml-auto"
            @click="selectedStrategy = null"
          >
            Change Strategy
          </button>
        </div>

        <!-- Key Metrics -->
        <div class="metrics-grid">
          <div class="metric">
            <div class="metric-label">Downtime</div>
            <div class="metric-value">{{ currentStrategy.downtime }}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Complexity</div>
            <div class="metric-value">{{ currentStrategy.complexity }}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Rollback</div>
            <div class="metric-value">{{ currentStrategy.rollbackCapability }}</div>
          </div>
          <div class="metric">
            <div class="metric-label">Resources</div>
            <div class="metric-value">{{ currentStrategy.resourceMultiplier }}x</div>
          </div>
        </div>
      </div>

      <!-- Prerequisites Check -->
      <div v-if="currentStrategy.prerequisites.length > 0" class="prerequisites-section">
        <h4 class="text-md font-semibold mb-3">Prerequisites</h4>

        <div class="prerequisites-list">
          <div
            v-for="(prereq, index) in currentStrategy.prerequisites"
            :key="index"
            class="prerequisite-item"
            :class="{ 'prerequisite-met': prerequisitesMet }"
          >
            <div class="prerequisite-icon">
              {{ prerequisitesMet ? '‚úÖ' : '‚ö†Ô∏è' }}
            </div>
            <div class="prerequisite-text">{{ prereq }}</div>
          </div>
        </div>

        <div v-if="!prerequisitesMet" class="alert alert-warning">
          <strong>Prerequisites not met.</strong> Please ensure all requirements are satisfied before proceeding.
        </div>
      </div>

      <!-- Capacity Indicator -->
      <CapacityIndicator
        v-if="['blue-green', 'canary'].includes(selectedStrategy)"
        :application="application"
        :strategy="currentStrategy"
        :capacity-data="capacityData"
        :loading="loadingCapacity"
      />

      <!-- Risk Assessment -->
      <RiskAssessment
        :application="application"
        :strategy="currentStrategy"
        :risk-level="deploymentRisk"
        :historical-deployments="historicalDeployments"
      />

      <!-- Strategy-Specific Configuration -->
      <div class="configuration-section">
        <h4 class="text-md font-semibold mb-3">Configuration</h4>

        <!-- Rolling Update Config -->
        <RollingUpdateConfig
          v-if="selectedStrategy === 'rolling'"
          v-model="rollingConfig"
          :servers="servers"
          :application="application"
        />

        <!-- Blue-Green Config -->
        <BlueGreenConfig
          v-if="selectedStrategy === 'blue-green'"
          v-model="blueGreenConfig"
          :application="application"
          :capacity-data="capacityData"
        />

        <!-- Canary Config -->
        <CanaryConfig
          v-if="selectedStrategy === 'canary'"
          v-model="canaryConfig"
          :application="application"
        />
      </div>

      <!-- Deployment Preview -->
      <DeploymentPreview
        v-if="showPreview"
        :strategy="currentStrategy"
        :config="getStrategyConfig()"
        :application="application"
        :servers="servers"
      />

      <!-- Actions -->
      <div class="actions">
        <button
          type="button"
          class="btn btn-secondary"
          @click="cancel"
        >
          Cancel
        </button>

        <button
          type="button"
          class="btn btn-primary"
          :disabled="!canProceed"
          @click="confirmStrategy"
        >
          <span v-if="!canProceed">Prerequisites Not Met</span>
          <span v-else>Proceed with {{ currentStrategy.name }}</span>
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.strategy-selector {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 2rem;
}

.header-actions {
  display: flex;
  gap: 0.5rem;
}

.recommendation-banner {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem 1.5rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 0.5rem;
  margin-bottom: 2rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.recommendation-icon {
  font-size: 2rem;
}

.recommendation-content {
  flex: 1;
}

.recommendation-content h3 {
  margin-bottom: 0.25rem;
}

.recommendation-content p {
  margin: 0;
  opacity: 0.95;
}

.strategies-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.strategy-configuration {
  max-width: 900px;
  margin: 0 auto;
}

.strategy-summary {
  background: white;
  dark:bg-gray-800;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.strategy-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.strategy-icon {
  width: 4rem;
  height: 4rem;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  border-radius: 0.5rem;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
}

.metric {
  text-align: center;
  padding: 1rem;
  background: #f9fafb;
  dark:bg-gray-700;
  border-radius: 0.375rem;
}

.metric-label {
  font-size: 0.875rem;
  color: #6b7280;
  dark:color-gray-400;
  margin-bottom: 0.5rem;
}

.metric-value {
  font-size: 1.125rem;
  font-weight: 600;
  color: #1f2937;
  dark:color-white;
}

.prerequisites-section {
  background: white;
  dark:bg-gray-800;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.prerequisites-list {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 1rem;
}

.prerequisite-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem;
  background: #fef3c7;
  dark:bg-yellow-900;
  border-radius: 0.375rem;
}

.prerequisite-item.prerequisite-met {
  background: #d1fae5;
  dark:bg-green-900;
}

.prerequisite-icon {
  font-size: 1.25rem;
}

.prerequisite-text {
  flex: 1;
}

.configuration-section {
  background: white;
  dark:bg-gray-800;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  padding-top: 1.5rem;
  border-top: 1px solid #e5e7eb;
}

.alert {
  padding: 1rem;
  border-radius: 0.375rem;
  margin-top: 1rem;
}

.alert-warning {
  background: #fef3c7;
  color: #92400e;
  border: 1px solid #fbbf24;
}

@media (max-width: 768px) {
  .strategies-grid {
    grid-template-columns: 1fr;
  }

  .metrics-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .recommendation-banner {
    flex-direction: column;
    text-align: center;
  }
}
</style>
```

### Child Component: StrategyCard.vue

**File:** `resources/js/Components/Enterprise/Deployment/StrategyCard.vue`

```vue
<script setup>
import { computed } from 'vue'

const props = defineProps({
  strategy: {
    type: Object,
    required: true,
  },
  isRecommended: {
    type: Boolean,
    default: false,
  },
  application: {
    type: Object,
    required: true,
  },
})

const emit = defineEmits(['select'])

const selectStrategy = () => {
  emit('select')
}
</script>

<template>
  <div
    class="strategy-card"
    :class="{ 'strategy-card--recommended': isRecommended }"
    @click="selectStrategy"
  >
    <div v-if="isRecommended" class="recommended-badge">
      ‚≠ê Recommended
    </div>

    <div class="strategy-card-header">
      <div class="strategy-card-icon" :class="`bg-${strategy.color}-100`">
        {{ strategy.icon }}
      </div>
      <h3 class="strategy-card-title">{{ strategy.name }}</h3>
    </div>

    <p class="strategy-card-description">
      {{ strategy.description }}
    </p>

    <div class="strategy-card-diagram">
      <!-- Placeholder for actual diagram component -->
      <img
        :src="`/images/deployment-diagrams/${strategy.diagram}.svg`"
        :alt="`${strategy.name} diagram`"
        class="diagram-image"
      />
    </div>

    <div class="strategy-card-metrics">
      <div class="metric-item">
        <span class="metric-label">Downtime:</span>
        <span class="metric-value">{{ strategy.downtime }}</span>
      </div>
      <div class="metric-item">
        <span class="metric-label">Complexity:</span>
        <span class="metric-value">{{ strategy.complexity }}</span>
      </div>
    </div>

    <div class="strategy-card-footer">
      <button class="btn btn-primary w-full">
        Select Strategy
      </button>
    </div>
  </div>
</template>

<style scoped>
.strategy-card {
  background: white;
  dark:bg-gray-800;
  border: 2px solid #e5e7eb;
  border-radius: 0.75rem;
  padding: 1.5rem;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.strategy-card:hover {
  border-color: #3b82f6;
  box-shadow: 0 8px 16px rgba(59, 130, 246, 0.1);
  transform: translateY(-4px);
}

.strategy-card--recommended {
  border-color: #8b5cf6;
  background: linear-gradient(135deg, #ffffff 0%, #f5f3ff 100%);
}

.recommended-badge {
  position: absolute;
  top: -12px;
  right: 1rem;
  background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 1rem;
  font-size: 0.75rem;
  font-weight: 600;
  box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
}

.strategy-card-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 1rem;
}

.strategy-card-icon {
  width: 4rem;
  height: 4rem;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  border-radius: 0.75rem;
  margin-bottom: 0.75rem;
}

.strategy-card-title {
  font-size: 1.25rem;
  font-weight: 600;
  text-align: center;
  margin: 0;
}

.strategy-card-description {
  text-align: center;
  color: #6b7280;
  dark:color-gray-400;
  margin-bottom: 1rem;
  min-height: 3rem;
}

.strategy-card-diagram {
  background: #f9fafb;
  dark:bg-gray-700;
  border-radius: 0.5rem;
  padding: 1rem;
  margin-bottom: 1rem;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.diagram-image {
  max-width: 100%;
  height: auto;
}

.strategy-card-metrics {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 1rem;
  background: #f9fafb;
  dark:bg-gray-700;
  border-radius: 0.5rem;
}

.metric-item {
  display: flex;
  justify-content: space-between;
  font-size: 0.875rem;
}

.metric-label {
  color: #6b7280;
  dark:color-gray-400;
}

.metric-value {
  font-weight: 600;
  color: #1f2937;
  dark:color-white;
}

.strategy-card-footer {
  margin-top: auto;
}
</style>
```

### Child Component: RollingUpdateConfig.vue

**File:** `resources/js/Components/Enterprise/Deployment/RollingUpdateConfig.vue`

```vue
<script setup>
import { computed } from 'vue'

const props = defineProps({
  modelValue: {
    type: Object,
    required: true,
  },
  servers: {
    type: Array,
    default: () => [],
  },
  application: {
    type: Object,
    required: true,
  },
})

const emit = defineEmits(['update:modelValue'])

const config = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
})

const updateBatchSize = (value) => {
  config.value = { ...config.value, batchSize: parseInt(value) }
}

const updateHealthCheckTimeout = (value) => {
  config.value = { ...config.value, healthCheckTimeout: parseInt(value) }
}

const updateInterBatchDelay = (value) => {
  config.value = { ...config.value, interBatchDelay: parseInt(value) }
}

const estimatedDuration = computed(() => {
  const numServers = props.servers.length
  const batchSize = config.value.batchSize / 100
  const numBatches = Math.ceil(1 / batchSize)
  const deploymentTimePerBatch = 60 // seconds
  const totalDelay = config.value.interBatchDelay * (numBatches - 1)
  const totalDeployment = deploymentTimePerBatch * numBatches

  return Math.ceil((totalDeployment + totalDelay) / 60) // minutes
})
</script>

<template>
  <div class="rolling-update-config">
    <!-- Batch Size -->
    <div class="form-group">
      <label class="form-label">
        Batch Size
        <span class="help-tooltip" title="Percentage of instances to update simultaneously">‚ÑπÔ∏è</span>
      </label>
      <div class="range-input-group">
        <input
          type="range"
          min="10"
          max="100"
          step="5"
          :value="config.batchSize"
          @input="updateBatchSize($event.target.value)"
          class="range-input"
        />
        <span class="range-value">{{ config.batchSize }}%</span>
      </div>
      <p class="form-help">
        Update {{ Math.ceil(servers.length * (config.batchSize / 100)) }} of {{ servers.length }} instances per batch
      </p>
    </div>

    <!-- Health Check Timeout -->
    <div class="form-group">
      <label class="form-label">
        Health Check Timeout
        <span class="help-tooltip" title="Maximum time to wait for instance to become healthy">‚ÑπÔ∏è</span>
      </label>
      <div class="input-group">
        <input
          type="number"
          min="30"
          max="300"
          step="10"
          :value="config.healthCheckTimeout"
          @input="updateHealthCheckTimeout($event.target.value)"
          class="form-input"
        />
        <span class="input-suffix">seconds</span>
      </div>
      <p class="form-help">
        Wait up to {{ config.healthCheckTimeout }}s for each instance to pass health checks
      </p>
    </div>

    <!-- Inter-Batch Delay -->
    <div class="form-group">
      <label class="form-label">
        Inter-Batch Delay
        <span class="help-tooltip" title="Wait time between batch updates">‚ÑπÔ∏è</span>
      </label>
      <div class="input-group">
        <input
          type="number"
          min="0"
          max="300"
          step="10"
          :value="config.interBatchDelay"
          @input="updateInterBatchDelay($event.target.value)"
          class="form-input"
        />
        <span class="input-suffix">seconds</span>
      </div>
      <p class="form-help">
        Pause for {{ config.interBatchDelay }}s between batches to observe stability
      </p>
    </div>

    <!-- Estimated Duration -->
    <div class="estimation-box">
      <div class="estimation-icon">‚è±Ô∏è</div>
      <div>
        <div class="estimation-label">Estimated Deployment Time</div>
        <div class="estimation-value">~{{ estimatedDuration }} minutes</div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.rolling-update-config {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.form-label {
  font-weight: 600;
  color: #1f2937;
  dark:color-white;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.help-tooltip {
  cursor: help;
  font-size: 0.875rem;
}

.range-input-group {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.range-input {
  flex: 1;
}

.range-value {
  font-weight: 600;
  min-width: 4rem;
  text-align: right;
}

.input-group {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.form-input {
  flex: 1;
  padding: 0.5rem 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
}

.input-suffix {
  color: #6b7280;
  dark:color-gray-400;
  font-size: 0.875rem;
}

.form-help {
  font-size: 0.875rem;
  color: #6b7280;
  dark:color-gray-400;
  margin: 0;
}

.estimation-box {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%);
  dark:bg-gradient-to-r;
  dark:from-blue-900;
  dark:to-purple-900;
  border-radius: 0.5rem;
  margin-top: 0.5rem;
}

.estimation-icon {
  font-size: 2rem;
}

.estimation-label {
  font-size: 0.875rem;
  color: #6b7280;
  dark:color-gray-300;
}

.estimation-value {
  font-size: 1.25rem;
  font-weight: 700;
  color: #1f2937;
  dark:color-white;
}
</style>
```

## Implementation Approach

### Step 1: Create Component Structure
1. Create `StrategySelector.vue` in `resources/js/Components/Enterprise/Deployment/`
2. Set up Vue 3 Composition API with props and emits
3. Define strategies array with complete metadata
4. Implement state management for selection and configuration

### Step 2: Build Strategy Cards
1. Create `StrategyCard.vue` child component
2. Design visual card layout with icon, description, diagrams
3. Add recommended badge for intelligent suggestions
4. Implement hover effects and selection interaction

### Step 3: Implement Strategy Configuration Forms
1. Create `RollingUpdateConfig.vue` with batch size, health check settings
2. Create `BlueGreenConfig.vue` with cutover validation, warmup duration
3. Create `CanaryConfig.vue` with traffic percentages, metrics thresholds
4. Add real-time validation and intelligent defaults

### Step 4: Build Capacity Integration
1. Create `CapacityIndicator.vue` component
2. Integrate with backend API route for capacity checking
3. Display available vs. required resources visually
4. Show warnings if capacity insufficient

### Step 5: Implement Risk Assessment
1. Create `RiskAssessment.vue` component
2. Build risk calculation algorithm based on strategy + app criticality
3. Display visual risk level indicator (Low/Medium/High)
4. Show historical deployment success rates

### Step 6: Add Deployment Preview
1. Create `DeploymentPreview.vue` component
2. Build step-by-step visualization of deployment process
3. Show timeline with estimated duration for each phase
4. Animate transitions between deployment stages

### Step 7: Implement Recommendation Engine
1. Build logic to analyze application context
2. Calculate recommended strategy based on:
   - Application type (web, API, worker)
   - Environment (dev, staging, production)
   - Traffic patterns and criticality
   - Available infrastructure
3. Display recommendation banner

### Step 8: Add Prerequisite Validation
1. Implement prerequisite checking logic
2. Display prerequisite status (met/not met) visually
3. Disable "Proceed" button if prerequisites not satisfied
4. Provide actionable guidance for missing prerequisites

### Step 9: Integrate with Backend
1. Create API route for capacity checking: `GET /api/capacity/check`
2. Create API endpoint for historical deployment data
3. Implement event emission to parent component
4. Handle loading states and error scenarios

### Step 10: Polish and Test
1. Add responsive design for tablet and mobile
2. Implement dark mode support
3. Add keyboard navigation
4. Write comprehensive unit and integration tests

## Test Strategy

### Unit Tests (Vitest)

**File:** `resources/js/Components/Enterprise/Deployment/__tests__/StrategySelector.spec.js`

```javascript
import { mount } from '@vue/test-utils'
import { describe, it, expect, vi } from 'vitest'
import StrategySelector from '../StrategySelector.vue'

describe('StrategySelector.vue', () => {
  const mockApplication = {
    id: 1,
    name: 'Test App',
    type: 'web',
    environment: 'production',
    criticality: 'high',
    health_check_url: '/health',
  }

  const mockServers = [
    { id: 1, name: 'Server 1' },
    { id: 2, name: 'Server 2' },
  ]

  it('renders all 4 deployment strategies', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    expect(wrapper.text()).toContain('Standard Deployment')
    expect(wrapper.text()).toContain('Rolling Update')
    expect(wrapper.text()).toContain('Blue-Green Deployment')
    expect(wrapper.text()).toContain('Canary Release')
  })

  it('shows recommendation banner for production apps', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    expect(wrapper.find('.recommendation-banner').exists()).toBe(true)
    expect(wrapper.text()).toContain('Recommended Strategy')
  })

  it('selects strategy and displays configuration form', async () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    // Click on rolling update strategy
    await wrapper.vm.selectStrategy('rolling')

    expect(wrapper.vm.selectedStrategy).toBe('rolling')
    expect(wrapper.find('.strategy-configuration').exists()).toBe(true)
  })

  it('validates prerequisites for rolling update', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    wrapper.vm.selectStrategy('rolling')

    // Rolling update requires 2+ servers and health check - both met
    expect(wrapper.vm.prerequisitesMet).toBe(true)
  })

  it('disables proceed button when prerequisites not met', async () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: { ...mockApplication, health_check_url: null },
        servers: [{ id: 1, name: 'Server 1' }], // Only 1 server
      }
    })

    await wrapper.vm.selectStrategy('rolling')

    expect(wrapper.vm.prerequisitesMet).toBe(false)
    expect(wrapper.vm.canProceed).toBe(false)
  })

  it('calculates deployment risk correctly', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: { ...mockApplication, criticality: 'high' },
        servers: mockServers,
      }
    })

    wrapper.vm.selectStrategy('standard')
    expect(wrapper.vm.deploymentRisk).toBe('high')

    wrapper.vm.selectStrategy('blue-green')
    expect(wrapper.vm.deploymentRisk).toBe('low')
  })

  it('emits strategy-selected event with configuration', async () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    await wrapper.vm.selectStrategy('rolling')
    await wrapper.vm.confirmStrategy()

    expect(wrapper.emitted('strategy-selected')).toBeTruthy()
    const emittedData = wrapper.emitted('strategy-selected')[0][0]
    expect(emittedData.strategy).toBe('rolling')
    expect(emittedData.config).toHaveProperty('batchSize')
  })

  it('recommends blue-green for critical high-capacity apps', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: { ...mockApplication, criticality: 'high' },
        servers: mockServers,
        availableCapacity: { canDoubleCapacity: true },
      }
    })

    expect(wrapper.vm.recommendedStrategy).toBe('blue-green')
  })

  it('recommends standard for development environment', () => {
    const wrapper = mount(StrategySelector, {
      props: {
        application: { ...mockApplication, environment: 'development' },
        servers: mockServers,
      }
    })

    expect(wrapper.vm.recommendedStrategy).toBe('standard')
  })

  it('fetches capacity data when selecting resource-heavy strategy', async () => {
    const mockAxios = vi.spyOn(window.axios, 'get').mockResolvedValue({
      data: { canDoubleCapacity: true, availableCPU: 80 },
    })

    const wrapper = mount(StrategySelector, {
      props: {
        application: mockApplication,
        servers: mockServers,
      }
    })

    await wrapper.vm.selectStrategy('blue-green')

    expect(mockAxios).toHaveBeenCalledWith(
      expect.stringContaining('/api/capacity/check')
    )
  })
})
```

### Integration Tests (Pest - Backend API)

**File:** `tests/Feature/Enterprise/DeploymentStrategySelectionTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Server;
use App\Models\User;
use App\Models\Organization;

it('provides capacity check API for strategy selection', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $servers = Server::factory(3)->create([
        'organization_id' => $organization->id,
    ]);

    $this->actingAs($user)
        ->get(route('api.capacity.check', [
            'application' => $application->id,
            'strategy' => 'blue-green',
        ]))
        ->assertOk()
        ->assertJsonStructure([
            'canDoubleCapacity',
            'availableCPU',
            'availableMemory',
            'requiredCPU',
            'requiredMemory',
        ]);
});

it('returns historical deployment data for risk assessment', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    // Create some historical deployments
    \App\Models\Deployment::factory(5)->create([
        'application_id' => $application->id,
        'deployment_strategy' => 'rolling',
        'status' => 'success',
    ]);

    $this->actingAs($user)
        ->get(route('api.deployments.history', [
            'application' => $application->id,
        ]))
        ->assertOk()
        ->assertJsonCount(5, 'data');
});
```

### Browser Tests (Dusk)

**File:** `tests/Browser/Enterprise/StrategySelectionTest.php`

```php
<?php

use Laravel\Dusk\Browser;

it('allows visual strategy selection workflow', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/applications/1/deploy')
            ->waitFor('.strategy-selector')

            // See all 4 strategies
            ->assertSee('Standard Deployment')
            ->assertSee('Rolling Update')
            ->assertSee('Blue-Green Deployment')
            ->assertSee('Canary Release')

            // See recommendation
            ->assertSee('Recommended Strategy')

            // Select rolling update
            ->click('@strategy-card-rolling')
            ->waitFor('.strategy-configuration')

            // Configure batch size
            ->drag('@batch-size-slider', 50, 0)
            ->assertInputValue('@batch-size-value', '50')

            // See estimated duration
            ->assertSee('Estimated Deployment Time')

            // Proceed with deployment
            ->click('@proceed-button')
            ->waitForText('Deployment started');
    });
});

it('prevents proceeding when prerequisites not met', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/applications/1/deploy')
            ->click('@strategy-card-blue-green')
            ->waitFor('.prerequisites-section')
            ->assertSee('Prerequisites not met')
            ->assertDisabled('@proceed-button');
    });
});
```

## Definition of Done

- [ ] StrategySelector.vue component created with Composition API
- [ ] 4 deployment strategies displayed with visual cards
- [ ] Each strategy card shows icon, description, diagram, pros/cons, use cases
- [ ] Strategy selection triggers configuration form
- [ ] RollingUpdateConfig.vue with batch size, health check, delay configuration
- [ ] BlueGreenConfig.vue with cutover validation and warmup settings
- [ ] CanaryConfig.vue with traffic percentages and metrics configuration
- [ ] StrategyCard.vue child component for individual strategy cards
- [ ] CapacityIndicator.vue for resource availability visualization
- [ ] RiskAssessment.vue for deployment risk display
- [ ] DeploymentPreview.vue for step-by-step simulation
- [ ] Prerequisite validation logic implemented
- [ ] Integration with backend capacity check API
- [ ] Integration with historical deployment data API
- [ ] Recommendation engine suggesting optimal strategy
- [ ] Risk calculation based on strategy and application criticality
- [ ] Event emission to parent component with complete configuration
- [ ] Responsive design for desktop, tablet, mobile
- [ ] Dark mode support
- [ ] Accessibility compliance (ARIA labels, keyboard navigation)
- [ ] Unit tests written and passing (15+ tests, >90% coverage)
- [ ] Integration tests for backend API routes (5+ tests)
- [ ] Browser test for full selection workflow
- [ ] Documentation updated with usage examples
- [ ] Code reviewed and approved
- [ ] No console errors or warnings

## Related Tasks

- **Depends on:** Task 32 (EnhancedDeploymentService backend implementation)
- **Integrates with:** Task 39 (DeploymentManager.vue parent component)
- **Uses:** Task 26 (CapacityManager for resource validation)
- **Uses:** Task 14 (TerraformService for infrastructure provisioning)
- **Displays:** Historical deployment data from database
