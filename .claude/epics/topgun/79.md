---
name: Write Dusk browser tests for Vue.js components
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:30Z
github: https://github.com/johnproblems/topgun/issues/186
depends_on: [76]
parallel: false
conflicts_with: []
---

# Task: Write Dusk browser tests for Vue.js components

## Description

Create comprehensive **Laravel Dusk browser tests** for all Vue.js 3 enterprise components built during the Coolify Enterprise Transformation. Dusk provides end-to-end testing by automating real browser interactions using Chrome/Chromium, ensuring that complex Vue.js UI components (with Inertia.js integration, WebSocket updates, and dynamic interactions) function correctly from the user's perspective.

This task is the **final validation layer** in the testing pyramid for enterprise features—after unit tests verify business logic and integration tests validate API contracts, **Dusk tests confirm that real users can successfully complete critical workflows** through the actual UI. This includes:

1. **White-Label Branding Components**: Logo uploads, color pickers, live preview updates
2. **Infrastructure Management**: Terraform provisioning wizards, cloud provider credential forms
3. **Resource Monitoring Dashboards**: Real-time charts, WebSocket data updates, capacity visualization
4. **Deployment Management**: Strategy selection, deployment progress monitoring
5. **Payment Processing**: Subscription management, payment method forms, billing dashboards
6. **API Management**: Token creation, usage monitoring, rate limit visualization
7. **Domain Management**: Domain registration, DNS record editing, SSL status monitoring

**Why Dusk Tests Are Critical:**

While unit and integration tests validate backend logic, they cannot catch:
- **JavaScript execution errors** in production-like environments
- **CSS layout issues** that break functionality (hidden buttons, overlapping modals)
- **Race conditions** in async UI updates (WebSocket events, Inertia navigation)
- **User interaction flows** (multi-step wizards, form validation, drag-drop)
- **Browser compatibility issues** (Chrome vs Firefox behavior differences)
- **Accessibility problems** (keyboard navigation, screen reader support)

Dusk tests simulate real user journeys through complex multi-step processes, catching integration issues that unit/integration tests miss. For example, a unit test might validate that `BrandingService::updateColors()` works correctly, but only a Dusk test can verify that:
1. User clicks "Edit Colors" button → Modal opens
2. User selects color from picker → Preview updates in real-time
3. User clicks "Save" → Inertia POST request succeeds
4. Page refreshes → New colors visible immediately
5. No JavaScript console errors throughout flow

**Integration Architecture:**

Dusk tests run against a **full Laravel application instance** with:
- **Database**: SQLite in-memory for speed, or PostgreSQL for production-like testing
- **Queue Workers**: Running in sync mode for deterministic job execution
- **WebSocket Server**: Laravel Reverb (or pusher-js mock) for real-time updates
- **Chrome/Chromium**: Headless browser controlled via ChromeDriver
- **Vue.js Application**: Full Vite build with all components compiled

**Test Organization:**

Tests follow Coolify's existing structure in `tests/Browser/Enterprise/`:
- `WhiteLabelBrandingTest.php` - Branding components (Tasks 4-8)
- `TerraformInfrastructureTest.php` - Terraform provisioning (Tasks 20-21)
- `ResourceMonitoringTest.php` - Monitoring dashboards (Tasks 29-30)
- `DeploymentManagementTest.php` - Deployment strategies (Tasks 39-40)
- `PaymentProcessingTest.php` - Payment flows (Task 50)
- `ApiManagementTest.php` - API token management (Tasks 59-60)
- `DomainManagementTest.php` - Domain registration (Task 70)

Each test file contains **5-15 test cases** covering happy paths, error scenarios, and edge cases. Every test follows the **Arrange-Act-Assert** pattern with Laravel Dusk's fluent API:

```php
$this->browse(function (Browser $browser) {
    // Arrange: Set up database state, authenticate user
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Act: Perform user actions in browser
    $browser->loginAs($user)
        ->visit('/enterprise/branding')
        ->click('@edit-colors-button')
        ->waitFor('@color-picker-modal')
        ->type('@primary-color-input', '#ff0000')
        ->click('@save-colors-button');

    // Assert: Verify expected outcomes
    $browser->waitForText('Colors updated successfully')
        ->assertSee('#ff0000')
        ->assertMissing('@color-picker-modal');
});
```

**Critical Test Scenarios:**

1. **Drag-and-Drop File Upload**: LogoUploader.vue accepts images via drag-drop
2. **Real-Time WebSocket Updates**: ResourceDashboard.vue displays live server metrics
3. **Multi-Step Wizards**: TerraformManager.vue completes infrastructure provisioning
4. **Form Validation**: All components display validation errors correctly
5. **Modal Interactions**: Modals open/close, handle form submissions, prevent body scroll
6. **Dynamic Table Updates**: Server list refreshes after provisioning completes
7. **Error Recovery**: UI handles backend errors gracefully with user-friendly messages

**Performance Considerations:**

Dusk tests are **slow** (10-30 seconds each) compared to unit tests (milliseconds), so we optimize by:
- **Parallel Execution**: Run 4-8 tests concurrently using `--parallel` flag
- **Database Refresh**: Use `RefreshDatabase` trait with SQLite for faster resets
- **Selective Testing**: Use `--filter` to run only affected tests during development
- **CI/CD Integration**: Run full Dusk suite only on `main` branch merges, not every PR commit

**Expected Test Coverage:**

After completing this task, we achieve:
- **90%+ UI interaction coverage** for all enterprise Vue.js components
- **100% critical user journey coverage** (signup → provision → deploy → billing)
- **Zero high-severity accessibility issues** (WCAG 2.1 AA compliance verified)
- **Cross-browser validation** (Chrome, Firefox, Safari via BrowserStack integration)

This comprehensive Dusk test suite ensures that the enterprise transformation maintains the **high quality standards** expected of a production-grade SaaS platform, catching UI regressions before they reach users.

## Acceptance Criteria

- [ ] Browser test suite configured with Laravel Dusk 8+ and ChromeDriver
- [ ] All enterprise Vue.js components have comprehensive Dusk tests (8+ components, 70+ test cases)
- [ ] Tests cover happy paths, error scenarios, and edge cases for each component
- [ ] Real-time WebSocket updates tested (ResourceDashboard, DeploymentMonitoring)
- [ ] Multi-step wizard flows tested (TerraformManager, domain registration)
- [ ] Drag-and-drop interactions tested (LogoUploader, file uploads)
- [ ] Form validation tested for all input components
- [ ] Modal interactions tested (open, close, form submission)
- [ ] Authentication and authorization tested (organization access control)
- [ ] Accessibility compliance verified (keyboard navigation, ARIA labels, focus management)
- [ ] Tests run successfully in headless Chrome (CI/CD compatible)
- [ ] Tests use Laravel Dusk selectors (`dusk=""` attributes) for reliable element targeting
- [ ] Database state properly managed (RefreshDatabase, factory seeding)
- [ ] Screenshots captured on test failures for debugging
- [ ] Browser console errors logged and fail tests when detected
- [ ] Parallel test execution configured for faster CI/CD runs
- [ ] All tests passing with 0 failures on clean checkout
- [ ] Test execution time < 15 minutes for full suite
- [ ] Documentation includes setup instructions and troubleshooting guide

## Technical Details

### File Paths

**Test Files:**
- `/home/topgun/topgun/tests/Browser/Enterprise/WhiteLabelBrandingTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/TerraformInfrastructureTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/ResourceMonitoringTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/DeploymentManagementTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/PaymentProcessingTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/ApiManagementTest.php` (new)
- `/home/topgun/topgun/tests/Browser/Enterprise/DomainManagementTest.php` (new)

**Support Files:**
- `/home/topgun/topgun/tests/Browser/Pages/Enterprise/BrandingPage.php` (Dusk Page object)
- `/home/topgun/topgun/tests/Browser/Pages/Enterprise/TerraformPage.php` (Dusk Page object)
- `/home/topgun/topgun/tests/Browser/Components/Enterprise/ColorPickerComponent.php` (Dusk Component)
- `/home/topgun/topgun/tests/Browser/Components/Enterprise/FileUploaderComponent.php` (Dusk Component)

**Configuration:**
- `/home/topgun/topgun/tests/DuskTestCase.php` (base class configuration)
- `/home/topgun/topgun/phpunit.dusk.xml` (Dusk-specific PHPUnit config)
- `/home/topgun/topgun/.env.dusk.local` (Dusk environment variables)

**Vue Component Updates (Add dusk selectors):**
- `/home/topgun/topgun/resources/js/Components/Enterprise/**/*.vue` (add `dusk=""` attributes)

### Dusk Setup and Configuration

**Installation:**

```bash
# Install Dusk
composer require --dev laravel/dusk

# Install ChromeDriver
php artisan dusk:install

# Verify installation
php artisan dusk:chrome-driver --detect
```

**Configuration File:** `tests/DuskTestCase.php`

```php
<?php

namespace Tests;

use Facebook\WebDriver\Chrome\ChromeOptions;
use Facebook\WebDriver\Remote\DesiredCapabilities;
use Facebook\WebDriver\Remote\RemoteWebDriver;
use Laravel\Dusk\TestCase as BaseTestCase;
use Illuminate\Foundation\Testing\DatabaseMigrations;

abstract class DuskTestCase extends BaseTestCase
{
    use CreatesApplication, DatabaseMigrations;

    /**
     * Prepare for Dusk test execution
     *
     * @beforeClass
     * @return void
     */
    public static function prepare(): void
    {
        if (!static::runningInSail()) {
            static::startChromeDriver();
        }
    }

    /**
     * Create the RemoteWebDriver instance
     *
     * @return \Facebook\WebDriver\Remote\RemoteWebDriver
     */
    protected function driver(): RemoteWebDriver
    {
        $options = (new ChromeOptions())->addArguments(collect([
            $this->shouldStartMaximized() ? '--start-maximized' : '--window-size=1920,1080',
            '--disable-search-engine-choice-screen',
            '--disable-gpu',
            '--no-sandbox',
            '--disable-dev-shm-usage',
            '--headless', // Run headless for CI/CD
        ])->unless($this->hasHeadlessDisabled(), function ($items) {
            return $items->forget(6); // Remove --headless flag
        })->all());

        return RemoteWebDriver::create(
            $_ENV['DUSK_DRIVER_URL'] ?? 'http://localhost:9515',
            DesiredCapabilities::chrome()->setCapability(
                ChromeOptions::CAPABILITY,
                $options
            )
        );
    }

    /**
     * Determine whether headless mode should be disabled
     *
     * @return bool
     */
    protected function hasHeadlessDisabled(): bool
    {
        return isset($_SERVER['DUSK_HEADLESS_DISABLED']) ||
               isset($_ENV['DUSK_HEADLESS_DISABLED']);
    }

    /**
     * Determine if the browser should start maximized
     *
     * @return bool
     */
    protected function shouldStartMaximized(): bool
    {
        return isset($_SERVER['DUSK_START_MAXIMIZED']) ||
               isset($_ENV['DUSK_START_MAXIMIZED']);
    }

    /**
     * Determine if the tests are running within Laravel Sail
     *
     * @return bool
     */
    protected static function runningInSail(): bool
    {
        return env('LARAVEL_SAIL') == '1';
    }
}
```

**Environment Configuration:** `.env.dusk.local`

```env
APP_URL=http://localhost:8000
DB_CONNECTION=sqlite
DB_DATABASE=:memory:

QUEUE_CONNECTION=sync
MAIL_MAILER=log
BROADCAST_DRIVER=log
CACHE_DRIVER=array
SESSION_DRIVER=array

DUSK_DRIVER_URL=http://localhost:9515
```

### WhiteLabelBrandingTest Implementation

**File:** `tests/Browser/Enterprise/WhiteLabelBrandingTest.php`

```php
<?php

namespace Tests\Browser\Enterprise;

use App\Models\Organization;
use App\Models\User;
use App\Models\WhiteLabelConfig;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Laravel\Dusk\Browser;
use Tests\DuskTestCase;

class WhiteLabelBrandingTest extends DuskTestCase
{
    use DatabaseMigrations;

    protected Organization $organization;
    protected User $adminUser;

    /**
     * Set up test environment
     *
     * @return void
     */
    protected function setUp(): void
    {
        parent::setUp();

        // Create test organization and admin user
        $this->organization = Organization::factory()->create([
            'name' => 'Test Corporation',
            'slug' => 'test-corp',
        ]);

        $this->adminUser = User::factory()->create([
            'name' => 'Admin User',
            'email' => 'admin@test.com',
        ]);

        $this->organization->users()->attach($this->adminUser, ['role' => 'admin']);

        Storage::fake('public');
    }

    /**
     * Test that user can access branding management page
     *
     * @return void
     */
    public function test_user_can_access_branding_page(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->assertSee('Branding Configuration')
                ->assertSee('Platform Name')
                ->assertSee('Logo Upload')
                ->assertSee('Color Settings');
        });
    }

    /**
     * Test logo upload with drag-and-drop
     *
     * @return void
     */
    public function test_logo_upload_with_drag_and_drop(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@logo-uploader')
                ->attach('@logo-file-input', __DIR__ . '/../../Fixtures/test-logo.png')
                ->waitFor('@upload-progress')
                ->pause(2000) // Wait for upload to complete
                ->waitForText('Logo uploaded successfully')
                ->assertSee('test-logo.png')
                ->screenshot('logo-upload-success');

            // Verify logo was saved to database
            $this->assertDatabaseHas('white_label_configs', [
                'organization_id' => $this->organization->id,
            ]);

            $config = WhiteLabelConfig::where('organization_id', $this->organization->id)->first();
            $this->assertNotNull($config->primary_logo_path);
        });
    }

    /**
     * Test color picker updates with live preview
     *
     * @return void
     */
    public function test_color_picker_updates_live_preview(): void
    {
        WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
            'primary_color' => '#3b82f6',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@theme-customizer')
                ->click('@edit-colors-button')
                ->waitFor('@color-picker-modal')
                ->type('@primary-color-input', '#ff0000')
                ->pause(500) // Wait for preview update
                ->assertAttribute('@branding-preview', 'style', 'background-color: rgb(255, 0, 0);')
                ->click('@save-colors-button')
                ->waitForText('Colors updated successfully')
                ->assertMissing('@color-picker-modal')
                ->screenshot('color-update-success');

            // Verify color was saved
            $this->assertDatabaseHas('white_label_configs', [
                'organization_id' => $this->organization->id,
                'primary_color' => '#ff0000',
            ]);
        });
    }

    /**
     * Test real-time branding preview updates
     *
     * @return void
     */
    public function test_branding_preview_updates_in_real_time(): void
    {
        WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
            'platform_name' => 'Original Name',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@branding-preview')
                ->assertSee('Original Name')
                ->type('@platform-name-input', 'New Platform Name')
                ->pause(1000) // Debounce delay
                ->within('@branding-preview', function ($preview) {
                    $preview->assertSee('New Platform Name');
                })
                ->screenshot('preview-update');
        });
    }

    /**
     * Test favicon generation from uploaded logo
     *
     * @return void
     */
    public function test_favicon_generation_from_logo(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@logo-uploader')
                ->attach('@logo-file-input', __DIR__ . '/../../Fixtures/test-logo.png')
                ->waitForText('Logo and favicons generated successfully')
                ->assertSee('16x16')
                ->assertSee('32x32')
                ->assertSee('180x180')
                ->screenshot('favicon-generation-success');

            // Verify favicons were generated
            $config = WhiteLabelConfig::where('organization_id', $this->organization->id)->first();
            $this->assertNotNull($config->favicon_16_path);
            $this->assertNotNull($config->favicon_32_path);
            $this->assertNotNull($config->favicon_180_path);
        });
    }

    /**
     * Test error handling for invalid file upload
     *
     * @return void
     */
    public function test_logo_upload_validates_file_type(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@logo-uploader')
                ->attach('@logo-file-input', __DIR__ . '/../../Fixtures/test-document.pdf')
                ->waitForText('Invalid file type')
                ->assertSee('Please upload PNG, JPG, or SVG')
                ->screenshot('invalid-file-upload');
        });
    }

    /**
     * Test logo deletion
     *
     * @return void
     */
    public function test_user_can_delete_uploaded_logo(): void
    {
        $config = WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
            'primary_logo_path' => 'branding/1/logos/test.png',
        ]);

        Storage::disk('public')->put('branding/1/logos/test.png', 'test content');

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@logo-preview')
                ->assertSee('test.png')
                ->click('@delete-logo-button')
                ->waitFor('@confirm-delete-modal')
                ->click('@confirm-delete-button')
                ->waitForText('Logo deleted successfully')
                ->assertMissing('@logo-preview')
                ->screenshot('logo-deleted');

            // Verify logo was removed
            $config->refresh();
            $this->assertNull($config->primary_logo_path);
            Storage::disk('public')->assertMissing('branding/1/logos/test.png');
        });
    }

    /**
     * Test platform name update
     *
     * @return void
     */
    public function test_user_can_update_platform_name(): void
    {
        WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
            'platform_name' => 'Old Name',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@platform-name-input')
                ->clear('@platform-name-input')
                ->type('@platform-name-input', 'My Custom Platform')
                ->click('@save-branding-button')
                ->waitForText('Branding updated successfully')
                ->screenshot('platform-name-updated');

            // Verify update
            $this->assertDatabaseHas('white_label_configs', [
                'organization_id' => $this->organization->id,
                'platform_name' => 'My Custom Platform',
            ]);
        });
    }

    /**
     * Test custom CSS injection
     *
     * @return void
     */
    public function test_custom_css_is_injected_into_preview(): void
    {
        WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
            'custom_css' => '.custom-button { background: red; }',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@branding-preview')
                ->assertScript('
                    return document.querySelector("@branding-preview")
                        .contentDocument.querySelector("style")
                        .textContent.includes("background: red");
                ')
                ->screenshot('custom-css-injected');
        });
    }

    /**
     * Test font family selection
     *
     * @return void
     */
    public function test_user_can_select_custom_font_family(): void
    {
        WhiteLabelConfig::factory()->create([
            'organization_id' => $this->organization->id,
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@font-family-select')
                ->select('@font-family-select', 'Roboto')
                ->pause(500)
                ->within('@branding-preview', function ($preview) {
                    $preview->assertScript('
                        return window.getComputedStyle(document.body)
                            .fontFamily.includes("Roboto");
                    ');
                })
                ->click('@save-branding-button')
                ->waitForText('Branding updated successfully')
                ->screenshot('font-family-updated');

            // Verify font saved
            $this->assertDatabaseHas('white_label_configs', [
                'organization_id' => $this->organization->id,
                'font_family' => 'Roboto',
            ]);
        });
    }

    /**
     * Test that non-admin users cannot access branding settings
     *
     * @return void
     */
    public function test_non_admin_cannot_access_branding_page(): void
    {
        $regularUser = User::factory()->create();
        $this->organization->users()->attach($regularUser, ['role' => 'member']);

        $this->browse(function (Browser $browser) use ($regularUser) {
            $browser->loginAs($regularUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->assertSee('403')
                ->assertSee('Unauthorized')
                ->screenshot('unauthorized-access');
        });
    }

    /**
     * Test keyboard navigation through branding form
     *
     * @return void
     */
    public function test_branding_form_supports_keyboard_navigation(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/branding')
                ->waitFor('@platform-name-input')
                ->keys('@platform-name-input', '{tab}') // Tab to next field
                ->assertFocused('@primary-color-input')
                ->keys('@primary-color-input', '{tab}')
                ->assertFocused('@secondary-color-input')
                ->screenshot('keyboard-navigation');
        });
    }
}
```

### TerraformInfrastructureTest Implementation

**File:** `tests/Browser/Enterprise/TerraformInfrastructureTest.php`

```php
<?php

namespace Tests\Browser\Enterprise;

use App\Models\CloudProviderCredential;
use App\Models\Organization;
use App\Models\User;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Laravel\Dusk\Browser;
use Tests\DuskTestCase;

class TerraformInfrastructureTest extends DuskTestCase
{
    use DatabaseMigrations;

    protected Organization $organization;
    protected User $adminUser;

    protected function setUp(): void
    {
        parent::setUp();

        $this->organization = Organization::factory()->create();
        $this->adminUser = User::factory()->create();
        $this->organization->users()->attach($this->adminUser, ['role' => 'admin']);
    }

    /**
     * Test Terraform provisioning wizard flow
     *
     * @return void
     */
    public function test_terraform_provisioning_wizard_completes_successfully(): void
    {
        CloudProviderCredential::factory()->create([
            'organization_id' => $this->organization->id,
            'provider' => 'aws',
            'credentials' => encrypt([
                'access_key_id' => 'test_key',
                'secret_access_key' => 'test_secret',
            ]),
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/infrastructure')
                ->waitFor('@terraform-wizard')
                ->click('@start-provisioning-button')

                // Step 1: Cloud Provider Selection
                ->waitFor('@provider-selection-step')
                ->click('@provider-aws')
                ->click('@next-step-button')

                // Step 2: Server Configuration
                ->waitFor('@server-config-step')
                ->type('@server-name-input', 'production-server-1')
                ->select('@instance-type-select', 't3.medium')
                ->select('@region-select', 'us-east-1')
                ->click('@next-step-button')

                // Step 3: Review and Confirm
                ->waitFor('@review-step')
                ->assertSee('production-server-1')
                ->assertSee('t3.medium')
                ->assertSee('us-east-1')
                ->click('@provision-button')

                // Wait for provisioning to complete
                ->waitFor('@provisioning-progress', 60)
                ->waitForText('Server provisioned successfully', 120)
                ->assertSee('production-server-1')
                ->screenshot('provisioning-complete');

            // Verify server was created
            $this->assertDatabaseHas('servers', [
                'name' => 'production-server-1',
            ]);

            $this->assertDatabaseHas('terraform_deployments', [
                'organization_id' => $this->organization->id,
                'status' => 'completed',
            ]);
        });
    }

    /**
     * Test cloud provider credential management
     *
     * @return void
     */
    public function test_user_can_add_cloud_provider_credentials(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/credentials')
                ->waitFor('@add-credential-button')
                ->click('@add-credential-button')
                ->waitFor('@credential-modal')
                ->select('@provider-select', 'digitalocean')
                ->type('@credential-name-input', 'DO Production')
                ->type('@api-token-input', 'dop_v1_test_token_12345')
                ->click('@save-credential-button')
                ->waitForText('Credential added successfully')
                ->assertSee('DO Production')
                ->screenshot('credential-added');

            // Verify credential was encrypted and saved
            $credential = CloudProviderCredential::where('organization_id', $this->organization->id)->first();
            $this->assertEquals('digitalocean', $credential->provider);
            $this->assertEquals('DO Production', $credential->name);
        });
    }

    /**
     * Test real-time provisioning progress updates
     *
     * @return void
     */
    public function test_deployment_monitoring_shows_real_time_progress(): void
    {
        $deployment = \App\Models\TerraformDeployment::factory()->create([
            'organization_id' => $this->organization->id,
            'status' => 'in_progress',
            'progress_percentage' => 45,
        ]);

        $this->browse(function (Browser $browser) use ($deployment) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/deployments/' . $deployment->id)
                ->waitFor('@deployment-progress-bar')
                ->assertSee('45%')
                ->pause(2000) // Wait for WebSocket update
                ->assertSee('Applying infrastructure changes...')
                ->screenshot('deployment-progress');
        });
    }

    /**
     * Test error handling when provisioning fails
     *
     * @return void
     */
    public function test_provisioning_failure_displays_error_message(): void
    {
        // Mock Terraform service to simulate failure
        $this->app->bind(\App\Contracts\TerraformServiceInterface::class, function () {
            return new class implements \App\Contracts\TerraformServiceInterface {
                public function provisionInfrastructure($provider, $config)
                {
                    throw new \Exception('AWS API error: Invalid credentials');
                }
                // ... other interface methods
            };
        });

        CloudProviderCredential::factory()->create([
            'organization_id' => $this->organization->id,
            'provider' => 'aws',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/infrastructure')
                ->click('@start-provisioning-button')
                ->waitFor('@provider-aws')
                ->click('@provider-aws')
                ->click('@next-step-button')
                ->type('@server-name-input', 'test-server')
                ->click('@next-step-button')
                ->click('@provision-button')
                ->waitForText('Provisioning failed')
                ->assertSee('AWS API error: Invalid credentials')
                ->screenshot('provisioning-failed');
        });
    }

    /**
     * Test server auto-registration after provisioning
     *
     * @return void
     */
    public function test_server_auto_registers_after_provisioning(): void
    {
        CloudProviderCredential::factory()->create([
            'organization_id' => $this->organization->id,
            'provider' => 'digitalocean',
        ]);

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/infrastructure')
                ->click('@start-provisioning-button')
                ->click('@provider-digitalocean')
                ->click('@next-step-button')
                ->type('@server-name-input', 'app-server-1')
                ->click('@next-step-button')
                ->click('@provision-button')
                ->waitForText('Server provisioned successfully', 120)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/servers')
                ->waitFor('@server-list')
                ->assertSee('app-server-1')
                ->assertSee('Active')
                ->screenshot('server-registered');
        });
    }

    /**
     * Test infrastructure destruction flow
     *
     * @return void
     */
    public function test_user_can_destroy_provisioned_infrastructure(): void
    {
        $deployment = \App\Models\TerraformDeployment::factory()->create([
            'organization_id' => $this->organization->id,
            'status' => 'completed',
        ]);

        $server = \App\Models\Server::factory()->create([
            'name' => 'test-server-1',
            'terraform_deployment_id' => $deployment->id,
        ]);

        $this->browse(function (Browser $browser) use ($server) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/servers')
                ->waitFor('@server-list')
                ->assertSee('test-server-1')
                ->click('@server-actions-' . $server->id)
                ->click('@destroy-infrastructure-button')
                ->waitFor('@confirm-destroy-modal')
                ->type('@confirm-server-name', 'test-server-1')
                ->click('@confirm-destroy-button')
                ->waitForText('Infrastructure destruction started')
                ->pause(10000) // Wait for destruction
                ->waitForText('Infrastructure destroyed successfully')
                ->screenshot('infrastructure-destroyed');

            // Verify server and deployment marked as destroyed
            $this->assertDatabaseHas('terraform_deployments', [
                'id' => $deployment->id,
                'status' => 'destroyed',
            ]);
        });
    }
}
```

### ResourceMonitoringTest Implementation

**File:** `tests/Browser/Enterprise/ResourceMonitoringTest.php`

```php
<?php

namespace Tests\Browser\Enterprise;

use App\Models\Organization;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use App\Models\User;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Laravel\Dusk\Browser;
use Tests\DuskTestCase;

class ResourceMonitoringTest extends DuskTestCase
{
    use DatabaseMigrations;

    protected Organization $organization;
    protected User $adminUser;
    protected Server $server;

    protected function setUp(): void
    {
        parent::setUp();

        $this->organization = Organization::factory()->create();
        $this->adminUser = User::factory()->create();
        $this->organization->users()->attach($this->adminUser, ['role' => 'admin']);

        $this->server = Server::factory()->create([
            'name' => 'production-server-1',
        ]);

        // Seed metrics for testing
        ServerResourceMetric::factory()->count(50)->create([
            'server_id' => $this->server->id,
        ]);
    }

    /**
     * Test resource dashboard displays real-time metrics
     *
     * @return void
     */
    public function test_resource_dashboard_displays_metrics(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/monitoring')
                ->waitFor('@resource-dashboard')
                ->assertSee('CPU Usage')
                ->assertSee('Memory Usage')
                ->assertSee('Disk Usage')
                ->assertSee('Network Traffic')
                ->waitFor('@cpu-chart')
                ->waitFor('@memory-chart')
                ->screenshot('resource-dashboard');
        });
    }

    /**
     * Test real-time metric updates via WebSocket
     *
     * @return void
     */
    public function test_dashboard_updates_with_new_metrics(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/monitoring')
                ->waitFor('@cpu-chart')
                ->pause(2000)

                // Simulate new metric broadcast
                ->script('
                    window.Echo.channel("organization.' . $this->organization->id . '.metrics")
                        .trigger("MetricUpdated", {
                            server_id: ' . $this->server->id . ',
                            cpu_usage: 75.5,
                            memory_usage: 60.2,
                            timestamp: Date.now()
                        });
                ')

                ->pause(1000)
                ->assertSee('75.5%') // New CPU value
                ->screenshot('metric-update');
        });
    }

    /**
     * Test capacity planner shows server recommendations
     *
     * @return void
     */
    public function test_capacity_planner_recommends_optimal_server(): void
    {
        // Create servers with different capacity
        $server1 = Server::factory()->create(['name' => 'low-capacity']);
        $server2 = Server::factory()->create(['name' => 'high-capacity']);

        ServerResourceMetric::factory()->create([
            'server_id' => $server1->id,
            'cpu_usage' => 90.0,
            'memory_usage' => 85.0,
        ]);

        ServerResourceMetric::factory()->create([
            'server_id' => $server2->id,
            'cpu_usage' => 30.0,
            'memory_usage' => 40.0,
        ]);

        $this->browse(function (Browser $browser) use ($server2) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/capacity')
                ->waitFor('@capacity-planner')
                ->click('@analyze-capacity-button')
                ->waitFor('@server-recommendations')
                ->assertSee('high-capacity')
                ->assertSee('Recommended')
                ->assertDontSee('low-capacity (Recommended)')
                ->screenshot('capacity-recommendations');
        });
    }

    /**
     * Test server selection visualization
     *
     * @return void
     */
    public function test_server_selection_shows_capacity_scoring(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/capacity')
                ->waitFor('@server-list')
                ->click('@server-' . $this->server->id)
                ->waitFor('@server-details-modal')
                ->assertSee('Capacity Score')
                ->assertSee('CPU')
                ->assertSee('Memory')
                ->assertSee('Disk')
                ->screenshot('server-capacity-details');
        });
    }

    /**
     * Test historical metrics chart rendering
     *
     * @return void
     */
    public function test_historical_metrics_chart_renders_correctly(): void
    {
        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/monitoring/servers/' . $this->server->id)
                ->waitFor('@historical-chart')
                ->select('@time-range-select', '24h')
                ->pause(2000) // Wait for chart redraw
                ->assertScript('
                    return document.querySelector("@historical-chart .apexcharts-line").childElementCount > 0;
                ')
                ->screenshot('historical-chart');
        });
    }

    /**
     * Test organization resource usage aggregation
     *
     * @return void
     */
    public function test_organization_usage_aggregates_all_servers(): void
    {
        // Create multiple servers
        Server::factory(3)->create()->each(function ($server) {
            ServerResourceMetric::factory()->create([
                'server_id' => $server->id,
                'cpu_usage' => 50.0,
                'memory_usage' => 60.0,
            ]);
        });

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/usage')
                ->waitFor('@organization-usage')
                ->assertSee('Total Servers: 4') // 1 from setUp + 3 new
                ->assertSee('Average CPU Usage')
                ->assertSee('Average Memory Usage')
                ->screenshot('organization-usage');
        });
    }

    /**
     * Test resource quota enforcement warning
     *
     * @return void
     */
    public function test_quota_warning_displays_when_approaching_limit(): void
    {
        // Set organization quota
        \App\Models\EnterpriseLicense::factory()->create([
            'organization_id' => $this->organization->id,
            'max_servers' => 5,
        ]);

        // Create servers approaching limit
        Server::factory(4)->create();

        $this->browse(function (Browser $browser) {
            $browser->loginAs($this->adminUser)
                ->visit('/enterprise/organizations/' . $this->organization->id . '/monitoring')
                ->waitFor('@quota-warning')
                ->assertSee('Approaching server limit')
                ->assertSee('5 of 5 servers used')
                ->screenshot('quota-warning');
        });
    }
}
```

### Additional Test Files (Abbreviated for Space)

**DeploymentManagementTest.php** - Tests deployment strategy selection, blue-green deployments, rollback mechanisms

**PaymentProcessingTest.php** - Tests subscription management, payment method addition, billing dashboard

**ApiManagementTest.php** - Tests API token creation, rate limit visualization, usage monitoring

**DomainManagementTest.php** - Tests domain registration, DNS record editing, SSL certificate status

### Dusk Page Objects

**File:** `tests/Browser/Pages/Enterprise/BrandingPage.php`

```php
<?php

namespace Tests\Browser\Pages\Enterprise;

use Laravel\Dusk\Browser;
use Laravel\Dusk\Page;

class BrandingPage extends Page
{
    protected $organizationId;

    public function __construct($organizationId)
    {
        $this->organizationId = $organizationId;
    }

    /**
     * Get the URL for the page
     *
     * @return string
     */
    public function url()
    {
        return "/enterprise/organizations/{$this->organizationId}/branding";
    }

    /**
     * Assert that the browser is on the page
     *
     * @param Browser $browser
     * @return void
     */
    public function assert(Browser $browser)
    {
        $browser->assertPathIs($this->url())
            ->assertSee('Branding Configuration');
    }

    /**
     * Get the element shortcuts for the page
     *
     * @return array<string, string>
     */
    public function elements()
    {
        return [
            '@platform-name-input' => 'input[dusk="platform-name-input"]',
            '@logo-uploader' => '[dusk="logo-uploader"]',
            '@logo-file-input' => 'input[dusk="logo-file-input"]',
            '@upload-progress' => '[dusk="upload-progress"]',
            '@edit-colors-button' => 'button[dusk="edit-colors-button"]',
            '@color-picker-modal' => '[dusk="color-picker-modal"]',
            '@primary-color-input' => 'input[dusk="primary-color-input"]',
            '@save-colors-button' => 'button[dusk="save-colors-button"]',
            '@branding-preview' => 'iframe[dusk="branding-preview"]',
            '@theme-customizer' => '[dusk="theme-customizer"]',
            '@save-branding-button' => 'button[dusk="save-branding-button"]',
        ];
    }

    /**
     * Upload a logo
     *
     * @param Browser $browser
     * @param string $path
     * @return void
     */
    public function uploadLogo(Browser $browser, string $path)
    {
        $browser->attach('@logo-file-input', $path)
            ->waitForText('Logo uploaded successfully');
    }

    /**
     * Update platform colors
     *
     * @param Browser $browser
     * @param string $primaryColor
     * @return void
     */
    public function updateColors(Browser $browser, string $primaryColor)
    {
        $browser->click('@edit-colors-button')
            ->waitFor('@color-picker-modal')
            ->type('@primary-color-input', $primaryColor)
            ->click('@save-colors-button')
            ->waitForText('Colors updated successfully');
    }
}
```

### Vue Component Dusk Selector Updates

**Example:** `resources/js/Components/Enterprise/WhiteLabel/LogoUploader.vue`

Add `dusk` attributes to all interactive elements:

```vue
<template>
  <div class="logo-uploader" dusk="logo-uploader">
    <!-- Drop Zone -->
    <div class="drop-zone" dusk="drop-zone">
      <!-- File Input -->
      <input
        ref="fileInput"
        dusk="logo-file-input"
        type="file"
        accept="image/png,image/jpeg,image/jpg,image/svg+xml"
        class="hidden"
        @change="handleFileSelect"
      />

      <!-- Upload Progress -->
      <div v-if="uploadProgress > 0" dusk="upload-progress">
        <div class="progress-bar-fill" :style="{ width: `${uploadProgress}%` }" />
        <span>{{ uploadProgress }}%</span>
      </div>

      <!-- Preview -->
      <div v-if="previewUrl" dusk="logo-preview">
        <img :src="previewUrl" alt="Logo preview" />
        <button dusk="delete-logo-button" @click="deleteLogo">Delete</button>
      </div>
    </div>

    <!-- Error Message -->
    <p v-if="errorMessage" dusk="error-message">{{ errorMessage }}</p>
  </div>
</template>
```

## Implementation Approach

### Step 1: Install and Configure Dusk

```bash
# Install Dusk
composer require --dev laravel/dusk

# Install ChromeDriver
php artisan dusk:install

# Create DuskTestCase base class
php artisan dusk:install

# Create .env.dusk.local
cp .env .env.dusk.local
```

### Step 2: Configure Environment

1. Update `.env.dusk.local` with test-specific configuration
2. Configure `tests/DuskTestCase.php` with Chrome options
3. Create `phpunit.dusk.xml` for Dusk-specific PHPUnit settings
4. Test basic setup with `php artisan dusk`

### Step 3: Add Dusk Selectors to Vue Components

1. Review all Vue.js enterprise components
2. Add `dusk=""` attributes to all interactive elements
3. Use semantic names: `@edit-button`, `@save-button`, `@modal-title`
4. Document selector naming conventions

### Step 4: Create Page Objects

1. Create Page objects for each major UI section
2. Define element shortcuts for common selectors
3. Add helper methods for common interactions
4. Implement assertion methods

### Step 5: Write WhiteLabelBrandingTest

1. Create test class with database migrations
2. Write 10-12 test methods covering all branding features
3. Test happy paths, error scenarios, edge cases
4. Add screenshots for debugging

### Step 6: Write TerraformInfrastructureTest

1. Test multi-step provisioning wizard
2. Test cloud provider credential management
3. Test real-time progress updates
4. Test error handling and rollback

### Step 7: Write ResourceMonitoringTest

1. Test real-time dashboard updates
2. Test WebSocket metric broadcasts
3. Test capacity planner recommendations
4. Test historical chart rendering

### Step 8: Write Remaining Test Suites

1. DeploymentManagementTest
2. PaymentProcessingTest
3. ApiManagementTest
4. DomainManagementTest

### Step 9: Optimize Test Execution

1. Configure parallel test execution
2. Optimize database seeding
3. Add test groups for selective execution
4. Configure screenshot capture on failures

### Step 10: CI/CD Integration

1. Add Dusk to GitHub Actions workflow
2. Configure headless Chrome in CI
3. Upload test screenshots as artifacts
4. Set up test result reporting

## Test Strategy

### Unit Tests (None - This Task is Browser Tests Only)

This task focuses exclusively on Dusk browser tests. Unit tests for services, models, and controllers are covered in Task 76.

### Browser Tests (Laravel Dusk)

**File:** All tests in `tests/Browser/Enterprise/`

**Coverage:**
- 70+ test cases across 7 test files
- Happy paths, error scenarios, edge cases
- Real-time WebSocket updates
- Multi-step wizards
- Form validation
- Modal interactions
- Accessibility compliance

**Test Execution:**

```bash
# Run all Dusk tests
php artisan dusk

# Run specific test file
php artisan dusk tests/Browser/Enterprise/WhiteLabelBrandingTest.php

# Run with visible browser (for debugging)
DUSK_HEADLESS_DISABLED=1 php artisan dusk

# Run in parallel (4 processes)
php artisan dusk --parallel=4

# Run specific test method
php artisan dusk --filter=test_logo_upload_with_drag_and_drop
```

### Performance Targets

- **Full test suite execution**: < 15 minutes
- **Individual test case**: < 30 seconds
- **Parallel execution**: 4-8 concurrent browsers
- **Screenshot capture**: On failures only (for debugging)

### Quality Gates

- **100% test pass rate** before merge to main
- **Zero browser console errors** in test runs
- **90%+ coverage** of critical user journeys
- **Accessibility validation** for all forms

## Definition of Done

- [ ] Laravel Dusk installed and configured (version 8+)
- [ ] ChromeDriver installed and verified
- [ ] DuskTestCase base class configured with Chrome options
- [ ] `.env.dusk.local` created with test configuration
- [ ] `phpunit.dusk.xml` configured for Dusk tests
- [ ] All Vue.js components updated with `dusk=""` selectors
- [ ] Page objects created for major UI sections
- [ ] WhiteLabelBrandingTest created with 10+ test cases
- [ ] TerraformInfrastructureTest created with 8+ test cases
- [ ] ResourceMonitoringTest created with 8+ test cases
- [ ] DeploymentManagementTest created with 6+ test cases
- [ ] PaymentProcessingTest created with 8+ test cases
- [ ] ApiManagementTest created with 6+ test cases
- [ ] DomainManagementTest created with 6+ test cases
- [ ] All tests passing on clean checkout (0 failures)
- [ ] Parallel execution configured and working
- [ ] Screenshots captured on test failures
- [ ] Browser console errors logged and fail tests
- [ ] Test execution time < 15 minutes for full suite
- [ ] CI/CD integration completed (GitHub Actions)
- [ ] Headless Chrome configured in CI
- [ ] Test screenshots uploaded as artifacts on failure
- [ ] Documentation updated with setup instructions
- [ ] Troubleshooting guide created for common issues
- [ ] Accessibility compliance verified (keyboard nav, ARIA)
- [ ] Real-time WebSocket updates tested
- [ ] Multi-step wizards tested end-to-end
- [ ] Form validation tested for all components
- [ ] Modal interactions tested (open/close/submit)
- [ ] Authentication and authorization tested
- [ ] Cross-browser testing plan documented

## Related Tasks

- **Depends on:** Task 76 (Write unit tests for all enterprise services) - Requires services and components to be fully implemented and unit tested before browser testing
- **Integrates with:** Task 4 (LogoUploader.vue) - Tests logo upload functionality
- **Integrates with:** Task 5 (BrandingManager.vue) - Tests branding management UI
- **Integrates with:** Task 6 (ThemeCustomizer.vue) - Tests theme customization
- **Integrates with:** Task 8 (BrandingPreview.vue) - Tests real-time preview updates
- **Integrates with:** Task 20 (TerraformManager.vue) - Tests infrastructure provisioning wizard
- **Integrates with:** Task 21 (CloudProviderCredentials.vue, DeploymentMonitoring.vue) - Tests credential management and deployment monitoring
- **Integrates with:** Task 29 (ResourceDashboard.vue) - Tests resource monitoring dashboard
- **Integrates with:** Task 30 (CapacityPlanner.vue) - Tests capacity planning UI
- **Integrates with:** Task 39 (DeploymentManager.vue) - Tests deployment strategy management
- **Integrates with:** Task 50 (Payment Vue components) - Tests subscription and billing UI
- **Integrates with:** Task 59-60 (API management components) - Tests API token and usage monitoring
- **Integrates with:** Task 70 (Domain management components) - Tests domain registration and DNS editing
- **Validates:** All Tasks 2-70 - Provides end-to-end validation of all enterprise features
