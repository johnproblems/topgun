---
name: Implement PaymentService with subscription and payment methods
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:54:31Z
github: https://github.com/johnproblems/topgun/issues/200
depends_on: [44, 45]
parallel: false
conflicts_with: []
---

# Task: Implement PaymentService with subscription and payment methods

## Description

Implement the core `PaymentService` that orchestrates payment processing, subscription management, and billing operations across multiple payment gateways. This service acts as the unified payment engine for the Coolify Enterprise platform, providing a clean abstraction over Stripe, PayPal, and other payment providers while handling the complex workflows of subscription lifecycle management, payment method storage, transaction processing, and webhook validation.

The service provides a consistent PHP interface to diverse payment gateway APIs, enabling Coolify to process payments, manage recurring subscriptions, calculate usage-based billing, and handle refunds—all through a single, well-designed service layer that abstracts provider-specific implementations.

**Core Responsibilities:**

1. **Subscription Management**: Create, update, pause, resume, and cancel subscriptions with automatic billing
2. **Payment Processing**: Process one-time payments and recurring charges with comprehensive error handling
3. **Payment Method Storage**: Securely tokenize and store payment methods (credit cards, bank accounts, PayPal)
4. **Usage-Based Billing**: Calculate overage charges based on resource consumption from monitoring system
5. **Refund Processing**: Handle full and partial refunds with automatic reconciliation
6. **Webhook Management**: Validate and process payment gateway webhooks with HMAC verification
7. **Invoice Generation**: Create detailed invoices with line items, taxes, and payment history
8. **Failed Payment Recovery**: Automatic retry logic with configurable schedules and dunning management

**Integration Architecture:**

**Upstream Dependencies (Payment Gateways):**
- **Stripe Integration** (Task 44): Credit cards, ACH, subscription billing, webhook handling
- **PayPal Integration** (Task 45): PayPal balance, credit cards via PayPal, alternative payment methods
- **Payment Gateway Factory**: Provider selection based on organization preferences or fallback logic

**Downstream Consumers:**
- **SubscriptionManager.vue** (Task 50): Frontend subscription management interface
- **BillingDashboard.vue** (Task 50): Usage metrics, cost breakdowns, invoice history
- **OrganizationService**: Subscription-driven feature activation and quota enforcement
- **ResourceMonitoringJob** (Task 24): Usage metrics for overage calculations
- **License Validation**: Subscription status affects license validity and feature access

**Database Models:**
- **OrganizationSubscription**: Subscription lifecycle, plan details, billing cycle
- **PaymentMethod**: Tokenized payment instruments with gateway-specific metadata
- **PaymentTransaction**: Immutable transaction log with full audit trail
- **Invoice**: Generated invoices with line items and payment status

**Why This Task Is Critical:**

Payment processing is the revenue engine of the enterprise platform. Without this service, organizations cannot subscribe to paid plans, limiting monetization to manual invoicing or external billing systems. This service enables:

- **Self-Service Subscriptions**: Organizations can upgrade, downgrade, or cancel without manual intervention
- **Automated Revenue Recognition**: Subscriptions create predictable recurring revenue with automatic billing
- **Usage-Based Monetization**: Charge for actual resource consumption, enabling pay-as-you-go pricing
- **Global Payment Methods**: Support multiple payment providers and currencies for international customers
- **Churn Reduction**: Automated payment retry and dunning management recovers failed payments automatically

The service transforms Coolify from a self-hosted platform into a monetizable SaaS business with enterprise billing capabilities, subscription tiers, and usage-based pricing—all while maintaining PCI compliance through tokenization and never storing raw payment card data.

## Acceptance Criteria

- [ ] PaymentService class implements PaymentServiceInterface with all required methods
- [ ] `createSubscription()` method creates subscriptions with plan selection and billing cycle
- [ ] `updateSubscription()` method handles plan changes with prorated billing
- [ ] `pauseSubscription()` and `resumeSubscription()` methods manage subscription lifecycle
- [ ] `cancelSubscription()` method cancels with immediate or end-of-period options
- [ ] `processPayment()` method handles one-time charges with idempotency
- [ ] `refundPayment()` method processes full and partial refunds with reason tracking
- [ ] `addPaymentMethod()` method tokenizes and stores payment instruments
- [ ] `removePaymentMethod()` method safely deletes with orphan subscription checks
- [ ] `setDefaultPaymentMethod()` updates organization's preferred payment method
- [ ] `calculateUsageBilling()` method computes overages from resource monitoring data
- [ ] `generateInvoice()` method creates invoices with line items, taxes, discounts
- [ ] `retryFailedPayment()` method with exponential backoff and maximum attempts
- [ ] Gateway abstraction supports multiple providers (Stripe, PayPal) via factory pattern
- [ ] Webhook signature validation with HMAC verification for security
- [ ] Idempotency key support prevents duplicate payment processing
- [ ] Comprehensive error handling with gateway-specific error codes
- [ ] Transaction logging with immutable audit trail
- [ ] Integration with OrganizationService for feature activation/deactivation
- [ ] Unit tests covering all public methods with >90% coverage
- [ ] Integration tests with payment gateway mocking

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/PaymentService.php` (implementation)
- `/home/topgun/topgun/app/Contracts/PaymentServiceInterface.php` (interface)

**Gateway Implementations:**
- `/home/topgun/topgun/app/Services/Enterprise/Gateways/StripeGateway.php` (existing from Task 44)
- `/home/topgun/topgun/app/Services/Enterprise/Gateways/PayPalGateway.php` (existing from Task 45)
- `/home/topgun/topgun/app/Services/Enterprise/Gateways/PaymentGatewayFactory.php` (existing from Task 43)

**Configuration:**
- `/home/topgun/topgun/config/payment.php` (payment settings)

**Models:**
- `/home/topgun/topgun/app/Models/OrganizationSubscription.php` (existing from Task 42)
- `/home/topgun/topgun/app/Models/PaymentMethod.php` (existing from Task 42)
- `/home/topgun/topgun/app/Models/PaymentTransaction.php` (existing from Task 42)
- `/home/topgun/topgun/app/Models/Invoice.php` (existing from Task 42)

**DTOs:**
- `/home/topgun/topgun/app/DTOs/PaymentResult.php` (new)
- `/home/topgun/topgun/app/DTOs/SubscriptionResult.php` (new)
- `/home/topgun/topgun/app/DTOs/UsageBillingResult.php` (new)

### Service Interface

**File:** `app/Contracts/PaymentServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Organization;
use App\Models\OrganizationSubscription;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use App\DTOs\PaymentResult;
use App\DTOs\SubscriptionResult;
use App\DTOs\UsageBillingResult;

interface PaymentServiceInterface
{
    /**
     * Create a new subscription for an organization
     *
     * @param Organization $organization
     * @param string $planId Plan identifier (e.g., 'pro-monthly')
     * @param PaymentMethod|null $paymentMethod Payment method to use (null = use default)
     * @param array $options Additional options (trial_days, coupon_code, etc.)
     * @return SubscriptionResult
     * @throws \App\Exceptions\PaymentException
     */
    public function createSubscription(
        Organization $organization,
        string $planId,
        ?PaymentMethod $paymentMethod = null,
        array $options = []
    ): SubscriptionResult;

    /**
     * Update an existing subscription (plan change, quantity, etc.)
     *
     * @param OrganizationSubscription $subscription
     * @param array $updates Changes to apply (plan_id, quantity, billing_cycle, etc.)
     * @param bool $prorate Whether to prorate billing (default: true)
     * @return SubscriptionResult
     * @throws \App\Exceptions\PaymentException
     */
    public function updateSubscription(
        OrganizationSubscription $subscription,
        array $updates,
        bool $prorate = true
    ): SubscriptionResult;

    /**
     * Pause a subscription (billing stops, features may be limited)
     *
     * @param OrganizationSubscription $subscription
     * @param string|null $resumeAt Optional resume date (ISO 8601)
     * @return bool
     * @throws \App\Exceptions\PaymentException
     */
    public function pauseSubscription(
        OrganizationSubscription $subscription,
        ?string $resumeAt = null
    ): bool;

    /**
     * Resume a paused subscription
     *
     * @param OrganizationSubscription $subscription
     * @return bool
     * @throws \App\Exceptions\PaymentException
     */
    public function resumeSubscription(OrganizationSubscription $subscription): bool;

    /**
     * Cancel a subscription
     *
     * @param OrganizationSubscription $subscription
     * @param bool $immediately Cancel now vs. at period end (default: false)
     * @param string|null $reason Optional cancellation reason
     * @return bool
     * @throws \App\Exceptions\PaymentException
     */
    public function cancelSubscription(
        OrganizationSubscription $subscription,
        bool $immediately = false,
        ?string $reason = null
    ): bool;

    /**
     * Process a one-time payment
     *
     * @param Organization $organization
     * @param int $amountCents Amount in cents
     * @param PaymentMethod $paymentMethod
     * @param array $metadata Additional metadata (description, invoice_id, etc.)
     * @return PaymentResult
     * @throws \App\Exceptions\PaymentException
     */
    public function processPayment(
        Organization $organization,
        int $amountCents,
        PaymentMethod $paymentMethod,
        array $metadata = []
    ): PaymentResult;

    /**
     * Refund a payment (full or partial)
     *
     * @param PaymentTransaction $transaction
     * @param int|null $amountCents Amount to refund (null = full refund)
     * @param string|null $reason Refund reason
     * @return PaymentResult
     * @throws \App\Exceptions\PaymentException
     */
    public function refundPayment(
        PaymentTransaction $transaction,
        ?int $amountCents = null,
        ?string $reason = null
    ): PaymentResult;

    /**
     * Add a payment method to an organization
     *
     * @param Organization $organization
     * @param string $gatewayToken Token from payment gateway (Stripe token, PayPal agreement, etc.)
     * @param string $gateway Gateway identifier (stripe, paypal)
     * @param bool $setAsDefault Set as default payment method
     * @return PaymentMethod
     * @throws \App\Exceptions\PaymentException
     */
    public function addPaymentMethod(
        Organization $organization,
        string $gatewayToken,
        string $gateway,
        bool $setAsDefault = false
    ): PaymentMethod;

    /**
     * Remove a payment method
     *
     * @param PaymentMethod $paymentMethod
     * @param bool $force Force removal even if active subscriptions exist
     * @return bool
     * @throws \App\Exceptions\PaymentException
     */
    public function removePaymentMethod(
        PaymentMethod $paymentMethod,
        bool $force = false
    ): bool;

    /**
     * Set the default payment method for an organization
     *
     * @param Organization $organization
     * @param PaymentMethod $paymentMethod
     * @return bool
     */
    public function setDefaultPaymentMethod(
        Organization $organization,
        PaymentMethod $paymentMethod
    ): bool;

    /**
     * Calculate usage-based billing charges
     *
     * @param OrganizationSubscription $subscription
     * @param \Carbon\Carbon $periodStart Billing period start
     * @param \Carbon\Carbon $periodEnd Billing period end
     * @return UsageBillingResult
     */
    public function calculateUsageBilling(
        OrganizationSubscription $subscription,
        \Carbon\Carbon $periodStart,
        \Carbon\Carbon $periodEnd
    ): UsageBillingResult;

    /**
     * Generate an invoice for a billing period
     *
     * @param Organization $organization
     * @param \Carbon\Carbon $periodStart
     * @param \Carbon\Carbon $periodEnd
     * @param array $lineItems Additional line items to include
     * @return \App\Models\Invoice
     */
    public function generateInvoice(
        Organization $organization,
        \Carbon\Carbon $periodStart,
        \Carbon\Carbon $periodEnd,
        array $lineItems = []
    ): \App\Models\Invoice;

    /**
     * Retry a failed payment
     *
     * @param PaymentTransaction $transaction
     * @param PaymentMethod|null $alternativePaymentMethod Try different payment method
     * @return PaymentResult
     * @throws \App\Exceptions\PaymentException
     */
    public function retryFailedPayment(
        PaymentTransaction $transaction,
        ?PaymentMethod $alternativePaymentMethod = null
    ): PaymentResult;

    /**
     * Get subscription status and upcoming charges
     *
     * @param OrganizationSubscription $subscription
     * @return array Subscription details and upcoming invoice preview
     */
    public function getSubscriptionStatus(OrganizationSubscription $subscription): array;

    /**
     * Get payment history for an organization
     *
     * @param Organization $organization
     * @param int $limit Number of transactions to retrieve
     * @return \Illuminate\Support\Collection
     */
    public function getPaymentHistory(Organization $organization, int $limit = 50): \Illuminate\Support\Collection;

    /**
     * Validate webhook signature from payment gateway
     *
     * @param string $payload Webhook payload
     * @param string $signature Signature header from gateway
     * @param string $gateway Gateway identifier
     * @return bool
     */
    public function validateWebhookSignature(
        string $payload,
        string $signature,
        string $gateway
    ): bool;

    /**
     * Process webhook event from payment gateway
     *
     * @param array $event Webhook event data
     * @param string $gateway Gateway identifier
     * @return void
     * @throws \App\Exceptions\PaymentException
     */
    public function processWebhookEvent(array $event, string $gateway): void;
}
```

### DTO Classes

**File:** `app/DTOs/PaymentResult.php`

```php
<?php

namespace App\DTOs;

class PaymentResult
{
    public function __construct(
        public bool $success,
        public ?string $transactionId = null,
        public ?int $amountCents = null,
        public ?string $currency = 'USD',
        public ?string $status = null,
        public ?string $failureMessage = null,
        public ?string $failureCode = null,
        public ?array $metadata = [],
        public ?\Carbon\Carbon $processedAt = null
    ) {
        $this->processedAt = $this->processedAt ?? now();
    }

    public function isSuccessful(): bool
    {
        return $this->success;
    }

    public function isFailed(): bool
    {
        return !$this->success;
    }

    public function toArray(): array
    {
        return [
            'success' => $this->success,
            'transaction_id' => $this->transactionId,
            'amount_cents' => $this->amountCents,
            'currency' => $this->currency,
            'status' => $this->status,
            'failure_message' => $this->failureMessage,
            'failure_code' => $this->failureCode,
            'metadata' => $this->metadata,
            'processed_at' => $this->processedAt?->toIso8601String(),
        ];
    }
}
```

**File:** `app/DTOs/SubscriptionResult.php`

```php
<?php

namespace App\DTOs;

use App\Models\OrganizationSubscription;

class SubscriptionResult
{
    public function __construct(
        public bool $success,
        public ?OrganizationSubscription $subscription = null,
        public ?string $message = null,
        public ?string $errorCode = null,
        public ?array $metadata = []
    ) {
    }

    public function isSuccessful(): bool
    {
        return $this->success && $this->subscription !== null;
    }

    public function toArray(): array
    {
        return [
            'success' => $this->success,
            'subscription_id' => $this->subscription?->id,
            'status' => $this->subscription?->status,
            'message' => $this->message,
            'error_code' => $this->errorCode,
            'metadata' => $this->metadata,
        ];
    }
}
```

**File:** `app/DTOs/UsageBillingResult.php`

```php
<?php

namespace App\DTOs;

class UsageBillingResult
{
    public function __construct(
        public int $baseAmountCents,
        public int $usageAmountCents,
        public int $totalAmountCents,
        public array $usageMetrics = [],
        public array $lineItems = [],
        public ?string $currency = 'USD'
    ) {
    }

    public function addLineItem(string $description, int $amountCents, array $metadata = []): void
    {
        $this->lineItems[] = [
            'description' => $description,
            'amount_cents' => $amountCents,
            'metadata' => $metadata,
        ];
    }

    public function toArray(): array
    {
        return [
            'base_amount_cents' => $this->baseAmountCents,
            'usage_amount_cents' => $this->usageAmountCents,
            'total_amount_cents' => $this->totalAmountCents,
            'usage_metrics' => $this->usageMetrics,
            'line_items' => $this->lineItems,
            'currency' => $this->currency,
        ];
    }
}
```

### Service Implementation

**File:** `app/Services/Enterprise/PaymentService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\PaymentServiceInterface;
use App\Services\Enterprise\Gateways\PaymentGatewayFactory;
use App\Models\Organization;
use App\Models\OrganizationSubscription;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use App\Models\Invoice;
use App\DTOs\PaymentResult;
use App\DTOs\SubscriptionResult;
use App\DTOs\UsageBillingResult;
use App\Exceptions\PaymentException;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Cache;
use Carbon\Carbon;

class PaymentService implements PaymentServiceInterface
{
    private const RETRY_DELAYS = [1, 3, 7]; // Days between retry attempts
    private const MAX_RETRY_ATTEMPTS = 3;
    private const CACHE_TTL = 3600; // 1 hour

    public function __construct(
        private PaymentGatewayFactory $gatewayFactory
    ) {
    }

    /**
     * Create a new subscription for an organization
     */
    public function createSubscription(
        Organization $organization,
        string $planId,
        ?PaymentMethod $paymentMethod = null,
        array $options = []
    ): SubscriptionResult {
        Log::info('Creating subscription', [
            'organization_id' => $organization->id,
            'plan_id' => $planId,
            'options' => $options,
        ]);

        try {
            DB::beginTransaction();

            // Validate organization doesn't have active subscription
            if ($organization->activeSubscription()) {
                throw new PaymentException('Organization already has an active subscription');
            }

            // Use default payment method if none provided
            if (!$paymentMethod) {
                $paymentMethod = $organization->defaultPaymentMethod();

                if (!$paymentMethod) {
                    throw new PaymentException('No payment method available');
                }
            }

            // Get payment gateway
            $gateway = $this->gatewayFactory->make($paymentMethod->gateway);

            // Fetch plan details from configuration
            $plan = $this->getPlanConfig($planId);

            if (!$plan) {
                throw new PaymentException("Plan not found: {$planId}");
            }

            // Create subscription via gateway
            $gatewaySubscription = $gateway->createSubscription(
                $paymentMethod,
                $plan,
                $options
            );

            // Create local subscription record
            $subscription = OrganizationSubscription::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => $paymentMethod->gateway,
                'gateway_subscription_id' => $gatewaySubscription['id'],
                'plan_id' => $planId,
                'plan_name' => $plan['name'],
                'status' => $gatewaySubscription['status'],
                'current_period_start' => $gatewaySubscription['current_period_start'],
                'current_period_end' => $gatewaySubscription['current_period_end'],
                'billing_cycle' => $plan['billing_cycle'],
                'amount_cents' => $plan['price_cents'],
                'currency' => $plan['currency'] ?? 'USD',
                'trial_ends_at' => $options['trial_days'] ?? 0 > 0
                    ? now()->addDays($options['trial_days'])
                    : null,
                'metadata' => array_merge($options, [
                    'gateway_data' => $gatewaySubscription,
                ]),
            ]);

            // Update organization's active subscription
            $organization->update([
                'active_subscription_id' => $subscription->id,
            ]);

            // Activate features based on plan
            $this->activatePlanFeatures($organization, $plan);

            DB::commit();

            Log::info('Subscription created successfully', [
                'subscription_id' => $subscription->id,
                'gateway_subscription_id' => $gatewaySubscription['id'],
            ]);

            return new SubscriptionResult(
                success: true,
                subscription: $subscription,
                message: 'Subscription created successfully'
            );

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Subscription creation failed', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to create subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Update an existing subscription
     */
    public function updateSubscription(
        OrganizationSubscription $subscription,
        array $updates,
        bool $prorate = true
    ): SubscriptionResult {
        Log::info('Updating subscription', [
            'subscription_id' => $subscription->id,
            'updates' => $updates,
            'prorate' => $prorate,
        ]);

        try {
            DB::beginTransaction();

            $gateway = $this->gatewayFactory->make($subscription->gateway);

            // Update subscription via gateway
            $gatewaySubscription = $gateway->updateSubscription(
                $subscription->gateway_subscription_id,
                $updates,
                $prorate
            );

            // Update local record
            $updateData = [
                'status' => $gatewaySubscription['status'],
                'current_period_start' => $gatewaySubscription['current_period_start'],
                'current_period_end' => $gatewaySubscription['current_period_end'],
            ];

            if (isset($updates['plan_id'])) {
                $plan = $this->getPlanConfig($updates['plan_id']);
                $updateData['plan_id'] = $updates['plan_id'];
                $updateData['plan_name'] = $plan['name'];
                $updateData['amount_cents'] = $plan['price_cents'];

                // Update plan features
                $this->activatePlanFeatures($subscription->organization, $plan);
            }

            if (isset($updates['quantity'])) {
                $updateData['quantity'] = $updates['quantity'];
            }

            $subscription->update($updateData);

            DB::commit();

            Log::info('Subscription updated successfully', [
                'subscription_id' => $subscription->id,
            ]);

            return new SubscriptionResult(
                success: true,
                subscription: $subscription->fresh(),
                message: 'Subscription updated successfully'
            );

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Subscription update failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to update subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Pause a subscription
     */
    public function pauseSubscription(
        OrganizationSubscription $subscription,
        ?string $resumeAt = null
    ): bool {
        Log::info('Pausing subscription', [
            'subscription_id' => $subscription->id,
            'resume_at' => $resumeAt,
        ]);

        try {
            $gateway = $this->gatewayFactory->make($subscription->gateway);

            // Pause via gateway
            $gateway->pauseSubscription(
                $subscription->gateway_subscription_id,
                $resumeAt
            );

            // Update local status
            $subscription->update([
                'status' => 'paused',
                'paused_at' => now(),
                'resume_at' => $resumeAt ? Carbon::parse($resumeAt) : null,
            ]);

            // Optionally deactivate features during pause
            // $this->deactivatePlanFeatures($subscription->organization);

            Log::info('Subscription paused successfully', [
                'subscription_id' => $subscription->id,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Subscription pause failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to pause subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Resume a paused subscription
     */
    public function resumeSubscription(OrganizationSubscription $subscription): bool
    {
        Log::info('Resuming subscription', [
            'subscription_id' => $subscription->id,
        ]);

        try {
            $gateway = $this->gatewayFactory->make($subscription->gateway);

            // Resume via gateway
            $gateway->resumeSubscription($subscription->gateway_subscription_id);

            // Update local status
            $subscription->update([
                'status' => 'active',
                'paused_at' => null,
                'resume_at' => null,
            ]);

            // Reactivate features
            $plan = $this->getPlanConfig($subscription->plan_id);
            $this->activatePlanFeatures($subscription->organization, $plan);

            Log::info('Subscription resumed successfully', [
                'subscription_id' => $subscription->id,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error('Subscription resume failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to resume subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Cancel a subscription
     */
    public function cancelSubscription(
        OrganizationSubscription $subscription,
        bool $immediately = false,
        ?string $reason = null
    ): bool {
        Log::info('Cancelling subscription', [
            'subscription_id' => $subscription->id,
            'immediately' => $immediately,
            'reason' => $reason,
        ]);

        try {
            DB::beginTransaction();

            $gateway = $this->gatewayFactory->make($subscription->gateway);

            // Cancel via gateway
            $gateway->cancelSubscription(
                $subscription->gateway_subscription_id,
                $immediately
            );

            // Update local record
            $updateData = [
                'status' => $immediately ? 'cancelled' : 'cancelling',
                'cancellation_reason' => $reason,
                'cancelled_at' => $immediately ? now() : null,
                'cancel_at_period_end' => !$immediately,
            ];

            if ($immediately) {
                $updateData['ends_at'] = now();

                // Deactivate features immediately
                $this->deactivatePlanFeatures($subscription->organization);

                // Clear organization's active subscription
                $subscription->organization->update([
                    'active_subscription_id' => null,
                ]);
            } else {
                $updateData['ends_at'] = $subscription->current_period_end;
            }

            $subscription->update($updateData);

            DB::commit();

            Log::info('Subscription cancelled successfully', [
                'subscription_id' => $subscription->id,
                'immediately' => $immediately,
            ]);

            return true;

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Subscription cancellation failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to cancel subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Process a one-time payment
     */
    public function processPayment(
        Organization $organization,
        int $amountCents,
        PaymentMethod $paymentMethod,
        array $metadata = []
    ): PaymentResult {
        Log::info('Processing one-time payment', [
            'organization_id' => $organization->id,
            'amount_cents' => $amountCents,
            'payment_method_id' => $paymentMethod->id,
        ]);

        try {
            DB::beginTransaction();

            $gateway = $this->gatewayFactory->make($paymentMethod->gateway);

            // Generate idempotency key
            $idempotencyKey = $metadata['idempotency_key'] ??
                'payment_' . $organization->id . '_' . time() . '_' . uniqid();

            // Process payment via gateway
            $gatewayResult = $gateway->processPayment(
                $paymentMethod,
                $amountCents,
                array_merge($metadata, [
                    'idempotency_key' => $idempotencyKey,
                    'customer_id' => $organization->id,
                ])
            );

            // Create transaction record
            $transaction = PaymentTransaction::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => $paymentMethod->gateway,
                'gateway_transaction_id' => $gatewayResult['id'],
                'type' => 'payment',
                'amount_cents' => $amountCents,
                'currency' => $metadata['currency'] ?? 'USD',
                'status' => $gatewayResult['status'],
                'description' => $metadata['description'] ?? 'One-time payment',
                'metadata' => array_merge($metadata, [
                    'gateway_data' => $gatewayResult,
                ]),
                'idempotency_key' => $idempotencyKey,
                'processed_at' => now(),
            ]);

            DB::commit();

            Log::info('Payment processed successfully', [
                'transaction_id' => $transaction->id,
                'gateway_transaction_id' => $gatewayResult['id'],
            ]);

            return new PaymentResult(
                success: true,
                transactionId: $transaction->id,
                amountCents: $amountCents,
                currency: $transaction->currency,
                status: $gatewayResult['status'],
                metadata: $metadata,
                processedAt: $transaction->processed_at
            );

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Payment processing failed', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
            ]);

            // Create failed transaction record for audit
            PaymentTransaction::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => $paymentMethod->gateway,
                'type' => 'payment',
                'amount_cents' => $amountCents,
                'currency' => $metadata['currency'] ?? 'USD',
                'status' => 'failed',
                'description' => $metadata['description'] ?? 'One-time payment',
                'error_message' => $e->getMessage(),
                'metadata' => $metadata,
                'processed_at' => now(),
            ]);

            return new PaymentResult(
                success: false,
                amountCents: $amountCents,
                status: 'failed',
                failureMessage: $e->getMessage(),
                failureCode: $e->getCode()
            );
        }
    }

    /**
     * Refund a payment
     */
    public function refundPayment(
        PaymentTransaction $transaction,
        ?int $amountCents = null,
        ?string $reason = null
    ): PaymentResult {
        Log::info('Processing refund', [
            'transaction_id' => $transaction->id,
            'amount_cents' => $amountCents,
            'reason' => $reason,
        ]);

        try {
            DB::beginTransaction();

            if ($transaction->status !== 'succeeded') {
                throw new PaymentException('Can only refund successful transactions');
            }

            // Default to full refund
            $refundAmount = $amountCents ?? $transaction->amount_cents;

            if ($refundAmount > $transaction->amount_cents) {
                throw new PaymentException('Refund amount exceeds original transaction amount');
            }

            $gateway = $this->gatewayFactory->make($transaction->gateway);

            // Process refund via gateway
            $gatewayRefund = $gateway->refundPayment(
                $transaction->gateway_transaction_id,
                $refundAmount,
                $reason
            );

            // Create refund transaction record
            $refundTransaction = PaymentTransaction::create([
                'organization_id' => $transaction->organization_id,
                'payment_method_id' => $transaction->payment_method_id,
                'parent_transaction_id' => $transaction->id,
                'gateway' => $transaction->gateway,
                'gateway_transaction_id' => $gatewayRefund['id'],
                'type' => 'refund',
                'amount_cents' => -$refundAmount, // Negative for refunds
                'currency' => $transaction->currency,
                'status' => $gatewayRefund['status'],
                'description' => "Refund: {$reason}",
                'metadata' => [
                    'gateway_data' => $gatewayRefund,
                    'original_transaction_id' => $transaction->id,
                    'reason' => $reason,
                ],
                'processed_at' => now(),
            ]);

            // Update original transaction
            $transaction->update([
                'refunded' => true,
                'refunded_amount_cents' => ($transaction->refunded_amount_cents ?? 0) + $refundAmount,
                'refunded_at' => now(),
            ]);

            DB::commit();

            Log::info('Refund processed successfully', [
                'refund_transaction_id' => $refundTransaction->id,
                'original_transaction_id' => $transaction->id,
            ]);

            return new PaymentResult(
                success: true,
                transactionId: $refundTransaction->id,
                amountCents: $refundAmount,
                currency: $transaction->currency,
                status: $gatewayRefund['status']
            );

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Refund processing failed', [
                'transaction_id' => $transaction->id,
                'error' => $e->getMessage(),
            ]);

            return new PaymentResult(
                success: false,
                amountCents: $refundAmount ?? 0,
                status: 'failed',
                failureMessage: $e->getMessage()
            );
        }
    }

    /**
     * Add a payment method to an organization
     */
    public function addPaymentMethod(
        Organization $organization,
        string $gatewayToken,
        string $gateway,
        bool $setAsDefault = false
    ): PaymentMethod {
        Log::info('Adding payment method', [
            'organization_id' => $organization->id,
            'gateway' => $gateway,
        ]);

        try {
            DB::beginTransaction();

            $gatewayInstance = $this->gatewayFactory->make($gateway);

            // Create payment method via gateway
            $gatewayPaymentMethod = $gatewayInstance->createPaymentMethod(
                $gatewayToken,
                $organization
            );

            // Create local payment method record
            $paymentMethod = PaymentMethod::create([
                'organization_id' => $organization->id,
                'gateway' => $gateway,
                'gateway_payment_method_id' => $gatewayPaymentMethod['id'],
                'type' => $gatewayPaymentMethod['type'], // card, bank_account, paypal
                'last_four' => $gatewayPaymentMethod['last_four'] ?? null,
                'brand' => $gatewayPaymentMethod['brand'] ?? null,
                'exp_month' => $gatewayPaymentMethod['exp_month'] ?? null,
                'exp_year' => $gatewayPaymentMethod['exp_year'] ?? null,
                'is_default' => $setAsDefault || $organization->paymentMethods()->count() === 0,
                'metadata' => [
                    'gateway_data' => $gatewayPaymentMethod,
                ],
            ]);

            // Update default if requested
            if ($setAsDefault) {
                $this->setDefaultPaymentMethod($organization, $paymentMethod);
            }

            DB::commit();

            Log::info('Payment method added successfully', [
                'payment_method_id' => $paymentMethod->id,
            ]);

            return $paymentMethod;

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Payment method creation failed', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to add payment method: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Remove a payment method
     */
    public function removePaymentMethod(
        PaymentMethod $paymentMethod,
        bool $force = false
    ): bool {
        Log::info('Removing payment method', [
            'payment_method_id' => $paymentMethod->id,
            'force' => $force,
        ]);

        try {
            DB::beginTransaction();

            // Check for active subscriptions using this payment method
            if (!$force && $paymentMethod->activeSubscriptions()->exists()) {
                throw new PaymentException(
                    'Cannot remove payment method with active subscriptions. Update subscription payment methods first or use force=true.'
                );
            }

            $gateway = $this->gatewayFactory->make($paymentMethod->gateway);

            // Delete from gateway
            $gateway->deletePaymentMethod($paymentMethod->gateway_payment_method_id);

            // Soft delete local record
            $paymentMethod->delete();

            DB::commit();

            Log::info('Payment method removed successfully', [
                'payment_method_id' => $paymentMethod->id,
            ]);

            return true;

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Payment method removal failed', [
                'payment_method_id' => $paymentMethod->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to remove payment method: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Set the default payment method for an organization
     */
    public function setDefaultPaymentMethod(
        Organization $organization,
        PaymentMethod $paymentMethod
    ): bool {
        if ($paymentMethod->organization_id !== $organization->id) {
            throw new PaymentException('Payment method does not belong to this organization');
        }

        DB::transaction(function () use ($organization, $paymentMethod) {
            // Clear existing default
            $organization->paymentMethods()->update(['is_default' => false]);

            // Set new default
            $paymentMethod->update(['is_default' => true]);
        });

        return true;
    }

    /**
     * Calculate usage-based billing charges
     */
    public function calculateUsageBilling(
        OrganizationSubscription $subscription,
        Carbon $periodStart,
        Carbon $periodEnd
    ): UsageBillingResult {
        Log::info('Calculating usage billing', [
            'subscription_id' => $subscription->id,
            'period_start' => $periodStart->toDateString(),
            'period_end' => $periodEnd->toDateString(),
        ]);

        $plan = $this->getPlanConfig($subscription->plan_id);
        $baseAmount = $plan['price_cents'];

        // Fetch usage metrics from organization_resource_usage table
        $usage = DB::table('organization_resource_usage')
            ->where('organization_id', $subscription->organization_id)
            ->whereBetween('created_at', [$periodStart, $periodEnd])
            ->first();

        $usageMetrics = [
            'servers' => $usage->server_count ?? 0,
            'applications' => $usage->application_count ?? 0,
            'deployments' => $usage->deployment_count ?? 0,
            'storage_gb' => $usage->storage_used_gb ?? 0,
            'bandwidth_gb' => $usage->bandwidth_used_gb ?? 0,
        ];

        $result = new UsageBillingResult(
            baseAmountCents: $baseAmount,
            usageAmountCents: 0,
            totalAmountCents: $baseAmount,
            usageMetrics: $usageMetrics,
            currency: $subscription->currency
        );

        // Calculate overages
        if (isset($plan['limits'])) {
            foreach ($plan['limits'] as $metric => $limit) {
                $actualUsage = $usageMetrics[$metric] ?? 0;

                if ($actualUsage > $limit['included']) {
                    $overage = $actualUsage - $limit['included'];
                    $overageCost = $overage * ($limit['overage_price_cents'] ?? 0);

                    $result->usageAmountCents += $overageCost;
                    $result->addLineItem(
                        description: "{$metric} overage ({$overage} units)",
                        amountCents: $overageCost,
                        metadata: [
                            'metric' => $metric,
                            'included' => $limit['included'],
                            'actual' => $actualUsage,
                            'overage' => $overage,
                        ]
                    );
                }
            }
        }

        $result->totalAmountCents = $result->baseAmountCents + $result->usageAmountCents;

        Log::info('Usage billing calculated', [
            'base_amount' => $result->baseAmountCents,
            'usage_amount' => $result->usageAmountCents,
            'total_amount' => $result->totalAmountCents,
        ]);

        return $result;
    }

    /**
     * Generate an invoice for a billing period
     */
    public function generateInvoice(
        Organization $organization,
        Carbon $periodStart,
        Carbon $periodEnd,
        array $lineItems = []
    ): Invoice {
        Log::info('Generating invoice', [
            'organization_id' => $organization->id,
            'period_start' => $periodStart->toDateString(),
            'period_end' => $periodEnd->toDateString(),
        ]);

        $subscription = $organization->activeSubscription();

        if (!$subscription) {
            throw new PaymentException('Organization has no active subscription');
        }

        // Calculate usage billing
        $billing = $this->calculateUsageBilling($subscription, $periodStart, $periodEnd);

        // Merge line items
        $allLineItems = array_merge($billing->lineItems, $lineItems);

        // Create invoice
        $invoice = Invoice::create([
            'organization_id' => $organization->id,
            'subscription_id' => $subscription->id,
            'invoice_number' => $this->generateInvoiceNumber($organization),
            'status' => 'pending',
            'period_start' => $periodStart,
            'period_end' => $periodEnd,
            'subtotal_cents' => $billing->baseAmountCents,
            'tax_cents' => 0, // TODO: Calculate tax based on organization location
            'total_cents' => $billing->totalAmountCents,
            'currency' => $subscription->currency,
            'line_items' => $allLineItems,
            'metadata' => [
                'usage_metrics' => $billing->usageMetrics,
            ],
            'due_date' => now()->addDays(config('payment.invoice_due_days', 7)),
        ]);

        Log::info('Invoice generated', [
            'invoice_id' => $invoice->id,
            'invoice_number' => $invoice->invoice_number,
            'total_cents' => $invoice->total_cents,
        ]);

        return $invoice;
    }

    /**
     * Retry a failed payment
     */
    public function retryFailedPayment(
        PaymentTransaction $transaction,
        ?PaymentMethod $alternativePaymentMethod = null
    ): PaymentResult {
        Log::info('Retrying failed payment', [
            'transaction_id' => $transaction->id,
            'retry_count' => $transaction->retry_count ?? 0,
        ]);

        if ($transaction->status === 'succeeded') {
            throw new PaymentException('Transaction already succeeded');
        }

        // Check retry limit
        $retryCount = $transaction->retry_count ?? 0;

        if ($retryCount >= self::MAX_RETRY_ATTEMPTS) {
            throw new PaymentException('Maximum retry attempts exceeded');
        }

        // Use alternative payment method if provided
        $paymentMethod = $alternativePaymentMethod ?? $transaction->paymentMethod;

        if (!$paymentMethod) {
            throw new PaymentException('No payment method available for retry');
        }

        // Retry payment
        $result = $this->processPayment(
            $transaction->organization,
            $transaction->amount_cents,
            $paymentMethod,
            array_merge($transaction->metadata ?? [], [
                'retry_attempt' => $retryCount + 1,
                'original_transaction_id' => $transaction->id,
            ])
        );

        // Update original transaction
        $transaction->update([
            'retry_count' => $retryCount + 1,
            'last_retry_at' => now(),
        ]);

        return $result;
    }

    /**
     * Get subscription status and upcoming charges
     */
    public function getSubscriptionStatus(OrganizationSubscription $subscription): array
    {
        $gateway = $this->gatewayFactory->make($subscription->gateway);

        // Get upcoming invoice preview from gateway
        $upcomingInvoice = $gateway->getUpcomingInvoice($subscription->gateway_subscription_id);

        return [
            'id' => $subscription->id,
            'status' => $subscription->status,
            'plan' => $subscription->plan_name,
            'current_period_start' => $subscription->current_period_start->toIso8601String(),
            'current_period_end' => $subscription->current_period_end->toIso8601String(),
            'cancel_at_period_end' => $subscription->cancel_at_period_end,
            'upcoming_invoice' => $upcomingInvoice,
            'payment_method' => [
                'id' => $subscription->paymentMethod->id,
                'type' => $subscription->paymentMethod->type,
                'last_four' => $subscription->paymentMethod->last_four,
            ],
        ];
    }

    /**
     * Get payment history for an organization
     */
    public function getPaymentHistory(Organization $organization, int $limit = 50): \Illuminate\Support\Collection
    {
        return PaymentTransaction::query()
            ->where('organization_id', $organization->id)
            ->with('paymentMethod')
            ->orderByDesc('created_at')
            ->limit($limit)
            ->get();
    }

    /**
     * Validate webhook signature from payment gateway
     */
    public function validateWebhookSignature(
        string $payload,
        string $signature,
        string $gateway
    ): bool {
        try {
            $gatewayInstance = $this->gatewayFactory->make($gateway);
            return $gatewayInstance->validateWebhookSignature($payload, $signature);
        } catch (\Exception $e) {
            Log::error('Webhook signature validation failed', [
                'gateway' => $gateway,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Process webhook event from payment gateway
     */
    public function processWebhookEvent(array $event, string $gateway): void
    {
        Log::info('Processing webhook event', [
            'gateway' => $gateway,
            'event_type' => $event['type'] ?? 'unknown',
            'event_id' => $event['id'] ?? 'unknown',
        ]);

        $gatewayInstance = $this->gatewayFactory->make($gateway);
        $gatewayInstance->handleWebhookEvent($event);
    }

    // Private helper methods

    private function getPlanConfig(string $planId): ?array
    {
        $cacheKey = "payment:plan:{$planId}";

        return Cache::remember($cacheKey, self::CACHE_TTL, function () use ($planId) {
            $plans = config('payment.plans', []);
            return $plans[$planId] ?? null;
        });
    }

    private function activatePlanFeatures(Organization $organization, array $plan): void
    {
        if (!isset($plan['features'])) {
            return;
        }

        // Update organization's license with plan features
        $license = $organization->enterpriseLicense;

        if ($license) {
            $license->update([
                'features' => array_merge($license->features ?? [], $plan['features']),
            ]);
        }

        // Clear feature cache
        Cache::forget("license:{$organization->id}:features");

        Log::info('Plan features activated', [
            'organization_id' => $organization->id,
            'plan_id' => $plan['id'],
            'features' => $plan['features'],
        ]);
    }

    private function deactivatePlanFeatures(Organization $organization): void
    {
        $license = $organization->enterpriseLicense;

        if ($license) {
            // Reset to free plan features
            $freePlan = $this->getPlanConfig('free');
            $license->update([
                'features' => $freePlan['features'] ?? [],
            ]);
        }

        // Clear feature cache
        Cache::forget("license:{$organization->id}:features");

        Log::info('Plan features deactivated', [
            'organization_id' => $organization->id,
        ]);
    }

    private function generateInvoiceNumber(Organization $organization): string
    {
        $prefix = config('payment.invoice_prefix', 'INV');
        $year = now()->year;
        $month = now()->format('m');

        // Get count of invoices this month
        $count = Invoice::query()
            ->where('organization_id', $organization->id)
            ->whereYear('created_at', $year)
            ->whereMonth('created_at', $month)
            ->count() + 1;

        return sprintf('%s-%s%s-%04d', $prefix, $year, $month, $count);
    }
}
```

### Configuration File

**File:** `config/payment.php`

```php
<?php

return [
    // Default payment gateway
    'default_gateway' => env('PAYMENT_DEFAULT_GATEWAY', 'stripe'),

    // Supported gateways
    'gateways' => [
        'stripe' => [
            'enabled' => env('STRIPE_ENABLED', true),
            'secret_key' => env('STRIPE_SECRET_KEY'),
            'publishable_key' => env('STRIPE_PUBLISHABLE_KEY'),
            'webhook_secret' => env('STRIPE_WEBHOOK_SECRET'),
        ],
        'paypal' => [
            'enabled' => env('PAYPAL_ENABLED', false),
            'client_id' => env('PAYPAL_CLIENT_ID'),
            'secret' => env('PAYPAL_SECRET'),
            'mode' => env('PAYPAL_MODE', 'sandbox'), // sandbox or live
            'webhook_id' => env('PAYPAL_WEBHOOK_ID'),
        ],
    ],

    // Subscription plans
    'plans' => [
        'free' => [
            'id' => 'free',
            'name' => 'Free',
            'price_cents' => 0,
            'billing_cycle' => 'monthly',
            'currency' => 'USD',
            'features' => [
                'max_servers' => 1,
                'max_applications' => 5,
                'max_deployments_per_month' => 10,
            ],
            'limits' => [],
        ],
        'starter-monthly' => [
            'id' => 'starter-monthly',
            'name' => 'Starter (Monthly)',
            'price_cents' => 2900, // $29/month
            'billing_cycle' => 'monthly',
            'currency' => 'USD',
            'features' => [
                'max_servers' => 5,
                'max_applications' => 25,
                'max_deployments_per_month' => 100,
                'white_label' => true,
            ],
            'limits' => [
                'servers' => [
                    'included' => 5,
                    'overage_price_cents' => 500, // $5 per additional server
                ],
                'storage_gb' => [
                    'included' => 100,
                    'overage_price_cents' => 10, // $0.10 per GB
                ],
            ],
        ],
        'pro-monthly' => [
            'id' => 'pro-monthly',
            'name' => 'Pro (Monthly)',
            'price_cents' => 9900, // $99/month
            'billing_cycle' => 'monthly',
            'currency' => 'USD',
            'features' => [
                'max_servers' => 25,
                'max_applications' => 100,
                'max_deployments_per_month' => 500,
                'white_label' => true,
                'terraform_provisioning' => true,
                'advanced_deployments' => true,
            ],
            'limits' => [
                'servers' => [
                    'included' => 25,
                    'overage_price_cents' => 400, // $4 per additional server
                ],
                'storage_gb' => [
                    'included' => 500,
                    'overage_price_cents' => 8, // $0.08 per GB
                ],
            ],
        ],
        'enterprise-monthly' => [
            'id' => 'enterprise-monthly',
            'name' => 'Enterprise (Monthly)',
            'price_cents' => 29900, // $299/month
            'billing_cycle' => 'monthly',
            'currency' => 'USD',
            'features' => [
                'max_servers' => -1, // Unlimited
                'max_applications' => -1,
                'max_deployments_per_month' => -1,
                'white_label' => true,
                'terraform_provisioning' => true,
                'advanced_deployments' => true,
                'priority_support' => true,
                'dedicated_account_manager' => true,
            ],
            'limits' => [
                'servers' => [
                    'included' => 100,
                    'overage_price_cents' => 300, // $3 per additional server
                ],
                'storage_gb' => [
                    'included' => 2000,
                    'overage_price_cents' => 5, // $0.05 per GB
                ],
            ],
        ],
    ],

    // Payment retry configuration
    'retry_delays_days' => [1, 3, 7],
    'max_retry_attempts' => 3,

    // Invoice settings
    'invoice_prefix' => env('PAYMENT_INVOICE_PREFIX', 'INV'),
    'invoice_due_days' => env('PAYMENT_INVOICE_DUE_DAYS', 7),

    // Currency settings
    'default_currency' => env('PAYMENT_DEFAULT_CURRENCY', 'USD'),
    'supported_currencies' => ['USD', 'EUR', 'GBP', 'CAD', 'AUD'],
];
```

### Exception Class

**File:** `app/Exceptions/PaymentException.php`

```php
<?php

namespace App\Exceptions;

class PaymentException extends \Exception
{
    public function __construct(
        string $message = "",
        int $code = 0,
        ?\Throwable $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }

    public function report(): void
    {
        \Log::error('Payment error occurred', [
            'message' => $this->getMessage(),
            'code' => $this->getCode(),
            'file' => $this->getFile(),
            'line' => $this->getLine(),
        ]);
    }
}
```

## Implementation Approach

### Step 1: Create DTOs
1. Create `PaymentResult`, `SubscriptionResult`, `UsageBillingResult` DTOs
2. Define all properties with proper type hints
3. Add helper methods (isSuccessful(), toArray())

### Step 2: Create Service Interface
1. Create `app/Contracts/PaymentServiceInterface.php`
2. Define all public method signatures
3. Document each method with comprehensive PHPDoc blocks

### Step 3: Create Configuration File
1. Create `config/payment.php` with all settings
2. Define subscription plans with pricing and features
3. Configure gateway settings and retry logic
4. Add environment variables to `.env.example`

### Step 4: Create Exception Class
1. Create `app/Exceptions/PaymentException.php`
2. Add custom error reporting logic
3. Integrate with Laravel's exception handler

### Step 5: Implement Service Class (Core Methods)
1. Create `app/Services/Enterprise/PaymentService.php`
2. Implement constructor with `PaymentGatewayFactory` injection
3. Implement `createSubscription()` with full workflow
4. Implement `updateSubscription()` with prorated billing
5. Implement `pauseSubscription()` and `resumeSubscription()`
6. Implement `cancelSubscription()` with immediate/period-end options

### Step 6: Implement Payment Processing
1. Implement `processPayment()` with idempotency support
2. Implement `refundPayment()` with partial refund capability
3. Add transaction logging for audit trail
4. Implement retry logic with exponential backoff

### Step 7: Implement Payment Method Management
1. Implement `addPaymentMethod()` with tokenization
2. Implement `removePaymentMethod()` with orphan checks
3. Implement `setDefaultPaymentMethod()`
4. Add validation and error handling

### Step 8: Implement Usage-Based Billing
1. Implement `calculateUsageBilling()` with overage calculation
2. Integrate with `organization_resource_usage` table
3. Implement line item generation for invoices
4. Add usage metrics aggregation

### Step 9: Implement Invoice Generation
1. Implement `generateInvoice()` method
2. Create invoice numbering system
3. Add line items, taxes, and metadata
4. Integrate with subscription billing cycle

### Step 10: Implement Helper Methods
1. Implement `retryFailedPayment()` with retry limits
2. Implement `getSubscriptionStatus()` with upcoming invoice preview
3. Implement `getPaymentHistory()` for transaction list
4. Implement webhook validation and processing

### Step 11: Feature Activation Integration
1. Implement `activatePlanFeatures()` method
2. Implement `deactivatePlanFeatures()` method
3. Integrate with `EnterpriseLicense` model
4. Add feature cache invalidation

### Step 12: Register Service
1. Add service binding in `EnterpriseServiceProvider`
2. Configure singleton binding for service instance
3. Add facade if needed

### Step 13: Testing
1. Unit tests for all public methods
2. Mock payment gateway responses
3. Test subscription lifecycle (create, update, cancel)
4. Test payment processing and refunds
5. Test usage billing calculations
6. Integration tests with complete workflows

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/PaymentServiceTest.php`

```php
<?php

use App\Services\Enterprise\PaymentService;
use App\Services\Enterprise\Gateways\PaymentGatewayFactory;
use App\Models\Organization;
use App\Models\OrganizationSubscription;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

beforeEach(function () {
    $this->gatewayFactory = $this->mock(PaymentGatewayFactory::class);
    $this->service = new PaymentService($this->gatewayFactory);
});

it('creates subscription successfully', function () {
    $organization = Organization::factory()->create();
    $paymentMethod = PaymentMethod::factory()->stripe()->create([
        'organization_id' => $organization->id,
    ]);

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('createSubscription')
        ->once()
        ->andReturn([
            'id' => 'sub_123',
            'status' => 'active',
            'current_period_start' => now(),
            'current_period_end' => now()->addMonth(),
        ]);

    $this->gatewayFactory->shouldReceive('make')
        ->with('stripe')
        ->andReturn($mockGateway);

    $result = $this->service->createSubscription(
        $organization,
        'starter-monthly',
        $paymentMethod
    );

    expect($result->isSuccessful())->toBeTrue()
        ->and($result->subscription)->not->toBeNull()
        ->and($result->subscription->status)->toBe('active');
});

it('processes one-time payment successfully', function () {
    $organization = Organization::factory()->create();
    $paymentMethod = PaymentMethod::factory()->stripe()->create([
        'organization_id' => $organization->id,
    ]);

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('processPayment')
        ->once()
        ->andReturn([
            'id' => 'ch_123',
            'status' => 'succeeded',
        ]);

    $this->gatewayFactory->shouldReceive('make')
        ->with('stripe')
        ->andReturn($mockGateway);

    $result = $this->service->processPayment(
        $organization,
        5000, // $50.00
        $paymentMethod,
        ['description' => 'Test payment']
    );

    expect($result->isSuccessful())->toBeTrue()
        ->and($result->amountCents)->toBe(5000)
        ->and($result->status)->toBe('succeeded');

    // Verify transaction was created
    $this->assertDatabaseHas('payment_transactions', [
        'organization_id' => $organization->id,
        'amount_cents' => 5000,
        'status' => 'succeeded',
    ]);
});

it('handles payment failures gracefully', function () {
    $organization = Organization::factory()->create();
    $paymentMethod = PaymentMethod::factory()->stripe()->create([
        'organization_id' => $organization->id,
    ]);

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('processPayment')
        ->once()
        ->andThrow(new \Exception('Card declined'));

    $this->gatewayFactory->shouldReceive('make')
        ->with('stripe')
        ->andReturn($mockGateway);

    $result = $this->service->processPayment(
        $organization,
        5000,
        $paymentMethod
    );

    expect($result->isFailed())->toBeTrue()
        ->and($result->failureMessage)->toContain('Card declined');

    // Verify failed transaction was logged
    $this->assertDatabaseHas('payment_transactions', [
        'organization_id' => $organization->id,
        'status' => 'failed',
    ]);
});

it('calculates usage billing correctly', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'plan_id' => 'starter-monthly',
        'amount_cents' => 2900,
    ]);

    // Create usage data
    DB::table('organization_resource_usage')->insert([
        'organization_id' => $organization->id,
        'server_count' => 7, // 2 over limit
        'storage_used_gb' => 120, // 20 GB over limit
        'created_at' => now(),
        'updated_at' => now(),
    ]);

    $billing = $this->service->calculateUsageBilling(
        $subscription,
        now()->startOfMonth(),
        now()->endOfMonth()
    );

    expect($billing->baseAmountCents)->toBe(2900)
        ->and($billing->usageAmountCents)->toBeGreaterThan(0)
        ->and($billing->totalAmountCents)->toBe($billing->baseAmountCents + $billing->usageAmountCents)
        ->and($billing->lineItems)->toHaveCount(2); // 2 overage items
});

it('refunds payment successfully', function () {
    $transaction = PaymentTransaction::factory()->create([
        'amount_cents' => 10000,
        'status' => 'succeeded',
    ]);

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('refundPayment')
        ->once()
        ->andReturn([
            'id' => 'ref_123',
            'status' => 'succeeded',
        ]);

    $this->gatewayFactory->shouldReceive('make')
        ->with($transaction->gateway)
        ->andReturn($mockGateway);

    $result = $this->service->refundPayment(
        $transaction,
        5000, // Partial refund
        'Customer request'
    );

    expect($result->isSuccessful())->toBeTrue()
        ->and($result->amountCents)->toBe(5000);

    // Verify refund transaction created
    $this->assertDatabaseHas('payment_transactions', [
        'type' => 'refund',
        'amount_cents' => -5000,
        'parent_transaction_id' => $transaction->id,
    ]);

    // Verify original transaction updated
    expect($transaction->fresh()->refunded)->toBeTrue()
        ->and($transaction->fresh()->refunded_amount_cents)->toBe(5000);
});

it('adds payment method successfully', function () {
    $organization = Organization::factory()->create();

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('createPaymentMethod')
        ->once()
        ->andReturn([
            'id' => 'pm_123',
            'type' => 'card',
            'last_four' => '4242',
            'brand' => 'visa',
            'exp_month' => 12,
            'exp_year' => 2025,
        ]);

    $this->gatewayFactory->shouldReceive('make')
        ->with('stripe')
        ->andReturn($mockGateway);

    $paymentMethod = $this->service->addPaymentMethod(
        $organization,
        'tok_visa',
        'stripe',
        true // Set as default
    );

    expect($paymentMethod)->toBeInstanceOf(PaymentMethod::class)
        ->and($paymentMethod->is_default)->toBeTrue()
        ->and($paymentMethod->last_four)->toBe('4242');
});

it('sets default payment method correctly', function () {
    $organization = Organization::factory()->create();
    $pm1 = PaymentMethod::factory()->create([
        'organization_id' => $organization->id,
        'is_default' => true,
    ]);
    $pm2 = PaymentMethod::factory()->create([
        'organization_id' => $organization->id,
        'is_default' => false,
    ]);

    $this->service->setDefaultPaymentMethod($organization, $pm2);

    expect($pm1->fresh()->is_default)->toBeFalse()
        ->and($pm2->fresh()->is_default)->toBeTrue();
});

it('cancels subscription immediately', function () {
    $subscription = OrganizationSubscription::factory()->create([
        'status' => 'active',
    ]);

    $mockGateway = Mockery::mock();
    $mockGateway->shouldReceive('cancelSubscription')
        ->once()
        ->with($subscription->gateway_subscription_id, true);

    $this->gatewayFactory->shouldReceive('make')
        ->with($subscription->gateway)
        ->andReturn($mockGateway);

    $result = $this->service->cancelSubscription(
        $subscription,
        immediately: true,
        reason: 'Test cancellation'
    );

    expect($result)->toBeTrue()
        ->and($subscription->fresh()->status)->toBe('cancelled')
        ->and($subscription->fresh()->cancellation_reason)->toBe('Test cancellation');
});

it('generates invoice with line items', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'plan_id' => 'pro-monthly',
    ]);

    // Create usage data
    DB::table('organization_resource_usage')->insert([
        'organization_id' => $organization->id,
        'server_count' => 30, // 5 over limit
        'created_at' => now(),
        'updated_at' => now(),
    ]);

    $invoice = $this->service->generateInvoice(
        $organization,
        now()->startOfMonth(),
        now()->endOfMonth()
    );

    expect($invoice)->toBeInstanceOf(Invoice::class)
        ->and($invoice->status)->toBe('pending')
        ->and($invoice->total_cents)->toBeGreaterThan(9900) // Base price + overages
        ->and($invoice->line_items)->not->toBeEmpty();
});
```

### Integration Tests

**File:** `tests/Feature/PaymentProcessingTest.php`

```php
<?php

use App\Services\Enterprise\PaymentService;
use App\Models\Organization;
use App\Models\PaymentMethod;

it('completes full subscription lifecycle', function () {
    $service = app(PaymentService::class);
    $organization = Organization::factory()->create();

    // Mock gateway
    $this->mockPaymentGateway();

    // 1. Add payment method
    $paymentMethod = $service->addPaymentMethod(
        $organization,
        'tok_visa',
        'stripe'
    );

    expect($paymentMethod)->toBeInstanceOf(PaymentMethod::class);

    // 2. Create subscription
    $result = $service->createSubscription(
        $organization,
        'pro-monthly',
        $paymentMethod
    );

    expect($result->isSuccessful())->toBeTrue();
    $subscription = $result->subscription;

    // 3. Update subscription
    $updateResult = $service->updateSubscription(
        $subscription,
        ['plan_id' => 'enterprise-monthly']
    );

    expect($updateResult->isSuccessful())->toBeTrue();

    // 4. Cancel subscription
    $cancelled = $service->cancelSubscription(
        $subscription,
        immediately: false
    );

    expect($cancelled)->toBeTrue()
        ->and($subscription->fresh()->cancel_at_period_end)->toBeTrue();
});

it('processes payment with automatic retry on failure', function () {
    $service = app(PaymentService::class);
    $organization = Organization::factory()->create();
    $paymentMethod = PaymentMethod::factory()->create([
        'organization_id' => $organization->id,
    ]);

    // First attempt fails
    $this->mockPaymentGatewayFailure();

    $result = $service->processPayment(
        $organization,
        5000,
        $paymentMethod
    );

    expect($result->isFailed())->toBeTrue();

    $transaction = PaymentTransaction::where('organization_id', $organization->id)
        ->where('status', 'failed')
        ->first();

    // Retry with successful mock
    $this->mockPaymentGatewaySuccess();

    $retryResult = $service->retryFailedPayment($transaction);

    expect($retryResult->isSuccessful())->toBeTrue();
});
```

## Definition of Done

- [ ] PaymentServiceInterface created with all method signatures
- [ ] PaymentService implementation complete
- [ ] PaymentResult, SubscriptionResult, UsageBillingResult DTOs created
- [ ] PaymentException class created
- [ ] Configuration file created (`config/payment.php`)
- [ ] Subscription plans configured with pricing and features
- [ ] `createSubscription()` method implemented with full workflow
- [ ] `updateSubscription()` method implemented with prorated billing
- [ ] `pauseSubscription()` and `resumeSubscription()` methods implemented
- [ ] `cancelSubscription()` method implemented with immediate/period-end options
- [ ] `processPayment()` method implemented with idempotency
- [ ] `refundPayment()` method implemented for full/partial refunds
- [ ] `addPaymentMethod()`, `removePaymentMethod()`, `setDefaultPaymentMethod()` implemented
- [ ] `calculateUsageBilling()` method implemented with overage calculation
- [ ] `generateInvoice()` method implemented with line items
- [ ] `retryFailedPayment()` method implemented with retry limits
- [ ] `getSubscriptionStatus()` method implemented
- [ ] `getPaymentHistory()` method implemented
- [ ] Webhook validation and processing methods implemented
- [ ] Feature activation/deactivation integration complete
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written (full workflow coverage)
- [ ] Payment gateway mocking working in tests
- [ ] PHPDoc blocks complete for all public methods
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing completed with Stripe test mode
- [ ] Documentation updated
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 44 (Stripe payment gateway integration)
- **Depends on:** Task 45 (PayPal payment gateway integration)
- **Used by:** Task 48 (Subscription lifecycle management)
- **Used by:** Task 49 (Usage-based billing calculations)
- **Used by:** Task 50 (Frontend payment components)
- **Integrates with:** Task 24 (Resource monitoring for usage data)
- **Integrates with:** Organization and EnterpriseLicense models
