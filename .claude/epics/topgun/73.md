---
name: Create LicenseTestingTrait with validation helpers
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:25Z
github: https://github.com/johnproblems/topgun/issues/180
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Create LicenseTestingTrait with validation helpers

## Description

Build a comprehensive testing trait that provides helper methods for testing license validation, feature flag enforcement, and quota management across all enterprise features. This trait will be the foundation for testing all license-dependent functionality in the Coolify Enterprise Transformation project, ensuring that feature gates, usage limits, and organization-tier restrictions work correctly in all scenarios.

The LicenseTestingTrait serves as a reusable toolkit for developers writing tests that involve:
1. **License Key Generation** - Create valid/invalid/expired license keys for testing
2. **Feature Flag Simulation** - Enable/disable specific features at the license level
3. **Usage Quota Testing** - Simulate quota limits (servers, deployments, users, storage)
4. **License State Transitions** - Test license activation, expiration, renewal, suspension
5. **Organization Tier Testing** - Test Starter, Professional, Enterprise, Custom tier behaviors
6. **Domain Authorization** - Test domain-based license restrictions
7. **License Validation Mocking** - Mock external license validation services

**Integration with Enterprise Testing:**
- Used by all test files testing license-dependent features (white-label, Terraform, payment, API rate limiting)
- Works alongside OrganizationTestingTrait (Task 72) for complete multi-tenant testing
- Integrates with TerraformTestingTrait (Task 74) and PaymentTestingTrait (Task 75)
- Essential for unit tests, integration tests, and browser tests across the entire enterprise system

**Why this task is important:** Without a standardized testing trait, every test file would need to duplicate license setup logic, leading to inconsistent test data, harder-to-maintain tests, and increased risk of bugs in license enforcement. This trait provides a single source of truth for license testing scenarios, ensuring all features correctly respect license restrictions. It's particularly critical because license validation touches every enterprise featureâ€”from white-label branding to infrastructure provisioning to API rate limiting. A bug in license enforcement could allow unauthorized feature access or quota violations, undermining the entire licensing model.

**Key Features:**
- Factory-style license creation with chainable configuration
- Preset license configurations for common testing scenarios (trial, starter, professional, enterprise)
- Helper assertions for testing license gates (`assertLicenseAllowsFeature()`, `assertQuotaEnforced()`)
- Automatic cleanup of test licenses after tests complete
- Time manipulation for testing expiration and renewal scenarios
- Mock license server responses for external validation testing

## Acceptance Criteria

- [ ] LicenseTestingTrait created in `tests/Traits/` directory
- [ ] Trait provides method to create basic license: `createLicense(Organization $org, array $overrides = [])`
- [ ] Trait provides preset license creators: `createTrialLicense()`, `createStarterLicense()`, `createProLicense()`, `createEnterpriseLicense()`
- [ ] Feature flag helpers: `enableFeature(EnterpriseLicense $license, string $feature)`, `disableFeature(EnterpriseLicense $license, string $feature)`
- [ ] Quota setting helpers: `setQuota(EnterpriseLicense $license, string $quotaType, int $limit)`
- [ ] License state helpers: `expireLicense()`, `suspendLicense()`, `renewLicense()`
- [ ] Domain authorization helpers: `setAuthorizedDomains(array $domains)`, `clearAuthorizedDomains()`
- [ ] Custom assertion methods: `assertLicenseAllowsFeature()`, `assertLicenseBlocksFeature()`, `assertQuotaEnforced()`, `assertWithinQuota()`
- [ ] Time travel helpers for expiration testing: `setLicenseExpiry(Carbon $date)`, `expireLicenseAfterDays(int $days)`
- [ ] License key generation: `generateValidLicenseKey()`, `generateInvalidLicenseKey()`, `generateExpiredLicenseKey()`
- [ ] Integration with LicensingService mocking: `mockLicenseValidation(bool $isValid)`
- [ ] Cleanup helper: `cleanupTestLicenses()` automatically called in trait teardown
- [ ] Comprehensive documentation with usage examples for all methods
- [ ] Works with both unit tests and feature tests (database transactions supported)
- [ ] Compatible with Pest testing framework's `uses()` function

## Technical Details

### File Paths

**Testing Trait:**
- `/home/topgun/topgun/tests/Traits/LicenseTestingTrait.php` (new)

**Usage in Tests:**
- `/home/topgun/topgun/tests/Feature/Enterprise/WhiteLabelLicenseTest.php` (example usage)
- `/home/topgun/topgun/tests/Feature/Enterprise/TerraformLicenseTest.php` (example usage)
- `/home/topgun/topgun/tests/Unit/Services/LicensingServiceTest.php` (example usage)

**Related Models:**
- `/home/topgun/topgun/app/Models/Enterprise/EnterpriseLicense.php` (existing)
- `/home/topgun/topgun/app/Models/Organization.php` (existing)

**Related Services:**
- `/home/topgun/topgun/app/Services/Enterprise/LicensingService.php` (existing)
- `/home/topgun/topgun/app/Contracts/LicensingServiceInterface.php` (existing)

### LicenseTestingTrait Implementation

**File:** `tests/Traits/LicenseTestingTrait.php`

```php
<?php

namespace Tests\Traits;

use App\Models\Enterprise\EnterpriseLicense;
use App\Models\Organization;
use App\Services\Enterprise\LicensingService;
use Carbon\Carbon;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Str;

trait LicenseTestingTrait
{
    /**
     * Store created licenses for cleanup
     *
     * @var array
     */
    protected array $createdTestLicenses = [];

    /**
     * Create a basic enterprise license with optional overrides
     *
     * @param Organization $organization
     * @param array $overrides
     * @return EnterpriseLicense
     */
    protected function createLicense(Organization $organization, array $overrides = []): EnterpriseLicense
    {
        $defaults = [
            'organization_id' => $organization->id,
            'license_key' => $this->generateValidLicenseKey(),
            'tier' => 'professional',
            'status' => 'active',
            'expires_at' => Carbon::now()->addYear(),
            'max_servers' => 10,
            'max_deployments_per_month' => 100,
            'max_users' => 25,
            'max_storage_gb' => 100,
            'features' => [
                'white_label' => true,
                'terraform_integration' => true,
                'advanced_monitoring' => true,
                'custom_domains' => true,
                'api_access' => true,
                'priority_support' => false,
            ],
            'metadata' => [
                'issued_at' => Carbon::now()->toIso8601String(),
                'issued_by' => 'test-suite',
            ],
        ];

        $licenseData = array_merge($defaults, $overrides);

        $license = EnterpriseLicense::create($licenseData);

        // Track for cleanup
        $this->createdTestLicenses[] = $license->id;

        return $license;
    }

    /**
     * Create a trial license (14-day, limited features)
     *
     * @param Organization $organization
     * @return EnterpriseLicense
     */
    protected function createTrialLicense(Organization $organization): EnterpriseLicense
    {
        return $this->createLicense($organization, [
            'tier' => 'trial',
            'status' => 'active',
            'expires_at' => Carbon::now()->addDays(14),
            'max_servers' => 2,
            'max_deployments_per_month' => 10,
            'max_users' => 3,
            'max_storage_gb' => 10,
            'features' => [
                'white_label' => false,
                'terraform_integration' => false,
                'advanced_monitoring' => false,
                'custom_domains' => false,
                'api_access' => true,
                'priority_support' => false,
            ],
        ]);
    }

    /**
     * Create a Starter tier license
     *
     * @param Organization $organization
     * @return EnterpriseLicense
     */
    protected function createStarterLicense(Organization $organization): EnterpriseLicense
    {
        return $this->createLicense($organization, [
            'tier' => 'starter',
            'status' => 'active',
            'expires_at' => Carbon::now()->addYear(),
            'max_servers' => 5,
            'max_deployments_per_month' => 50,
            'max_users' => 10,
            'max_storage_gb' => 50,
            'features' => [
                'white_label' => false,
                'terraform_integration' => false,
                'advanced_monitoring' => true,
                'custom_domains' => true,
                'api_access' => true,
                'priority_support' => false,
            ],
        ]);
    }

    /**
     * Create a Professional tier license
     *
     * @param Organization $organization
     * @return EnterpriseLicense
     */
    protected function createProLicense(Organization $organization): EnterpriseLicense
    {
        return $this->createLicense($organization, [
            'tier' => 'professional',
            'status' => 'active',
            'expires_at' => Carbon::now()->addYear(),
            'max_servers' => 25,
            'max_deployments_per_month' => 250,
            'max_users' => 50,
            'max_storage_gb' => 250,
            'features' => [
                'white_label' => true,
                'terraform_integration' => true,
                'advanced_monitoring' => true,
                'custom_domains' => true,
                'api_access' => true,
                'priority_support' => true,
            ],
        ]);
    }

    /**
     * Create an Enterprise tier license (unlimited)
     *
     * @param Organization $organization
     * @return EnterpriseLicense
     */
    protected function createEnterpriseLicense(Organization $organization): EnterpriseLicense
    {
        return $this->createLicense($organization, [
            'tier' => 'enterprise',
            'status' => 'active',
            'expires_at' => Carbon::now()->addYears(3),
            'max_servers' => -1, // -1 = unlimited
            'max_deployments_per_month' => -1,
            'max_users' => -1,
            'max_storage_gb' => -1,
            'features' => [
                'white_label' => true,
                'terraform_integration' => true,
                'advanced_monitoring' => true,
                'custom_domains' => true,
                'api_access' => true,
                'priority_support' => true,
                'dedicated_support' => true,
                'custom_integrations' => true,
                'sla_guarantee' => true,
            ],
        ]);
    }

    /**
     * Create a custom tier license with specific configuration
     *
     * @param Organization $organization
     * @param array $features
     * @param array $quotas
     * @return EnterpriseLicense
     */
    protected function createCustomLicense(
        Organization $organization,
        array $features,
        array $quotas
    ): EnterpriseLicense {
        return $this->createLicense($organization, [
            'tier' => 'custom',
            'features' => $features,
            'max_servers' => $quotas['servers'] ?? 10,
            'max_deployments_per_month' => $quotas['deployments'] ?? 100,
            'max_users' => $quotas['users'] ?? 25,
            'max_storage_gb' => $quotas['storage'] ?? 100,
        ]);
    }

    /**
     * Enable a specific feature on a license
     *
     * @param EnterpriseLicense $license
     * @param string $feature
     * @return EnterpriseLicense
     */
    protected function enableFeature(EnterpriseLicense $license, string $feature): EnterpriseLicense
    {
        $features = $license->features ?? [];
        $features[$feature] = true;

        $license->update(['features' => $features]);
        $license->refresh();

        // Clear cache
        Cache::forget("license:{$license->id}:features");

        return $license;
    }

    /**
     * Disable a specific feature on a license
     *
     * @param EnterpriseLicense $license
     * @param string $feature
     * @return EnterpriseLicense
     */
    protected function disableFeature(EnterpriseLicense $license, string $feature): EnterpriseLicense
    {
        $features = $license->features ?? [];
        $features[$feature] = false;

        $license->update(['features' => $features]);
        $license->refresh();

        // Clear cache
        Cache::forget("license:{$license->id}:features");

        return $license;
    }

    /**
     * Set quota limit for a specific resource type
     *
     * @param EnterpriseLicense $license
     * @param string $quotaType (servers, deployments, users, storage)
     * @param int $limit (-1 for unlimited)
     * @return EnterpriseLicense
     */
    protected function setQuota(EnterpriseLicense $license, string $quotaType, int $limit): EnterpriseLicense
    {
        $quotaMap = [
            'servers' => 'max_servers',
            'deployments' => 'max_deployments_per_month',
            'users' => 'max_users',
            'storage' => 'max_storage_gb',
        ];

        if (!isset($quotaMap[$quotaType])) {
            throw new \InvalidArgumentException("Invalid quota type: {$quotaType}");
        }

        $license->update([
            $quotaMap[$quotaType] => $limit,
        ]);

        $license->refresh();

        return $license;
    }

    /**
     * Set license expiry date
     *
     * @param EnterpriseLicense $license
     * @param Carbon $expiryDate
     * @return EnterpriseLicense
     */
    protected function setLicenseExpiry(EnterpriseLicense $license, Carbon $expiryDate): EnterpriseLicense
    {
        $license->update(['expires_at' => $expiryDate]);
        $license->refresh();

        return $license;
    }

    /**
     * Expire license after specified number of days
     *
     * @param EnterpriseLicense $license
     * @param int $days
     * @return EnterpriseLicense
     */
    protected function expireLicenseAfterDays(EnterpriseLicense $license, int $days): EnterpriseLicense
    {
        return $this->setLicenseExpiry($license, Carbon::now()->addDays($days));
    }

    /**
     * Immediately expire a license (set expiry to past)
     *
     * @param EnterpriseLicense $license
     * @return EnterpriseLicense
     */
    protected function expireLicense(EnterpriseLicense $license): EnterpriseLicense
    {
        $license->update([
            'expires_at' => Carbon::now()->subDay(),
            'status' => 'expired',
        ]);

        $license->refresh();

        // Clear cache
        Cache::forget("license:{$license->id}:validation");

        return $license;
    }

    /**
     * Suspend a license
     *
     * @param EnterpriseLicense $license
     * @param string|null $reason
     * @return EnterpriseLicense
     */
    protected function suspendLicense(EnterpriseLicense $license, ?string $reason = null): EnterpriseLicense
    {
        $metadata = $license->metadata ?? [];
        $metadata['suspension_reason'] = $reason ?? 'Test suspension';
        $metadata['suspended_at'] = Carbon::now()->toIso8601String();

        $license->update([
            'status' => 'suspended',
            'metadata' => $metadata,
        ]);

        $license->refresh();

        // Clear cache
        Cache::forget("license:{$license->id}:validation");

        return $license;
    }

    /**
     * Renew a license (extend expiry and activate)
     *
     * @param EnterpriseLicense $license
     * @param int $extensionDays
     * @return EnterpriseLicense
     */
    protected function renewLicense(EnterpriseLicense $license, int $extensionDays = 365): EnterpriseLicense
    {
        $currentExpiry = $license->expires_at ?? Carbon::now();
        $newExpiry = Carbon::parse($currentExpiry)->addDays($extensionDays);

        $license->update([
            'expires_at' => $newExpiry,
            'status' => 'active',
        ]);

        $license->refresh();

        // Clear cache
        Cache::forget("license:{$license->id}:validation");

        return $license;
    }

    /**
     * Set authorized domains for license
     *
     * @param EnterpriseLicense $license
     * @param array $domains
     * @return EnterpriseLicense
     */
    protected function setAuthorizedDomains(EnterpriseLicense $license, array $domains): EnterpriseLicense
    {
        $license->update(['authorized_domains' => $domains]);
        $license->refresh();

        return $license;
    }

    /**
     * Clear all authorized domains
     *
     * @param EnterpriseLicense $license
     * @return EnterpriseLicense
     */
    protected function clearAuthorizedDomains(EnterpriseLicense $license): EnterpriseLicense
    {
        $license->update(['authorized_domains' => []]);
        $license->refresh();

        return $license;
    }

    /**
     * Generate a valid license key
     *
     * @return string
     */
    protected function generateValidLicenseKey(): string
    {
        // Format: COOL-XXXX-XXXX-XXXX-XXXX (Coolify Enterprise format)
        $segments = [];

        for ($i = 0; $i < 4; $i++) {
            $segments[] = strtoupper(Str::random(4));
        }

        return 'COOL-' . implode('-', $segments);
    }

    /**
     * Generate an invalid license key (for negative testing)
     *
     * @return string
     */
    protected function generateInvalidLicenseKey(): string
    {
        return 'INVALID-' . strtoupper(Str::random(12));
    }

    /**
     * Generate an expired license key
     *
     * @param Organization $organization
     * @return EnterpriseLicense
     */
    protected function generateExpiredLicense(Organization $organization): EnterpriseLicense
    {
        $license = $this->createLicense($organization);

        return $this->expireLicense($license);
    }

    /**
     * Mock LicensingService validation result
     *
     * @param bool $isValid
     * @param array $validationData
     * @return void
     */
    protected function mockLicenseValidation(bool $isValid, array $validationData = []): void
    {
        $mockService = $this->mock(LicensingService::class);

        $defaultData = [
            'is_valid' => $isValid,
            'message' => $isValid ? 'License valid' : 'License invalid',
            'features' => $isValid ? ['white_label' => true] : [],
        ];

        $resultData = array_merge($defaultData, $validationData);

        $mockService->shouldReceive('validateLicense')
            ->andReturn((object) $resultData);
    }

    /**
     * Assert that a license allows a specific feature
     *
     * @param EnterpriseLicense $license
     * @param string $feature
     * @param string|null $message
     * @return void
     */
    protected function assertLicenseAllowsFeature(
        EnterpriseLicense $license,
        string $feature,
        ?string $message = null
    ): void {
        $features = $license->features ?? [];

        $this->assertTrue(
            $features[$feature] ?? false,
            $message ?? "License does not allow feature: {$feature}"
        );
    }

    /**
     * Assert that a license blocks a specific feature
     *
     * @param EnterpriseLicense $license
     * @param string $feature
     * @param string|null $message
     * @return void
     */
    protected function assertLicenseBlocksFeature(
        EnterpriseLicense $license,
        string $feature,
        ?string $message = null
    ): void {
        $features = $license->features ?? [];

        $this->assertFalse(
            $features[$feature] ?? false,
            $message ?? "License should block feature: {$feature}"
        );
    }

    /**
     * Assert that quota is enforced for an organization
     *
     * @param Organization $organization
     * @param string $quotaType
     * @param int $currentUsage
     * @param string|null $message
     * @return void
     */
    protected function assertQuotaEnforced(
        Organization $organization,
        string $quotaType,
        int $currentUsage,
        ?string $message = null
    ): void {
        $license = $organization->enterpriseLicense;

        $quotaMap = [
            'servers' => 'max_servers',
            'deployments' => 'max_deployments_per_month',
            'users' => 'max_users',
            'storage' => 'max_storage_gb',
        ];

        $quotaField = $quotaMap[$quotaType] ?? null;

        $this->assertNotNull($quotaField, "Invalid quota type: {$quotaType}");

        $limit = $license->{$quotaField};

        // -1 means unlimited
        if ($limit === -1) {
            $this->assertTrue(true);
            return;
        }

        $this->assertGreaterThanOrEqual(
            $currentUsage,
            $limit,
            $message ?? "Quota exceeded for {$quotaType}: {$currentUsage}/{$limit}"
        );
    }

    /**
     * Assert that current usage is within quota limits
     *
     * @param Organization $organization
     * @param string $quotaType
     * @param int $currentUsage
     * @param string|null $message
     * @return void
     */
    protected function assertWithinQuota(
        Organization $organization,
        string $quotaType,
        int $currentUsage,
        ?string $message = null
    ): void {
        $license = $organization->enterpriseLicense;

        $quotaMap = [
            'servers' => 'max_servers',
            'deployments' => 'max_deployments_per_month',
            'users' => 'max_users',
            'storage' => 'max_storage_gb',
        ];

        $quotaField = $quotaMap[$quotaType] ?? null;

        $this->assertNotNull($quotaField, "Invalid quota type: {$quotaType}");

        $limit = $license->{$quotaField};

        // -1 means unlimited - always within quota
        if ($limit === -1) {
            $this->assertTrue(true);
            return;
        }

        $this->assertLessThanOrEqual(
            $limit,
            $currentUsage,
            $message ?? "Usage exceeds quota for {$quotaType}: {$currentUsage}/{$limit}"
        );
    }

    /**
     * Assert that a license is expired
     *
     * @param EnterpriseLicense $license
     * @param string|null $message
     * @return void
     */
    protected function assertLicenseExpired(EnterpriseLicense $license, ?string $message = null): void
    {
        $this->assertTrue(
            $license->expires_at->isPast(),
            $message ?? "License should be expired but expires at: {$license->expires_at}"
        );

        $this->assertEquals(
            'expired',
            $license->status,
            "License status should be 'expired' but is: {$license->status}"
        );
    }

    /**
     * Assert that a license is active
     *
     * @param EnterpriseLicense $license
     * @param string|null $message
     * @return void
     */
    protected function assertLicenseActive(EnterpriseLicense $license, ?string $message = null): void
    {
        $this->assertEquals(
            'active',
            $license->status,
            $message ?? "License should be active but status is: {$license->status}"
        );

        $this->assertTrue(
            $license->expires_at->isFuture(),
            "License should not be expired but expires at: {$license->expires_at}"
        );
    }

    /**
     * Clean up all test licenses created during test
     *
     * @return void
     */
    protected function cleanupTestLicenses(): void
    {
        if (!empty($this->createdTestLicenses)) {
            EnterpriseLicense::whereIn('id', $this->createdTestLicenses)->delete();
            $this->createdTestLicenses = [];
        }

        // Clear all license caches
        Cache::flush();
    }

    /**
     * Teardown hook - automatically clean up licenses
     *
     * @return void
     */
    protected function tearDown(): void
    {
        $this->cleanupTestLicenses();

        parent::tearDown();
    }
}
```

### Usage Examples

**Example 1: Testing White-Label Feature with License Gate**

**File:** `tests/Feature/Enterprise/WhiteLabelLicenseTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use Tests\Traits\LicenseTestingTrait;

uses(LicenseTestingTrait::class);

it('allows white-label branding for professional license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $this->assertLicenseAllowsFeature($license, 'white_label');

    $this->actingAs($user)
        ->post(route('enterprise.whitelabel.update', $organization), [
            'primary_color' => '#ff0000',
            'platform_name' => 'My Custom Platform',
        ])
        ->assertSuccessful();
});

it('blocks white-label branding for starter license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $this->assertLicenseBlocksFeature($license, 'white_label');

    $this->actingAs($user)
        ->post(route('enterprise.whitelabel.update', $organization), [
            'primary_color' => '#ff0000',
        ])
        ->assertForbidden();
});
```

**Example 2: Testing Quota Enforcement**

**File:** `tests/Feature/Enterprise/TerraformQuotaTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use Tests\Traits\LicenseTestingTrait;

uses(LicenseTestingTrait::class);

it('enforces server quota limit', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization); // max 5 servers

    // Create 5 servers (at quota limit)
    Server::factory()->count(5)->create(['organization_id' => $organization->id]);

    $currentServerCount = $organization->servers()->count();

    $this->assertWithinQuota($organization, 'servers', $currentServerCount);

    // Try to create 6th server - should fail
    $this->actingAs($organization->users()->first())
        ->post(route('enterprise.servers.provision', $organization), [
            'name' => 'server-6',
            'cloud_provider' => 'aws',
        ])
        ->assertForbidden()
        ->assertJson(['message' => 'Server quota exceeded']);
});

it('allows unlimited servers for enterprise license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createEnterpriseLicense($organization); // unlimited servers

    // Create 100 servers
    Server::factory()->count(100)->create(['organization_id' => $organization->id]);

    $currentServerCount = $organization->servers()->count();

    $this->assertWithinQuota($organization, 'servers', $currentServerCount);
    $this->assertEquals(-1, $license->max_servers); // Verify unlimited
});
```

**Example 3: Testing License Expiration**

**File:** `tests/Unit/Services/LicensingServiceTest.php`

```php
<?php

use App\Models\Organization;
use App\Services\Enterprise\LicensingService;
use Tests\Traits\LicenseTestingTrait;

uses(LicenseTestingTrait::class);

it('detects expired licenses', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    // Expire the license
    $this->expireLicense($license);

    $this->assertLicenseExpired($license);

    $service = app(LicensingService::class);
    $validation = $service->validateLicense($license->license_key);

    expect($validation->is_valid)->toBeFalse();
    expect($validation->message)->toContain('expired');
});

it('renews expired license successfully', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    // Expire license
    $this->expireLicense($license);
    $this->assertLicenseExpired($license);

    // Renew license
    $this->renewLicense($license, 365);

    $this->assertLicenseActive($license);
    expect($license->expires_at)->toBeGreaterThan(now());
});
```

**Example 4: Testing Custom Features**

```php
it('enables custom features on demand', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    // Initially doesn't have dedicated support
    expect($license->features['dedicated_support'] ?? false)->toBeFalse();

    // Enable custom feature
    $this->enableFeature($license, 'dedicated_support');

    $this->assertLicenseAllowsFeature($license, 'dedicated_support');
});

it('dynamically adjusts quotas', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization);

    expect($license->max_servers)->toBe(5);

    // Upgrade quota
    $this->setQuota($license, 'servers', 50);

    expect($license->max_servers)->toBe(50);
});
```

## Implementation Approach

### Step 1: Create Trait File
1. Create `tests/Traits/LicenseTestingTrait.php`
2. Define namespace and basic trait structure
3. Add property for tracking created licenses: `protected array $createdTestLicenses = []`

### Step 2: Implement Core License Creators
1. Add `createLicense()` base method with sensible defaults
2. Add preset creators: `createTrialLicense()`, `createStarterLicense()`, `createProLicense()`, `createEnterpriseLicense()`
3. Add `createCustomLicense()` for flexible configuration
4. Ensure all creators track license IDs for cleanup

### Step 3: Implement Feature Flag Helpers
1. Add `enableFeature()` method with cache invalidation
2. Add `disableFeature()` method with cache invalidation
3. Add `setQuota()` method with validation for quota types
4. Test feature flag mutations

### Step 4: Implement License State Helpers
1. Add `setLicenseExpiry()` for date manipulation
2. Add `expireLicense()` for immediate expiration
3. Add `suspendLicense()` with reason tracking
4. Add `renewLicense()` with extension days
5. Add `setAuthorizedDomains()` and `clearAuthorizedDomains()`

### Step 5: Implement License Key Generation
1. Add `generateValidLicenseKey()` with proper format (COOL-XXXX-XXXX-XXXX-XXXX)
2. Add `generateInvalidLicenseKey()` for negative testing
3. Add `generateExpiredLicense()` convenience method

### Step 6: Implement Custom Assertions
1. Add `assertLicenseAllowsFeature()` for feature gate testing
2. Add `assertLicenseBlocksFeature()` for negative feature testing
3. Add `assertQuotaEnforced()` for quota validation
4. Add `assertWithinQuota()` for usage validation
5. Add `assertLicenseExpired()` and `assertLicenseActive()` for state validation

### Step 7: Implement Mocking Helpers
1. Add `mockLicenseValidation()` for service mocking
2. Support custom validation data overrides
3. Integrate with Laravel's mock system

### Step 8: Implement Cleanup System
1. Add `cleanupTestLicenses()` method
2. Add `tearDown()` hook for automatic cleanup
3. Add cache clearing for license validations

### Step 9: Write Documentation
1. Add comprehensive PHPDoc blocks for all methods
2. Create usage examples in comments
3. Document integration with other testing traits
4. Add inline examples for common scenarios

### Step 10: Testing the Trait
1. Write tests for the trait itself (meta-testing)
2. Create example test files demonstrating usage
3. Verify integration with existing test suite
4. Test cleanup and teardown behavior

## Test Strategy

### Unit Tests for the Trait Itself

**File:** `tests/Unit/Traits/LicenseTestingTraitTest.php`

```php
<?php

use App\Models\Organization;
use Tests\Traits\LicenseTestingTrait;

uses(LicenseTestingTrait::class);

it('creates basic license with defaults', function () {
    $organization = Organization::factory()->create();

    $license = $this->createLicense($organization);

    expect($license)->not->toBeNull();
    expect($license->organization_id)->toBe($organization->id);
    expect($license->status)->toBe('active');
    expect($license->tier)->toBe('professional');
    expect($license->expires_at)->toBeInstanceOf(\Carbon\Carbon::class);
});

it('creates trial license with correct limits', function () {
    $organization = Organization::factory()->create();

    $license = $this->createTrialLicense($organization);

    expect($license->tier)->toBe('trial');
    expect($license->max_servers)->toBe(2);
    expect($license->max_users)->toBe(3);
    expect($license->features['white_label'])->toBeFalse();
    expect($license->expires_at)->toBeLessThan(now()->addDays(15));
});

it('creates starter license with correct configuration', function () {
    $organization = Organization::factory()->create();

    $license = $this->createStarterLicense($organization);

    expect($license->tier)->toBe('starter');
    expect($license->max_servers)->toBe(5);
    expect($license->max_users)->toBe(10);
    expect($license->features['white_label'])->toBeFalse();
    expect($license->features['api_access'])->toBeTrue();
});

it('creates professional license with correct features', function () {
    $organization = Organization::factory()->create();

    $license = $this->createProLicense($organization);

    expect($license->tier)->toBe('professional');
    expect($license->max_servers)->toBe(25);
    expect($license->features['white_label'])->toBeTrue();
    expect($license->features['terraform_integration'])->toBeTrue();
    expect($license->features['priority_support'])->toBeTrue();
});

it('creates enterprise license with unlimited quotas', function () {
    $organization = Organization::factory()->create();

    $license = $this->createEnterpriseLicense($organization);

    expect($license->tier)->toBe('enterprise');
    expect($license->max_servers)->toBe(-1); // Unlimited
    expect($license->max_users)->toBe(-1);
    expect($license->features['dedicated_support'])->toBeTrue();
});

it('enables feature on existing license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization);

    expect($license->features['white_label'])->toBeFalse();

    $this->enableFeature($license, 'white_label');

    expect($license->features['white_label'])->toBeTrue();
});

it('disables feature on existing license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    expect($license->features['white_label'])->toBeTrue();

    $this->disableFeature($license, 'white_label');

    expect($license->features['white_label'])->toBeFalse();
});

it('sets quota limits correctly', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization);

    expect($license->max_servers)->toBe(5);

    $this->setQuota($license, 'servers', 20);

    expect($license->max_servers)->toBe(20);
});

it('expires license correctly', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    $this->assertLicenseActive($license);

    $this->expireLicense($license);

    $this->assertLicenseExpired($license);
    expect($license->status)->toBe('expired');
});

it('renews expired license', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    $this->expireLicense($license);
    $this->assertLicenseExpired($license);

    $this->renewLicense($license, 365);

    $this->assertLicenseActive($license);
    expect($license->expires_at)->toBeGreaterThan(now());
});

it('generates valid license key', function () {
    $key = $this->generateValidLicenseKey();

    expect($key)->toStartWith('COOL-');
    expect($key)->toHaveLength(24); // COOL-XXXX-XXXX-XXXX-XXXX
});

it('generates invalid license key', function () {
    $key = $this->generateInvalidLicenseKey();

    expect($key)->toStartWith('INVALID-');
    expect($key)->not->toStartWith('COOL-');
});

it('asserts license allows feature correctly', function () {
    $organization = Organization::factory()->create();
    $license = $this->createProLicense($organization);

    $this->assertLicenseAllowsFeature($license, 'white_label');
});

it('asserts license blocks feature correctly', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization);

    $this->assertLicenseBlocksFeature($license, 'white_label');
});

it('cleans up test licenses on teardown', function () {
    $organization = Organization::factory()->create();

    $license1 = $this->createLicense($organization);
    $license2 = $this->createProLicense($organization);

    $licenseIds = [$license1->id, $license2->id];

    expect($this->createdTestLicenses)->toContain($license1->id);
    expect($this->createdTestLicenses)->toContain($license2->id);

    $this->cleanupTestLicenses();

    expect($this->createdTestLicenses)->toBeEmpty();

    // Verify licenses were deleted
    foreach ($licenseIds as $id) {
        expect(EnterpriseLicense::find($id))->toBeNull();
    }
});
```

### Integration Tests

**File:** `tests/Feature/Traits/LicenseTestingTraitIntegrationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use Tests\Traits\LicenseTestingTrait;
use Tests\Traits\OrganizationTestingTrait;

uses(LicenseTestingTrait::class, OrganizationTestingTrait::class);

it('integrates with organization testing trait', function () {
    $organization = $this->createOrganization('Test Org');
    $license = $this->createProLicense($organization);

    expect($organization->enterpriseLicense->id)->toBe($license->id);
    $this->assertLicenseActive($license);
});

it('validates quota enforcement in real scenario', function () {
    $organization = Organization::factory()->create();
    $license = $this->createStarterLicense($organization); // max 5 servers

    // Create 5 servers
    Server::factory()->count(5)->create(['organization_id' => $organization->id]);

    $currentCount = $organization->servers()->count();

    $this->assertWithinQuota($organization, 'servers', $currentCount);

    // Verify quota prevents 6th server (would need controller test)
    expect($currentCount)->toBe($license->max_servers);
});
```

## Definition of Done

- [ ] LicenseTestingTrait created in `tests/Traits/` directory
- [ ] Base `createLicense()` method implemented with sensible defaults
- [ ] Preset license creators implemented (trial, starter, pro, enterprise, custom)
- [ ] Feature flag helpers implemented (`enableFeature()`, `disableFeature()`)
- [ ] Quota manipulation helpers implemented (`setQuota()`)
- [ ] License state helpers implemented (expire, suspend, renew, set expiry)
- [ ] Domain authorization helpers implemented
- [ ] License key generation methods implemented
- [ ] Custom assertion methods implemented (8+ assertions)
- [ ] Mock license validation helper implemented
- [ ] Automatic cleanup system implemented (`cleanupTestLicenses()`, `tearDown()`)
- [ ] Comprehensive PHPDoc blocks for all methods (30+ methods documented)
- [ ] Usage examples created for all major features (5+ example test files)
- [ ] Unit tests for trait itself written and passing (15+ tests)
- [ ] Integration tests with OrganizationTestingTrait written and passing (5+ tests)
- [ ] Trait compatible with Pest `uses()` function
- [ ] Works with both unit and feature tests (database transactions supported)
- [ ] Code follows Laravel 12 and Pest best practices
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing with zero errors
- [ ] All tests passing (`php artisan test --filter=LicenseTestingTrait`)
- [ ] Integration verified with existing test suite (no breaking changes)
- [ ] Documentation updated in TESTING.md with trait usage guide
- [ ] Code reviewed and approved by team
- [ ] Manual testing completed with real test scenarios

## Related Tasks

- **Works with:** Task 72 (OrganizationTestingTrait) - Organization hierarchy testing
- **Works with:** Task 74 (TerraformTestingTrait) - Infrastructure provisioning testing
- **Works with:** Task 75 (PaymentTestingTrait) - Payment gateway testing
- **Used by:** Task 76 (Unit tests for enterprise services) - Service layer testing
- **Used by:** Task 77 (Integration tests for workflows) - End-to-end testing
- **Used by:** Task 78 (API tests) - API endpoint testing with license gates
- **Used by:** All white-label tests (Tasks 2-11) - Feature gate validation
- **Used by:** All Terraform tests (Tasks 12-21) - Quota enforcement validation
- **Used by:** All monitoring tests (Tasks 22-31) - Feature availability validation
