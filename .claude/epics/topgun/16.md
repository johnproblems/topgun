---
name: Create modular Terraform templates for DigitalOcean and Hetzner
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:34Z
github: https://github.com/johnproblems/topgun/issues/126
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Create modular Terraform templates for DigitalOcean and Hetzner

## Description

Design and implement comprehensive, production-ready Terraform templates (HCL files) for provisioning infrastructure on **DigitalOcean Droplets** and **Hetzner Cloud** servers. These templates complement the AWS templates (Task 15) and provide cost-effective alternatives for organizations seeking simpler cloud providers with transparent pricing and developer-friendly APIs.

This task creates two complete template sets that abstract the complexity of multi-cloud infrastructure provisioning while maintaining consistency in configuration patterns across providers. The templates enable Coolify's TerraformService (Task 14) to provision infrastructure on DigitalOcean and Hetzner with the same ease as AWS, supporting the platform's multi-cloud strategy.

**DigitalOcean Template Features:**

1. **Droplet Provisioning**: Parameterized droplet creation with flexible sizing (s-1vcpu-1gb to c-32vcpu-64gb)
2. **Networking**: VPC creation, firewall rules, and reserved IP (floating IP) support
3. **SSH Key Management**: SSH key creation and injection for secure access
4. **Volume Attachment**: Optional block storage volume mounting for additional capacity
5. **Cloud-Init**: User data script support for automated Docker and Coolify agent installation
6. **Project Organization**: Resource tagging with DigitalOcean project assignment

**Hetzner Cloud Template Features:**

1. **Server Provisioning**: Cloud server creation from CX11 to CCX63 instance types
2. **Networking**: Private network creation, firewall configuration, and primary IP management
3. **SSH Key Management**: SSH key registration and automatic injection
4. **Volume Attachment**: Optional Hetzner volume creation and mounting
5. **Cloud-Init**: User data support for server initialization
6. **Location Selection**: Data center selection (Nuremberg, Helsinki, Falkenstein, etc.)

**Design Philosophy:**

- **Cost Optimization**: Default to affordable instance types suitable for development/staging
- **Provider Parity**: Consistent variable naming across providers for unified TerraformService interface
- **Security First**: Restrictive firewall rules with explicit port allowlisting
- **Production Ready**: Follow provider best practices for networking and resource organization
- **Simplicity**: Leverage provider-specific simplicity (no complex VPC setup like AWS)

**Integration with Coolify:**

The TerraformService copies these templates to deployment workspaces based on the selected cloud provider from CloudProviderCredential. The service injects provider-specific API tokens via terraform.tfvars and executes the standard Terraform workflow (init → plan → apply). After provisioning, Terraform outputs (IP addresses, server IDs) are parsed and used by the ServerAutoRegistration system (Task 19) to automatically add the newly created servers to Coolify's server inventory.

**Why This Task Is Critical:**

DigitalOcean and Hetzner are popular choices for developers and startups due to their:
- **Transparent Pricing**: Predictable costs without AWS-style billing complexity
- **Simplicity**: Fewer moving parts compared to AWS (no complex VPC/subnet configurations)
- **Performance/Cost Ratio**: Excellent value for money, especially Hetzner
- **Developer Experience**: Clean APIs and straightforward resource management

By supporting these providers, Coolify becomes accessible to a broader audience beyond AWS-centric enterprises. These templates enable the same infrastructure-as-code benefits while catering to cost-conscious organizations and developers who prefer simpler cloud platforms.

## Acceptance Criteria

### General Requirements
- [ ] Terraform templates written in HCL format with Terraform 1.5+ compatibility
- [ ] Templates structured with `variables.tf`, `main.tf`, `outputs.tf`, and `versions.tf`
- [ ] All variables documented with descriptions, types, and sensible defaults
- [ ] Provider authentication via API token with sensitive variable marking
- [ ] SSH key creation and injection for server access
- [ ] Firewall/security group configuration for SSH, HTTP, HTTPS, and custom ports
- [ ] User data (cloud-init) support for automated server initialization
- [ ] Resource tagging for organization tracking and billing
- [ ] Terraform validate passes with zero errors for both providers
- [ ] Example `terraform.tfvars` files with realistic sample values
- [ ] README documentation explaining template usage and variables

### DigitalOcean Specific
- [ ] Droplet resource with parameterized size (slug) and region
- [ ] VPC creation with optional private networking
- [ ] Cloud Firewall resource with inbound/outbound rules
- [ ] Reserved IP (floating IP) optional assignment
- [ ] Block Storage volume creation and attachment (optional)
- [ ] Project resource assignment for organization
- [ ] Outputs include: droplet ID, public IPv4, private IPv4, reserved IP

### Hetzner Specific
- [ ] Cloud Server resource with parameterized server type and location
- [ ] Private Network creation with subnet configuration
- [ ] Firewall resource with rule-based access control
- [ ] Primary IP management for stable addressing
- [ ] Volume creation and attachment (optional)
- [ ] Placement group support for high availability (optional)
- [ ] Outputs include: server ID, public IPv4, private IPv4, volume ID

## Technical Details

### File Structure

```
storage/app/terraform/templates/
├── digitalocean/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   ├── versions.tf
│   ├── terraform.tfvars.example
│   └── README.md
└── hetzner/
    ├── main.tf
    ├── variables.tf
    ├── outputs.tf
    ├── versions.tf
    ├── terraform.tfvars.example
    └── README.md
```

### DigitalOcean Templates

#### File: `storage/app/terraform/templates/digitalocean/variables.tf`

```hcl
# DigitalOcean Provider Authentication
variable "do_token" {
  description = "DigitalOcean API token for authentication"
  type        = string
  sensitive   = true
}

# Deployment Metadata
variable "deployment_name" {
  description = "Name for this deployment (used for resource naming)"
  type        = string
  default     = "coolify-server"
}

variable "organization_id" {
  description = "Coolify organization ID for tagging"
  type        = string
}

variable "organization_name" {
  description = "Organization name for resource tagging"
  type        = string
}

# Droplet Configuration
variable "droplet_size" {
  description = "DigitalOcean droplet size slug (s-1vcpu-1gb, s-2vcpu-2gb, s-2vcpu-4gb, etc.)"
  type        = string
  default     = "s-2vcpu-2gb"

  validation {
    condition     = can(regex("^(s|c|m|g|so|gd|c2)-", var.droplet_size))
    error_message = "Droplet size must be a valid DigitalOcean slug."
  }
}

variable "region" {
  description = "DigitalOcean region (nyc1, nyc3, sfo3, ams3, sgp1, lon1, fra1, tor1, blr1, syd1)"
  type        = string
  default     = "nyc3"
}

variable "image" {
  description = "Droplet image (ubuntu-22-04-x64, ubuntu-20-04-x64, debian-11-x64, etc.)"
  type        = string
  default     = "ubuntu-22-04-x64"
}

variable "enable_monitoring" {
  description = "Enable DigitalOcean monitoring agent"
  type        = bool
  default     = true
}

variable "enable_backups" {
  description = "Enable automatic weekly backups"
  type        = bool
  default     = false
}

variable "enable_ipv6" {
  description = "Enable IPv6 networking"
  type        = bool
  default     = true
}

# Networking Configuration
variable "create_vpc" {
  description = "Create a new VPC for private networking"
  type        = bool
  default     = true
}

variable "vpc_ip_range" {
  description = "IP range for VPC in CIDR notation"
  type        = string
  default     = "10.10.10.0/24"
}

variable "existing_vpc_id" {
  description = "Existing VPC UUID to use (if create_vpc = false)"
  type        = string
  default     = null
}

# Firewall Configuration
variable "allowed_ssh_cidr_blocks" {
  description = "CIDR blocks allowed to SSH to droplet"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "allowed_http_cidr_blocks" {
  description = "CIDR blocks allowed HTTP access"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "allowed_https_cidr_blocks" {
  description = "CIDR blocks allowed HTTPS access"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "custom_firewall_ports" {
  description = "Additional ports to allow (list of port numbers)"
  type        = list(number)
  default     = [8080, 8443]  # Coolify application ports
}

# SSH Configuration
variable "ssh_public_key" {
  description = "SSH public key for droplet access"
  type        = string
}

variable "ssh_key_name" {
  description = "Name for SSH key in DigitalOcean"
  type        = string
  default     = null
}

# Reserved IP (Floating IP)
variable "create_reserved_ip" {
  description = "Create and assign a reserved IP (floating IP)"
  type        = bool
  default     = false
}

# Block Storage
variable "create_volume" {
  description = "Create an additional block storage volume"
  type        = bool
  default     = false
}

variable "volume_size" {
  description = "Size of block storage volume in GB"
  type        = number
  default     = 100
}

# User Data (Cloud-Init)
variable "user_data" {
  description = "Cloud-init user data script for droplet initialization"
  type        = string
  default     = ""
}

# Project Organization
variable "project_name" {
  description = "DigitalOcean project name for resource organization"
  type        = string
  default     = "Coolify Infrastructure"
}

variable "project_description" {
  description = "Project description"
  type        = string
  default     = "Coolify managed infrastructure"
}

variable "project_purpose" {
  description = "Project purpose (Web Application, Service or API, etc.)"
  type        = string
  default     = "Web Application"
}
```

#### File: `storage/app/terraform/templates/digitalocean/main.tf`

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    digitalocean = {
      source  = "digitalocean/digitalocean"
      version = "~> 2.34"
    }
  }
}

provider "digitalocean" {
  token = var.do_token
}

# Data source for available regions (validation)
data "digitalocean_regions" "available" {}

# Create SSH key
resource "digitalocean_ssh_key" "coolify" {
  name       = var.ssh_key_name != null ? var.ssh_key_name : "${var.deployment_name}-ssh-key"
  public_key = var.ssh_public_key
}

# Create VPC (optional)
resource "digitalocean_vpc" "coolify" {
  count = var.create_vpc ? 1 : 0

  name        = "${var.deployment_name}-vpc"
  region      = var.region
  ip_range    = var.vpc_ip_range
  description = "VPC for ${var.organization_name}"
}

# Determine VPC ID (created or existing)
locals {
  vpc_id = var.create_vpc ? digitalocean_vpc.coolify[0].id : var.existing_vpc_id
}

# Create Droplet
resource "digitalocean_droplet" "coolify_server" {
  name   = var.deployment_name
  region = var.region
  size   = var.droplet_size
  image  = var.image

  ssh_keys = [digitalocean_ssh_key.coolify.id]

  vpc_uuid = local.vpc_id

  monitoring = var.enable_monitoring
  backups    = var.enable_backups
  ipv6       = var.enable_ipv6

  user_data = var.user_data != "" ? var.user_data : templatefile("${path.module}/user-data.sh", {
    hostname = var.deployment_name
  })

  tags = [
    "coolify",
    "organization:${var.organization_id}",
    "managed-by:terraform",
    var.deployment_name
  ]
}

# Create Cloud Firewall
resource "digitalocean_firewall" "coolify" {
  name = "${var.deployment_name}-firewall"

  droplet_ids = [digitalocean_droplet.coolify_server.id]

  # SSH access
  inbound_rule {
    protocol         = "tcp"
    port_range       = "22"
    source_addresses = var.allowed_ssh_cidr_blocks
  }

  # HTTP access
  inbound_rule {
    protocol         = "tcp"
    port_range       = "80"
    source_addresses = var.allowed_http_cidr_blocks
  }

  # HTTPS access
  inbound_rule {
    protocol         = "tcp"
    port_range       = "443"
    source_addresses = var.allowed_https_cidr_blocks
  }

  # Custom ports (Coolify application ports)
  dynamic "inbound_rule" {
    for_each = var.custom_firewall_ports
    content {
      protocol         = "tcp"
      port_range       = tostring(inbound_rule.value)
      source_addresses = ["0.0.0.0/0", "::/0"]
    }
  }

  # ICMP (ping)
  inbound_rule {
    protocol         = "icmp"
    source_addresses = ["0.0.0.0/0", "::/0"]
  }

  # Allow all outbound traffic
  outbound_rule {
    protocol              = "tcp"
    port_range            = "1-65535"
    destination_addresses = ["0.0.0.0/0", "::/0"]
  }

  outbound_rule {
    protocol              = "udp"
    port_range            = "1-65535"
    destination_addresses = ["0.0.0.0/0", "::/0"]
  }

  outbound_rule {
    protocol              = "icmp"
    destination_addresses = ["0.0.0.0/0", "::/0"]
  }
}

# Create Reserved IP (Floating IP) - Optional
resource "digitalocean_reserved_ip" "coolify" {
  count  = var.create_reserved_ip ? 1 : 0
  region = var.region
}

resource "digitalocean_reserved_ip_assignment" "coolify" {
  count      = var.create_reserved_ip ? 1 : 0
  ip_address = digitalocean_reserved_ip.coolify[0].ip_address
  droplet_id = digitalocean_droplet.coolify_server.id
}

# Create Block Storage Volume - Optional
resource "digitalocean_volume" "coolify" {
  count       = var.create_volume ? 1 : 0
  region      = var.region
  name        = "${var.deployment_name}-volume"
  size        = var.volume_size
  description = "Additional storage for ${var.deployment_name}"

  tags = [
    "coolify",
    "organization:${var.organization_id}"
  ]
}

resource "digitalocean_volume_attachment" "coolify" {
  count      = var.create_volume ? 1 : 0
  droplet_id = digitalocean_droplet.coolify_server.id
  volume_id  = digitalocean_volume.coolify[0].id
}

# Create Project for Organization
resource "digitalocean_project" "coolify" {
  name        = var.project_name
  description = var.project_description
  purpose     = var.project_purpose
  environment = "Production"

  resources = [
    digitalocean_droplet.coolify_server.urn
  ]
}
```

#### File: `storage/app/terraform/templates/digitalocean/outputs.tf`

```hcl
output "droplet_id" {
  description = "DigitalOcean droplet ID"
  value       = digitalocean_droplet.coolify_server.id
}

output "droplet_name" {
  description = "Droplet name"
  value       = digitalocean_droplet.coolify_server.name
}

output "public_ipv4" {
  description = "Public IPv4 address"
  value       = digitalocean_droplet.coolify_server.ipv4_address
}

output "public_ipv6" {
  description = "Public IPv6 address"
  value       = var.enable_ipv6 ? digitalocean_droplet.coolify_server.ipv6_address : null
}

output "private_ipv4" {
  description = "Private IPv4 address (VPC)"
  value       = digitalocean_droplet.coolify_server.ipv4_address_private
}

output "reserved_ip" {
  description = "Reserved IP (floating IP) if created"
  value       = var.create_reserved_ip ? digitalocean_reserved_ip.coolify[0].ip_address : null
}

output "vpc_id" {
  description = "VPC UUID"
  value       = local.vpc_id
}

output "volume_id" {
  description = "Block storage volume ID if created"
  value       = var.create_volume ? digitalocean_volume.coolify[0].id : null
}

output "firewall_id" {
  description = "Cloud Firewall ID"
  value       = digitalocean_firewall.coolify.id
}

output "ssh_key_fingerprint" {
  description = "SSH key fingerprint"
  value       = digitalocean_ssh_key.coolify.fingerprint
}

output "region" {
  description = "Droplet region"
  value       = var.region
}

output "size" {
  description = "Droplet size slug"
  value       = var.droplet_size
}
```

#### File: `storage/app/terraform/templates/digitalocean/versions.tf`

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    digitalocean = {
      source  = "digitalocean/digitalocean"
      version = "~> 2.34"
    }
  }
}
```

### Hetzner Cloud Templates

#### File: `storage/app/terraform/templates/hetzner/variables.tf`

```hcl
# Hetzner Cloud Provider Authentication
variable "hcloud_token" {
  description = "Hetzner Cloud API token for authentication"
  type        = string
  sensitive   = true
}

# Deployment Metadata
variable "deployment_name" {
  description = "Name for this deployment (used for resource naming)"
  type        = string
  default     = "coolify-server"
}

variable "organization_id" {
  description = "Coolify organization ID for labeling"
  type        = string
}

variable "organization_name" {
  description = "Organization name for resource labeling"
  type        = string
}

# Server Configuration
variable "server_type" {
  description = "Hetzner server type (cx11, cx21, cx31, cx41, cx51, cpx11, cpx21, cpx31, ccx13, ccx23, ccx33, etc.)"
  type        = string
  default     = "cx21"  # 2 vCPU, 4GB RAM

  validation {
    condition     = can(regex("^(cx|cpx|ccx)", var.server_type))
    error_message = "Server type must be a valid Hetzner server type."
  }
}

variable "location" {
  description = "Hetzner datacenter location (nbg1, fsn1, hel1, ash, hil)"
  type        = string
  default     = "nbg1"  # Nuremberg, Germany
}

variable "image" {
  description = "Server image (ubuntu-22.04, ubuntu-20.04, debian-11, debian-12, etc.)"
  type        = string
  default     = "ubuntu-22.04"
}

variable "enable_backups" {
  description = "Enable automatic backups (costs extra)"
  type        = bool
  default     = false
}

# Networking Configuration
variable "create_private_network" {
  description = "Create a private network for the server"
  type        = bool
  default     = true
}

variable "private_network_ip_range" {
  description = "IP range for private network in CIDR notation"
  type        = string
  default     = "10.0.0.0/16"
}

variable "private_network_subnet" {
  description = "Subnet range within private network"
  type        = string
  default     = "10.0.1.0/24"
}

variable "existing_network_id" {
  description = "Existing private network ID to use (if create_private_network = false)"
  type        = number
  default     = null
}

# Firewall Configuration
variable "allowed_ssh_cidr_blocks" {
  description = "CIDR blocks allowed to SSH to server"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "allowed_http_cidr_blocks" {
  description = "CIDR blocks allowed HTTP access"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "allowed_https_cidr_blocks" {
  description = "CIDR blocks allowed HTTPS access"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}

variable "custom_firewall_ports" {
  description = "Additional TCP ports to allow (list of port numbers)"
  type        = list(number)
  default     = [8080, 8443]
}

# SSH Configuration
variable "ssh_public_key" {
  description = "SSH public key for server access"
  type        = string
}

variable "ssh_key_name" {
  description = "Name for SSH key in Hetzner Cloud"
  type        = string
  default     = null
}

# Volume Configuration
variable "create_volume" {
  description = "Create an additional volume"
  type        = bool
  default     = false
}

variable "volume_size" {
  description = "Size of volume in GB"
  type        = number
  default     = 100
}

variable "volume_format" {
  description = "Filesystem format for volume (xfs or ext4)"
  type        = string
  default     = "ext4"
}

# User Data (Cloud-Init)
variable "user_data" {
  description = "Cloud-init user data script for server initialization"
  type        = string
  default     = ""
}

# High Availability
variable "create_placement_group" {
  description = "Create a placement group for high availability"
  type        = bool
  default     = false
}

variable "placement_group_type" {
  description = "Placement group type (spread for HA)"
  type        = string
  default     = "spread"
}
```

#### File: `storage/app/terraform/templates/hetzner/main.tf`

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    hcloud = {
      source  = "hetznercloud/hcloud"
      version = "~> 1.45"
    }
  }
}

provider "hcloud" {
  token = var.hcloud_token
}

# Create SSH key
resource "hcloud_ssh_key" "coolify" {
  name       = var.ssh_key_name != null ? var.ssh_key_name : "${var.deployment_name}-ssh-key"
  public_key = var.ssh_public_key

  labels = {
    managed_by      = "terraform"
    organization_id = var.organization_id
    deployment      = var.deployment_name
  }
}

# Create Private Network (optional)
resource "hcloud_network" "coolify" {
  count    = var.create_private_network ? 1 : 0
  name     = "${var.deployment_name}-network"
  ip_range = var.private_network_ip_range

  labels = {
    managed_by      = "terraform"
    organization_id = var.organization_id
  }
}

resource "hcloud_network_subnet" "coolify" {
  count        = var.create_private_network ? 1 : 0
  network_id   = hcloud_network.coolify[0].id
  type         = "cloud"
  network_zone = "eu-central"  # Adjust based on location
  ip_range     = var.private_network_subnet
}

# Determine network ID (created or existing)
locals {
  network_id = var.create_private_network ? hcloud_network.coolify[0].id : var.existing_network_id
}

# Create Placement Group (optional, for HA)
resource "hcloud_placement_group" "coolify" {
  count  = var.create_placement_group ? 1 : 0
  name   = "${var.deployment_name}-placement-group"
  type   = var.placement_group_type

  labels = {
    managed_by      = "terraform"
    organization_id = var.organization_id
  }
}

# Create Server
resource "hcloud_server" "coolify_server" {
  name        = var.deployment_name
  server_type = var.server_type
  location    = var.location
  image       = var.image

  ssh_keys = [hcloud_ssh_key.coolify.id]

  backups = var.enable_backups

  user_data = var.user_data != "" ? var.user_data : templatefile("${path.module}/user-data.sh", {
    hostname = var.deployment_name
  })

  placement_group_id = var.create_placement_group ? hcloud_placement_group.coolify[0].id : null

  labels = {
    managed_by       = "terraform"
    organization_id  = var.organization_id
    organization     = var.organization_name
    deployment       = var.deployment_name
    coolify_managed  = "true"
  }

  # Prevent accidental deletion
  lifecycle {
    prevent_destroy = false
  }
}

# Attach server to private network
resource "hcloud_server_network" "coolify" {
  count      = var.create_private_network ? 1 : 0
  server_id  = hcloud_server.coolify_server.id
  network_id = hcloud_network.coolify[0].id
}

# Create Firewall
resource "hcloud_firewall" "coolify" {
  name = "${var.deployment_name}-firewall"

  # SSH access
  rule {
    direction   = "in"
    protocol    = "tcp"
    port        = "22"
    source_ips  = var.allowed_ssh_cidr_blocks
    description = "SSH access"
  }

  # HTTP access
  rule {
    direction   = "in"
    protocol    = "tcp"
    port        = "80"
    source_ips  = var.allowed_http_cidr_blocks
    description = "HTTP access"
  }

  # HTTPS access
  rule {
    direction   = "in"
    protocol    = "tcp"
    port        = "443"
    source_ips  = var.allowed_https_cidr_blocks
    description = "HTTPS access"
  }

  # Custom ports
  dynamic "rule" {
    for_each = var.custom_firewall_ports
    content {
      direction   = "in"
      protocol    = "tcp"
      port        = tostring(rule.value)
      source_ips  = ["0.0.0.0/0", "::/0"]
      description = "Custom port ${rule.value}"
    }
  }

  # ICMP (ping)
  rule {
    direction   = "in"
    protocol    = "icmp"
    source_ips  = ["0.0.0.0/0", "::/0"]
    description = "ICMP (ping)"
  }

  labels = {
    managed_by      = "terraform"
    organization_id = var.organization_id
  }
}

# Attach firewall to server
resource "hcloud_firewall_attachment" "coolify" {
  firewall_id = hcloud_firewall.coolify.id
  server_ids  = [hcloud_server.coolify_server.id]
}

# Create Volume (optional)
resource "hcloud_volume" "coolify" {
  count     = var.create_volume ? 1 : 0
  name      = "${var.deployment_name}-volume"
  size      = var.volume_size
  location  = var.location
  format    = var.volume_format

  labels = {
    managed_by      = "terraform"
    organization_id = var.organization_id
  }
}

# Attach volume to server
resource "hcloud_volume_attachment" "coolify" {
  count     = var.create_volume ? 1 : 0
  volume_id = hcloud_volume.coolify[0].id
  server_id = hcloud_server.coolify_server.id
  automount = true
}
```

#### File: `storage/app/terraform/templates/hetzner/outputs.tf`

```hcl
output "server_id" {
  description = "Hetzner Cloud server ID"
  value       = hcloud_server.coolify_server.id
}

output "server_name" {
  description = "Server name"
  value       = hcloud_server.coolify_server.name
}

output "public_ipv4" {
  description = "Public IPv4 address"
  value       = hcloud_server.coolify_server.ipv4_address
}

output "public_ipv6" {
  description = "Public IPv6 address"
  value       = hcloud_server.coolify_server.ipv6_address
}

output "private_ipv4" {
  description = "Private IPv4 address (private network)"
  value       = var.create_private_network ? hcloud_server_network.coolify[0].ip : null
}

output "network_id" {
  description = "Private network ID"
  value       = local.network_id
}

output "volume_id" {
  description = "Volume ID if created"
  value       = var.create_volume ? hcloud_volume.coolify[0].id : null
}

output "volume_linux_device" {
  description = "Linux device path for volume"
  value       = var.create_volume ? hcloud_volume.coolify[0].linux_device : null
}

output "firewall_id" {
  description = "Firewall ID"
  value       = hcloud_firewall.coolify.id
}

output "ssh_key_id" {
  description = "SSH key ID"
  value       = hcloud_ssh_key.coolify.id
}

output "location" {
  description = "Server location"
  value       = var.location
}

output "server_type" {
  description = "Server type"
  value       = var.server_type
}

output "placement_group_id" {
  description = "Placement group ID if created"
  value       = var.create_placement_group ? hcloud_placement_group.coolify[0].id : null
}
```

#### File: `storage/app/terraform/templates/hetzner/versions.tf`

```hcl
terraform {
  required_version = ">= 1.5.0"

  required_providers {
    hcloud = {
      source  = "hetznercloud/hcloud"
      version = "~> 1.45"
    }
  }
}
```

### User Data Scripts

Both providers need cloud-init scripts for automated server initialization.

#### File: `storage/app/terraform/templates/digitalocean/user-data.sh`

```bash
#!/bin/bash

set -euo pipefail

# Set hostname
hostnamectl set-hostname ${hostname}

# Update system packages
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
systemctl enable docker
systemctl start docker

# Install Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# Install essential tools
apt-get install -y \
  curl \
  wget \
  git \
  unzip \
  htop \
  net-tools \
  ca-certificates \
  gnupg \
  lsb-release

# Configure firewall (ufw)
ufw --force enable
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw allow 8080/tcp  # Coolify
ufw allow 8443/tcp  # Coolify SSL

# Create Coolify directory
mkdir -p /opt/coolify

# Signal completion
touch /var/log/cloud-init-complete.log

echo "Cloud-init completed successfully at $(date)" >> /var/log/cloud-init-complete.log
```

#### File: `storage/app/terraform/templates/hetzner/user-data.sh`

```bash
#!/bin/bash

set -euo pipefail

# Set hostname
hostnamectl set-hostname ${hostname}

# Update system packages
export DEBIAN_FRONTEND=noninteractive
apt-get update
apt-get upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
systemctl enable docker
systemctl start docker

# Install Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# Install essential tools
apt-get install -y \
  curl \
  wget \
  git \
  unzip \
  htop \
  net-tools \
  ca-certificates \
  gnupg \
  lsb-release

# Configure firewall (ufw)
ufw --force enable
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw allow 8080/tcp  # Coolify
ufw allow 8443/tcp  # Coolify SSL

# Create Coolify directory
mkdir -p /opt/coolify

# Signal completion
touch /var/log/cloud-init-complete.log

echo "Cloud-init completed successfully at $(date)" >> /var/log/cloud-init-complete.log
```

### Example Variable Files

#### File: `storage/app/terraform/templates/digitalocean/terraform.tfvars.example`

```hcl
# DigitalOcean Authentication
do_token = "dop_v1_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

# Deployment Configuration
deployment_name   = "coolify-production-server"
organization_id   = "123"
organization_name = "Acme Corporation"

# Droplet Configuration
droplet_size      = "s-2vcpu-2gb"  # $12/month
region            = "nyc3"
image             = "ubuntu-22-04-x64"
enable_monitoring = true
enable_backups    = false
enable_ipv6       = true

# Networking
create_vpc      = true
vpc_ip_range    = "10.10.10.0/24"

# SSH Configuration
ssh_public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ... user@example.com"
ssh_key_name   = "coolify-deploy-key"

# Firewall
allowed_ssh_cidr_blocks   = ["203.0.113.0/24"]  # Your office IP
allowed_http_cidr_blocks  = ["0.0.0.0/0"]
allowed_https_cidr_blocks = ["0.0.0.0/0"]

# Reserved IP
create_reserved_ip = false

# Volume
create_volume = true
volume_size   = 100  # GB

# Project
project_name        = "Coolify Production"
project_description = "Production infrastructure managed by Coolify"
```

#### File: `storage/app/terraform/templates/hetzner/terraform.tfvars.example`

```hcl
# Hetzner Cloud Authentication
hcloud_token = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

# Deployment Configuration
deployment_name   = "coolify-production-server"
organization_id   = "123"
organization_name = "Acme Corporation"

# Server Configuration
server_type     = "cx21"  # 2 vCPU, 4GB RAM, ~€5/month
location        = "nbg1"  # Nuremberg
image           = "ubuntu-22.04"
enable_backups  = false

# Networking
create_private_network    = true
private_network_ip_range  = "10.0.0.0/16"
private_network_subnet    = "10.0.1.0/24"

# SSH Configuration
ssh_public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ... user@example.com"
ssh_key_name   = "coolify-deploy-key"

# Firewall
allowed_ssh_cidr_blocks   = ["203.0.113.0/24"]  # Your office IP
allowed_http_cidr_blocks  = ["0.0.0.0/0"]
allowed_https_cidr_blocks = ["0.0.0.0/0"]

# Volume
create_volume  = true
volume_size    = 100  # GB
volume_format  = "ext4"

# High Availability
create_placement_group = false
```

## Implementation Approach

### Step 1: Create Directory Structure
1. Create `storage/app/terraform/templates/digitalocean/` directory
2. Create `storage/app/terraform/templates/hetzner/` directory
3. Verify directory permissions (755) for TerraformService access

### Step 2: Implement DigitalOcean Templates
1. Create `variables.tf` with all DigitalOcean-specific variables
2. Create `main.tf` with droplet, VPC, firewall, and volume resources
3. Create `outputs.tf` with structured output values
4. Create `versions.tf` with provider version constraints
5. Create `user-data.sh` cloud-init script
6. Create `terraform.tfvars.example` with sample values
7. Create `README.md` documenting template usage

### Step 3: Implement Hetzner Cloud Templates
1. Create `variables.tf` with all Hetzner-specific variables
2. Create `main.tf` with server, network, firewall, and volume resources
3. Create `outputs.tf` with structured output values
4. Create `versions.tf` with provider version constraints
5. Create `user-data.sh` cloud-init script
6. Create `terraform.tfvars.example` with sample values
7. Create `README.md` documenting template usage

### Step 4: Validate Templates
1. Run `terraform init` in both template directories
2. Run `terraform validate` to check HCL syntax
3. Run `terraform fmt` to format files
4. Test with sample `terraform.tfvars` (without actual API tokens)
5. Verify all variables have descriptions and defaults

### Step 5: Test with TerraformService
1. Update TerraformService to support DigitalOcean and Hetzner providers
2. Create test CloudProviderCredential records for both providers
3. Test full provisioning workflow with mock credentials
4. Verify template files are copied correctly to workspaces
5. Verify terraform.tfvars generation matches provider expectations

### Step 6: Integration Testing
1. Provision actual DigitalOcean droplet (use smallest size for testing)
2. Provision actual Hetzner server (use cx11 for testing)
3. Verify SSH access to provisioned servers
4. Verify cloud-init scripts executed successfully
5. Test destroy workflow and verify cleanup
6. Verify outputs are parsed correctly by TerraformService

### Step 7: Documentation
1. Create comprehensive README for each provider
2. Document all variables with examples
3. Add troubleshooting section
4. Document cost estimates for different configurations
5. Add links to provider documentation

### Step 8: Cost Optimization Review
1. Verify default instance types are cost-effective
2. Document cost implications of optional features (backups, volumes)
3. Add cost estimation examples to README
4. Consider adding cost calculator tool

## Test Strategy

### Manual Testing Checklist

#### DigitalOcean Template Testing
```bash
# Initialize template
cd storage/app/terraform/templates/digitalocean
terraform init

# Validate syntax
terraform validate

# Format check
terraform fmt -check

# Create test tfvars
cp terraform.tfvars.example terraform.tfvars
# Edit with test credentials

# Plan (dry run)
terraform plan

# Apply (if credentials valid)
terraform apply

# Verify outputs
terraform output

# Destroy
terraform destroy
```

#### Hetzner Template Testing
```bash
# Initialize template
cd storage/app/terraform/templates/hetzner
terraform init

# Validate syntax
terraform validate

# Format check
terraform fmt -check

# Create test tfvars
cp terraform.tfvars.example terraform.tfvars
# Edit with test credentials

# Plan (dry run)
terraform plan

# Apply (if credentials valid)
terraform apply

# Verify outputs
terraform output

# Destroy
terraform destroy
```

### Integration Tests

**File:** `tests/Feature/TerraformMultiCloudTest.php`

```php
<?php

use App\Services\Enterprise\TerraformService;
use App\Models\CloudProviderCredential;
use App\Models\Organization;

it('provisions DigitalOcean droplet successfully', function () {
    $organization = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->digitalocean()->create([
        'organization_id' => $organization->id,
    ]);

    $service = app(TerraformService::class);

    $config = [
        'name' => 'test-droplet',
        'droplet_size' => 's-1vcpu-1gb',
        'region' => 'nyc3',
        'ssh_public_key' => 'ssh-rsa AAAAB3NzaC1yc2E... test@example.com',
    ];

    $deployment = $service->provisionInfrastructure($credential, $config);

    expect($deployment->status)->toBe('completed')
        ->and($deployment->outputs)->toHaveKey('public_ipv4')
        ->and($deployment->outputs)->toHaveKey('droplet_id');
});

it('provisions Hetzner server successfully', function () {
    $organization = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->hetzner()->create([
        'organization_id' => $organization->id,
    ]);

    $service = app(TerraformService::class);

    $config = [
        'name' => 'test-server',
        'server_type' => 'cx11',
        'location' => 'nbg1',
        'ssh_public_key' => 'ssh-rsa AAAAB3NzaC1yc2E... test@example.com',
    ];

    $deployment = $service->provisionInfrastructure($credential, $config);

    expect($deployment->status)->toBe('completed')
        ->and($deployment->outputs)->toHaveKey('public_ipv4')
        ->and($deployment->outputs)->toHaveKey('server_id');
});

it('validates DigitalOcean template syntax', function () {
    $service = app(TerraformService::class);
    $templatePath = storage_path('app/terraform/templates/digitalocean/main.tf');

    $result = $service->validateTemplate($templatePath);

    expect($result['valid'])->toBeTrue()
        ->and($result['errors'])->toBeEmpty();
});

it('validates Hetzner template syntax', function () {
    $service = app(TerraformService::class);
    $templatePath = storage_path('app/terraform/templates/hetzner/main.tf');

    $result = $service->validateTemplate($templatePath);

    expect($result['valid'])->toBeTrue()
        ->and($result['errors'])->toBeEmpty();
});
```

### Performance Benchmarks

- **Template validation:** < 5 seconds per provider
- **Initial provisioning (DigitalOcean):** < 2 minutes
- **Initial provisioning (Hetzner):** < 1 minute
- **Destroy operation:** < 1 minute for both providers

## Definition of Done

### DigitalOcean Templates
- [ ] Directory created at `storage/app/terraform/templates/digitalocean/`
- [ ] `variables.tf` created with all variables documented
- [ ] `main.tf` created with droplet, VPC, firewall, volume resources
- [ ] `outputs.tf` created with comprehensive output values
- [ ] `versions.tf` created with provider version constraints
- [ ] `user-data.sh` created with cloud-init script
- [ ] `terraform.tfvars.example` created with realistic examples
- [ ] `README.md` created with usage documentation
- [ ] `terraform validate` passes with zero errors
- [ ] `terraform fmt -check` passes (proper formatting)
- [ ] All resources properly labeled/tagged
- [ ] Firewall rules include SSH, HTTP, HTTPS, custom ports
- [ ] VPC creation optional with existing VPC support
- [ ] Reserved IP (floating IP) creation optional
- [ ] Volume creation and attachment optional

### Hetzner Templates
- [ ] Directory created at `storage/app/terraform/templates/hetzner/`
- [ ] `variables.tf` created with all variables documented
- [ ] `main.tf` created with server, network, firewall, volume resources
- [ ] `outputs.tf` created with comprehensive output values
- [ ] `versions.tf` created with provider version constraints
- [ ] `user-data.sh` created with cloud-init script
- [ ] `terraform.tfvars.example` created with realistic examples
- [ ] `README.md` created with usage documentation
- [ ] `terraform validate` passes with zero errors
- [ ] `terraform fmt -check` passes (proper formatting)
- [ ] All resources properly labeled
- [ ] Firewall rules include SSH, HTTP, HTTPS, custom ports
- [ ] Private network creation optional
- [ ] Volume creation and attachment optional
- [ ] Placement group support for HA

### Integration & Testing
- [ ] TerraformService updated to support DigitalOcean provider
- [ ] TerraformService updated to support Hetzner provider
- [ ] Manual testing completed with actual DigitalOcean account
- [ ] Manual testing completed with actual Hetzner account
- [ ] Integration tests written for both providers
- [ ] Template validation tests passing
- [ ] Cost estimation documented for both providers
- [ ] Performance benchmarks met (< 2 minutes provisioning)

### Documentation & Code Quality
- [ ] Code follows HCL best practices
- [ ] Variable naming consistent across providers
- [ ] All resources commented and documented
- [ ] README files comprehensive and accurate
- [ ] Example tfvars files realistic and helpful
- [ ] Security best practices followed (restrictive firewalls)
- [ ] Cost optimization considered in defaults
- [ ] Templates reviewed by team member

## Related Tasks

- **Parallel to:** Task 15 (AWS Terraform templates)
- **Used by:** Task 14 (TerraformService for template loading)
- **Used by:** Task 18 (TerraformDeploymentJob for async execution)
- **Used by:** Task 19 (Server auto-registration after provisioning)
- **Used by:** Task 20 (TerraformManager.vue frontend component)
- **Integrates with:** Task 13 (CloudProviderCredential model for API tokens)
