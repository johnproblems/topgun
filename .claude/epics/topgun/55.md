---
name: Add rate limit headers to all API responses
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:09Z
github: https://github.com/johnproblems/topgun/issues/163
depends_on: [54]
parallel: false
conflicts_with: []
---

# Task: Add rate limit headers to all API responses

## Description

Implement standardized rate limit headers (`X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`) on all API responses to provide clients with transparent rate limiting information. This task enhances the API experience by enabling clients to implement intelligent retry logic, avoid hitting rate limits, and understand their current usage against tier-based quotas.

Rate limit headers are industry-standard HTTP headers that communicate rate limiting information to API consumers. This implementation follows RFC 6585 and common practices used by major APIs (GitHub, Twitter, Stripe):

- **X-RateLimit-Limit**: Maximum number of requests allowed in the current time window
- **X-RateLimit-Remaining**: Number of requests remaining in the current window
- **X-RateLimit-Reset**: Unix timestamp when the rate limit window resets

This task integrates with the existing tiered rate limiting system (Task 54) to expose rate limit state to API clients, enabling:

1. **Proactive Rate Limit Avoidance**: Clients can check `X-RateLimit-Remaining` and delay requests before hitting the limit
2. **Intelligent Retry Logic**: Clients can use `X-RateLimit-Reset` to determine when to retry failed requests
3. **Usage Monitoring**: Developers can track API consumption patterns and optimize their integration
4. **Debugging Support**: Clear visibility into rate limit enforcement helps troubleshoot 429 errors
5. **Multi-Tier Transparency**: Different organizations see their specific tier limits (Starter: 100/min, Pro: 500/min, Enterprise: 2000/min)

**Integration Points:**

- **Task 54 Dependency**: Requires the Redis-based rate limiting middleware to be operational
- **RateLimitMiddleware**: Extends existing middleware to inject headers based on Redis state
- **All API Routes**: Headers must be added to every API response (success and error)
- **EnterpriseLicense Model**: Tier-based limits sourced from license configuration
- **Redis Cache**: Rate limit counters and TTL information from existing implementation

**Why This Task Is Important:**

Rate limit headers transform opaque rate limiting into a transparent, developer-friendly system. Without these headers, API consumers have no way to know they're approaching a limit until they receive a 429 error—leading to failed requests, poor user experience, and increased support burden. By exposing rate limit state in every response, we enable clients to implement graceful degradation, intelligent backoff strategies, and proactive usage monitoring. This is a fundamental best practice for professional APIs and essential for the enterprise transformation.

## Acceptance Criteria

- [ ] X-RateLimit-Limit header added to all API responses with tier-based limit value
- [ ] X-RateLimit-Remaining header added with accurate remaining request count from Redis
- [ ] X-RateLimit-Reset header added with Unix timestamp for window reset time
- [ ] Headers present on successful responses (200, 201, 204, etc.)
- [ ] Headers present on rate-limited responses (429 Too Many Requests)
- [ ] Headers present on error responses (400, 401, 403, 500, etc.)
- [ ] Redis integration retrieves current usage and TTL without performance degradation
- [ ] Headers respect organization tier limits from enterprise_licenses table
- [ ] Headers update correctly after each request (remaining decrements)
- [ ] Multiple concurrent requests show consistent header values (no race conditions)
- [ ] Header values validated for correctness (remaining ≤ limit, reset > current time)
- [ ] API documentation updated to explain rate limit headers
- [ ] Unit tests verify header injection for all response types
- [ ] Integration tests verify Redis data accuracy in headers
- [ ] Performance impact < 5ms per request (header calculation overhead)

## Technical Details

### File Paths

**Middleware:**
- `/home/topgun/topgun/app/Http/Middleware/RateLimitMiddleware.php` (enhance existing)

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/RateLimitService.php` (enhance existing from Task 54)

**Configuration:**
- `/home/topgun/topgun/config/ratelimit.php` (existing from Task 54)

**Tests:**
- `/home/topgun/topgun/tests/Unit/Middleware/RateLimitHeadersTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Api/RateLimitHeadersTest.php` (new)

### Rate Limit Header Standards

Following industry best practices and RFC 6585:

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 500
X-RateLimit-Remaining: 487
X-RateLimit-Reset: 1704988800
Content-Type: application/json
```

**Header Definitions:**

1. **X-RateLimit-Limit** (integer)
   - Maximum requests allowed per time window
   - Static value based on organization tier
   - Example: `500` (Pro tier: 500 requests per minute)

2. **X-RateLimit-Remaining** (integer)
   - Requests remaining in current window
   - Decrements with each request
   - Example: `487` (13 requests consumed, 487 remaining)
   - Minimum value: `0` (when rate limited)

3. **X-RateLimit-Reset** (Unix timestamp)
   - Time when the rate limit window resets
   - Enables clients to calculate wait time
   - Example: `1704988800` (January 11, 2024 12:00:00 UTC)
   - Format: Seconds since Unix epoch

### Enhanced RateLimitMiddleware

**File:** `app/Http/Middleware/RateLimitMiddleware.php`

```php
<?php

namespace App\Http\Middleware;

use App\Services\Enterprise\RateLimitService;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;

class RateLimitMiddleware
{
    public function __construct(
        private RateLimitService $rateLimitService
    ) {}

    /**
     * Handle incoming request with rate limiting
     *
     * @param Request $request
     * @param Closure $next
     * @return Response
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Skip rate limiting for non-API routes
        if (!$request->is('api/*')) {
            return $next($request);
        }

        // Get authenticated user's organization
        $organization = $request->user()?->currentOrganization;

        if (!$organization) {
            // No organization context - allow but log
            Log::warning('API request without organization context', [
                'path' => $request->path(),
                'user_id' => $request->user()?->id,
            ]);

            return $next($request);
        }

        // Get rate limit configuration for organization
        $limit = $this->rateLimitService->getRateLimitForOrganization($organization);

        // Generate rate limit key (organization-scoped)
        $key = $this->getRateLimitKey($organization, $request);

        // Check rate limit and get current state
        $rateLimitState = $this->rateLimitService->checkRateLimit(
            $key,
            $limit['max_requests'],
            $limit['window_seconds']
        );

        // If rate limit exceeded, return 429 with headers
        if (!$rateLimitState['allowed']) {
            Log::info('Rate limit exceeded', [
                'organization_id' => $organization->id,
                'key' => $key,
                'limit' => $rateLimitState['limit'],
                'remaining' => $rateLimitState['remaining'],
            ]);

            return response()->json([
                'message' => 'Rate limit exceeded. Please try again later.',
                'error' => 'too_many_requests',
                'retry_after' => $rateLimitState['retry_after_seconds'],
            ], 429)
                ->withHeaders($this->formatRateLimitHeaders($rateLimitState));
        }

        // Process the request
        $response = $next($request);

        // Add rate limit headers to successful response
        return $response->withHeaders($this->formatRateLimitHeaders($rateLimitState));
    }

    /**
     * Generate rate limit cache key
     *
     * @param \App\Models\Organization $organization
     * @param Request $request
     * @return string
     */
    private function getRateLimitKey($organization, Request $request): string
    {
        // Organization-scoped rate limiting
        // Format: ratelimit:org:{org_id}:api
        return "ratelimit:org:{$organization->id}:api";
    }

    /**
     * Format rate limit state into HTTP headers
     *
     * @param array $rateLimitState State from RateLimitService
     * @return array HTTP headers
     */
    private function formatRateLimitHeaders(array $rateLimitState): array
    {
        return [
            'X-RateLimit-Limit' => (string) $rateLimitState['limit'],
            'X-RateLimit-Remaining' => (string) max(0, $rateLimitState['remaining']),
            'X-RateLimit-Reset' => (string) $rateLimitState['reset_at'],
        ];
    }

    /**
     * Handle response termination
     *
     * Log rate limit metrics for monitoring
     *
     * @param Request $request
     * @param Response $response
     * @return void
     */
    public function terminate(Request $request, Response $response): void
    {
        // Extract rate limit headers for metrics
        $limit = $response->headers->get('X-RateLimit-Limit');
        $remaining = $response->headers->get('X-RateLimit-Remaining');

        if ($limit && $remaining !== null) {
            $usagePercent = $limit > 0 ? (($limit - $remaining) / $limit) * 100 : 0;

            // Log high usage (>80%) for monitoring
            if ($usagePercent > 80) {
                Log::info('High rate limit usage', [
                    'organization_id' => $request->user()?->currentOrganization?->id,
                    'usage_percent' => round($usagePercent, 2),
                    'remaining' => $remaining,
                    'limit' => $limit,
                ]);
            }
        }
    }
}
```

### Enhanced RateLimitService

**File:** `app/Services/Enterprise/RateLimitService.php`

Add method to return detailed rate limit state with headers:

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\RateLimitServiceInterface;
use App\Models\Organization;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

class RateLimitService implements RateLimitServiceInterface
{
    // Existing methods from Task 54...

    /**
     * Check rate limit and return detailed state for headers
     *
     * @param string $key Cache key
     * @param int $maxRequests Maximum requests allowed
     * @param int $windowSeconds Time window in seconds
     * @return array Detailed rate limit state
     */
    public function checkRateLimit(string $key, int $maxRequests, int $windowSeconds): array
    {
        $redis = Redis::connection('cache');

        // Get current request count
        $currentCount = (int) $redis->get($key) ?: 0;

        // Get TTL (time until reset)
        $ttl = $redis->ttl($key);

        // Calculate reset timestamp
        if ($ttl > 0) {
            $resetAt = time() + $ttl;
        } else {
            // No TTL means key doesn't exist or expired - set new window
            $resetAt = time() + $windowSeconds;
        }

        // Check if rate limit exceeded
        $allowed = $currentCount < $maxRequests;

        if ($allowed) {
            // Increment counter
            $newCount = $redis->incr($key);

            // Set expiration on first request in window
            if ($newCount === 1) {
                $redis->expire($key, $windowSeconds);
                $resetAt = time() + $windowSeconds;
            }

            $remaining = max(0, $maxRequests - $newCount);
        } else {
            // Rate limit exceeded
            $remaining = 0;
        }

        return [
            'allowed' => $allowed,
            'limit' => $maxRequests,
            'remaining' => $remaining,
            'reset_at' => $resetAt,
            'retry_after_seconds' => $allowed ? 0 : $ttl,
            'window_seconds' => $windowSeconds,
        ];
    }

    /**
     * Get rate limit configuration for organization
     *
     * @param Organization $organization
     * @return array Rate limit config
     */
    public function getRateLimitForOrganization(Organization $organization): array
    {
        // Cache the license lookup for 5 minutes
        $cacheKey = "ratelimit:config:org:{$organization->id}";

        return Cache::remember($cacheKey, 300, function () use ($organization) {
            $license = $organization->enterpriseLicense;

            if (!$license) {
                // Default rate limit for organizations without license
                return [
                    'max_requests' => config('ratelimit.default_limit', 100),
                    'window_seconds' => 60,
                    'tier' => 'free',
                ];
            }

            // Get tier-based limits from license
            $tierLimits = $license->feature_flags['api_rate_limit'] ?? null;

            if (!$tierLimits) {
                // Fallback to tier-based defaults
                $tierLimits = $this->getDefaultLimitsForTier($license->tier);
            }

            return [
                'max_requests' => $tierLimits['max_requests'],
                'window_seconds' => $tierLimits['window_seconds'] ?? 60,
                'tier' => $license->tier,
            ];
        });
    }

    /**
     * Get default rate limits for license tier
     *
     * @param string $tier
     * @return array
     */
    private function getDefaultLimitsForTier(string $tier): array
    {
        return match (strtolower($tier)) {
            'starter', 'free' => [
                'max_requests' => 100,
                'window_seconds' => 60,
            ],
            'pro', 'professional' => [
                'max_requests' => 500,
                'window_seconds' => 60,
            ],
            'enterprise', 'unlimited' => [
                'max_requests' => 2000,
                'window_seconds' => 60,
            ],
            default => [
                'max_requests' => config('ratelimit.default_limit', 100),
                'window_seconds' => 60,
            ],
        };
    }

    /**
     * Get current rate limit status without incrementing
     *
     * Useful for status endpoints that shouldn't consume quota
     *
     * @param string $key
     * @param int $maxRequests
     * @param int $windowSeconds
     * @return array
     */
    public function getRateLimitStatus(string $key, int $maxRequests, int $windowSeconds): array
    {
        $redis = Redis::connection('cache');

        $currentCount = (int) $redis->get($key) ?: 0;
        $ttl = $redis->ttl($key);

        $resetAt = $ttl > 0 ? time() + $ttl : time() + $windowSeconds;
        $remaining = max(0, $maxRequests - $currentCount);

        return [
            'limit' => $maxRequests,
            'remaining' => $remaining,
            'reset_at' => $resetAt,
            'used' => $currentCount,
            'window_seconds' => $windowSeconds,
        ];
    }
}
```

### Exception Handler Enhancement

**File:** `app/Exceptions/Handler.php`

Ensure rate limit headers are included on error responses:

```php
<?php

namespace App\Exceptions;

use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Illuminate\Http\Request;
use Symfony\Component\HttpKernel\Exception\TooManyRequestsHttpException;
use Throwable;

class Handler extends ExceptionHandler
{
    // Existing exception handling...

    /**
     * Render an exception into an HTTP response.
     *
     * @param Request $request
     * @param Throwable $e
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function render($request, Throwable $e)
    {
        $response = parent::render($request, $e);

        // Preserve rate limit headers from middleware even on errors
        if ($request->is('api/*') && $request->attributes->has('ratelimit_state')) {
            $rateLimitState = $request->attributes->get('ratelimit_state');

            $response->headers->set('X-RateLimit-Limit', (string) $rateLimitState['limit']);
            $response->headers->set('X-RateLimit-Remaining', (string) max(0, $rateLimitState['remaining']));
            $response->headers->set('X-RateLimit-Reset', (string) $rateLimitState['reset_at']);
        }

        return $response;
    }

    /**
     * Convert TooManyRequestsHttpException to JSON with rate limit info
     *
     * @param Request $request
     * @param TooManyRequestsHttpException $exception
     * @return \Illuminate\Http\JsonResponse
     */
    protected function convertTooManyRequestsException(Request $request, TooManyRequestsHttpException $exception)
    {
        $retryAfter = $exception->getHeaders()['Retry-After'] ?? null;

        return response()->json([
            'message' => 'Too Many Requests',
            'error' => 'rate_limit_exceeded',
            'retry_after' => $retryAfter,
        ], 429);
    }
}
```

### API Response Helper

**File:** `app/Http/Helpers/ApiResponse.php` (optional enhancement)

```php
<?php

namespace App\Http\Helpers;

use Illuminate\Http\JsonResponse;

class ApiResponse
{
    /**
     * Create standardized API response with rate limit headers
     *
     * @param mixed $data
     * @param int $statusCode
     * @param array $headers
     * @return JsonResponse
     */
    public static function success($data, int $statusCode = 200, array $headers = []): JsonResponse
    {
        return response()->json($data, $statusCode)->withHeaders($headers);
    }

    /**
     * Create error response with rate limit headers
     *
     * @param string $message
     * @param int $statusCode
     * @param array $headers
     * @return JsonResponse
     */
    public static function error(string $message, int $statusCode = 400, array $headers = []): JsonResponse
    {
        return response()->json([
            'message' => $message,
            'error' => true,
        ], $statusCode)->withHeaders($headers);
    }
}
```

### Configuration

**File:** `config/ratelimit.php` (existing from Task 54)

Add configuration for header behavior:

```php
<?php

return [
    // Rate limit tiers (from Task 54)
    'tiers' => [
        'free' => [
            'max_requests' => env('RATE_LIMIT_FREE', 100),
            'window_seconds' => 60,
        ],
        'pro' => [
            'max_requests' => env('RATE_LIMIT_PRO', 500),
            'window_seconds' => 60,
        ],
        'enterprise' => [
            'max_requests' => env('RATE_LIMIT_ENTERPRISE', 2000),
            'window_seconds' => 60,
        ],
    ],

    // Default limit for organizations without license
    'default_limit' => env('RATE_LIMIT_DEFAULT', 100),

    // Header configuration
    'headers' => [
        'enabled' => env('RATE_LIMIT_HEADERS_ENABLED', true),
        'prefix' => 'X-RateLimit-', // Standard prefix
    ],

    // Redis configuration
    'redis_connection' => 'cache',
    'cache_prefix' => 'ratelimit:',

    // Monitoring
    'log_high_usage_threshold' => 80, // Log when usage exceeds 80%
];
```

## Implementation Approach

### Step 1: Enhance RateLimitService

1. Open `app/Services/Enterprise/RateLimitService.php` (created in Task 54)
2. Add `checkRateLimit()` method that returns detailed state array
3. Ensure method returns: `allowed`, `limit`, `remaining`, `reset_at`, `retry_after_seconds`
4. Add `getRateLimitStatus()` for non-consuming queries
5. Test Redis TTL calculation for accurate reset timestamps

### Step 2: Update RateLimitMiddleware

1. Open `app/Http/Middleware/RateLimitMiddleware.php` (created in Task 54)
2. Modify `handle()` method to use new `checkRateLimit()` with detailed state
3. Add `formatRateLimitHeaders()` private method to convert state to HTTP headers
4. Call `withHeaders()` on response to inject rate limit headers
5. Ensure headers are added to both success and 429 responses
6. Add `terminate()` method for logging high usage

### Step 3: Update Exception Handler

1. Open `app/Exceptions/Handler.php`
2. Override `render()` method to preserve rate limit headers on exceptions
3. Add special handling for TooManyRequestsHttpException
4. Ensure rate limit headers are included on all error responses (400, 401, 403, 500)

### Step 4: Add API Status Endpoint (Optional)

1. Create `/api/v1/rate-limit/status` endpoint
2. Return current rate limit status without consuming quota
3. Use `getRateLimitStatus()` method to avoid incrementing counter
4. Useful for clients to check their status before making real requests

### Step 5: Update API Documentation

1. Open API documentation (OpenAPI/Swagger spec)
2. Add global response header definitions for all endpoints
3. Document header meanings and example values
4. Add code examples showing how clients should use headers
5. Document the 429 response format and retry logic

### Step 6: Testing

1. Create unit tests for `formatRateLimitHeaders()` method
2. Create unit tests for `checkRateLimit()` state calculation
3. Create integration tests verifying headers on successful requests
4. Create integration tests verifying headers on 429 responses
5. Create integration tests verifying headers on error responses
6. Test concurrent requests for race conditions
7. Test TTL expiration and window reset behavior

### Step 7: Performance Validation

1. Benchmark middleware overhead with header injection
2. Ensure < 5ms added latency per request
3. Verify Redis connection pooling is efficient
4. Test under high concurrency (1000+ req/s)

### Step 8: Deployment

1. Deploy middleware changes to staging
2. Verify headers appear in staging API responses
3. Test with sample API clients
4. Deploy to production with monitoring
5. Monitor error rates and header accuracy

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Middleware/RateLimitHeadersTest.php`

```php
<?php

namespace Tests\Unit\Middleware;

use App\Http\Middleware\RateLimitMiddleware;
use App\Services\Enterprise\RateLimitService;
use App\Models\Organization;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Tests\TestCase;

class RateLimitHeadersTest extends TestCase
{
    private RateLimitMiddleware $middleware;
    private RateLimitService $rateLimitService;

    protected function setUp(): void
    {
        parent::setUp();

        $this->rateLimitService = $this->mock(RateLimitService::class);
        $this->middleware = new RateLimitMiddleware($this->rateLimitService);
    }

    public function test_adds_rate_limit_headers_to_successful_response(): void
    {
        $organization = Organization::factory()->create();
        $user = User::factory()->create();
        $user->currentOrganization = $organization;

        $request = Request::create('/api/v1/test', 'GET');
        $request->setUserResolver(fn() => $user);

        $this->rateLimitService->shouldReceive('getRateLimitForOrganization')
            ->with($organization)
            ->andReturn([
                'max_requests' => 500,
                'window_seconds' => 60,
                'tier' => 'pro',
            ]);

        $this->rateLimitService->shouldReceive('checkRateLimit')
            ->andReturn([
                'allowed' => true,
                'limit' => 500,
                'remaining' => 487,
                'reset_at' => 1704988800,
                'retry_after_seconds' => 0,
                'window_seconds' => 60,
            ]);

        $response = $this->middleware->handle($request, function ($req) {
            return new Response('OK', 200);
        });

        expect($response->headers->get('X-RateLimit-Limit'))->toBe('500')
            ->and($response->headers->get('X-RateLimit-Remaining'))->toBe('487')
            ->and($response->headers->get('X-RateLimit-Reset'))->toBe('1704988800');
    }

    public function test_adds_rate_limit_headers_to_429_response(): void
    {
        $organization = Organization::factory()->create();
        $user = User::factory()->create();
        $user->currentOrganization = $organization;

        $request = Request::create('/api/v1/test', 'GET');
        $request->setUserResolver(fn() => $user);

        $this->rateLimitService->shouldReceive('getRateLimitForOrganization')
            ->andReturn(['max_requests' => 100, 'window_seconds' => 60, 'tier' => 'free']);

        $this->rateLimitService->shouldReceive('checkRateLimit')
            ->andReturn([
                'allowed' => false,
                'limit' => 100,
                'remaining' => 0,
                'reset_at' => 1704988860,
                'retry_after_seconds' => 45,
                'window_seconds' => 60,
            ]);

        $response = $this->middleware->handle($request, function ($req) {
            return new Response('OK', 200);
        });

        expect($response->getStatusCode())->toBe(429)
            ->and($response->headers->get('X-RateLimit-Limit'))->toBe('100')
            ->and($response->headers->get('X-RateLimit-Remaining'))->toBe('0')
            ->and($response->headers->get('X-RateLimit-Reset'))->toBe('1704988860');
    }

    public function test_remaining_never_goes_negative(): void
    {
        $organization = Organization::factory()->create();
        $user = User::factory()->create();
        $user->currentOrganization = $organization;

        $request = Request::create('/api/v1/test', 'GET');
        $request->setUserResolver(fn() => $user);

        $this->rateLimitService->shouldReceive('getRateLimitForOrganization')
            ->andReturn(['max_requests' => 100, 'window_seconds' => 60]);

        $this->rateLimitService->shouldReceive('checkRateLimit')
            ->andReturn([
                'allowed' => false,
                'limit' => 100,
                'remaining' => -5, // Negative value from service
                'reset_at' => 1704988800,
                'retry_after_seconds' => 30,
            ]);

        $response = $this->middleware->handle($request, function ($req) {
            return new Response('OK', 200);
        });

        // Should be clamped to 0
        expect($response->headers->get('X-RateLimit-Remaining'))->toBe('0');
    }

    public function test_headers_are_strings_not_integers(): void
    {
        $organization = Organization::factory()->create();
        $user = User::factory()->create();
        $user->currentOrganization = $organization;

        $request = Request::create('/api/v1/test', 'GET');
        $request->setUserResolver(fn() => $user);

        $this->rateLimitService->shouldReceive('getRateLimitForOrganization')
            ->andReturn(['max_requests' => 500, 'window_seconds' => 60]);

        $this->rateLimitService->shouldReceive('checkRateLimit')
            ->andReturn([
                'allowed' => true,
                'limit' => 500,
                'remaining' => 499,
                'reset_at' => 1704988800,
                'retry_after_seconds' => 0,
            ]);

        $response = $this->middleware->handle($request, function ($req) {
            return new Response('OK', 200);
        });

        // Headers must be strings
        expect($response->headers->get('X-RateLimit-Limit'))->toBeString()
            ->and($response->headers->get('X-RateLimit-Remaining'))->toBeString()
            ->and($response->headers->get('X-RateLimit-Reset'))->toBeString();
    }
}
```

### Integration Tests

**File:** `tests/Feature/Api/RateLimitHeadersTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Organization;
use App\Models\User;
use App\Models\EnterpriseLicense;
use Illuminate\Support\Facades\Redis;
use Tests\TestCase;

class RateLimitHeadersTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp();

        // Clear Redis before each test
        Redis::connection('cache')->flushdb();
    }

    public function test_api_requests_include_rate_limit_headers(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'pro',
            'feature_flags' => [
                'api_rate_limit' => [
                    'max_requests' => 500,
                    'window_seconds' => 60,
                ],
            ],
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        $response = $this->actingAs($user)
            ->getJson('/api/v1/organizations');

        $response->assertOk()
            ->assertHeader('X-RateLimit-Limit', '500')
            ->assertHeader('X-RateLimit-Remaining', '499') // 1 request consumed
            ->assertHeader('X-RateLimit-Reset');

        // Verify reset timestamp is in the future
        $resetAt = (int) $response->headers->get('X-RateLimit-Reset');
        expect($resetAt)->toBeGreaterThan(time());
    }

    public function test_headers_decrement_with_each_request(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'starter',
            'feature_flags' => [
                'api_rate_limit' => [
                    'max_requests' => 100,
                    'window_seconds' => 60,
                ],
            ],
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // First request
        $response1 = $this->actingAs($user)->getJson('/api/v1/organizations');
        $remaining1 = (int) $response1->headers->get('X-RateLimit-Remaining');

        // Second request
        $response2 = $this->actingAs($user)->getJson('/api/v1/organizations');
        $remaining2 = (int) $response2->headers->get('X-RateLimit-Remaining');

        // Third request
        $response3 = $this->actingAs($user)->getJson('/api/v1/organizations');
        $remaining3 = (int) $response3->headers->get('X-RateLimit-Remaining');

        expect($remaining1)->toBe(99)
            ->and($remaining2)->toBe(98)
            ->and($remaining3)->toBe(97);
    }

    public function test_429_response_includes_rate_limit_headers(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'free',
            'feature_flags' => [
                'api_rate_limit' => [
                    'max_requests' => 5, // Very low limit for testing
                    'window_seconds' => 60,
                ],
            ],
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Make 5 requests to exhaust limit
        for ($i = 0; $i < 5; $i++) {
            $this->actingAs($user)->getJson('/api/v1/organizations');
        }

        // 6th request should be rate limited
        $response = $this->actingAs($user)->getJson('/api/v1/organizations');

        $response->assertStatus(429)
            ->assertHeader('X-RateLimit-Limit', '5')
            ->assertHeader('X-RateLimit-Remaining', '0')
            ->assertHeader('X-RateLimit-Reset')
            ->assertJson([
                'message' => 'Rate limit exceeded. Please try again later.',
                'error' => 'too_many_requests',
            ]);

        // Verify retry_after is present and reasonable
        $retryAfter = $response->json('retry_after');
        expect($retryAfter)->toBeInt()
            ->toBeGreaterThan(0)
            ->toBeLessThanOrEqual(60);
    }

    public function test_error_responses_include_rate_limit_headers(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'pro',
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Make request to non-existent endpoint (404)
        $response = $this->actingAs($user)->getJson('/api/v1/nonexistent');

        $response->assertNotFound()
            ->assertHeader('X-RateLimit-Limit', '500')
            ->assertHeader('X-RateLimit-Remaining', '499')
            ->assertHeader('X-RateLimit-Reset');
    }

    public function test_different_tiers_have_different_limits(): void
    {
        // Free tier organization
        $orgFree = Organization::factory()->create();
        EnterpriseLicense::factory()->create([
            'organization_id' => $orgFree->id,
            'tier' => 'free',
        ]);
        $userFree = User::factory()->create();
        $orgFree->users()->attach($userFree, ['role' => 'admin']);

        // Enterprise tier organization
        $orgEnterprise = Organization::factory()->create();
        EnterpriseLicense::factory()->create([
            'organization_id' => $orgEnterprise->id,
            'tier' => 'enterprise',
        ]);
        $userEnterprise = User::factory()->create();
        $orgEnterprise->users()->attach($userEnterprise, ['role' => 'admin']);

        // Test free tier
        $responseFree = $this->actingAs($userFree)->getJson('/api/v1/organizations');
        expect($responseFree->headers->get('X-RateLimit-Limit'))->toBe('100');

        // Test enterprise tier
        $responseEnterprise = $this->actingAs($userEnterprise)->getJson('/api/v1/organizations');
        expect($responseEnterprise->headers->get('X-RateLimit-Limit'))->toBe('2000');
    }

    public function test_reset_timestamp_updates_after_window_expires(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'pro',
            'feature_flags' => [
                'api_rate_limit' => [
                    'max_requests' => 100,
                    'window_seconds' => 2, // 2 second window for testing
                ],
            ],
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // First request
        $response1 = $this->actingAs($user)->getJson('/api/v1/organizations');
        $reset1 = (int) $response1->headers->get('X-RateLimit-Reset');
        $remaining1 = (int) $response1->headers->get('X-RateLimit-Remaining');

        // Wait for window to expire
        sleep(3);

        // Request after window expiration
        $response2 = $this->actingAs($user)->getJson('/api/v1/organizations');
        $reset2 = (int) $response2->headers->get('X-RateLimit-Reset');
        $remaining2 = (int) $response2->headers->get('X-RateLimit-Remaining');

        // New window should have higher reset time and reset remaining count
        expect($reset2)->toBeGreaterThan($reset1)
            ->and($remaining2)->toBe(99); // Fresh window, 1 request consumed
    }
}
```

### Performance Tests

**File:** `tests/Feature/Api/RateLimitPerformanceTest.php`

```php
<?php

namespace Tests\Feature\Api;

use App\Models\Organization;
use App\Models\User;
use App\Models\EnterpriseLicense;
use Illuminate\Support\Facades\Redis;
use Tests\TestCase;

class RateLimitPerformanceTest extends TestCase
{
    public function test_header_injection_adds_minimal_latency(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'pro',
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        $iterations = 100;
        $totalTime = 0;

        for ($i = 0; $i < $iterations; $i++) {
            $start = microtime(true);

            $this->actingAs($user)->getJson('/api/v1/organizations');

            $end = microtime(true);
            $totalTime += ($end - $start);
        }

        $averageTime = ($totalTime / $iterations) * 1000; // Convert to milliseconds

        // Average response time should be under 50ms for simple endpoint
        expect($averageTime)->toBeLessThan(50);

        // Redis operations should not significantly impact performance
        $this->assertTrue(true, "Average response time: {$averageTime}ms");
    }

    public function test_concurrent_requests_maintain_header_consistency(): void
    {
        $organization = Organization::factory()->create();
        $license = EnterpriseLicense::factory()->create([
            'organization_id' => $organization->id,
            'tier' => 'pro',
            'feature_flags' => [
                'api_rate_limit' => [
                    'max_requests' => 1000,
                    'window_seconds' => 60,
                ],
            ],
        ]);

        $user = User::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        // Simulate 10 concurrent requests
        $promises = [];
        for ($i = 0; $i < 10; $i++) {
            $promises[] = $this->actingAs($user)->getJson('/api/v1/organizations');
        }

        // Collect all responses
        $remainingCounts = array_map(
            fn($response) => (int) $response->headers->get('X-RateLimit-Remaining'),
            $promises
        );

        // All remaining counts should be unique and sequential
        expect(count(array_unique($remainingCounts)))->toBe(10)
            ->and(max($remainingCounts))->toBe(999) // First request
            ->and(min($remainingCounts))->toBe(990); // 10th request
    }
}
```

## Definition of Done

- [ ] RateLimitService enhanced with `checkRateLimit()` method returning detailed state
- [ ] RateLimitService includes `getRateLimitStatus()` for non-consuming queries
- [ ] RateLimitMiddleware injects headers on all API responses
- [ ] RateLimitMiddleware includes headers on 200, 201, 204 success responses
- [ ] RateLimitMiddleware includes headers on 429 rate-limited responses
- [ ] RateLimitMiddleware includes headers on 400, 401, 403, 500 error responses
- [ ] Exception handler preserves rate limit headers on exceptions
- [ ] Header values are accurate and consistent with Redis state
- [ ] X-RateLimit-Limit shows tier-based limit from license
- [ ] X-RateLimit-Remaining decrements correctly with each request
- [ ] X-RateLimit-Remaining never goes negative (clamped to 0)
- [ ] X-RateLimit-Reset shows accurate Unix timestamp for window reset
- [ ] Header values are strings (not integers) for HTTP compliance
- [ ] Redis TTL calculation is accurate for reset timestamp
- [ ] Concurrent requests show consistent header values (no race conditions)
- [ ] Configuration allows disabling headers via environment variable
- [ ] Unit tests written and passing (10+ tests, >90% coverage)
- [ ] Integration tests written and passing (8+ tests)
- [ ] Performance tests verify < 5ms overhead
- [ ] API documentation updated with header definitions and examples
- [ ] Code follows Laravel 12 and Coolify coding standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 analysis passes with zero errors
- [ ] Manual testing completed with various API clients
- [ ] Monitoring added for high usage logging
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 54 (Implement tiered rate limiting middleware using Redis)
- **Enables:** Better API client experience with transparent rate limiting
- **Integrates with:** Task 56 (Create new API endpoints - all endpoints need headers)
- **Integrates with:** Task 57 (OpenAPI documentation - document headers)
- **Integrates with:** Task 60 (API usage monitoring - headers enable client-side monitoring)
