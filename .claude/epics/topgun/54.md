---
name: Implement tiered rate limiting middleware using Redis
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:09Z
github: https://github.com/johnproblems/topgun/issues/162
depends_on: [53]
parallel: false
conflicts_with: []
---

# Task: Implement tiered rate limiting middleware using Redis

## Description

Implement a sophisticated tiered rate limiting middleware system that enforces organization-specific API request limits based on their enterprise license tier. This middleware protects the Coolify Enterprise platform from abuse, ensures fair resource allocation across organizations, and enforces commercial tier boundaries through Redis-backed rate limiting.

The rate limiting system provides granular control over API access patterns by tracking requests per organization, per user, and per API endpoint. It uses Laravel's built-in rate limiting framework enhanced with Redis for distributed rate limiting across multiple application servers, ensuring consistent enforcement even in load-balanced environments.

**Core Features:**

1. **Tiered Rate Limits**: License-based limits (Starter: 100/min, Professional: 500/min, Enterprise: 2000/min, Custom: configurable)
2. **Multi-Dimensional Tracking**: Track limits per organization, per user, per endpoint, and per IP address
3. **Graceful Degradation**: Configurable responses when limits are exceeded (429 with Retry-After header)
4. **Real-Time Monitoring**: Integration with monitoring dashboard showing rate limit consumption
5. **Bypass Mechanism**: Whitelist critical operations and administrative endpoints
6. **Dynamic Configuration**: Update rate limits without deployment via admin dashboard
7. **Detailed Analytics**: Log rate limit hits for abuse pattern detection and capacity planning

**Integration Points:**

- **EnterpriseLicense Model**: Retrieve organization tier and custom rate limits from `feature_limits` JSON column
- **ApiOrganizationScope Middleware** (Task 53): Organization context already established before rate limiting
- **Redis**: Distributed storage for rate limit counters with automatic expiration
- **API Response Headers**: Standard rate limit headers (`X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`)
- **ApiUsageMonitoring.vue** (Task 60): Real-time dashboard showing rate limit consumption

**Why This Task Is Critical:**

Rate limiting is essential for multi-tenant SaaS platforms to prevent resource monopolization, enforce commercial boundaries, and protect infrastructure from abuse. Without proper rate limiting, a single organization could overwhelm the system, degrading performance for all users. Tiered rate limits also serve as a commercial differentiation mechanism, encouraging upgrades to higher-tier licenses for increased API capacity. This implementation ensures fair resource allocation while maintaining platform stability and revenue potential.

## Acceptance Criteria

- [ ] Laravel middleware `EnterpriseRateLimitMiddleware` created with tier-based limit enforcement
- [ ] Redis-backed rate limiting with atomic increment operations
- [ ] Support for multiple rate limit dimensions: per-organization, per-user, per-endpoint, per-IP
- [ ] License tier detection from `EnterpriseLicense` model with fallback to default limits
- [ ] Custom rate limits supported via `feature_limits` JSON column in licenses table
- [ ] Standard HTTP 429 responses with `Retry-After` header
- [ ] Rate limit headers included in all API responses (`X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`)
- [ ] Whitelist mechanism for critical endpoints and administrative operations
- [ ] Rate limit hit logging for analytics and abuse detection
- [ ] Configuration file for default tier limits and whitelist endpoints
- [ ] Graceful handling when Redis is unavailable (fail-open vs fail-closed configurable)
- [ ] Integration with Laravel's built-in `ThrottleRequests` middleware as fallback
- [ ] Unit tests covering all rate limit tiers and edge cases (>90% coverage)
- [ ] Integration tests with Redis and organization context
- [ ] Performance benchmarks (< 5ms overhead per request)

## Technical Details

### File Paths

**Middleware:**
- `/home/topgun/topgun/app/Http/Middleware/Enterprise/EnterpriseRateLimitMiddleware.php` (new)

**Configuration:**
- `/home/topgun/topgun/config/enterprise.php` (enhance with rate_limiting section)

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/RateLimitService.php` (new)
- `/home/topgun/topgun/app/Contracts/RateLimitServiceInterface.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/EnterpriseLicense.php` (existing - add rate limit accessors)
- `/home/topgun/topgun/app/Models/RateLimitLog.php` (new - optional analytics)

**Routes:**
- `/home/topgun/topgun/routes/api.php` (apply middleware to API routes)

### Middleware Implementation

**File:** `app/Http/Middleware/Enterprise/EnterpriseRateLimitMiddleware.php`

```php
<?php

namespace App\Http\Middleware\Enterprise;

use App\Contracts\RateLimitServiceInterface;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response as HttpResponse;

class EnterpriseRateLimitMiddleware
{
    /**
     * Rate limit window in seconds (default: 60 seconds = 1 minute)
     */
    private const WINDOW_SECONDS = 60;

    /**
     * Default rate limits per tier (requests per minute)
     */
    private const DEFAULT_TIER_LIMITS = [
        'starter' => 100,
        'professional' => 500,
        'enterprise' => 2000,
        'custom' => 5000, // Default for custom tiers
    ];

    public function __construct(
        private RateLimitServiceInterface $rateLimitService
    ) {}

    /**
     * Handle an incoming request
     *
     * @param Request $request
     * @param Closure $next
     * @return Response
     */
    public function handle(Request $request, Closure $next)
    {
        // Skip rate limiting for whitelisted routes
        if ($this->isWhitelisted($request)) {
            return $next($request);
        }

        // Get organization from request context (set by ApiOrganizationScope middleware)
        $organization = $request->user()?->currentOrganization ?? $request->organization;

        if (!$organization) {
            // No organization context - apply strictest default limit
            return $this->handleNoOrganization($request, $next);
        }

        // Get rate limit for organization
        $limit = $this->getRateLimit($organization);

        // Build rate limit key
        $key = $this->buildRateLimitKey($request, $organization);

        // Check and increment rate limit
        $result = $this->rateLimitService->checkAndIncrement(
            $key,
            $limit,
            self::WINDOW_SECONDS
        );

        // Add rate limit headers to response
        $response = $next($request);
        $this->addRateLimitHeaders($response, $result);

        // Log rate limit hit if threshold exceeded
        if ($result['remaining'] < ($limit * 0.1)) { // Less than 10% remaining
            $this->logRateLimitWarning($organization, $result);
        }

        // If limit exceeded, return 429
        if ($result['exceeded']) {
            return $this->buildRateLimitExceededResponse($result);
        }

        return $response;
    }

    /**
     * Get rate limit for organization based on license tier
     *
     * @param \App\Models\Organization $organization
     * @return int Requests per minute
     */
    private function getRateLimit($organization): int
    {
        $license = $organization->currentLicense;

        if (!$license) {
            return self::DEFAULT_TIER_LIMITS['starter']; // Default to lowest tier
        }

        // Check for custom rate limit in feature_limits
        if ($license->feature_limits && isset($license->feature_limits['api_rate_limit'])) {
            return (int) $license->feature_limits['api_rate_limit'];
        }

        // Use tier-based default
        $tier = strtolower($license->tier);
        return self::DEFAULT_TIER_LIMITS[$tier] ?? self::DEFAULT_TIER_LIMITS['starter'];
    }

    /**
     * Build Redis key for rate limiting
     *
     * @param Request $request
     * @param \App\Models\Organization $organization
     * @return string
     */
    private function buildRateLimitKey(Request $request, $organization): string
    {
        $userId = $request->user()?->id ?? 'anonymous';
        $organizationId = $organization->id;
        $endpoint = $request->path();

        // Use different strategies based on configuration
        $strategy = config('enterprise.rate_limiting.strategy', 'organization');

        return match ($strategy) {
            'organization' => "rate_limit:org:{$organizationId}",
            'user' => "rate_limit:user:{$userId}",
            'endpoint' => "rate_limit:org:{$organizationId}:endpoint:{$endpoint}",
            'combined' => "rate_limit:org:{$organizationId}:user:{$userId}",
            default => "rate_limit:org:{$organizationId}",
        };
    }

    /**
     * Check if route is whitelisted from rate limiting
     *
     * @param Request $request
     * @return bool
     */
    private function isWhitelisted(Request $request): bool
    {
        $whitelistedRoutes = config('enterprise.rate_limiting.whitelist', []);

        $path = $request->path();
        $routeName = $request->route()?->getName();

        // Check by path
        foreach ($whitelistedRoutes as $pattern) {
            if (fnmatch($pattern, $path)) {
                return true;
            }
        }

        // Check by route name
        if ($routeName && in_array($routeName, $whitelistedRoutes)) {
            return true;
        }

        return false;
    }

    /**
     * Handle requests without organization context
     *
     * @param Request $request
     * @param Closure $next
     * @return Response
     */
    private function handleNoOrganization(Request $request, Closure $next)
    {
        // Apply IP-based rate limiting for unauthenticated requests
        $ip = $request->ip();
        $key = "rate_limit:ip:{$ip}";
        $limit = config('enterprise.rate_limiting.anonymous_limit', 60);

        $result = $this->rateLimitService->checkAndIncrement(
            $key,
            $limit,
            self::WINDOW_SECONDS
        );

        if ($result['exceeded']) {
            return $this->buildRateLimitExceededResponse($result);
        }

        $response = $next($request);
        $this->addRateLimitHeaders($response, $result);

        return $response;
    }

    /**
     * Add rate limit headers to response
     *
     * @param Response $response
     * @param array $result
     * @return void
     */
    private function addRateLimitHeaders($response, array $result): void
    {
        $response->headers->set('X-RateLimit-Limit', $result['limit']);
        $response->headers->set('X-RateLimit-Remaining', max(0, $result['remaining']));
        $response->headers->set('X-RateLimit-Reset', $result['reset_at']);

        // Add custom header for organization tier (optional)
        if (isset($result['tier'])) {
            $response->headers->set('X-RateLimit-Tier', $result['tier']);
        }
    }

    /**
     * Build 429 response when rate limit exceeded
     *
     * @param array $result
     * @return Response
     */
    private function buildRateLimitExceededResponse(array $result): Response
    {
        $retryAfter = $result['reset_at'] - time();

        return response()->json([
            'message' => 'Rate limit exceeded. Please try again later.',
            'error' => 'rate_limit_exceeded',
            'limit' => $result['limit'],
            'reset_at' => $result['reset_at'],
            'retry_after_seconds' => max(1, $retryAfter),
        ], HttpResponse::HTTP_TOO_MANY_REQUESTS)
            ->header('Retry-After', $retryAfter)
            ->header('X-RateLimit-Limit', $result['limit'])
            ->header('X-RateLimit-Remaining', 0)
            ->header('X-RateLimit-Reset', $result['reset_at']);
    }

    /**
     * Log rate limit warning when threshold exceeded
     *
     * @param \App\Models\Organization $organization
     * @param array $result
     * @return void
     */
    private function logRateLimitWarning($organization, array $result): void
    {
        Log::warning('Organization approaching rate limit', [
            'organization_id' => $organization->id,
            'organization_name' => $organization->name,
            'limit' => $result['limit'],
            'remaining' => $result['remaining'],
            'percentage_used' => round((1 - ($result['remaining'] / $result['limit'])) * 100, 2),
        ]);

        // Optional: Store in analytics table for dashboard
        if (config('enterprise.rate_limiting.log_analytics', true)) {
            $this->rateLimitService->logRateLimitHit($organization, $result);
        }
    }
}
```

### Rate Limit Service Implementation

**File:** `app/Services/Enterprise/RateLimitService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\RateLimitServiceInterface;
use App\Models\Organization;
use Illuminate\Support\Facades\Redis;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

class RateLimitService implements RateLimitServiceInterface
{
    /**
     * Check rate limit and increment counter atomically
     *
     * @param string $key Redis key for rate limit
     * @param int $limit Maximum requests allowed
     * @param int $windowSeconds Time window in seconds
     * @return array Status array with limit info
     */
    public function checkAndIncrement(string $key, int $limit, int $windowSeconds): array
    {
        try {
            // Use Redis MULTI/EXEC for atomic operations
            $redis = Redis::connection('cache');

            // Get current value
            $current = (int) $redis->get($key) ?? 0;

            // Calculate reset timestamp
            $ttl = $redis->ttl($key);
            $resetAt = $ttl > 0 ? time() + $ttl : time() + $windowSeconds;

            // Check if limit exceeded
            if ($current >= $limit) {
                return [
                    'exceeded' => true,
                    'limit' => $limit,
                    'remaining' => 0,
                    'current' => $current,
                    'reset_at' => $resetAt,
                ];
            }

            // Increment counter atomically
            $redis->multi();
            $newValue = $redis->incr($key);

            // Set expiration if key is new
            if ($current === 0) {
                $redis->expire($key, $windowSeconds);
            }

            $redis->exec();

            $remaining = max(0, $limit - $newValue);

            return [
                'exceeded' => false,
                'limit' => $limit,
                'remaining' => $remaining,
                'current' => $newValue,
                'reset_at' => $resetAt,
            ];

        } catch (\Exception $e) {
            Log::error('Rate limit check failed', [
                'error' => $e->getMessage(),
                'key' => $key,
            ]);

            // Decide fail-open vs fail-closed based on config
            $failOpen = config('enterprise.rate_limiting.fail_open', true);

            if ($failOpen) {
                // Allow request to proceed
                return [
                    'exceeded' => false,
                    'limit' => $limit,
                    'remaining' => $limit,
                    'current' => 0,
                    'reset_at' => time() + $windowSeconds,
                    'fallback' => true,
                ];
            }

            // Block request on error
            return [
                'exceeded' => true,
                'limit' => $limit,
                'remaining' => 0,
                'current' => 0,
                'reset_at' => time() + $windowSeconds,
                'error' => true,
            ];
        }
    }

    /**
     * Get current rate limit status without incrementing
     *
     * @param string $key Redis key
     * @param int $limit Maximum requests allowed
     * @return array Current status
     */
    public function getStatus(string $key, int $limit): array
    {
        try {
            $redis = Redis::connection('cache');
            $current = (int) $redis->get($key) ?? 0;
            $ttl = $redis->ttl($key);
            $resetAt = $ttl > 0 ? time() + $ttl : time() + 60;

            return [
                'limit' => $limit,
                'remaining' => max(0, $limit - $current),
                'current' => $current,
                'reset_at' => $resetAt,
                'exceeded' => $current >= $limit,
            ];
        } catch (\Exception $e) {
            Log::error('Failed to get rate limit status', [
                'error' => $e->getMessage(),
                'key' => $key,
            ]);

            return [
                'limit' => $limit,
                'remaining' => $limit,
                'current' => 0,
                'reset_at' => time() + 60,
                'exceeded' => false,
                'error' => true,
            ];
        }
    }

    /**
     * Reset rate limit counter for a key
     *
     * @param string $key Redis key
     * @return bool Success
     */
    public function reset(string $key): bool
    {
        try {
            Redis::connection('cache')->del($key);
            return true;
        } catch (\Exception $e) {
            Log::error('Failed to reset rate limit', [
                'error' => $e->getMessage(),
                'key' => $key,
            ]);
            return false;
        }
    }

    /**
     * Log rate limit hit for analytics
     *
     * @param Organization $organization
     * @param array $result Rate limit result
     * @return void
     */
    public function logRateLimitHit(Organization $organization, array $result): void
    {
        try {
            DB::table('rate_limit_logs')->insert([
                'organization_id' => $organization->id,
                'limit' => $result['limit'],
                'remaining' => $result['remaining'],
                'exceeded' => $result['exceeded'] ?? false,
                'timestamp' => now(),
                'created_at' => now(),
            ]);
        } catch (\Exception $e) {
            // Fail silently for analytics - don't block requests
            Log::debug('Failed to log rate limit hit', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Get rate limit statistics for organization
     *
     * @param Organization $organization
     * @param int $hours Lookback period in hours
     * @return array Statistics
     */
    public function getStatistics(Organization $organization, int $hours = 24): array
    {
        try {
            $since = now()->subHours($hours);

            $stats = DB::table('rate_limit_logs')
                ->where('organization_id', $organization->id)
                ->where('timestamp', '>=', $since)
                ->selectRaw('
                    COUNT(*) as total_requests,
                    SUM(CASE WHEN exceeded = true THEN 1 ELSE 0 END) as exceeded_count,
                    AVG(remaining) as avg_remaining,
                    MAX(limit) as max_limit
                ')
                ->first();

            return [
                'total_requests' => $stats->total_requests ?? 0,
                'exceeded_count' => $stats->exceeded_count ?? 0,
                'success_rate' => $stats->total_requests > 0
                    ? round((1 - ($stats->exceeded_count / $stats->total_requests)) * 100, 2)
                    : 100,
                'avg_remaining' => round($stats->avg_remaining ?? 0, 2),
                'max_limit' => $stats->max_limit ?? 0,
                'period_hours' => $hours,
            ];
        } catch (\Exception $e) {
            Log::error('Failed to get rate limit statistics', [
                'error' => $e->getMessage(),
                'organization_id' => $organization->id,
            ]);

            return [
                'total_requests' => 0,
                'exceeded_count' => 0,
                'success_rate' => 100,
                'avg_remaining' => 0,
                'max_limit' => 0,
                'period_hours' => $hours,
                'error' => true,
            ];
        }
    }

    /**
     * Clear all rate limits for organization (admin function)
     *
     * @param Organization $organization
     * @return bool Success
     */
    public function clearOrganizationLimits(Organization $organization): bool
    {
        try {
            $redis = Redis::connection('cache');
            $pattern = "rate_limit:org:{$organization->id}*";

            $keys = $redis->keys($pattern);

            if (!empty($keys)) {
                $redis->del($keys);
            }

            Log::info('Cleared rate limits for organization', [
                'organization_id' => $organization->id,
                'keys_cleared' => count($keys),
            ]);

            return true;
        } catch (\Exception $e) {
            Log::error('Failed to clear organization rate limits', [
                'error' => $e->getMessage(),
                'organization_id' => $organization->id,
            ]);

            return false;
        }
    }
}
```

### Service Interface

**File:** `app/Contracts/RateLimitServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Organization;

interface RateLimitServiceInterface
{
    /**
     * Check rate limit and increment counter atomically
     *
     * @param string $key Redis key for rate limit
     * @param int $limit Maximum requests allowed
     * @param int $windowSeconds Time window in seconds
     * @return array Status array with limit info
     */
    public function checkAndIncrement(string $key, int $limit, int $windowSeconds): array;

    /**
     * Get current rate limit status without incrementing
     *
     * @param string $key Redis key
     * @param int $limit Maximum requests allowed
     * @return array Current status
     */
    public function getStatus(string $key, int $limit): array;

    /**
     * Reset rate limit counter for a key
     *
     * @param string $key Redis key
     * @return bool Success
     */
    public function reset(string $key): bool;

    /**
     * Log rate limit hit for analytics
     *
     * @param Organization $organization
     * @param array $result Rate limit result
     * @return void
     */
    public function logRateLimitHit(Organization $organization, array $result): void;

    /**
     * Get rate limit statistics for organization
     *
     * @param Organization $organization
     * @param int $hours Lookback period in hours
     * @return array Statistics
     */
    public function getStatistics(Organization $organization, int $hours = 24): array;

    /**
     * Clear all rate limits for organization (admin function)
     *
     * @param Organization $organization
     * @return bool Success
     */
    public function clearOrganizationLimits(Organization $organization): bool;
}
```

### Configuration

**File:** `config/enterprise.php` (add rate_limiting section)

```php
<?php

return [
    // ... existing configuration ...

    'rate_limiting' => [
        // Rate limiting strategy
        'strategy' => env('RATE_LIMIT_STRATEGY', 'organization'), // organization, user, endpoint, combined

        // Default tier limits (requests per minute)
        'tier_limits' => [
            'starter' => env('RATE_LIMIT_STARTER', 100),
            'professional' => env('RATE_LIMIT_PROFESSIONAL', 500),
            'enterprise' => env('RATE_LIMIT_ENTERPRISE', 2000),
            'custom' => env('RATE_LIMIT_CUSTOM', 5000),
        ],

        // Anonymous/unauthenticated request limit
        'anonymous_limit' => env('RATE_LIMIT_ANONYMOUS', 60),

        // Whitelisted routes (no rate limiting)
        'whitelist' => [
            'api/health',
            'api/status',
            'webhooks/*',
        ],

        // Fail-open vs fail-closed when Redis unavailable
        'fail_open' => env('RATE_LIMIT_FAIL_OPEN', true),

        // Log analytics to database
        'log_analytics' => env('RATE_LIMIT_LOG_ANALYTICS', true),

        // Warning threshold (percentage of limit)
        'warning_threshold' => env('RATE_LIMIT_WARNING_THRESHOLD', 0.9), // 90%
    ],
];
```

### Database Migration (Optional Analytics Table)

**File:** `database/migrations/xxxx_create_rate_limit_logs_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('rate_limit_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->cascadeOnDelete();
            $table->integer('limit')->comment('Rate limit applied');
            $table->integer('remaining')->comment('Remaining requests');
            $table->boolean('exceeded')->default(false)->comment('Was limit exceeded');
            $table->timestamp('timestamp')->useCurrent();
            $table->timestamps();

            // Indexes for fast queries
            $table->index(['organization_id', 'timestamp']);
            $table->index('exceeded');
        });

        // Create partitions by month for performance (optional)
        // Implementation depends on database (PostgreSQL, MySQL 8+)
    }

    public function down(): void
    {
        Schema::dropIfExists('rate_limit_logs');
    }
};
```

### Route Registration

**File:** `routes/api.php`

```php
<?php

use App\Http\Middleware\Enterprise\EnterpriseRateLimitMiddleware;

// Apply rate limiting to all API routes
Route::middleware(['api', 'auth:sanctum', ApiOrganizationScope::class, EnterpriseRateLimitMiddleware::class])
    ->prefix('api')
    ->group(function () {
        // All API routes here are rate limited
        Route::get('/organizations', [OrganizationController::class, 'index']);
        Route::get('/servers', [ServerController::class, 'index']);
        // ... other routes
    });

// Exempt specific routes from rate limiting
Route::middleware(['api'])
    ->prefix('api')
    ->group(function () {
        Route::get('/health', [HealthController::class, 'check']);
        Route::post('/webhooks/stripe', [StripeWebhookController::class, 'handle']);
    });
```

### EnterpriseLicense Model Enhancement

**File:** `app/Models/EnterpriseLicense.php` (add accessor)

```php
/**
 * Get API rate limit for this license
 *
 * @return int Requests per minute
 */
public function getApiRateLimitAttribute(): int
{
    // Check for custom limit in feature_limits
    if ($this->feature_limits && isset($this->feature_limits['api_rate_limit'])) {
        return (int) $this->feature_limits['api_rate_limit'];
    }

    // Use tier-based default
    $defaults = config('enterprise.rate_limiting.tier_limits');
    $tier = strtolower($this->tier);

    return $defaults[$tier] ?? $defaults['starter'];
}
```

## Implementation Approach

### Step 1: Create Service Layer
1. Create `RateLimitServiceInterface` in `app/Contracts/`
2. Implement `RateLimitService` in `app/Services/Enterprise/`
3. Register service binding in `EnterpriseServiceProvider`

### Step 2: Create Middleware
1. Create `EnterpriseRateLimitMiddleware` in `app/Http/Middleware/Enterprise/`
2. Implement `checkAndIncrement()` logic with Redis
3. Add rate limit header methods
4. Add whitelist checking

### Step 3: Configure Rate Limits
1. Add `rate_limiting` section to `config/enterprise.php`
2. Define tier-based limits
3. Configure whitelist routes
4. Add environment variables to `.env.example`

### Step 4: Database Migration (Optional)
1. Create `rate_limit_logs` table migration
2. Add indexes for performance
3. Run migration: `php artisan migrate`

### Step 5: Register Middleware
1. Add middleware to `app/Http/Kernel.php` (or routes directly in Laravel 11+)
2. Apply to API routes in `routes/api.php`
3. Configure whitelist exceptions

### Step 6: Enhance EnterpriseLicense Model
1. Add `getApiRateLimitAttribute()` accessor
2. Support custom limits via `feature_limits` JSON column
3. Add tests for accessor logic

### Step 7: Testing
1. Unit tests for `RateLimitService` methods
2. Unit tests for middleware with mocked Redis
3. Integration tests with real Redis connection
4. Test all tier limits (Starter, Professional, Enterprise)
5. Test whitelist functionality
6. Test fail-open/fail-closed behavior
7. Performance benchmarks

### Step 8: Documentation
1. Document rate limit configuration
2. Add examples for custom limits in licenses
3. Document whitelist configuration
4. Add troubleshooting guide for Redis issues

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Middleware/EnterpriseRateLimitMiddlewareTest.php`

```php
<?php

use App\Http\Middleware\Enterprise\EnterpriseRateLimitMiddleware;
use App\Models\Organization;
use App\Models\EnterpriseLicense;
use App\Services\Enterprise\RateLimitService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Redis;

beforeEach(function () {
    Redis::fake();
    $this->middleware = new EnterpriseRateLimitMiddleware(
        app(RateLimitService::class)
    );
});

it('allows requests within rate limit', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->professional()->create([
        'organization_id' => $organization->id,
    ]);

    $request = Request::create('/api/test', 'GET');
    $request->organization = $organization;

    $response = $this->middleware->handle($request, function ($req) {
        return response()->json(['success' => true]);
    });

    expect($response->status())->toBe(200)
        ->and($response->headers->has('X-RateLimit-Limit'))->toBeTrue()
        ->and($response->headers->get('X-RateLimit-Limit'))->toBe('500'); // Professional tier
});

it('blocks requests exceeding rate limit', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->starter()->create([
        'organization_id' => $organization->id,
    ]);

    $request = Request::create('/api/test', 'GET');
    $request->organization = $organization;

    // Simulate exceeding limit
    Redis::shouldReceive('get')->andReturn(101); // Over 100 limit
    Redis::shouldReceive('ttl')->andReturn(30);

    $response = $this->middleware->handle($request, function ($req) {
        return response()->json(['success' => true]);
    });

    expect($response->status())->toBe(429)
        ->and($response->headers->has('Retry-After'))->toBeTrue();
});

it('uses custom rate limit from license feature_limits', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'tier' => 'custom',
        'feature_limits' => ['api_rate_limit' => 10000],
    ]);

    $request = Request::create('/api/test', 'GET');
    $request->organization = $organization;

    Redis::shouldReceive('get')->andReturn(5000);
    Redis::shouldReceive('ttl')->andReturn(30);
    Redis::shouldReceive('incr')->andReturn(5001);
    Redis::shouldReceive('multi')->andReturnSelf();
    Redis::shouldReceive('exec');

    $response = $this->middleware->handle($request, function ($req) {
        return response()->json(['success' => true]);
    });

    expect($response->headers->get('X-RateLimit-Limit'))->toBe('10000');
});

it('whitelists configured routes', function () {
    config(['enterprise.rate_limiting.whitelist' => ['api/health']]);

    $request = Request::create('/api/health', 'GET');

    // Should not call Redis at all
    Redis::shouldReceive('get')->never();

    $response = $this->middleware->handle($request, function ($req) {
        return response()->json(['status' => 'healthy']);
    });

    expect($response->status())->toBe(200);
});

it('applies IP-based rate limiting for unauthenticated requests', function () {
    $request = Request::create('/api/public', 'GET');
    $request->server->set('REMOTE_ADDR', '1.2.3.4');

    Redis::shouldReceive('get')->with('rate_limit:ip:1.2.3.4')->andReturn(30);
    Redis::shouldReceive('ttl')->andReturn(30);
    Redis::shouldReceive('incr')->andReturn(31);
    Redis::shouldReceive('multi')->andReturnSelf();
    Redis::shouldReceive('exec');

    $response = $this->middleware->handle($request, function ($req) {
        return response()->json(['success' => true]);
    });

    expect($response->headers->get('X-RateLimit-Limit'))
        ->toBe((string) config('enterprise.rate_limiting.anonymous_limit'));
});
```

### Service Tests

**File:** `tests/Unit/Services/RateLimitServiceTest.php`

```php
<?php

use App\Services\Enterprise\RateLimitService;
use Illuminate\Support\Facades\Redis;

beforeEach(function () {
    Redis::fake();
    $this->service = app(RateLimitService::class);
});

it('increments counter atomically', function () {
    Redis::shouldReceive('get')->with('test_key')->andReturn(5);
    Redis::shouldReceive('ttl')->with('test_key')->andReturn(30);
    Redis::shouldReceive('incr')->with('test_key')->andReturn(6);
    Redis::shouldReceive('multi')->andReturnSelf();
    Redis::shouldReceive('exec');

    $result = $this->service->checkAndIncrement('test_key', 10, 60);

    expect($result['exceeded'])->toBeFalse()
        ->and($result['current'])->toBe(6)
        ->and($result['remaining'])->toBe(4);
});

it('detects limit exceeded', function () {
    Redis::shouldReceive('get')->with('test_key')->andReturn(10);
    Redis::shouldReceive('ttl')->with('test_key')->andReturn(30);

    $result = $this->service->checkAndIncrement('test_key', 10, 60);

    expect($result['exceeded'])->toBeTrue()
        ->and($result['remaining'])->toBe(0);
});

it('sets expiration on new keys', function () {
    Redis::shouldReceive('get')->with('new_key')->andReturn(0);
    Redis::shouldReceive('ttl')->andReturn(-2); // Key doesn't exist
    Redis::shouldReceive('incr')->andReturn(1);
    Redis::shouldReceive('multi')->andReturnSelf();
    Redis::shouldReceive('expire')->with('new_key', 60)->once();
    Redis::shouldReceive('exec');

    $result = $this->service->checkAndIncrement('new_key', 100, 60);

    expect($result['current'])->toBe(1);
});

it('resets rate limit counter', function () {
    Redis::shouldReceive('del')->with('test_key')->once()->andReturn(1);

    $result = $this->service->reset('test_key');

    expect($result)->toBeTrue();
});

it('handles Redis failures gracefully with fail-open', function () {
    config(['enterprise.rate_limiting.fail_open' => true]);

    Redis::shouldReceive('get')->andThrow(new \Exception('Redis unavailable'));

    $result = $this->service->checkAndIncrement('test_key', 10, 60);

    expect($result['exceeded'])->toBeFalse()
        ->and($result['fallback'])->toBeTrue();
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/RateLimitingTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\EnterpriseLicense;
use App\Models\User;
use Illuminate\Support\Facades\Redis;

it('enforces starter tier rate limit (100/min)', function () {
    Redis::flushAll(); // Clear Redis for clean test

    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->starter()->create([
        'organization_id' => $organization->id,
    ]);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Make 100 successful requests
    for ($i = 0; $i < 100; $i++) {
        $response = $this->actingAs($user, 'sanctum')
            ->getJson('/api/organizations');

        $response->assertOk();
    }

    // 101st request should be rate limited
    $response = $this->actingAs($user, 'sanctum')
        ->getJson('/api/organizations');

    $response->assertStatus(429)
        ->assertJsonStructure(['message', 'error', 'retry_after_seconds']);
});

it('enforces professional tier rate limit (500/min)', function () {
    Redis::flushAll();

    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->professional()->create([
        'organization_id' => $organization->id,
    ]);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Make 500 successful requests
    for ($i = 0; $i < 500; $i++) {
        $response = $this->actingAs($user, 'sanctum')
            ->getJson('/api/organizations');

        if ($i % 100 === 0) {
            // Check rate limit headers periodically
            expect($response->headers->get('X-RateLimit-Limit'))->toBe('500');
        }

        $response->assertOk();
    }

    // 501st request should be rate limited
    $response = $this->actingAs($user, 'sanctum')
        ->getJson('/api/organizations');

    $response->assertStatus(429);
});

it('includes correct rate limit headers', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->enterprise()->create([
        'organization_id' => $organization->id,
    ]);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $response = $this->actingAs($user, 'sanctum')
        ->getJson('/api/organizations');

    $response->assertOk()
        ->assertHeader('X-RateLimit-Limit', '2000')
        ->assertHeader('X-RateLimit-Remaining')
        ->assertHeader('X-RateLimit-Reset');
});

it('resets rate limits after time window', function () {
    Redis::flushAll();

    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->starter()->create([
        'organization_id' => $organization->id,
    ]);
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Exceed limit
    for ($i = 0; $i < 101; $i++) {
        $this->actingAs($user, 'sanctum')->getJson('/api/organizations');
    }

    // Should be rate limited
    $response = $this->actingAs($user, 'sanctum')
        ->getJson('/api/organizations');
    $response->assertStatus(429);

    // Wait for window to expire (simulate with manual Redis clear for testing)
    $key = "rate_limit:org:{$organization->id}";
    Redis::del($key);

    // Should work again
    $response = $this->actingAs($user, 'sanctum')
        ->getJson('/api/organizations');
    $response->assertOk();
});
```

## Definition of Done

- [ ] EnterpriseRateLimitMiddleware created and tested
- [ ] RateLimitService and RateLimitServiceInterface implemented
- [ ] Configuration added to `config/enterprise.php`
- [ ] Redis-backed atomic counter implementation working
- [ ] Tier-based rate limits enforced (Starter: 100, Pro: 500, Enterprise: 2000)
- [ ] Custom rate limits via `feature_limits` JSON column supported
- [ ] HTTP 429 responses with `Retry-After` header implemented
- [ ] Rate limit headers added to all API responses
- [ ] Whitelist mechanism working for configured routes
- [ ] IP-based rate limiting for unauthenticated requests
- [ ] Fail-open vs fail-closed configuration working
- [ ] Rate limit analytics logging implemented (optional table)
- [ ] EnterpriseLicense model enhanced with rate limit accessor
- [ ] Middleware registered in `routes/api.php`
- [ ] Environment variables documented in `.env.example`
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests with Redis written
- [ ] Performance benchmarks passing (< 5ms overhead)
- [ ] Documentation updated with configuration examples
- [ ] Code follows PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Manual testing with different tiers completed
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 53 (ApiOrganizationScope middleware - organization context required)
- **Used by:** Task 60 (ApiUsageMonitoring.vue - displays rate limit consumption)
- **Integrates with:** Task 61 (Comprehensive API tests include rate limit validation)
- **Enhances:** Existing Sanctum API authentication with tier-based access control
- **Supports:** Enterprise licensing feature differentiation (Task 1 foundation)
