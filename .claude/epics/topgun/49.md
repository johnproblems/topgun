---
name: Implement usage-based billing calculations
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:04Z
github: https://github.com/johnproblems/topgun/issues/157
depends_on: [25, 48]
parallel: false
conflicts_with: []
---

# Task: Implement usage-based billing calculations

## Description

Implement a comprehensive usage-based billing system that calculates charges based on actual resource consumption and integrates with the payment processing infrastructure. This backend service bridges resource monitoring (Task 25 - SystemResourceMonitor) with subscription management (Task 48) to enable metered billing, overage charges, and usage-based pricing tiers.

Modern SaaS platforms require flexible billing that aligns costs with actual consumption rather than fixed subscription fees. This task creates a sophisticated billing calculation engine that:

1. **Tracks Billable Resources** - CPU hours, memory GB-hours, storage GB-months, bandwidth GB
2. **Calculates Usage Charges** - Aggregates resource metrics into billable amounts per organization
3. **Handles Pricing Tiers** - Different rates based on subscription tier and volume discounts
4. **Manages Overages** - Charges for usage exceeding subscription quotas
5. **Generates Invoices** - Creates detailed invoice line items with usage breakdowns
6. **Supports Proration** - Handles mid-cycle subscription changes and upgrades/downgrades
7. **Provides Usage Forecasting** - Predicts end-of-month costs based on current trends

**Integration Points:**

- **SystemResourceMonitor** (Task 25) - Source of resource usage metrics
- **SubscriptionLifecycleManager** (Task 48) - Subscription plan quotas and billing cycles
- **PaymentService** (Task 46) - Process calculated charges via payment gateways
- **OrganizationResourceUsage** (Task 28) - Quota enforcement and usage tracking
- **BillingDashboard.vue** (Task 50) - Frontend display of usage and projected costs

**Why this task is important:** Fixed pricing doesn't work for enterprise customers with variable workloads. Usage-based billing aligns costs with value delivered, enables "pay-as-you-grow" business models, and prevents surprise bills through real-time usage monitoring. Without this system, Coolify Enterprise can't compete with modern cloud platforms that offer transparent, consumption-based pricing. This task is the financial engine that makes the enterprise platform commercially viable.

## Acceptance Criteria

- [ ] UsageBillingService created with complete calculation logic
- [ ] Support for multiple pricing models: flat-rate, tiered, volume-based, per-unit
- [ ] Accurate aggregation of resource metrics from server_resource_metrics table
- [ ] Calculate billable amounts for CPU hours, memory GB-hours, storage GB-months, bandwidth GB
- [ ] Handle subscription quota overages with configurable overage rates
- [ ] Generate detailed invoice line items with resource breakdown
- [ ] Support proration for mid-cycle subscription changes (upgrades, downgrades, cancellations)
- [ ] Calculate usage projections based on current consumption trends
- [ ] Store billing calculations in organization_billing_usage table for audit trail
- [ ] Integration with PaymentService for automated charge processing
- [ ] Handle timezone conversion for consistent billing cycles (UTC-based)
- [ ] Performance: Calculate monthly usage for 1000 organizations in < 60 seconds
- [ ] Accuracy: Billing calculations match resource metrics with 99.9%+ accuracy
- [ ] Support custom billing cycles: monthly, quarterly, annual
- [ ] Implement volume discounts (e.g., 10% off > 1000 CPU hours)
- [ ] Generate usage reports in CSV/PDF format for customer visibility

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/UsageBillingService.php` (new)
- `/home/topgun/topgun/app/Contracts/UsageBillingServiceInterface.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Enterprise/BillingUsage.php` (new)
- `/home/topgun/topgun/app/Models/Enterprise/InvoiceLineItem.php` (new)
- `/home/topgun/topgun/app/Models/Enterprise/PricingRule.php` (new)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/CalculateMonthlyUsageJob.php` (new)
- `/home/topgun/topgun/app/Jobs/Enterprise/ProcessUsageChargesJob.php` (new)

**Database Migrations:**
- `database/migrations/2024_XX_XX_create_billing_usage_table.php`
- `database/migrations/2024_XX_XX_create_invoice_line_items_table.php`
- `database/migrations/2024_XX_XX_create_pricing_rules_table.php`

**Configuration:**
- `config/enterprise.php` - Add billing calculation settings

**Artisan Commands:**
- `/home/topgun/topgun/app/Console/Commands/CalculateBillingUsage.php` (new)
- `/home/topgun/topgun/app/Console/Commands/GenerateUsageReport.php` (new)

### Database Schema

**Billing Usage Table** (stores calculated usage per organization per billing period):

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('billing_usage', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->cascadeOnDelete();
            $table->foreignId('subscription_id')->nullable()->constrained('organization_subscriptions')->nullOnDelete();

            // Billing period
            $table->date('billing_period_start');
            $table->date('billing_period_end');
            $table->string('billing_cycle', 20); // monthly, quarterly, annual

            // Resource usage metrics (aggregated from server_resource_metrics)
            $table->decimal('cpu_hours', 15, 4)->default(0); // Total CPU hours consumed
            $table->decimal('memory_gb_hours', 15, 4)->default(0); // Memory GB-hours
            $table->decimal('storage_gb_months', 15, 4)->default(0); // Storage GB-months
            $table->decimal('bandwidth_gb', 15, 4)->default(0); // Bandwidth GB transferred
            $table->integer('build_minutes')->default(0); // CI/CD build minutes

            // Calculated costs (in cents)
            $table->integer('base_subscription_cost')->default(0); // Fixed subscription fee
            $table->integer('cpu_cost')->default(0);
            $table->integer('memory_cost')->default(0);
            $table->integer('storage_cost')->default(0);
            $table->integer('bandwidth_cost')->default(0);
            $table->integer('build_cost')->default(0);
            $table->integer('overage_cost')->default(0); // Cost for exceeding quotas
            $table->integer('total_cost')->default(0); // Sum of all costs

            // Applied discounts and credits
            $table->integer('volume_discount')->default(0); // Discount in cents
            $table->integer('promotional_credit')->default(0); // Applied credits
            $table->integer('final_amount')->default(0); // After discounts and credits

            // Status and payment tracking
            $table->enum('status', ['calculating', 'calculated', 'invoiced', 'paid', 'disputed'])->default('calculating');
            $table->foreignId('invoice_id')->nullable()->constrained('invoices')->nullOnDelete();
            $table->timestamp('calculated_at')->nullable();
            $table->timestamp('invoiced_at')->nullable();
            $table->timestamp('paid_at')->nullable();

            // Metadata
            $table->json('usage_breakdown')->nullable(); // Detailed JSON breakdown
            $table->json('pricing_rules_applied')->nullable(); // Pricing rules snapshot
            $table->text('notes')->nullable();

            $table->timestamps();

            // Indexes for query performance
            $table->index(['organization_id', 'billing_period_start', 'billing_period_end']);
            $table->index(['status', 'billing_period_end']);
            $table->index('subscription_id');
            $table->unique(['organization_id', 'billing_period_start', 'billing_period_end']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('billing_usage');
    }
};
```

**Invoice Line Items Table** (detailed breakdown of charges):

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('invoice_line_items', function (Blueprint $table) {
            $table->id();
            $table->foreignId('invoice_id')->constrained()->cascadeOnDelete();
            $table->foreignId('billing_usage_id')->nullable()->constrained('billing_usage')->nullOnDelete();

            // Line item details
            $table->string('item_type', 50); // subscription, cpu, memory, storage, bandwidth, build, overage, discount, credit
            $table->string('description');
            $table->decimal('quantity', 15, 4); // Hours, GB, etc.
            $table->string('unit', 20)->nullable(); // hour, GB, month, etc.
            $table->integer('unit_price')->default(0); // Price per unit in cents
            $table->integer('amount')->default(0); // Total amount in cents

            // Resource reference (for audit trail)
            $table->string('resource_type')->nullable(); // server, application, database, etc.
            $table->unsignedBigInteger('resource_id')->nullable();

            // Metadata
            $table->json('metadata')->nullable(); // Additional details
            $table->integer('sort_order')->default(0);

            $table->timestamps();

            $table->index(['invoice_id', 'item_type']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('invoice_line_items');
    }
};
```

**Pricing Rules Table** (configurable pricing structure):

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('pricing_rules', function (Blueprint $table) {
            $table->id();

            // Rule identification
            $table->string('name');
            $table->string('resource_type'); // cpu, memory, storage, bandwidth, build
            $table->enum('pricing_model', ['flat_rate', 'tiered', 'volume', 'per_unit'])->default('per_unit');

            // Pricing configuration (JSON for flexibility)
            $table->json('pricing_tiers'); // Example: [{"min": 0, "max": 100, "price": 500}, {"min": 101, "max": null, "price": 400}]
            $table->integer('base_price')->nullable(); // Base price in cents
            $table->string('unit', 20); // hour, GB, month, etc.

            // Applicability
            $table->string('subscription_tier')->nullable(); // null = all tiers, or specific tier
            $table->boolean('is_overage')->default(false); // Is this for overage charges?
            $table->boolean('is_active')->default(true);

            // Effective dates
            $table->date('effective_from');
            $table->date('effective_until')->nullable();

            // Metadata
            $table->text('description')->nullable();
            $table->integer('priority')->default(0); // For rule conflict resolution

            $table->timestamps();

            $table->index(['resource_type', 'is_active', 'effective_from']);
            $table->index('subscription_tier');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('pricing_rules');
    }
};
```

### Service Implementation

**File:** `app/Services/Enterprise/UsageBillingService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\UsageBillingServiceInterface;
use App\Models\Organization;
use App\Models\Enterprise\BillingUsage;
use App\Models\Enterprise\InvoiceLineItem;
use App\Models\Enterprise\PricingRule;
use App\Models\Enterprise\OrganizationSubscription;
use App\Models\ServerResourceMetric;
use Carbon\Carbon;
use Carbon\CarbonPeriod;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class UsageBillingService implements UsageBillingServiceInterface
{
    /**
     * Calculate usage for a billing period
     *
     * @param Organization $organization
     * @param Carbon $periodStart
     * @param Carbon $periodEnd
     * @return BillingUsage
     */
    public function calculateUsage(
        Organization $organization,
        Carbon $periodStart,
        Carbon $periodEnd
    ): BillingUsage {
        Log::info("Calculating usage for organization {$organization->id}", [
            'period_start' => $periodStart->toDateString(),
            'period_end' => $periodEnd->toDateString(),
        ]);

        // Get or create billing usage record
        $billingUsage = BillingUsage::firstOrNew([
            'organization_id' => $organization->id,
            'billing_period_start' => $periodStart->toDateString(),
            'billing_period_end' => $periodEnd->toDateString(),
        ]);

        $billingUsage->status = 'calculating';
        $billingUsage->save();

        // Get active subscription
        $subscription = $organization->activeSubscription;
        $billingUsage->subscription_id = $subscription?->id;

        // Aggregate resource metrics
        $resourceUsage = $this->aggregateResourceMetrics($organization, $periodStart, $periodEnd);

        // Store aggregated usage
        $billingUsage->cpu_hours = $resourceUsage['cpu_hours'];
        $billingUsage->memory_gb_hours = $resourceUsage['memory_gb_hours'];
        $billingUsage->storage_gb_months = $resourceUsage['storage_gb_months'];
        $billingUsage->bandwidth_gb = $resourceUsage['bandwidth_gb'];
        $billingUsage->build_minutes = $resourceUsage['build_minutes'];

        // Calculate costs based on pricing rules
        $costs = $this->calculateCosts($organization, $resourceUsage, $subscription);

        $billingUsage->cpu_cost = $costs['cpu_cost'];
        $billingUsage->memory_cost = $costs['memory_cost'];
        $billingUsage->storage_cost = $costs['storage_cost'];
        $billingUsage->bandwidth_cost = $costs['bandwidth_cost'];
        $billingUsage->build_cost = $costs['build_cost'];
        $billingUsage->overage_cost = $costs['overage_cost'];
        $billingUsage->base_subscription_cost = $costs['base_subscription_cost'];
        $billingUsage->total_cost = array_sum($costs);

        // Apply discounts and credits
        $finalAmount = $this->applyDiscountsAndCredits(
            $organization,
            $billingUsage->total_cost,
            $resourceUsage
        );

        $billingUsage->volume_discount = $finalAmount['discount'];
        $billingUsage->promotional_credit = $finalAmount['credit'];
        $billingUsage->final_amount = $finalAmount['final'];

        // Store detailed breakdown
        $billingUsage->usage_breakdown = [
            'resources' => $resourceUsage,
            'costs' => $costs,
            'discounts' => $finalAmount,
        ];

        $billingUsage->status = 'calculated';
        $billingUsage->calculated_at = now();
        $billingUsage->save();

        Log::info("Usage calculation complete", [
            'organization_id' => $organization->id,
            'total_cost' => $billingUsage->total_cost,
            'final_amount' => $billingUsage->final_amount,
        ]);

        return $billingUsage;
    }

    /**
     * Aggregate resource metrics from monitoring data
     *
     * @param Organization $organization
     * @param Carbon $periodStart
     * @param Carbon $periodEnd
     * @return array
     */
    private function aggregateResourceMetrics(
        Organization $organization,
        Carbon $periodStart,
        Carbon $periodEnd
    ): array {
        // Get all servers for organization
        $serverIds = $organization->servers()->pluck('id');

        if ($serverIds->isEmpty()) {
            return [
                'cpu_hours' => 0,
                'memory_gb_hours' => 0,
                'storage_gb_months' => 0,
                'bandwidth_gb' => 0,
                'build_minutes' => 0,
            ];
        }

        // Query server_resource_metrics for the billing period
        $metrics = ServerResourceMetric::whereIn('server_id', $serverIds)
            ->whereBetween('recorded_at', [$periodStart, $periodEnd])
            ->select([
                DB::raw('SUM(cpu_usage_percent / 100 * EXTRACT(EPOCH FROM (recorded_at - LAG(recorded_at) OVER (PARTITION BY server_id ORDER BY recorded_at))) / 3600) as cpu_hours'),
                DB::raw('SUM(memory_used_gb * EXTRACT(EPOCH FROM (recorded_at - LAG(recorded_at) OVER (PARTITION BY server_id ORDER BY recorded_at))) / 3600) as memory_gb_hours'),
                DB::raw('AVG(disk_used_gb) * EXTRACT(DAY FROM (:period_end - :period_start)) / 30 as storage_gb_months'),
                DB::raw('SUM(network_rx_gb + network_tx_gb) as bandwidth_gb'),
            ])
            ->setBindings([
                'period_end' => $periodEnd,
                'period_start' => $periodStart,
            ], 'select')
            ->first();

        // Get build minutes from application deployments
        $buildMinutes = $organization->applicationDeployments()
            ->whereBetween('created_at', [$periodStart, $periodEnd])
            ->sum('build_duration_minutes');

        return [
            'cpu_hours' => round($metrics->cpu_hours ?? 0, 4),
            'memory_gb_hours' => round($metrics->memory_gb_hours ?? 0, 4),
            'storage_gb_months' => round($metrics->storage_gb_months ?? 0, 4),
            'bandwidth_gb' => round($metrics->bandwidth_gb ?? 0, 4),
            'build_minutes' => $buildMinutes ?? 0,
        ];
    }

    /**
     * Calculate costs based on pricing rules
     *
     * @param Organization $organization
     * @param array $resourceUsage
     * @param OrganizationSubscription|null $subscription
     * @return array
     */
    private function calculateCosts(
        Organization $organization,
        array $resourceUsage,
        ?OrganizationSubscription $subscription
    ): array {
        $subscriptionTier = $subscription?->tier ?? 'free';
        $costs = [];

        // Base subscription cost
        $costs['base_subscription_cost'] = $subscription?->plan_price ?? 0;

        // Calculate cost for each resource type
        foreach (['cpu', 'memory', 'storage', 'bandwidth', 'build'] as $resourceType) {
            $usageKey = $this->getUsageKey($resourceType);
            $usage = $resourceUsage[$usageKey] ?? 0;

            // Get subscription quota
            $quota = $this->getSubscriptionQuota($subscription, $resourceType);

            // Calculate included and overage usage
            $includedUsage = min($usage, $quota);
            $overageUsage = max(0, $usage - $quota);

            // Get pricing rules
            $includedPrice = $this->getPricing($resourceType, $subscriptionTier, false);
            $overagePrice = $this->getPricing($resourceType, $subscriptionTier, true);

            // Calculate costs (convert to cents)
            $includedCost = $this->applyPricingRule($includedUsage, $includedPrice);
            $overageCost = $this->applyPricingRule($overageUsage, $overagePrice);

            $costs["{$resourceType}_cost"] = $includedCost;
            $costs['overage_cost'] = ($costs['overage_cost'] ?? 0) + $overageCost;
        }

        return $costs;
    }

    /**
     * Get pricing rule for resource type
     *
     * @param string $resourceType
     * @param string $subscriptionTier
     * @param bool $isOverage
     * @return PricingRule|null
     */
    private function getPricing(string $resourceType, string $subscriptionTier, bool $isOverage): ?PricingRule
    {
        return PricingRule::where('resource_type', $resourceType)
            ->where('is_overage', $isOverage)
            ->where('is_active', true)
            ->where(function ($query) use ($subscriptionTier) {
                $query->whereNull('subscription_tier')
                    ->orWhere('subscription_tier', $subscriptionTier);
            })
            ->where('effective_from', '<=', now())
            ->where(function ($query) {
                $query->whereNull('effective_until')
                    ->orWhere('effective_until', '>=', now());
            })
            ->orderBy('priority', 'desc')
            ->first();
    }

    /**
     * Apply pricing rule to calculate cost
     *
     * @param float $usage
     * @param PricingRule|null $pricingRule
     * @return int Cost in cents
     */
    private function applyPricingRule(float $usage, ?PricingRule $pricingRule): int
    {
        if (!$pricingRule || $usage <= 0) {
            return 0;
        }

        switch ($pricingRule->pricing_model) {
            case 'flat_rate':
                return $pricingRule->base_price;

            case 'per_unit':
                $tiers = $pricingRule->pricing_tiers;
                $unitPrice = $tiers[0]['price'] ?? 0;
                return (int) round($usage * $unitPrice);

            case 'tiered':
                return $this->calculateTieredPricing($usage, $pricingRule->pricing_tiers);

            case 'volume':
                return $this->calculateVolumePricing($usage, $pricingRule->pricing_tiers);

            default:
                return 0;
        }
    }

    /**
     * Calculate tiered pricing (different rates for different tiers)
     *
     * @param float $usage
     * @param array $tiers Example: [{"min": 0, "max": 100, "price": 500}, {"min": 101, "max": null, "price": 400}]
     * @return int Cost in cents
     */
    private function calculateTieredPricing(float $usage, array $tiers): int
    {
        $totalCost = 0;

        foreach ($tiers as $tier) {
            $min = $tier['min'];
            $max = $tier['max'] ?? PHP_INT_MAX;
            $price = $tier['price'];

            if ($usage <= $min) {
                break;
            }

            $tierUsage = min($usage, $max) - $min;
            $totalCost += $tierUsage * $price;
        }

        return (int) round($totalCost);
    }

    /**
     * Calculate volume pricing (all units at the same rate based on total)
     *
     * @param float $usage
     * @param array $tiers
     * @return int Cost in cents
     */
    private function calculateVolumePricing(float $usage, array $tiers): int
    {
        // Find applicable tier based on total usage
        $applicableTier = null;

        foreach ($tiers as $tier) {
            if ($usage >= $tier['min'] && ($tier['max'] === null || $usage <= $tier['max'])) {
                $applicableTier = $tier;
                break;
            }
        }

        if (!$applicableTier) {
            return 0;
        }

        return (int) round($usage * $applicableTier['price']);
    }

    /**
     * Get subscription quota for resource type
     *
     * @param OrganizationSubscription|null $subscription
     * @param string $resourceType
     * @return float
     */
    private function getSubscriptionQuota(?OrganizationSubscription $subscription, string $resourceType): float
    {
        if (!$subscription) {
            return 0;
        }

        $quotaKey = $this->getQuotaKey($resourceType);
        return $subscription->{$quotaKey} ?? 0;
    }

    /**
     * Apply volume discounts and promotional credits
     *
     * @param Organization $organization
     * @param int $totalCost
     * @param array $resourceUsage
     * @return array
     */
    private function applyDiscountsAndCredits(
        Organization $organization,
        int $totalCost,
        array $resourceUsage
    ): array {
        $discount = 0;
        $credit = 0;

        // Apply volume discount (example: 10% off if total CPU hours > 1000)
        if ($resourceUsage['cpu_hours'] > 1000) {
            $discount = (int) round($totalCost * 0.10);
        }

        // Apply promotional credits
        $availableCredit = $organization->promotional_credit_balance ?? 0;
        $credit = min($availableCredit, $totalCost - $discount);

        $finalAmount = max(0, $totalCost - $discount - $credit);

        return [
            'discount' => $discount,
            'credit' => $credit,
            'final' => $finalAmount,
        ];
    }

    /**
     * Get usage key for resource type
     *
     * @param string $resourceType
     * @return string
     */
    private function getUsageKey(string $resourceType): string
    {
        $map = [
            'cpu' => 'cpu_hours',
            'memory' => 'memory_gb_hours',
            'storage' => 'storage_gb_months',
            'bandwidth' => 'bandwidth_gb',
            'build' => 'build_minutes',
        ];

        return $map[$resourceType] ?? '';
    }

    /**
     * Get quota key for resource type
     *
     * @param string $resourceType
     * @return string
     */
    private function getQuotaKey(string $resourceType): string
    {
        $map = [
            'cpu' => 'cpu_hours_quota',
            'memory' => 'memory_gb_hours_quota',
            'storage' => 'storage_gb_quota',
            'bandwidth' => 'bandwidth_gb_quota',
            'build' => 'build_minutes_quota',
        ];

        return $map[$resourceType] ?? '';
    }

    /**
     * Generate invoice line items from billing usage
     *
     * @param BillingUsage $billingUsage
     * @param int $invoiceId
     * @return void
     */
    public function generateInvoiceLineItems(BillingUsage $billingUsage, int $invoiceId): void
    {
        $breakdown = $billingUsage->usage_breakdown;

        // Base subscription
        if ($billingUsage->base_subscription_cost > 0) {
            InvoiceLineItem::create([
                'invoice_id' => $invoiceId,
                'billing_usage_id' => $billingUsage->id,
                'item_type' => 'subscription',
                'description' => 'Base Subscription Fee',
                'quantity' => 1,
                'unit' => 'month',
                'unit_price' => $billingUsage->base_subscription_cost,
                'amount' => $billingUsage->base_subscription_cost,
                'sort_order' => 0,
            ]);
        }

        // Resource usage line items
        $lineItems = [
            ['type' => 'cpu', 'description' => 'CPU Hours', 'usage_key' => 'cpu_hours', 'cost_key' => 'cpu_cost', 'unit' => 'hour'],
            ['type' => 'memory', 'description' => 'Memory GB-Hours', 'usage_key' => 'memory_gb_hours', 'cost_key' => 'memory_cost', 'unit' => 'GB-hour'],
            ['type' => 'storage', 'description' => 'Storage GB-Months', 'usage_key' => 'storage_gb_months', 'cost_key' => 'storage_cost', 'unit' => 'GB-month'],
            ['type' => 'bandwidth', 'description' => 'Bandwidth', 'usage_key' => 'bandwidth_gb', 'cost_key' => 'bandwidth_cost', 'unit' => 'GB'],
            ['type' => 'build', 'description' => 'Build Minutes', 'usage_key' => 'build_minutes', 'cost_key' => 'build_cost', 'unit' => 'minute'],
        ];

        $sortOrder = 1;
        foreach ($lineItems as $item) {
            $quantity = $breakdown['resources'][$item['usage_key']] ?? 0;
            $amount = $billingUsage->{$item['cost_key']};

            if ($amount > 0) {
                InvoiceLineItem::create([
                    'invoice_id' => $invoiceId,
                    'billing_usage_id' => $billingUsage->id,
                    'item_type' => $item['type'],
                    'description' => $item['description'],
                    'quantity' => $quantity,
                    'unit' => $item['unit'],
                    'unit_price' => $quantity > 0 ? (int) round($amount / $quantity) : 0,
                    'amount' => $amount,
                    'sort_order' => $sortOrder++,
                ]);
            }
        }

        // Overage charges
        if ($billingUsage->overage_cost > 0) {
            InvoiceLineItem::create([
                'invoice_id' => $invoiceId,
                'billing_usage_id' => $billingUsage->id,
                'item_type' => 'overage',
                'description' => 'Overage Charges',
                'quantity' => 1,
                'unit' => null,
                'unit_price' => $billingUsage->overage_cost,
                'amount' => $billingUsage->overage_cost,
                'sort_order' => $sortOrder++,
            ]);
        }

        // Discounts
        if ($billingUsage->volume_discount > 0) {
            InvoiceLineItem::create([
                'invoice_id' => $invoiceId,
                'billing_usage_id' => $billingUsage->id,
                'item_type' => 'discount',
                'description' => 'Volume Discount',
                'quantity' => 1,
                'unit' => null,
                'unit_price' => -$billingUsage->volume_discount,
                'amount' => -$billingUsage->volume_discount,
                'sort_order' => $sortOrder++,
            ]);
        }

        // Credits
        if ($billingUsage->promotional_credit > 0) {
            InvoiceLineItem::create([
                'invoice_id' => $invoiceId,
                'billing_usage_id' => $billingUsage->id,
                'item_type' => 'credit',
                'description' => 'Promotional Credit',
                'quantity' => 1,
                'unit' => null,
                'unit_price' => -$billingUsage->promotional_credit,
                'amount' => -$billingUsage->promotional_credit,
                'sort_order' => $sortOrder++,
            ]);
        }
    }

    /**
     * Project end-of-month cost based on current usage
     *
     * @param Organization $organization
     * @return array
     */
    public function projectMonthEndCost(Organization $organization): array
    {
        $now = now();
        $monthStart = $now->copy()->startOfMonth();
        $monthEnd = $now->copy()->endOfMonth();
        $daysInMonth = $monthStart->daysInMonth;
        $daysPassed = $now->day;

        // Calculate usage for days passed
        $currentUsage = $this->aggregateResourceMetrics($organization, $monthStart, $now);

        // Project usage for remaining days
        $dailyAverage = [];
        foreach ($currentUsage as $key => $value) {
            $dailyAverage[$key] = $daysPassed > 0 ? $value / $daysPassed : 0;
        }

        $projectedUsage = [];
        foreach ($currentUsage as $key => $value) {
            $projectedUsage[$key] = $value + ($dailyAverage[$key] * ($daysInMonth - $daysPassed));
        }

        // Calculate projected costs
        $subscription = $organization->activeSubscription;
        $projectedCosts = $this->calculateCosts($organization, $projectedUsage, $subscription);
        $totalProjected = array_sum($projectedCosts);

        return [
            'current_usage' => $currentUsage,
            'projected_usage' => $projectedUsage,
            'projected_cost' => $totalProjected,
            'days_remaining' => $daysInMonth - $daysPassed,
        ];
    }
}
```

### Service Interface

**File:** `app/Contracts/UsageBillingServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Organization;
use App\Models\Enterprise\BillingUsage;
use Carbon\Carbon;

interface UsageBillingServiceInterface
{
    /**
     * Calculate usage for a billing period
     *
     * @param Organization $organization
     * @param Carbon $periodStart
     * @param Carbon $periodEnd
     * @return BillingUsage
     */
    public function calculateUsage(
        Organization $organization,
        Carbon $periodStart,
        Carbon $periodEnd
    ): BillingUsage;

    /**
     * Generate invoice line items from billing usage
     *
     * @param BillingUsage $billingUsage
     * @param int $invoiceId
     * @return void
     */
    public function generateInvoiceLineItems(BillingUsage $billingUsage, int $invoiceId): void;

    /**
     * Project end-of-month cost based on current usage
     *
     * @param Organization $organization
     * @return array
     */
    public function projectMonthEndCost(Organization $organization): array;
}
```

### Background Jobs

**File:** `app/Jobs/Enterprise/CalculateMonthlyUsageJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\UsageBillingServiceInterface;
use App\Models\Organization;
use Carbon\Carbon;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class CalculateMonthlyUsageJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        public Organization $organization,
        public Carbon $periodStart,
        public Carbon $periodEnd
    ) {}

    public function handle(UsageBillingServiceInterface $billingService): void
    {
        try {
            $billingUsage = $billingService->calculateUsage(
                $this->organization,
                $this->periodStart,
                $this->periodEnd
            );

            Log::info("Monthly usage calculated successfully", [
                'organization_id' => $this->organization->id,
                'billing_usage_id' => $billingUsage->id,
                'final_amount' => $billingUsage->final_amount,
            ]);
        } catch (\Exception $e) {
            Log::error("Failed to calculate monthly usage", [
                'organization_id' => $this->organization->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

**File:** `app/Jobs/Enterprise/ProcessUsageChargesJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\PaymentServiceInterface;
use App\Contracts\UsageBillingServiceInterface;
use App\Models\Enterprise\BillingUsage;
use App\Models\Invoice;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ProcessUsageChargesJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        public BillingUsage $billingUsage
    ) {}

    public function handle(
        PaymentServiceInterface $paymentService,
        UsageBillingServiceInterface $billingService
    ): void {
        if ($this->billingUsage->status !== 'calculated') {
            Log::warning("Skipping usage charge processing - not calculated", [
                'billing_usage_id' => $this->billingUsage->id,
                'status' => $this->billingUsage->status,
            ]);
            return;
        }

        try {
            // Create invoice
            $invoice = Invoice::create([
                'organization_id' => $this->billingUsage->organization_id,
                'subscription_id' => $this->billingUsage->subscription_id,
                'amount' => $this->billingUsage->final_amount,
                'status' => 'pending',
                'due_date' => now()->addDays(7),
                'billing_period_start' => $this->billingUsage->billing_period_start,
                'billing_period_end' => $this->billingUsage->billing_period_end,
            ]);

            // Generate invoice line items
            $billingService->generateInvoiceLineItems($this->billingUsage, $invoice->id);

            // Update billing usage
            $this->billingUsage->update([
                'invoice_id' => $invoice->id,
                'status' => 'invoiced',
                'invoiced_at' => now(),
            ]);

            // Attempt to charge payment method
            $subscription = $this->billingUsage->subscription;
            if ($subscription && $subscription->payment_method_id) {
                $paymentResult = $paymentService->processPayment(
                    $subscription->payment_method_id,
                    $this->billingUsage->final_amount,
                    [
                        'description' => "Usage charges for {$this->billingUsage->billing_period_start} to {$this->billingUsage->billing_period_end}",
                        'invoice_id' => $invoice->id,
                    ]
                );

                if ($paymentResult['success']) {
                    $invoice->update(['status' => 'paid', 'paid_at' => now()]);
                    $this->billingUsage->update(['status' => 'paid', 'paid_at' => now()]);

                    Log::info("Usage charges processed successfully", [
                        'billing_usage_id' => $this->billingUsage->id,
                        'invoice_id' => $invoice->id,
                        'amount' => $this->billingUsage->final_amount,
                    ]);
                }
            }
        } catch (\Exception $e) {
            Log::error("Failed to process usage charges", [
                'billing_usage_id' => $this->billingUsage->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

### Artisan Commands

**File:** `app/Console/Commands/CalculateBillingUsage.php`

```php
<?php

namespace App\Console\Commands;

use App\Contracts\UsageBillingServiceInterface;
use App\Jobs\Enterprise\CalculateMonthlyUsageJob;
use App\Models\Organization;
use Carbon\Carbon;
use Illuminate\Console\Command;

class CalculateBillingUsage extends Command
{
    protected $signature = 'billing:calculate-usage
                            {--organization= : Organization ID to calculate}
                            {--period-start= : Start date (YYYY-MM-DD)}
                            {--period-end= : End date (YYYY-MM-DD)}
                            {--async : Process asynchronously via queue}';

    protected $description = 'Calculate billing usage for organizations';

    public function handle(UsageBillingServiceInterface $billingService): int
    {
        $organizationId = $this->option('organization');
        $periodStart = $this->option('period-start')
            ? Carbon::parse($this->option('period-start'))
            : now()->startOfMonth();
        $periodEnd = $this->option('period-end')
            ? Carbon::parse($this->option('period-end'))
            : now();
        $async = $this->option('async');

        if ($organizationId) {
            $organization = Organization::findOrFail($organizationId);
            $this->calculateForOrganization($organization, $periodStart, $periodEnd, $async, $billingService);
        } else {
            $organizations = Organization::has('activeSubscription')->get();
            $this->info("Calculating usage for {$organizations->count()} organizations...");

            $progressBar = $this->output->createProgressBar($organizations->count());

            foreach ($organizations as $organization) {
                $this->calculateForOrganization($organization, $periodStart, $periodEnd, $async, $billingService);
                $progressBar->advance();
            }

            $progressBar->finish();
            $this->newLine();
        }

        return self::SUCCESS;
    }

    private function calculateForOrganization(
        Organization $organization,
        Carbon $periodStart,
        Carbon $periodEnd,
        bool $async,
        UsageBillingServiceInterface $billingService
    ): void {
        try {
            if ($async) {
                CalculateMonthlyUsageJob::dispatch($organization, $periodStart, $periodEnd);
                $this->info("Queued calculation for: {$organization->name}");
            } else {
                $billingUsage = $billingService->calculateUsage($organization, $periodStart, $periodEnd);
                $this->info("Calculated for {$organization->name}: \${$billingUsage->final_amount / 100}");
            }
        } catch (\Exception $e) {
            $this->error("Failed for {$organization->name}: {$e->getMessage()}");
        }
    }
}
```

### Configuration

**File:** `config/enterprise.php` (add billing section)

```php
'billing' => [
    'default_billing_cycle' => env('BILLING_DEFAULT_CYCLE', 'monthly'),
    'billing_day' => env('BILLING_DAY', 1), // Day of month to bill
    'invoice_due_days' => env('INVOICE_DUE_DAYS', 7),

    // Default pricing (in cents)
    'default_pricing' => [
        'cpu_hour' => 50, // $0.50 per CPU hour
        'memory_gb_hour' => 25, // $0.25 per GB-hour
        'storage_gb_month' => 10, // $0.10 per GB-month
        'bandwidth_gb' => 5, // $0.05 per GB
        'build_minute' => 1, // $0.01 per build minute
    ],

    // Overage multipliers
    'overage_multiplier' => 1.5, // 50% premium on overage charges
],
```

## Implementation Approach

### Step 1: Database Migrations
1. Create `billing_usage` table migration
2. Create `invoice_line_items` table migration
3. Create `pricing_rules` table migration
4. Run migrations: `php artisan migrate`

### Step 2: Create Models
1. Create `BillingUsage` model with casts and relationships
2. Create `InvoiceLineItem` model
3. Create `PricingRule` model with JSON casting
4. Add factory and seeders for testing

### Step 3: Implement Service Interface and Implementation
1. Create `UsageBillingServiceInterface` in `app/Contracts/`
2. Implement `UsageBillingService` in `app/Services/Enterprise/`
3. Register service in `EnterpriseServiceProvider`
4. Implement all methods: `calculateUsage()`, `generateInvoiceLineItems()`, `projectMonthEndCost()`

### Step 4: Implement Calculation Logic
1. Add `aggregateResourceMetrics()` method with time-series SQL queries
2. Implement `calculateCosts()` with pricing rule application
3. Add tiered and volume pricing calculations
4. Implement discount and credit application logic

### Step 5: Create Background Jobs
1. Create `CalculateMonthlyUsageJob` for async processing
2. Create `ProcessUsageChargesJob` for invoice generation and payment
3. Register jobs in queue configuration
4. Add scheduled task for end-of-month calculations

### Step 6: Create Artisan Commands
1. Create `CalculateBillingUsage` command
2. Add `GenerateUsageReport` command for CSV/PDF exports
3. Test commands with various parameters

### Step 7: Seed Pricing Rules
1. Create pricing rule seeder with default rates
2. Add tiered pricing examples (volume discounts)
3. Add overage pricing rules with multipliers

### Step 8: Integration with Existing Services
1. Integrate with `SystemResourceMonitor` for metric retrieval
2. Connect to `PaymentService` for automated charging
3. Link to subscription lifecycle for quota enforcement

### Step 9: Testing
1. Unit test pricing calculations (tiered, volume, per-unit)
2. Test resource metric aggregation with sample data
3. Integration test full billing cycle
4. Performance test with 1000+ organizations

### Step 10: Scheduled Task Configuration
1. Add scheduled task in `Kernel.php` for monthly calculations
2. Configure queue workers for async processing
3. Add monitoring for failed billing calculations

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Enterprise/UsageBillingServiceTest.php`

```php
<?php

use App\Services\Enterprise\UsageBillingService;
use App\Models\Organization;
use App\Models\Enterprise\PricingRule;
use Carbon\Carbon;

beforeEach(function () {
    $this->service = app(UsageBillingService::class);
});

it('calculates CPU hour costs correctly', function () {
    $organization = Organization::factory()->create();

    PricingRule::create([
        'name' => 'CPU Per Hour',
        'resource_type' => 'cpu',
        'pricing_model' => 'per_unit',
        'pricing_tiers' => [['min' => 0, 'max' => null, 'price' => 50]],
        'unit' => 'hour',
        'is_active' => true,
        'effective_from' => now()->subMonth(),
    ]);

    // Mock 100 CPU hours usage
    $resourceUsage = ['cpu_hours' => 100, 'memory_gb_hours' => 0, 'storage_gb_months' => 0, 'bandwidth_gb' => 0, 'build_minutes' => 0];

    $costs = invade($this->service)->calculateCosts($organization, $resourceUsage, null);

    expect($costs['cpu_cost'])->toBe(5000); // 100 hours * $0.50 = $50.00 (5000 cents)
});

it('applies tiered pricing correctly', function () {
    PricingRule::create([
        'name' => 'Tiered Memory',
        'resource_type' => 'memory',
        'pricing_model' => 'tiered',
        'pricing_tiers' => [
            ['min' => 0, 'max' => 100, 'price' => 25],
            ['min' => 101, 'max' => null, 'price' => 20],
        ],
        'unit' => 'GB-hour',
        'is_active' => true,
        'effective_from' => now()->subMonth(),
    ]);

    // 150 GB-hours: first 100 at $0.25, next 50 at $0.20
    $usage = 150;
    $cost = invade($this->service)->calculateTieredPricing($usage, [
        ['min' => 0, 'max' => 100, 'price' => 25],
        ['min' => 101, 'max' => null, 'price' => 20],
    ]);

    expect($cost)->toBe(3500); // (100 * 0.25) + (50 * 0.20) = $35.00
});

it('applies volume pricing correctly', function () {
    // Volume pricing: all units at same rate based on total
    $tiers = [
        ['min' => 0, 'max' => 99, 'price' => 10],
        ['min' => 100, 'max' => 499, 'price' => 8],
        ['min' => 500, 'max' => null, 'price' => 6],
    ];

    // 150 units at tier 2 rate ($0.08 each)
    $cost = invade($this->service)->calculateVolumePricing(150, $tiers);
    expect($cost)->toBe(1200); // 150 * $0.08 = $12.00

    // 600 units at tier 3 rate ($0.06 each)
    $cost = invade($this->service)->calculateVolumePricing(600, $tiers);
    expect($cost)->toBe(3600); // 600 * $0.06 = $36.00
});

it('calculates overage costs separately', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'cpu_hours_quota' => 100,
        'plan_price' => 2000, // $20 base price
    ]);

    PricingRule::create([
        'name' => 'CPU Overage',
        'resource_type' => 'cpu',
        'pricing_model' => 'per_unit',
        'pricing_tiers' => [['min' => 0, 'max' => null, 'price' => 75]], // $0.75 for overages (50% premium)
        'unit' => 'hour',
        'is_overage' => true,
        'is_active' => true,
        'effective_from' => now()->subMonth(),
    ]);

    // 150 CPU hours (100 included, 50 overage)
    $resourceUsage = ['cpu_hours' => 150, 'memory_gb_hours' => 0, 'storage_gb_months' => 0, 'bandwidth_gb' => 0, 'build_minutes' => 0];

    $costs = invade($this->service)->calculateCosts($organization, $resourceUsage, $subscription);

    expect($costs['overage_cost'])->toBe(3750); // 50 hours * $0.75 = $37.50
});

it('applies volume discounts', function () {
    $organization = Organization::factory()->create();
    $totalCost = 10000; // $100.00
    $resourceUsage = ['cpu_hours' => 1500, 'memory_gb_hours' => 0, 'storage_gb_months' => 0, 'bandwidth_gb' => 0, 'build_minutes' => 0];

    $result = invade($this->service)->applyDiscountsAndCredits($organization, $totalCost, $resourceUsage);

    // 10% discount for > 1000 CPU hours
    expect($result['discount'])->toBe(1000); // $10.00 discount
    expect($result['final'])->toBe(9000); // $90.00 after discount
});

it('projects end-of-month costs accurately', function () {
    $organization = Organization::factory()->create();

    // Mock: 15 days into a 30-day month, 100 CPU hours consumed
    Carbon::setTestNow(Carbon::parse('2024-01-15'));

    // Assume aggregateResourceMetrics returns half-month usage
    $projection = $this->service->projectMonthEndCost($organization);

    expect($projection)->toHaveKeys(['current_usage', 'projected_usage', 'projected_cost', 'days_remaining']);
    expect($projection['days_remaining'])->toBe(16); // 30 - 15 + 1
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/UsageBillingIntegrationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Enterprise\OrganizationSubscription;
use App\Models\Enterprise\BillingUsage;
use App\Models\ServerResourceMetric;
use App\Services\Enterprise\UsageBillingService;
use Carbon\Carbon;

it('calculates full billing cycle end-to-end', function () {
    $organization = Organization::factory()->create();
    $subscription = OrganizationSubscription::factory()->create([
        'organization_id' => $organization->id,
        'plan_price' => 5000, // $50 base
        'cpu_hours_quota' => 100,
        'memory_gb_hours_quota' => 200,
    ]);

    // Create sample resource metrics
    $server = Server::factory()->create(['organization_id' => $organization->id]);

    $periodStart = Carbon::parse('2024-01-01');
    $periodEnd = Carbon::parse('2024-01-31');

    // Simulate metric collection (simplified)
    ServerResourceMetric::create([
        'server_id' => $server->id,
        'cpu_usage_percent' => 50,
        'memory_used_gb' => 8,
        'disk_used_gb' => 100,
        'network_rx_gb' => 10,
        'network_tx_gb' => 5,
        'recorded_at' => $periodStart->copy()->addDays(1),
    ]);

    // Seed pricing rules
    PricingRule::factory()->create([
        'resource_type' => 'cpu',
        'pricing_model' => 'per_unit',
        'pricing_tiers' => [['min' => 0, 'max' => null, 'price' => 50]],
    ]);

    $billingService = app(UsageBillingService::class);
    $billingUsage = $billingService->calculateUsage($organization, $periodStart, $periodEnd);

    expect($billingUsage)->toBeInstanceOf(BillingUsage::class);
    expect($billingUsage->status)->toBe('calculated');
    expect($billingUsage->final_amount)->toBeGreaterThan(0);
    expect($billingUsage->usage_breakdown)->not->toBeNull();
});

it('generates invoice line items correctly', function () {
    $billingUsage = BillingUsage::factory()->create([
        'base_subscription_cost' => 5000,
        'cpu_cost' => 2500,
        'memory_cost' => 1500,
        'overage_cost' => 1000,
        'volume_discount' => 500,
        'total_cost' => 9500,
        'final_amount' => 9000,
    ]);

    $invoice = Invoice::create([
        'organization_id' => $billingUsage->organization_id,
        'amount' => $billingUsage->final_amount,
        'status' => 'pending',
        'due_date' => now()->addDays(7),
    ]);

    $billingService = app(UsageBillingService::class);
    $billingService->generateInvoiceLineItems($billingUsage, $invoice->id);

    $lineItems = $invoice->lineItems;

    expect($lineItems)->toHaveCount(5); // subscription, cpu, memory, overage, discount
    expect($lineItems->where('item_type', 'subscription')->first()->amount)->toBe(5000);
    expect($lineItems->where('item_type', 'discount')->first()->amount)->toBe(-500);
});

it('processes usage charges via background job', function () {
    Queue::fake();

    $billingUsage = BillingUsage::factory()->create(['status' => 'calculated']);

    ProcessUsageChargesJob::dispatch($billingUsage);

    Queue::assertPushed(ProcessUsageChargesJob::class, function ($job) use ($billingUsage) {
        return $job->billingUsage->id === $billingUsage->id;
    });
});
```

### Performance Tests

```php
it('calculates usage for 1000 organizations in under 60 seconds', function () {
    $organizations = Organization::factory()->count(1000)->create();

    $startTime = microtime(true);

    foreach ($organizations as $organization) {
        CalculateMonthlyUsageJob::dispatchSync(
            $organization,
            now()->startOfMonth(),
            now()
        );
    }

    $duration = microtime(true) - $startTime;

    expect($duration)->toBeLessThan(60);
})->group('performance');
```

## Definition of Done

- [ ] Database migrations created and run successfully
- [ ] BillingUsage model created with relationships and casts
- [ ] InvoiceLineItem model created
- [ ] PricingRule model created with JSON casting
- [ ] UsageBillingServiceInterface created
- [ ] UsageBillingService implemented with all methods
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Resource metric aggregation implemented with time-series SQL
- [ ] Pricing calculation logic supports all models (flat, tiered, volume, per-unit)
- [ ] Overage calculation implemented with premium rates
- [ ] Volume discount logic implemented
- [ ] Promotional credit application implemented
- [ ] Invoice line item generation implemented
- [ ] Cost projection method implemented
- [ ] CalculateMonthlyUsageJob created and tested
- [ ] ProcessUsageChargesJob created and tested
- [ ] CalculateBillingUsage artisan command created
- [ ] GenerateUsageReport artisan command created
- [ ] Scheduled task configured for monthly calculations
- [ ] Integration with SystemResourceMonitor complete
- [ ] Integration with PaymentService complete
- [ ] Integration with subscription lifecycle complete
- [ ] Pricing rule seeder created with default rates
- [ ] Unit tests written (15+ tests, >90% coverage)
- [ ] Integration tests written (8+ tests)
- [ ] Performance test validates 1000 orgs in <60s
- [ ] Manual testing with real subscription data
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing (`./vendor/bin/phpstan`)
- [ ] Documentation updated (service methods, configuration)
- [ ] Code reviewed and approved
- [ ] All tests passing (`php artisan test --filter=UsageBilling`)

## Related Tasks

- **Depends on:** Task 25 (SystemResourceMonitor - source of metrics)
- **Depends on:** Task 48 (Subscription lifecycle - quota enforcement)
- **Integrates with:** Task 46 (PaymentService - process charges)
- **Integrates with:** Task 28 (OrganizationResourceUsage - quota tracking)
- **Used by:** Task 50 (BillingDashboard.vue - display usage and costs)
- **Enables:** Task 47 (Webhook handling - payment confirmations)
- **Enables:** Invoice generation and automated billing workflows
