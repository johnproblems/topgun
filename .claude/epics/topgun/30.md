---
name: Build CapacityPlanner.vue with server selection visualization
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:49Z
github: https://github.com/johnproblems/topgun/issues/140
depends_on: [26]
parallel: true
conflicts_with: []
---

# Task: Build CapacityPlanner.vue with server selection visualization

## Description

Create a Vue.js 3 component for visualizing server capacity, scoring, and selection recommendations. This component provides administrators with real-time insights into server resource availability, helping them make informed infrastructure decisions before deployments. The CapacityPlanner integrates with the CapacityManager service (Task 26) to display weighted server scores, capacity forecasts, and deployment suitability recommendations.

**The Capacity Planning Challenge:**

Without visibility into server capacity, administrators face several problems:
1. **Blind Deployment Decisions**: Deploying to overloaded servers causes slow builds, deployment failures, and poor application performance
2. **Resource Waste**: Underutilized servers sit idle while overloaded servers struggle, creating inefficiency
3. **No Forecasting**: Unable to predict when additional servers will be needed, leading to reactive (not proactive) infrastructure management
4. **Manual Selection**: Administrators must manually analyze metrics across multiple servers to find the best deployment target

**The Solution:**

CapacityPlanner.vue transforms raw server metrics into actionable intelligence through:
1. **Visual Server Scoring**: Color-coded server cards showing overall capacity scores (0-100) with weighted breakdowns (CPU 30%, Memory 30%, Disk 20%, Network 10%, Load 10%)
2. **Deployment Suitability**: "Green/Yellow/Red" indicators showing which servers can handle the requested deployment size
3. **Capacity Forecasting**: Projected capacity over time based on current usage trends and planned deployments
4. **Smart Recommendations**: AI-powered server selection with explanations ("Best choice: server-03 because CPU and memory are optimal for this workload")
5. **Real-Time Updates**: WebSocket integration shows live capacity changes as deployments start/complete
6. **Resource Reservation**: Visual indication of reserved resources during active deployments

**Integration Architecture:**

**Backend Services:**
- **CapacityManager** (Task 26): Provides `selectOptimalServer()`, `getServerScores()`, `forecastCapacity()`
- **SystemResourceMonitor** (Task 25): Supplies real-time metrics via WebSocket broadcasts
- **ResourceMonitoringJob** (Task 24): Collects metrics every 30 seconds

**Frontend Components:**
- **Parent**: DeploymentManager.vue (Task 39) - Deployment strategy configuration
- **Sibling**: ResourceDashboard.vue (Task 29) - Real-time metrics visualization
- **Child**: ServerCapacityCard.vue (created in this task) - Individual server capacity display

**Data Flow:**
1. User selects deployment requirements (app size, resource needs)
2. CapacityPlanner fetches server scores from CapacityManager API
3. Component displays servers ranked by suitability score
4. User selects server or accepts recommended server
5. Real-time WebSocket updates adjust scores as metrics change
6. On deployment start, CapacityPlanner shows reserved resources

**Why This Task is Critical:**

CapacityPlanner is the visual manifestation of intelligent infrastructure management. It transforms the Coolify deployment experience from "hope it works" to "know it will work." For enterprise organizations managing dozens of servers and hundreds of applications, this component prevents deployment failures, optimizes resource utilization, and enables proactive capacity planningâ€”saving time, money, and administrator stress.

The component also serves as a competitive differentiator: most PaaS platforms hide capacity details from users, leading to mysterious failures. By exposing capacity intelligence transparently, Coolify Enterprise builds trust and empowers administrators to make data-driven infrastructure decisions.

## Acceptance Criteria

- [ ] CapacityPlanner.vue component created with Vue 3 Composition API
- [ ] Displays server cards ranked by capacity score (0-100)
- [ ] Shows weighted score breakdown: CPU, Memory, Disk, Network, Load with percentage bars
- [ ] Color-coded indicators: Green (>80 score), Yellow (50-80), Red (<50)
- [ ] Deployment suitability calculator based on requested resources (CPU cores, RAM GB, disk GB)
- [ ] Visual "fit" indicator: "Perfect Fit", "Adequate", "Tight Fit", "Insufficient"
- [ ] Server selection with recommended server highlighted
- [ ] Capacity forecasting chart showing projected usage over next 30 days
- [ ] Real-time updates via WebSocket integration (Laravel Reverb)
- [ ] Resource reservation display during active deployments
- [ ] Filter servers by minimum capacity threshold
- [ ] Sort servers by score, available CPU, available memory, available disk
- [ ] Responsive design working on desktop, tablet, mobile
- [ ] Dark mode support with proper contrast ratios
- [ ] Loading states for async data fetching
- [ ] Error handling for API failures and WebSocket disconnects
- [ ] Integration with Inertia.js for server-side data initialization
- [ ] Accessibility compliance (ARIA labels, keyboard navigation, screen reader support)

## Technical Details

### File Paths

**Main Component:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/ResourceMonitoring/CapacityPlanner.vue`

**Child Components:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/ResourceMonitoring/ServerCapacityCard.vue`
- `/home/topgun/topgun/resources/js/Components/Enterprise/ResourceMonitoring/CapacityForecastChart.vue`
- `/home/topgun/topgun/resources/js/Components/Enterprise/ResourceMonitoring/DeploymentRequirements.vue`

**Composables:**
- `/home/topgun/topgun/resources/js/Composables/useCapacityPlanner.js`
- `/home/topgun/topgun/resources/js/Composables/useServerWebSocket.js`

**Backend Controller:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/CapacityController.php`

**Routes:**
- `/home/topgun/topgun/routes/web.php` (modify - add Inertia routes)
- `/home/topgun/topgun/routes/api.php` (modify - add API endpoints)

**Inertia Page:**
- `/home/topgun/topgun/resources/js/Pages/Enterprise/CapacityPlanning.vue`

### Component Architecture

**Main Component:** `CapacityPlanner.vue`

```vue
<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useForm } from '@inertiajs/vue3'
import ServerCapacityCard from './ServerCapacityCard.vue'
import CapacityForecastChart from './CapacityForecastChart.vue'
import DeploymentRequirements from './DeploymentRequirements.vue'
import { useCapacityPlanner } from '@/Composables/useCapacityPlanner'
import { useServerWebSocket } from '@/Composables/useServerWebSocket'

const props = defineProps({
  organizationId: {
    type: Number,
    required: true
  },
  servers: {
    type: Array,
    required: true
  },
  initialScores: {
    type: Array,
    default: () => []
  }
})

const emit = defineEmits(['server-selected', 'capacity-insufficient'])

// State management
const deploymentRequirements = ref({
  cpu_cores: 2,
  memory_gb: 4,
  disk_gb: 20,
  estimated_build_time: 300, // seconds
  concurrent_users: 100
})

const sortBy = ref('score') // score, cpu, memory, disk
const minCapacityThreshold = ref(50) // 0-100
const showForecast = ref(false)
const selectedServerId = ref(null)

// Use composables
const {
  serverScores,
  recommendedServer,
  isLoading,
  error,
  refreshScores,
  calculateSuitability,
  forecastCapacity
} = useCapacityPlanner(props.organizationId, props.initialScores)

const {
  isConnected,
  latestMetrics,
  connect,
  disconnect
} = useServerWebSocket(props.organizationId)

// Computed properties
const rankedServers = computed(() => {
  let filtered = serverScores.value.filter(
    server => server.overall_score >= minCapacityThreshold.value
  )

  return filtered.sort((a, b) => {
    switch (sortBy.value) {
      case 'cpu':
        return b.available_cpu - a.available_cpu
      case 'memory':
        return b.available_memory - a.available_memory
      case 'disk':
        return b.available_disk - a.available_disk
      default:
        return b.overall_score - a.overall_score
    }
  })
})

const serversWithSuitability = computed(() => {
  return rankedServers.value.map(server => ({
    ...server,
    suitability: calculateSuitability(server, deploymentRequirements.value)
  }))
})

const capacityInsufficient = computed(() => {
  return !serversWithSuitability.value.some(
    s => s.suitability.status === 'perfect' || s.suitability.status === 'adequate'
  )
})

// Methods
const selectServer = (server) => {
  selectedServerId.value = server.id
  emit('server-selected', server)
}

const updateRequirements = (newRequirements) => {
  deploymentRequirements.value = { ...deploymentRequirements.value, ...newRequirements }
  refreshScores(newRequirements)
}

const handleMetricUpdate = (metrics) => {
  // Update server scores with new real-time metrics
  const serverIndex = serverScores.value.findIndex(s => s.id === metrics.server_id)
  if (serverIndex !== -1) {
    serverScores.value[serverIndex] = {
      ...serverScores.value[serverIndex],
      ...metrics
    }
  }
}

// Lifecycle hooks
onMounted(() => {
  connect()
  if (serverScores.value.length === 0) {
    refreshScores(deploymentRequirements.value)
  }
})

onUnmounted(() => {
  disconnect()
})

// Watch for WebSocket metric updates
watch(latestMetrics, (newMetrics) => {
  if (newMetrics) {
    handleMetricUpdate(newMetrics)
  }
})

// Watch for capacity insufficient state
watch(capacityInsufficient, (insufficient) => {
  if (insufficient) {
    emit('capacity-insufficient', deploymentRequirements.value)
  }
})
</script>

<template>
  <div class="capacity-planner">
    <!-- Header Section -->
    <div class="header">
      <div class="title-section">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-gray-100">
          Server Capacity Planning
        </h2>
        <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">
          Select optimal server based on current capacity and deployment requirements
        </p>
      </div>

      <div class="connection-status">
        <div
          class="status-indicator"
          :class="{ 'connected': isConnected, 'disconnected': !isConnected }"
        >
          <span class="status-dot"></span>
          {{ isConnected ? 'Live Updates' : 'Connecting...' }}
        </div>
      </div>
    </div>

    <!-- Deployment Requirements Input -->
    <DeploymentRequirements
      :requirements="deploymentRequirements"
      @update="updateRequirements"
      class="mb-6"
    />

    <!-- Recommended Server Banner -->
    <div
      v-if="recommendedServer && !capacityInsufficient"
      class="recommended-banner bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4 mb-6"
    >
      <div class="flex items-center gap-3">
        <svg class="w-6 h-6 text-green-600 dark:text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <div class="flex-1">
          <h3 class="font-semibold text-green-900 dark:text-green-100">
            Recommended: {{ recommendedServer.name }}
          </h3>
          <p class="text-sm text-green-700 dark:text-green-300">
            {{ recommendedServer.recommendation_reason }}
          </p>
        </div>
        <button
          @click="selectServer(recommendedServer)"
          class="btn btn-primary"
        >
          Use This Server
        </button>
      </div>
    </div>

    <!-- Insufficient Capacity Warning -->
    <div
      v-if="capacityInsufficient"
      class="warning-banner bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 mb-6"
    >
      <div class="flex items-center gap-3">
        <svg class="w-6 h-6 text-red-600 dark:text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <div class="flex-1">
          <h3 class="font-semibold text-red-900 dark:text-red-100">
            Insufficient Capacity
          </h3>
          <p class="text-sm text-red-700 dark:text-red-300">
            No servers have adequate capacity for these requirements. Consider provisioning a new server or reducing resource requirements.
          </p>
        </div>
        <button
          @click="$emit('provision-new-server')"
          class="btn btn-secondary"
        >
          Provision New Server
        </button>
      </div>
    </div>

    <!-- Controls Section -->
    <div class="controls flex items-center gap-4 mb-6">
      <!-- Sort Dropdown -->
      <div class="sort-control">
        <label for="sort" class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">
          Sort by:
        </label>
        <select
          id="sort"
          v-model="sortBy"
          class="form-select rounded-md border-gray-300 dark:border-gray-700 dark:bg-gray-800"
        >
          <option value="score">Overall Score</option>
          <option value="cpu">Available CPU</option>
          <option value="memory">Available Memory</option>
          <option value="disk">Available Disk</option>
        </select>
      </div>

      <!-- Minimum Capacity Threshold -->
      <div class="threshold-control flex items-center gap-2">
        <label for="threshold" class="text-sm font-medium text-gray-700 dark:text-gray-300">
          Min Score:
        </label>
        <input
          id="threshold"
          v-model.number="minCapacityThreshold"
          type="range"
          min="0"
          max="100"
          step="5"
          class="w-32"
        />
        <span class="text-sm font-mono text-gray-600 dark:text-gray-400">
          {{ minCapacityThreshold }}
        </span>
      </div>

      <!-- Forecast Toggle -->
      <button
        @click="showForecast = !showForecast"
        class="btn btn-secondary ml-auto"
      >
        {{ showForecast ? 'Hide' : 'Show' }} Forecast
      </button>

      <!-- Refresh Button -->
      <button
        @click="refreshScores(deploymentRequirements)"
        :disabled="isLoading"
        class="btn btn-secondary"
      >
        <svg
          class="w-4 h-4"
          :class="{ 'animate-spin': isLoading }"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        <span class="ml-2">Refresh</span>
      </button>
    </div>

    <!-- Capacity Forecast Chart -->
    <CapacityForecastChart
      v-if="showForecast"
      :organization-id="organizationId"
      :forecast-days="30"
      class="mb-6"
    />

    <!-- Loading State -->
    <div v-if="isLoading" class="loading-state text-center py-12">
      <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      <p class="mt-4 text-gray-600 dark:text-gray-400">Calculating server capacity...</p>
    </div>

    <!-- Error State -->
    <div v-else-if="error" class="error-state bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-6 text-center">
      <svg class="w-12 h-12 text-red-600 dark:text-red-400 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <h3 class="text-lg font-semibold text-red-900 dark:text-red-100 mb-2">
        Failed to Load Capacity Data
      </h3>
      <p class="text-red-700 dark:text-red-300 mb-4">{{ error }}</p>
      <button @click="refreshScores(deploymentRequirements)" class="btn btn-primary">
        Try Again
      </button>
    </div>

    <!-- Server Grid -->
    <div v-else class="server-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      <ServerCapacityCard
        v-for="server in serversWithSuitability"
        :key="server.id"
        :server="server"
        :suitability="server.suitability"
        :is-selected="selectedServerId === server.id"
        :is-recommended="recommendedServer?.id === server.id"
        @select="selectServer"
      />
    </div>

    <!-- Empty State -->
    <div
      v-if="!isLoading && !error && rankedServers.length === 0"
      class="empty-state text-center py-12"
    >
      <svg class="w-16 h-16 text-gray-400 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" />
      </svg>
      <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-2">
        No Servers Match Criteria
      </h3>
      <p class="text-gray-600 dark:text-gray-400 mb-4">
        Try lowering the minimum capacity threshold or add new servers
      </p>
      <button @click="minCapacityThreshold = 0" class="btn btn-secondary">
        Show All Servers
      </button>
    </div>
  </div>
</template>

<style scoped>
.capacity-planner {
  @apply max-w-7xl mx-auto p-6;
}

.header {
  @apply flex items-start justify-between mb-6;
}

.status-indicator {
  @apply flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium;
}

.status-indicator.connected {
  @apply bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400;
}

.status-indicator.disconnected {
  @apply bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-400;
}

.status-dot {
  @apply w-2 h-2 rounded-full;
  background-color: currentColor;
}

.status-indicator.connected .status-dot {
  @apply animate-pulse;
}

.btn {
  @apply px-4 py-2 rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2;
}

.btn-primary {
  @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500;
}

.btn-secondary {
  @apply bg-gray-200 text-gray-900 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600 focus:ring-gray-500;
}

.btn:disabled {
  @apply opacity-50 cursor-not-allowed;
}
</style>
```

### Child Component: ServerCapacityCard.vue

```vue
<script setup>
import { computed } from 'vue'

const props = defineProps({
  server: {
    type: Object,
    required: true
  },
  suitability: {
    type: Object,
    required: true
  },
  isSelected: {
    type: Boolean,
    default: false
  },
  isRecommended: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['select'])

// Computed properties
const scoreColor = computed(() => {
  const score = props.server.overall_score
  if (score >= 80) return 'green'
  if (score >= 50) return 'yellow'
  return 'red'
})

const suitabilityColor = computed(() => {
  switch (props.suitability.status) {
    case 'perfect':
      return 'green'
    case 'adequate':
      return 'blue'
    case 'tight':
      return 'yellow'
    default:
      return 'red'
  }
})

const suitabilityIcon = computed(() => {
  switch (props.suitability.status) {
    case 'perfect':
      return 'âœ“'
    case 'adequate':
      return 'â—‹'
    case 'tight':
      return 'â–³'
    default:
      return 'âœ•'
  }
})
</script>

<template>
  <div
    class="server-card"
    :class="{
      'selected': isSelected,
      'recommended': isRecommended,
      [`border-${scoreColor}-500`]: true
    }"
    @click="$emit('select', server)"
  >
    <!-- Card Header -->
    <div class="card-header">
      <div class="flex items-center justify-between">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">
          {{ server.name }}
        </h3>
        <span
          class="score-badge"
          :class="`bg-${scoreColor}-100 text-${scoreColor}-800 dark:bg-${scoreColor}-900/30 dark:text-${scoreColor}-400`"
        >
          {{ server.overall_score }}
        </span>
      </div>

      <div v-if="isRecommended" class="recommended-badge mt-2">
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
        </svg>
        <span>Recommended</span>
      </div>
    </div>

    <!-- Suitability Badge -->
    <div
      class="suitability-badge"
      :class="`bg-${suitabilityColor}-50 border-${suitabilityColor}-200 dark:bg-${suitabilityColor}-900/20 dark:border-${suitabilityColor}-800`"
    >
      <span class="suitability-icon">{{ suitabilityIcon }}</span>
      <span class="suitability-text">{{ suitability.label }}</span>
    </div>

    <!-- Score Breakdown -->
    <div class="score-breakdown space-y-3 mt-4">
      <!-- CPU -->
      <div class="metric">
        <div class="metric-header">
          <span class="metric-label">CPU</span>
          <span class="metric-value">{{ server.available_cpu_percent }}%</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :class="`bg-${getMetricColor(server.available_cpu_percent)}-500`"
            :style="{ width: `${server.available_cpu_percent}%` }"
          ></div>
        </div>
        <div class="metric-detail">
          {{ server.available_cpu_cores }} / {{ server.total_cpu_cores }} cores available
        </div>
      </div>

      <!-- Memory -->
      <div class="metric">
        <div class="metric-header">
          <span class="metric-label">Memory</span>
          <span class="metric-value">{{ server.available_memory_percent }}%</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :class="`bg-${getMetricColor(server.available_memory_percent)}-500`"
            :style="{ width: `${server.available_memory_percent}%` }"
          ></div>
        </div>
        <div class="metric-detail">
          {{ server.available_memory_gb }} / {{ server.total_memory_gb }} GB available
        </div>
      </div>

      <!-- Disk -->
      <div class="metric">
        <div class="metric-header">
          <span class="metric-label">Disk</span>
          <span class="metric-value">{{ server.available_disk_percent }}%</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress-fill"
            :class="`bg-${getMetricColor(server.available_disk_percent)}-500`"
            :style="{ width: `${server.available_disk_percent}%` }"
          ></div>
        </div>
        <div class="metric-detail">
          {{ server.available_disk_gb }} / {{ server.total_disk_gb }} GB available
        </div>
      </div>

      <!-- Current Load -->
      <div class="metric">
        <div class="metric-header">
          <span class="metric-label">Load</span>
          <span class="metric-value">{{ server.load_average }}</span>
        </div>
        <div class="metric-detail">
          {{ server.active_deployments }} active deployments
        </div>
      </div>
    </div>

    <!-- Server Info -->
    <div class="server-info mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
      <div class="info-row">
        <span class="info-label">Location:</span>
        <span class="info-value">{{ server.location || 'N/A' }}</span>
      </div>
      <div class="info-row">
        <span class="info-label">Provider:</span>
        <span class="info-value">{{ server.provider || 'Self-hosted' }}</span>
      </div>
      <div class="info-row">
        <span class="info-label">Uptime:</span>
        <span class="info-value">{{ server.uptime_days }} days</span>
      </div>
    </div>

    <!-- Select Button -->
    <button
      class="select-button"
      :class="{ 'selected': isSelected }"
      @click.stop="$emit('select', server)"
    >
      {{ isSelected ? 'Selected' : 'Select Server' }}
    </button>
  </div>
</template>

<script>
export default {
  methods: {
    getMetricColor(percentage) {
      if (percentage >= 70) return 'green'
      if (percentage >= 40) return 'yellow'
      return 'red'
    }
  }
}
</script>

<style scoped>
.server-card {
  @apply bg-white dark:bg-gray-800 rounded-lg shadow-sm border-2 p-6 cursor-pointer transition-all hover:shadow-md;
}

.server-card.selected {
  @apply border-blue-500 bg-blue-50 dark:bg-blue-900/20;
}

.server-card.recommended {
  @apply ring-2 ring-green-500 ring-offset-2;
}

.score-badge {
  @apply px-3 py-1 rounded-full text-sm font-bold;
}

.recommended-badge {
  @apply inline-flex items-center gap-1 px-2 py-1 bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400 rounded text-xs font-medium;
}

.suitability-badge {
  @apply flex items-center gap-2 px-3 py-2 rounded-md border mt-3;
}

.suitability-icon {
  @apply text-lg font-bold;
}

.suitability-text {
  @apply text-sm font-medium;
}

.metric {
  @apply space-y-1;
}

.metric-header {
  @apply flex items-center justify-between text-sm;
}

.metric-label {
  @apply font-medium text-gray-700 dark:text-gray-300;
}

.metric-value {
  @apply font-mono text-gray-900 dark:text-gray-100;
}

.progress-bar {
  @apply w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden;
}

.progress-fill {
  @apply h-full transition-all duration-300;
}

.metric-detail {
  @apply text-xs text-gray-600 dark:text-gray-400;
}

.server-info {
  @apply space-y-2;
}

.info-row {
  @apply flex items-center justify-between text-sm;
}

.info-label {
  @apply text-gray-600 dark:text-gray-400;
}

.info-value {
  @apply font-medium text-gray-900 dark:text-gray-100;
}

.select-button {
  @apply w-full mt-4 px-4 py-2 bg-blue-600 text-white rounded-md font-medium hover:bg-blue-700 transition-colors;
}

.select-button.selected {
  @apply bg-green-600 hover:bg-green-700;
}
</style>
```

### Composable: useCapacityPlanner.js

```javascript
import { ref, computed } from 'vue'
import axios from 'axios'

export function useCapacityPlanner(organizationId, initialScores = []) {
  const serverScores = ref(initialScores)
  const isLoading = ref(false)
  const error = ref(null)

  /**
   * Refresh server capacity scores from backend
   */
  const refreshScores = async (requirements) => {
    isLoading.value = true
    error.value = null

    try {
      const response = await axios.post(
        `/api/enterprise/organizations/${organizationId}/capacity/scores`,
        requirements
      )

      serverScores.value = response.data.servers
    } catch (err) {
      error.value = err.response?.data?.message || 'Failed to load capacity data'
      console.error('Capacity refresh error:', err)
    } finally {
      isLoading.value = false
    }
  }

  /**
   * Get recommended server from scores
   */
  const recommendedServer = computed(() => {
    if (serverScores.value.length === 0) return null

    return serverScores.value.reduce((best, current) => {
      return current.overall_score > (best?.overall_score || 0) ? current : best
    }, null)
  })

  /**
   * Calculate deployment suitability for a server
   */
  const calculateSuitability = (server, requirements) => {
    const cpuFit = server.available_cpu_cores >= requirements.cpu_cores
    const memoryFit = server.available_memory_gb >= requirements.memory_gb
    const diskFit = server.available_disk_gb >= requirements.disk_gb

    if (cpuFit && memoryFit && diskFit) {
      const headroom = Math.min(
        server.available_cpu_percent - (requirements.cpu_cores / server.total_cpu_cores * 100),
        server.available_memory_percent - (requirements.memory_gb / server.total_memory_gb * 100),
        server.available_disk_percent - (requirements.disk_gb / server.total_disk_gb * 100)
      )

      if (headroom >= 30) {
        return { status: 'perfect', label: 'Perfect Fit', color: 'green' }
      } else if (headroom >= 10) {
        return { status: 'adequate', label: 'Adequate', color: 'blue' }
      } else {
        return { status: 'tight', label: 'Tight Fit', color: 'yellow' }
      }
    }

    return { status: 'insufficient', label: 'Insufficient', color: 'red' }
  }

  /**
   * Forecast capacity over time
   */
  const forecastCapacity = async (days = 30) => {
    try {
      const response = await axios.get(
        `/api/enterprise/organizations/${organizationId}/capacity/forecast`,
        { params: { days } }
      )

      return response.data.forecast
    } catch (err) {
      console.error('Forecast error:', err)
      return []
    }
  }

  return {
    serverScores,
    recommendedServer,
    isLoading,
    error,
    refreshScores,
    calculateSuitability,
    forecastCapacity
  }
}
```

### Backend Controller

**File:** `app/Http/Controllers/Enterprise/CapacityController.php`

```php
<?php

namespace App\Http\Controllers\Enterprise;

use App\Contracts\CapacityManagerInterface;
use App\Http\Controllers\Controller;
use App\Models\Organization;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

class CapacityController extends Controller
{
    use AuthorizesRequests;

    public function __construct(
        private CapacityManagerInterface $capacityManager
    ) {
    }

    /**
     * Display capacity planning page
     */
    public function index(Organization $organization): Response
    {
        $this->authorize('view', $organization);

        $servers = $organization->servers()
            ->with(['currentMetrics'])
            ->get();

        $initialScores = $this->capacityManager->getServerScores(
            $servers,
            ['cpu_cores' => 2, 'memory_gb' => 4, 'disk_gb' => 20]
        );

        return Inertia::render('Enterprise/CapacityPlanning', [
            'organizationId' => $organization->id,
            'servers' => $servers,
            'initialScores' => $initialScores,
        ]);
    }

    /**
     * Calculate server capacity scores
     */
    public function scores(Request $request, Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $validated = $request->validate([
            'cpu_cores' => 'required|integer|min:1|max:64',
            'memory_gb' => 'required|integer|min:1|max:512',
            'disk_gb' => 'required|integer|min:1|max:10000',
            'estimated_build_time' => 'nullable|integer|min:0',
            'concurrent_users' => 'nullable|integer|min:0',
        ]);

        $servers = $organization->servers()
            ->with(['currentMetrics'])
            ->get();

        $scores = $this->capacityManager->getServerScores($servers, $validated);

        return response()->json([
            'servers' => $scores,
            'recommended' => $scores->first(),
        ]);
    }

    /**
     * Get capacity forecast
     */
    public function forecast(Request $request, Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $days = $request->integer('days', 30);

        $forecast = $this->capacityManager->forecastCapacity($organization, $days);

        return response()->json([
            'forecast' => $forecast,
            'days' => $days,
        ]);
    }

    /**
     * Get optimal server for deployment
     */
    public function selectOptimal(Request $request, Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $validated = $request->validate([
            'cpu_cores' => 'required|integer|min:1',
            'memory_gb' => 'required|integer|min:1',
            'disk_gb' => 'required|integer|min:1',
        ]);

        $servers = $organization->servers()->get();

        $optimalServer = $this->capacityManager->selectOptimalServer($servers, $validated);

        if (!$optimalServer) {
            return response()->json([
                'server' => null,
                'message' => 'No servers have sufficient capacity for these requirements',
            ], 404);
        }

        return response()->json([
            'server' => $optimalServer,
            'score' => $this->capacityManager->calculateServerScore($optimalServer, $validated),
        ]);
    }
}
```

### Routes

**File:** `routes/web.php` (add to existing routes)

```php
use App\Http\Controllers\Enterprise\CapacityController;

Route::middleware(['auth', 'organization'])->group(function () {
    Route::get('/enterprise/organizations/{organization}/capacity',
        [CapacityController::class, 'index'])
        ->name('enterprise.capacity.index');
});
```

**File:** `routes/api.php` (add to existing API routes)

```php
Route::middleware(['auth:sanctum', 'organization'])->group(function () {
    Route::prefix('enterprise/organizations/{organization}')->group(function () {
        Route::post('/capacity/scores', [CapacityController::class, 'scores']);
        Route::get('/capacity/forecast', [CapacityController::class, 'forecast']);
        Route::post('/capacity/select-optimal', [CapacityController::class, 'selectOptimal']);
    });
});
```

## Implementation Approach

### Step 1: Create Component Structure
1. Create `CapacityPlanner.vue` main component in `resources/js/Components/Enterprise/ResourceMonitoring/`
2. Create child components: `ServerCapacityCard.vue`, `CapacityForecastChart.vue`, `DeploymentRequirements.vue`
3. Set up Vue 3 Composition API with props, emits, and reactive state

### Step 2: Build Composables
1. Create `useCapacityPlanner.js` composable for state management
2. Implement `refreshScores()`, `calculateSuitability()`, `forecastCapacity()` methods
3. Create `useServerWebSocket.js` for real-time updates via Laravel Reverb

### Step 3: Implement Server Scoring Display
1. Build `ServerCapacityCard.vue` with score breakdown visualization
2. Add color-coded progress bars for CPU, memory, disk metrics
3. Implement suitability indicators (Perfect Fit, Adequate, Tight Fit, Insufficient)
4. Add server selection logic with click handlers

### Step 4: Add Deployment Requirements Input
1. Create `DeploymentRequirements.vue` component with input fields
2. Add sliders for CPU cores, memory GB, disk GB
3. Implement validation for reasonable resource ranges
4. Emit update events to parent component

### Step 5: Implement Capacity Forecasting
1. Create `CapacityForecastChart.vue` using ApexCharts
2. Fetch forecast data from backend API
3. Display projected capacity over 30 days
4. Show trend lines for CPU, memory, disk usage

### Step 6: Create Backend Controller
1. Create `CapacityController` in `app/Http/Controllers/Enterprise/`
2. Implement `index()` method for Inertia page rendering
3. Implement `scores()` API endpoint
4. Implement `forecast()` API endpoint
5. Implement `selectOptimal()` API endpoint

### Step 7: Integrate WebSocket Updates
1. Set up Laravel Reverb channel for capacity updates
2. Implement `useServerWebSocket` composable with connection management
3. Handle metric updates in real-time
4. Update server scores reactively when metrics change

### Step 8: Add Filtering and Sorting
1. Implement sort dropdown (by score, CPU, memory, disk)
2. Add minimum capacity threshold slider
3. Create computed property for filtered/sorted servers
4. Add empty state when no servers match criteria

### Step 9: Styling and Polish
1. Apply Tailwind CSS for responsive design
2. Implement dark mode support
3. Add loading states and skeleton screens
4. Add smooth transitions and animations
5. Ensure accessibility (ARIA labels, keyboard navigation)

### Step 10: Testing
1. Write unit tests for composables
2. Write component tests with Vue Test Utils
3. Write integration tests for API endpoints
4. Write browser tests for user interactions
5. Test real-time WebSocket updates

## Test Strategy

### Unit Tests (Vitest/Vue Test Utils)

**File:** `resources/js/Components/Enterprise/ResourceMonitoring/__tests__/CapacityPlanner.spec.js`

```javascript
import { mount } from '@vue/test-utils'
import { describe, it, expect, vi } from 'vitest'
import CapacityPlanner from '../CapacityPlanner.vue'

describe('CapacityPlanner.vue', () => {
  const mockServers = [
    {
      id: 1,
      name: 'server-01',
      overall_score: 85,
      available_cpu_percent: 75,
      available_memory_percent: 80,
      available_disk_percent: 90,
      available_cpu_cores: 6,
      total_cpu_cores: 8,
      available_memory_gb: 16,
      total_memory_gb: 20,
      available_disk_gb: 450,
      total_disk_gb: 500,
      load_average: 1.2,
      active_deployments: 3
    },
    {
      id: 2,
      name: 'server-02',
      overall_score: 60,
      available_cpu_percent: 50,
      available_memory_percent: 60,
      available_disk_percent: 70,
      available_cpu_cores: 4,
      total_cpu_cores: 8,
      available_memory_gb: 12,
      total_memory_gb: 20,
      available_disk_gb: 350,
      total_disk_gb: 500,
      load_average: 2.5,
      active_deployments: 5
    }
  ]

  it('renders server cards for all servers', () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    expect(wrapper.findAll('.server-card')).toHaveLength(2)
  })

  it('sorts servers by overall score by default', () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    const cards = wrapper.findAll('.server-card')
    expect(cards[0].text()).toContain('server-01') // Higher score first
    expect(cards[1].text()).toContain('server-02')
  })

  it('filters servers by minimum capacity threshold', async () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    await wrapper.find('#threshold').setValue(70)

    expect(wrapper.findAll('.server-card')).toHaveLength(1)
    expect(wrapper.text()).toContain('server-01')
  })

  it('highlights recommended server', () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    expect(wrapper.find('.recommended-banner').exists()).toBe(true)
    expect(wrapper.find('.recommended-banner').text()).toContain('server-01')
  })

  it('emits server-selected event when server clicked', async () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    await wrapper.findAll('.server-card')[0].trigger('click')

    expect(wrapper.emitted('server-selected')).toBeTruthy()
    expect(wrapper.emitted('server-selected')[0][0].id).toBe(1)
  })

  it('displays insufficient capacity warning when no suitable servers', async () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    await wrapper.vm.updateRequirements({
      cpu_cores: 100, // Impossible requirement
      memory_gb: 500,
      disk_gb: 1000
    })

    expect(wrapper.find('.warning-banner').exists()).toBe(true)
    expect(wrapper.text()).toContain('Insufficient Capacity')
  })

  it('toggles forecast chart visibility', async () => {
    const wrapper = mount(CapacityPlanner, {
      props: {
        organizationId: 1,
        servers: mockServers,
        initialScores: mockServers
      }
    })

    expect(wrapper.find('.capacity-forecast-chart').exists()).toBe(false)

    await wrapper.find('button:contains("Show Forecast")').trigger('click')

    expect(wrapper.find('.capacity-forecast-chart').exists()).toBe(true)
  })
})
```

### Composable Tests

**File:** `resources/js/Composables/__tests__/useCapacityPlanner.spec.js`

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useCapacityPlanner } from '../useCapacityPlanner'
import axios from 'axios'

vi.mock('axios')

describe('useCapacityPlanner', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('refreshes server scores from API', async () => {
    const mockResponse = {
      data: {
        servers: [{ id: 1, name: 'server-01', overall_score: 85 }]
      }
    }

    axios.post.mockResolvedValue(mockResponse)

    const { serverScores, refreshScores } = useCapacityPlanner(1, [])

    await refreshScores({ cpu_cores: 2, memory_gb: 4, disk_gb: 20 })

    expect(serverScores.value).toEqual(mockResponse.data.servers)
  })

  it('calculates suitability correctly for perfect fit', () => {
    const { calculateSuitability } = useCapacityPlanner(1, [])

    const server = {
      available_cpu_cores: 8,
      available_memory_gb: 32,
      available_disk_gb: 500,
      available_cpu_percent: 90,
      available_memory_percent: 90,
      available_disk_percent: 90,
      total_cpu_cores: 8,
      total_memory_gb: 32,
      total_disk_gb: 500
    }

    const requirements = {
      cpu_cores: 2,
      memory_gb: 4,
      disk_gb: 20
    }

    const result = calculateSuitability(server, requirements)

    expect(result.status).toBe('perfect')
    expect(result.label).toBe('Perfect Fit')
  })

  it('calculates suitability correctly for insufficient capacity', () => {
    const { calculateSuitability } = useCapacityPlanner(1, [])

    const server = {
      available_cpu_cores: 1,
      available_memory_gb: 2,
      available_disk_gb: 10,
      available_cpu_percent: 10,
      available_memory_percent: 10,
      available_disk_percent: 10,
      total_cpu_cores: 8,
      total_memory_gb: 32,
      total_disk_gb: 500
    }

    const requirements = {
      cpu_cores: 4,
      memory_gb: 16,
      disk_gb: 100
    }

    const result = calculateSuitability(server, requirements)

    expect(result.status).toBe('insufficient')
    expect(result.label).toBe('Insufficient')
  })

  it('identifies recommended server correctly', () => {
    const servers = [
      { id: 1, overall_score: 60 },
      { id: 2, overall_score: 85 },
      { id: 3, overall_score: 70 }
    ]

    const { recommendedServer } = useCapacityPlanner(1, servers)

    expect(recommendedServer.value.id).toBe(2)
    expect(recommendedServer.value.overall_score).toBe(85)
  })
})
```

### Integration Tests (Pest)

**File:** `tests/Feature/Enterprise/CapacityPlannerTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\Server;
use App\Models\User;

it('displays capacity planning page', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Server::factory(3)->create(['organization_id' => $organization->id]);

    $this->actingAs($user)
        ->get(route('enterprise.capacity.index', $organization))
        ->assertSuccessful()
        ->assertInertia(fn ($page) => $page
            ->component('Enterprise/CapacityPlanning')
            ->has('servers', 3)
            ->has('initialScores')
        );
});

it('calculates server capacity scores', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Server::factory(2)->create(['organization_id' => $organization->id]);

    $this->actingAs($user)
        ->postJson("/api/enterprise/organizations/{$organization->id}/capacity/scores", [
            'cpu_cores' => 2,
            'memory_gb' => 4,
            'disk_gb' => 20,
        ])
        ->assertSuccessful()
        ->assertJsonStructure([
            'servers' => [
                '*' => [
                    'id',
                    'name',
                    'overall_score',
                    'available_cpu_percent',
                    'available_memory_percent',
                    'available_disk_percent',
                ]
            ],
            'recommended'
        ]);
});

it('returns capacity forecast', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $this->actingAs($user)
        ->getJson("/api/enterprise/organizations/{$organization->id}/capacity/forecast?days=30")
        ->assertSuccessful()
        ->assertJsonStructure([
            'forecast',
            'days'
        ]);
});

it('selects optimal server for deployment', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Server::factory()->create([
        'organization_id' => $organization->id,
        'total_cpu_cores' => 8,
        'total_memory_gb' => 32,
        'total_disk_gb' => 500,
    ]);

    $this->actingAs($user)
        ->postJson("/api/enterprise/organizations/{$organization->id}/capacity/select-optimal", [
            'cpu_cores' => 2,
            'memory_gb' => 4,
            'disk_gb' => 20,
        ])
        ->assertSuccessful()
        ->assertJsonStructure([
            'server',
            'score'
        ]);
});

it('returns 404 when no servers have sufficient capacity', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Server::factory()->create([
        'organization_id' => $organization->id,
        'total_cpu_cores' => 2,
        'total_memory_gb' => 4,
        'total_disk_gb' => 20,
    ]);

    $this->actingAs($user)
        ->postJson("/api/enterprise/organizations/{$organization->id}/capacity/select-optimal", [
            'cpu_cores' => 16, // Impossible requirement
            'memory_gb' => 64,
            'disk_gb' => 1000,
        ])
        ->assertNotFound()
        ->assertJson([
            'server' => null,
            'message' => 'No servers have sufficient capacity for these requirements'
        ]);
});
```

### Browser Tests (Dusk)

**File:** `tests/Browser/Enterprise/CapacityPlannerTest.php`

```php
<?php

use Laravel\Dusk\Browser;

it('allows selecting server from capacity planner', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/enterprise/organizations/1/capacity')
            ->waitForText('Server Capacity Planning')
            ->assertSee('server-01')
            ->click('.server-card:first-child')
            ->assertSee('Selected')
            ->waitForText('Recommended: server-01')
            ->click('button:contains("Use This Server")')
            ->assertRouteIs('enterprise.deployment.configure');
    });
});

it('filters servers by capacity threshold', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/enterprise/organizations/1/capacity')
            ->waitForText('Server Capacity Planning')
            ->assertSee('server-01')
            ->assertSee('server-02')
            ->drag('#threshold', 80, 0) // Increase threshold to 80
            ->waitUntilMissing('.server-card:contains("server-02")')
            ->assertSee('server-01')
            ->assertDontSee('server-02');
    });
});

it('displays real-time capacity updates', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/enterprise/organizations/1/capacity')
            ->waitForText('Live Updates')
            ->assertSee('Connected')
            ->pause(5000) // Wait for WebSocket update
            ->assertSeeIn('.server-card:first-child .metric-value', '%'); // Updated metric
    });
});
```

## Definition of Done

- [ ] CapacityPlanner.vue main component created with Composition API
- [ ] ServerCapacityCard.vue child component created
- [ ] CapacityForecastChart.vue child component created
- [ ] DeploymentRequirements.vue child component created
- [ ] useCapacityPlanner composable implemented
- [ ] useServerWebSocket composable implemented for real-time updates
- [ ] CapacityController created with index, scores, forecast, selectOptimal methods
- [ ] API routes registered for capacity endpoints
- [ ] Inertia route registered for capacity planning page
- [ ] Server capacity scores displayed with weighted breakdown
- [ ] Color-coded indicators implemented (green/yellow/red)
- [ ] Deployment suitability calculator working correctly
- [ ] Server selection functionality implemented
- [ ] Recommended server highlighting working
- [ ] Capacity forecasting chart displaying correctly
- [ ] Real-time WebSocket updates functioning
- [ ] Filter by minimum capacity threshold working
- [ ] Sort by score/CPU/memory/disk implemented
- [ ] Responsive design working on all screen sizes
- [ ] Dark mode support fully implemented
- [ ] Loading states and error handling working
- [ ] Accessibility compliance verified (ARIA, keyboard navigation)
- [ ] Unit tests written for components (10+ tests, >90% coverage)
- [ ] Unit tests written for composables (8+ tests)
- [ ] Integration tests written for API endpoints (5+ tests)
- [ ] Browser tests written for user interactions (3+ tests)
- [ ] Code follows Vue.js 3 and Coolify best practices
- [ ] Laravel Pint formatting applied to PHP code
- [ ] PHPStan level 5 passing
- [ ] Documentation updated with component props and usage
- [ ] Code reviewed and approved
- [ ] Manual testing completed with various deployment scenarios
- [ ] Performance verified (component renders in <100ms, API responses <200ms)

## Related Tasks

- **Depends on:** Task 26 (CapacityManager service provides scoring logic)
- **Integrates with:** Task 25 (SystemResourceMonitor provides real-time metrics)
- **Integrates with:** Task 24 (ResourceMonitoringJob collects metrics)
- **Integrates with:** Task 29 (ResourceDashboard.vue shares visualization patterns)
- **Used by:** Task 39 (DeploymentManager.vue uses CapacityPlanner for server selection)
- **Used by:** Task 37 (Automatic infrastructure provisioning triggered on insufficient capacity)
