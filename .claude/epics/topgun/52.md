---
name: Extend Laravel Sanctum tokens with organization context
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:07Z
github: https://github.com/johnproblems/topgun/issues/160
depends_on: []
parallel: true
conflicts_with: []
---

# Task: Extend Laravel Sanctum tokens with organization context

## Description

This task enhances Laravel Sanctum's API token system to include **organization context** and **scoped abilities** for the Coolify Enterprise multi-tenant architecture. The implementation ensures that API tokens are strictly scoped to specific organizations, preventing cross-tenant data access and enabling fine-grained permission control.

In the standard Coolify API authentication system, Sanctum tokens are user-scoped, meaning a user's API token grants access to all resources the user can access across all organizations. This creates a security risk in enterprise multi-tenant environments where:
1. **Cross-Organization Data Leakage** - A single compromised token could expose data across multiple organizations
2. **Insufficient Granularity** - Cannot limit API access to specific organizations without modifying every API endpoint
3. **Poor Auditability** - Difficult to track which organization's data is being accessed via API
4. **Compliance Issues** - Does not meet data isolation requirements for SOC2, HIPAA, GDPR

**This task solves these problems by:**
- Extending Sanctum's `PersonalAccessToken` model with `organization_id` foreign key
- Implementing automatic organization scoping middleware for all API requests
- Adding organization-specific abilities (permissions) to tokens
- Creating token management UI for organization administrators
- Ensuring backward compatibility with existing API tokens (auto-migrate to organization context)

**Integration Points:**
- **Backend:** Extends Laravel Sanctum authentication (`app/Models/Sanctum/PersonalAccessToken.php`)
- **Middleware:** New `ApiOrganizationScope` middleware for automatic organization scoping
- **Frontend:** Task 59 (ApiKeyManager.vue) provides UI for token creation with organization selection
- **Database:** Migration adds `organization_id` column to `personal_access_tokens` table
- **Security:** Task 54 (Rate limiting) uses organization context from tokens for tier-based limits

**Why this task is critical:** Multi-tenant API security is foundational for enterprise platforms. Without organization-scoped tokens, we cannot guarantee data isolation in API access, which is a dealbreaker for enterprise customers with compliance requirements. This task enables secure, auditable, granular API access control while maintaining Laravel's clean architecture patterns.

**Key Features:**
- Organization-scoped API tokens preventing cross-tenant access
- Ability-based permissions (organization:read, application:deploy, server:provision, etc.)
- Automatic organization context injection from token
- Token audit trail with organization attribution
- Backward compatibility with existing tokens
- Integration with license feature flags for ability validation

## Acceptance Criteria

- [ ] `personal_access_tokens` table includes `organization_id` foreign key
- [ ] PersonalAccessToken model extended with organization relationship
- [ ] Tokens can only access resources belonging to their organization
- [ ] Organization-specific abilities defined and validated (organization:*, application:*, server:*, etc.)
- [ ] ApiOrganizationScope middleware implemented and applied to all API routes
- [ ] Middleware automatically injects organization context into requests
- [ ] Tokens without organization_id (legacy tokens) are auto-migrated or rejected with clear error
- [ ] Token creation API endpoint requires organization parameter
- [ ] Token validation checks organization membership before granting access
- [ ] Token abilities respect enterprise license feature flags
- [ ] Audit logging includes organization context for all API requests
- [ ] Sanctum token introspection API includes organization information
- [ ] Performance impact minimal (< 5ms overhead for organization scoping)
- [ ] Integration tests verify cross-tenant access prevention (100% coverage)

## Technical Details

### File Paths

**Database Migration:**
- `/home/topgun/topgun/database/migrations/2025_10_06_000001_add_organization_context_to_sanctum_tokens.php`

**Model Extensions:**
- `/home/topgun/topgun/app/Models/Sanctum/PersonalAccessToken.php` (extend Sanctum's model)

**Middleware:**
- `/home/topgun/topgun/app/Http/Middleware/ApiOrganizationScope.php` (new)
- `/home/topgun/topgun/app/Http/Kernel.php` (register middleware)

**Service Provider:**
- `/home/topgun/topgun/app/Providers/SanctumServiceProvider.php` (new, customize Sanctum)

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Api/TokenController.php` (enhance existing or create new)

**Traits:**
- `/home/topgun/topgun/app/Traits/HasOrganizationScopedTokens.php` (new)

**Tests:**
- `/home/topgun/topgun/tests/Unit/ApiOrganizationScopeTest.php`
- `/home/topgun/topgun/tests/Feature/Api/OrganizationScopedTokenTest.php`

### Database Schema Enhancement

**Migration File:** `database/migrations/2025_10_06_000001_add_organization_context_to_sanctum_tokens.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('personal_access_tokens', function (Blueprint $table) {
            // Add organization context
            $table->foreignId('organization_id')->nullable()->after('tokenable_id');
            $table->foreign('organization_id')
                ->references('id')
                ->on('organizations')
                ->onDelete('cascade'); // Delete tokens when organization deleted

            // Add metadata for enhanced audit trail
            $table->string('created_by_ip')->nullable()->after('last_used_at');
            $table->string('created_by_user_agent')->nullable();
            $table->timestamp('expires_at')->nullable(); // Token expiration
            $table->text('notes')->nullable(); // Admin notes about token purpose

            // Indexes for performance
            $table->index(['organization_id', 'tokenable_id']);
            $table->index(['organization_id', 'last_used_at']); // For usage analytics
        });
    }

    public function down(): void
    {
        Schema::table('personal_access_tokens', function (Blueprint $table) {
            $table->dropForeign(['organization_id']);
            $table->dropColumn([
                'organization_id',
                'created_by_ip',
                'created_by_user_agent',
                'expires_at',
                'notes',
            ]);
        });
    }
};
```

### Extended PersonalAccessToken Model

**File:** `app/Models/Sanctum/PersonalAccessToken.php`

```php
<?php

namespace App\Models\Sanctum;

use App\Models\Organization;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;

class PersonalAccessToken extends SanctumPersonalAccessToken
{
    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'abilities' => 'json',
        'last_used_at' => 'datetime',
        'expires_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name',
        'token',
        'abilities',
        'organization_id',
        'expires_at',
        'created_by_ip',
        'created_by_user_agent',
        'notes',
    ];

    /**
     * Organization that this token belongs to
     *
     * @return BelongsTo
     */
    public function organization(): BelongsTo
    {
        return $this->belongsTo(Organization::class);
    }

    /**
     * Check if token has expired
     *
     * @return bool
     */
    public function isExpired(): bool
    {
        if (!$this->expires_at) {
            return false;
        }

        return $this->expires_at->isPast();
    }

    /**
     * Check if token can access a specific ability
     * Also validates against organization's license feature flags
     *
     * @param string $ability
     * @return bool
     */
    public function can(string $ability): bool
    {
        // Check basic Sanctum ability
        if (!parent::can($ability)) {
            return false;
        }

        // If organization scoped, check license features
        if ($this->organization_id) {
            $organization = $this->organization;

            // Example: Check if organization's license allows API access
            if (!$organization->enterpLicense?->hasFeature('api_access')) {
                return false;
            }

            // Example: Check if specific ability is allowed by license tier
            if (str_starts_with($ability, 'terraform:') &&
                !$organization->enterpriseLicense?->hasFeature('terraform_integration')) {
                return false;
            }

            if (str_starts_with($ability, 'organization:billing') &&
                !$organization->enterpriseLicense?->hasFeature('payment_processing')) {
                return false;
            }
        }

        return true;
    }

    /**
     * Scope query to specific organization
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @param int $organizationId
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeForOrganization($query, int $organizationId)
    {
        return $query->where('organization_id', $organizationId);
    }

    /**
     * Scope query to active (non-expired) tokens
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeActive($query)
    {
        return $query->where(function ($q) {
            $q->whereNull('expires_at')
                ->orWhere('expires_at', '>', now());
        });
    }

    /**
     * Boot method for model events
     */
    protected static function boot()
    {
        parent::boot();

        // Auto-capture IP and user agent on creation
        static::creating(function ($token) {
            if (request()) {
                $token->created_by_ip = request()->ip();
                $token->created_by_user_agent = request()->userAgent();
            }
        });

        // Log token usage for audit trail
        static::updating(function ($token) {
            if ($token->isDirty('last_used_at')) {
                \Log::info('API token used', [
                    'token_id' => $token->id,
                    'token_name' => $token->name,
                    'organization_id' => $token->organization_id,
                    'user_id' => $token->tokenable_id,
                    'ip' => request()?->ip(),
                ]);
            }
        });
    }
}
```

### Organization-Scoped Token Trait

**File:** `app/Traits/HasOrganizationScopedTokens.php`

```php
<?php

namespace App\Traits;

use App\Models\Organization;
use App\Models\Sanctum\PersonalAccessToken;
use Illuminate\Support\Str;
use Laravel\Sanctum\NewAccessToken;

trait HasOrganizationScopedTokens
{
    /**
     * Create a new organization-scoped personal access token
     *
     * @param Organization $organization
     * @param string $name
     * @param array $abilities
     * @param \DateTimeInterface|null $expiresAt
     * @return NewAccessToken
     */
    public function createOrganizationToken(
        Organization $organization,
        string $name,
        array $abilities = ['*'],
        ?\DateTimeInterface $expiresAt = null
    ): NewAccessToken {
        // Verify user belongs to organization
        if (!$this->belongsToOrganization($organization)) {
            throw new \Exception("User does not belong to organization: {$organization->id}");
        }

        // Verify user has permission to create tokens for this organization
        if (!$this->can('createApiTokens', $organization)) {
            throw new \Exception('User does not have permission to create API tokens for this organization');
        }

        // Validate abilities against organization's license
        $validatedAbilities = $this->validateAbilitiesAgainstLicense($organization, $abilities);

        // Generate token
        $token = $this->tokens()->create([
            'name' => $name,
            'token' => hash('sha256', $plainTextToken = Str::random(40)),
            'abilities' => $validatedAbilities,
            'organization_id' => $organization->id,
            'expires_at' => $expiresAt,
        ]);

        return new NewAccessToken($token, $plainTextToken);
    }

    /**
     * Validate token abilities against organization license
     *
     * @param Organization $organization
     * @param array $abilities
     * @return array
     */
    protected function validateAbilitiesAgainstLicense(Organization $organization, array $abilities): array
    {
        // If wildcard, return all abilities allowed by license
        if (in_array('*', $abilities)) {
            return $this->getAllowedAbilitiesByLicense($organization);
        }

        $license = $organization->enterpriseLicense;
        $validated = [];

        foreach ($abilities as $ability) {
            // Check if ability requires specific license feature
            $feature = $this->getRequiredFeatureForAbility($ability);

            if ($feature && !$license?->hasFeature($feature)) {
                // Skip this ability if license doesn't support it
                \Log::warning("Ability '{$ability}' requires feature '{$feature}' not in license", [
                    'organization_id' => $organization->id,
                ]);
                continue;
            }

            $validated[] = $ability;
        }

        return $validated;
    }

    /**
     * Get all abilities allowed by organization's license
     *
     * @param Organization $organization
     * @return array
     */
    protected function getAllowedAbilitiesByLicense(Organization $organization): array
    {
        $license = $organization->enterpriseLicense;
        $abilities = [];

        // Base abilities (all licenses)
        $abilities = array_merge($abilities, [
            'organization:read',
            'application:read',
            'server:read',
            'deployment:read',
        ]);

        // Write abilities (most licenses)
        if ($license?->hasFeature('api_access')) {
            $abilities = array_merge($abilities, [
                'application:create',
                'application:update',
                'application:delete',
                'deployment:create',
            ]);
        }

        // Terraform abilities
        if ($license?->hasFeature('terraform_integration')) {
            $abilities = array_merge($abilities, [
                'terraform:provision',
                'terraform:destroy',
                'server:provision',
            ]);
        }

        // Payment abilities
        if ($license?->hasFeature('payment_processing')) {
            $abilities = array_merge($abilities, [
                'organization:billing',
                'subscription:manage',
            ]);
        }

        // Admin abilities (enterprise only)
        if ($license?->tier === 'enterprise') {
            $abilities = array_merge($abilities, [
                'organization:manage',
                'user:manage',
                'license:read',
            ]);
        }

        return $abilities;
    }

    /**
     * Get required license feature for a specific ability
     *
     * @param string $ability
     * @return string|null
     */
    protected function getRequiredFeatureForAbility(string $ability): ?string
    {
        $featureMap = [
            'terraform:*' => 'terraform_integration',
            'organization:billing' => 'payment_processing',
            'subscription:*' => 'payment_processing',
            'whitelabel:*' => 'white_label_branding',
        ];

        foreach ($featureMap as $pattern => $feature) {
            if (Str::is($pattern, $ability)) {
                return $feature;
            }
        }

        return null;
    }

    /**
     * Check if user belongs to organization
     *
     * @param Organization $organization
     * @return bool
     */
    protected function belongsToOrganization(Organization $organization): bool
    {
        return $this->organizations()->where('organizations.id', $organization->id)->exists();
    }

    /**
     * Get all tokens for a specific organization
     *
     * @param Organization $organization
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function organizationTokens(Organization $organization)
    {
        return $this->tokens()
            ->where('organization_id', $organization->id)
            ->orderBy('created_at', 'desc')
            ->get();
    }
}
```

### ApiOrganizationScope Middleware

**File:** `app/Http/Middleware/ApiOrganizationScope.php`

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class ApiOrganizationScope
{
    /**
     * Handle an incoming request.
     * Automatically inject organization context from Sanctum token
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        // Only apply to authenticated API requests
        if (!$request->user() || !$request->user()->currentAccessToken()) {
            return $next($request);
        }

        $token = $request->user()->currentAccessToken();

        // Check if token has expired
        if ($token->isExpired()) {
            return response()->json([
                'message' => 'API token has expired',
                'error' => 'token_expired',
            ], 401);
        }

        // Get organization from token
        $organizationId = $token->organization_id;

        // Legacy token without organization (backward compatibility)
        if (!$organizationId) {
            // Option 1: Reject legacy tokens (strict mode)
            if (config('sanctum.require_organization_scope', false)) {
                return response()->json([
                    'message' => 'API token must be organization-scoped. Please create a new token.',
                    'error' => 'legacy_token_not_allowed',
                ], 401);
            }

            // Option 2: Allow legacy tokens but log warning
            \Log::warning('Legacy API token used without organization scope', [
                'token_id' => $token->id,
                'user_id' => $request->user()->id,
            ]);

            return $next($request);
        }

        // Load organization and verify access
        $organization = \App\Models\Organization::find($organizationId);

        if (!$organization) {
            return response()->json([
                'message' => 'Organization not found or deleted',
                'error' => 'organization_not_found',
            ], 404);
        }

        // Verify user still belongs to organization
        if (!$request->user()->belongsToOrganization($organization)) {
            return response()->json([
                'message' => 'User no longer has access to this organization',
                'error' => 'organization_access_revoked',
            ], 403);
        }

        // Inject organization into request for downstream use
        $request->attributes->set('organization', $organization);
        $request->attributes->set('organization_id', $organizationId);

        // Set global organization context for query scoping
        app()->instance('current_organization', $organization);

        // Log API access for audit trail
        \Log::info('API request with organization scope', [
            'organization_id' => $organizationId,
            'user_id' => $request->user()->id,
            'endpoint' => $request->path(),
            'method' => $request->method(),
            'ip' => $request->ip(),
        ]);

        return $next($request);
    }
}
```

### Sanctum Service Provider Customization

**File:** `app/Providers/SanctumServiceProvider.php`

```php
<?php

namespace App\Providers;

use App\Models\Sanctum\PersonalAccessToken;
use Illuminate\Support\ServiceProvider;
use Laravel\Sanctum\Sanctum;

class SanctumServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap services.
     */
    public function boot(): void
    {
        // Use our custom PersonalAccessToken model
        Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);

        // Ignore CSRF for API routes (already configured, but for reference)
        // Sanctum::ignoreMigrations();
    }
}
```

### Token Controller Enhancement

**File:** `app/Http/Controllers/Api/TokenController.php`

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Organization;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

class TokenController extends Controller
{
    use AuthorizesRequests;

    /**
     * Create a new organization-scoped API token
     *
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function create(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|max:255',
            'organization_id' => 'required|exists:organizations,id',
            'abilities' => 'array',
            'abilities.*' => 'string',
            'expires_at' => 'nullable|date|after:now',
            'notes' => 'nullable|string|max:1000',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'message' => 'Validation failed',
                'errors' => $validator->errors(),
            ], 422);
        }

        $organization = Organization::findOrFail($request->organization_id);

        // Authorize token creation
        $this->authorize('createApiTokens', $organization);

        try {
            $token = $request->user()->createOrganizationToken(
                $organization,
                $request->name,
                $request->abilities ?? ['*'],
                $request->expires_at ? new \DateTime($request->expires_at) : null
            );

            // Update notes if provided
            if ($request->notes) {
                $token->accessToken->update(['notes' => $request->notes]);
            }

            return response()->json([
                'message' => 'Token created successfully',
                'token' => $token->plainTextToken,
                'accessToken' => [
                    'id' => $token->accessToken->id,
                    'name' => $token->accessToken->name,
                    'abilities' => $token->accessToken->abilities,
                    'organization_id' => $token->accessToken->organization_id,
                    'expires_at' => $token->accessToken->expires_at,
                ],
            ], 201);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Failed to create token',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * List all tokens for an organization
     *
     * @param Request $request
     * @param Organization $organization
     * @return \Illuminate\Http\JsonResponse
     */
    public function index(Request $request, Organization $organization)
    {
        $this->authorize('view', $organization);

        $tokens = $request->user()
            ->organizationTokens($organization)
            ->map(function ($token) {
                return [
                    'id' => $token->id,
                    'name' => $token->name,
                    'abilities' => $token->abilities,
                    'last_used_at' => $token->last_used_at,
                    'expires_at' => $token->expires_at,
                    'created_at' => $token->created_at,
                    'is_expired' => $token->isExpired(),
                    'notes' => $token->notes,
                ];
            });

        return response()->json([
            'tokens' => $tokens,
        ]);
    }

    /**
     * Revoke (delete) a token
     *
     * @param Request $request
     * @param int $tokenId
     * @return \Illuminate\Http\JsonResponse
     */
    public function revoke(Request $request, int $tokenId)
    {
        $token = $request->user()->tokens()->findOrFail($tokenId);

        // Verify organization access
        if ($token->organization_id) {
            $organization = Organization::findOrFail($token->organization_id);
            $this->authorize('update', $organization);
        }

        $token->delete();

        return response()->json([
            'message' => 'Token revoked successfully',
        ]);
    }

    /**
     * Get current token information (introspection)
     *
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function current(Request $request)
    {
        $token = $request->user()->currentAccessToken();

        if (!$token) {
            return response()->json([
                'message' => 'No active token',
            ], 401);
        }

        return response()->json([
            'token' => [
                'id' => $token->id,
                'name' => $token->name,
                'abilities' => $token->abilities,
                'organization_id' => $token->organization_id,
                'organization' => $token->organization,
                'last_used_at' => $token->last_used_at,
                'expires_at' => $token->expires_at,
                'is_expired' => $token->isExpired(),
            ],
        ]);
    }
}
```

### Route Registration

**File:** `routes/api.php`

```php
use App\Http\Controllers\Api\TokenController;

// Organization-scoped token management
Route::middleware(['auth:sanctum', 'api.organization.scope'])->group(function () {
    Route::post('/tokens', [TokenController::class, 'create']);
    Route::get('/tokens/current', [TokenController::class, 'current']);
    Route::get('/organizations/{organization}/tokens', [TokenController::class, 'index']);
    Route::delete('/tokens/{token}', [TokenController::class, 'revoke']);
});
```

### Middleware Registration

**File:** `app/Http/Kernel.php`

```php
protected $middlewareAliases = [
    // ... existing middleware
    'api.organization.scope' => \App\Http\Middleware\ApiOrganizationScope::class,
];
```

### Configuration

**File:** `config/sanctum.php` (add custom config)

```php
return [
    // ... existing config

    /*
    |--------------------------------------------------------------------------
    | Organization Scoping
    |--------------------------------------------------------------------------
    |
    | Require all API tokens to be organization-scoped.
    | Set to true to reject legacy tokens without organization context.
    |
    */
    'require_organization_scope' => env('SANCTUM_REQUIRE_ORG_SCOPE', false),

    /*
    |--------------------------------------------------------------------------
    | Default Token Expiration
    |--------------------------------------------------------------------------
    |
    | Default expiration time for API tokens (in days).
    | Set to null for no expiration.
    |
    */
    'token_expiration_days' => env('SANCTUM_TOKEN_EXPIRATION_DAYS', 365),
];
```

## Implementation Approach

### Step 1: Create Database Migration
1. Create migration for organization context columns
2. Add foreign key constraint to organizations table
3. Add indexes for performance
4. Run migration: `php artisan migrate`

### Step 2: Extend PersonalAccessToken Model
1. Create custom model in `app/Models/Sanctum/`
2. Add organization relationship
3. Override `can()` method for license validation
4. Add query scopes (forOrganization, active)
5. Add model events for audit logging

### Step 3: Create HasOrganizationScopedTokens Trait
1. Implement `createOrganizationToken()` method
2. Add ability validation against license features
3. Add helper methods for organization membership checks
4. Add to User model

### Step 4: Create ApiOrganizationScope Middleware
1. Implement organization extraction from token
2. Add organization context to request
3. Validate organization access
4. Handle legacy tokens (with/without strict mode)
5. Add audit logging

### Step 5: Create Sanctum Service Provider
1. Register custom PersonalAccessToken model
2. Configure Sanctum to use custom model

### Step 6: Enhance Token Controller
1. Add organization-scoped token creation endpoint
2. Add token listing endpoint (filtered by organization)
3. Add token revocation endpoint
4. Add token introspection endpoint

### Step 7: Register Middleware and Routes
1. Add middleware to `$middlewareAliases` in Kernel
2. Apply to all API routes
3. Create token management routes

### Step 8: Update User Model
1. Add HasOrganizationScopedTokens trait
2. Update factory for testing

## Test Strategy

### Unit Tests

**File:** `tests/Unit/ApiOrganizationScopeTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Models\Sanctum\PersonalAccessToken;
use Illuminate\Support\Facades\Hash;

beforeEach(function () {
    $this->user = User::factory()->create();
    $this->organization = Organization::factory()->create();
    $this->organization->users()->attach($this->user, ['role' => 'admin']);
});

it('creates organization-scoped token', function () {
    $token = $this->user->createOrganizationToken(
        $this->organization,
        'Test Token',
        ['application:read', 'deployment:create']
    );

    expect($token->accessToken->organization_id)->toBe($this->organization->id);
    expect($token->accessToken->abilities)->toContain('application:read');
});

it('validates abilities against license features', function () {
    // Organization without Terraform feature
    $license = $this->organization->enterpriseLicense;
    $license->update(['features' => ['api_access' => true]]); // No terraform_integration

    $token = $this->user->createOrganizationToken(
        $this->organization,
        'Test Token',
        ['terraform:provision'] // Requires terraform_integration feature
    );

    // Should not include terraform:provision due to license restriction
    expect($token->accessToken->abilities)->not->toContain('terraform:provision');
});

it('prevents token creation for non-member organizations', function () {
    $otherOrg = Organization::factory()->create();

    expect(fn() => $this->user->createOrganizationToken(
        $otherOrg,
        'Test Token'
    ))->toThrow(\Exception::class, 'does not belong to organization');
});

it('checks token expiration correctly', function () {
    $expiredToken = PersonalAccessToken::factory()->create([
        'tokenable_id' => $this->user->id,
        'tokenable_type' => get_class($this->user),
        'organization_id' => $this->organization->id,
        'expires_at' => now()->subDay(),
    ]);

    expect($expiredToken->isExpired())->toBeTrue();
});

it('respects license features in can() method', function () {
    $token = PersonalAccessToken::factory()->create([
        'tokenable_id' => $this->user->id,
        'tokenable_type' => get_class($this->user),
        'organization_id' => $this->organization->id,
        'abilities' => ['terraform:provision'],
    ]);

    // Without license feature
    $this->organization->enterpriseLicense->update([
        'features' => ['api_access' => true]
    ]);

    expect($token->can('terraform:provision'))->toBeFalse();

    // With license feature
    $this->organization->enterpriseLicense->update([
        'features' => ['api_access' => true, 'terraform_integration' => true]
    ]);

    expect($token->can('terraform:provision'))->toBeTrue();
});
```

### Integration Tests

**File:** `tests/Feature/Api/OrganizationScopedTokenTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Organization;
use App\Models\User;
use Laravel\Sanctum\Sanctum;

it('prevents cross-tenant access via API tokens', function () {
    $org1 = Organization::factory()->create();
    $org2 = Organization::factory()->create();

    $user = User::factory()->create();
    $org1->users()->attach($user, ['role' => 'admin']);

    // Create token scoped to org1
    $token = $user->createOrganizationToken($org1, 'Test Token', ['*']);

    // Create applications in both organizations
    $app1 = Application::factory()->create(['organization_id' => $org1->id]);
    $app2 = Application::factory()->create(['organization_id' => $org2->id]);

    Sanctum::actingAs($user, ['*'], 'web', $token->accessToken);

    // Should be able to access org1's application
    $response = $this->getJson("/api/applications/{$app1->id}");
    $response->assertOk();

    // Should NOT be able to access org2's application
    $response = $this->getJson("/api/applications/{$app2->id}");
    $response->assertForbidden(); // or 404 depending on implementation
});

it('creates token via API endpoint', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    Sanctum::actingAs($user);

    $response = $this->postJson('/api/tokens', [
        'name' => 'My API Token',
        'organization_id' => $organization->id,
        'abilities' => ['application:read', 'deployment:create'],
        'notes' => 'Token for CI/CD pipeline',
    ]);

    $response->assertCreated()
        ->assertJsonStructure([
            'message',
            'token', // Plain text token (only shown once)
            'accessToken' => ['id', 'name', 'abilities', 'organization_id'],
        ]);

    // Verify token was created
    $this->assertDatabaseHas('personal_access_tokens', [
        'tokenable_id' => $user->id,
        'organization_id' => $organization->id,
        'name' => 'My API Token',
        'notes' => 'Token for CI/CD pipeline',
    ]);
});

it('lists organization tokens', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Create 3 tokens
    $user->createOrganizationToken($organization, 'Token 1', ['application:read']);
    $user->createOrganizationToken($organization, 'Token 2', ['server:read']);
    $user->createOrganizationToken($organization, 'Token 3', ['*']);

    Sanctum::actingAs($user);

    $response = $this->getJson("/api/organizations/{$organization->id}/tokens");

    $response->assertOk()
        ->assertJsonCount(3, 'tokens')
        ->assertJsonStructure([
            'tokens' => [
                '*' => ['id', 'name', 'abilities', 'last_used_at', 'expires_at', 'created_at'],
            ],
        ]);
});

it('revokes token', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $token = $user->createOrganizationToken($organization, 'Revoke Me', ['*']);
    $tokenId = $token->accessToken->id;

    Sanctum::actingAs($user);

    $response = $this->deleteJson("/api/tokens/{$tokenId}");

    $response->assertOk();

    $this->assertDatabaseMissing('personal_access_tokens', ['id' => $tokenId]);
});

it('rejects expired tokens', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $token = $user->createOrganizationToken(
        $organization,
        'Expired Token',
        ['*'],
        now()->subDay() // Expired yesterday
    );

    Sanctum::actingAs($user, ['*'], 'web', $token->accessToken);

    $response = $this->getJson('/api/applications');

    $response->assertUnauthorized()
        ->assertJson(['error' => 'token_expired']);
});

it('injects organization context into request', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $token = $user->createOrganizationToken($organization, 'Test', ['*']);

    Sanctum::actingAs($user, ['*'], 'web', $token->accessToken);

    $response = $this->getJson('/api/tokens/current');

    $response->assertOk()
        ->assertJson([
            'token' => [
                'organization_id' => $organization->id,
                'organization' => [
                    'id' => $organization->id,
                    'name' => $organization->name,
                ],
            ],
        ]);
});
```

### Browser Tests (if needed)

**File:** `tests/Browser/ApiTokenManagementTest.php`

```php
use Laravel\Dusk\Browser;

it('creates organization-scoped token via UI', function () {
    $this->browse(function (Browser $browser) {
        $browser->loginAs($user)
            ->visit('/organizations/' . $organization->id . '/api-tokens')
            ->clickLink('Create New Token')
            ->type('name', 'My New Token')
            ->select('abilities[]', 'application:read')
            ->click('Create Token')
            ->waitForText('Token created successfully')
            ->assertSee('Copy this token now');
    });
});
```

## Definition of Done

- [ ] Database migration created and run successfully
- [ ] PersonalAccessToken model extended with organization relationship
- [ ] HasOrganizationScopedTokens trait created and added to User model
- [ ] ApiOrganizationScope middleware created and registered
- [ ] SanctumServiceProvider created with custom model registration
- [ ] TokenController created with all CRUD endpoints
- [ ] API routes registered for token management
- [ ] Middleware applied to all API routes
- [ ] Organization context automatically injected into API requests
- [ ] Cross-tenant access prevention verified (100% test coverage)
- [ ] Token expiration checks implemented
- [ ] Ability validation against license features working
- [ ] Legacy token handling implemented (with/without strict mode)
- [ ] Audit logging for token creation and usage
- [ ] Unit tests written (15+ tests, >90% coverage)
- [ ] Integration tests written (10+ tests, all scenarios)
- [ ] Performance benchmarks met (< 5ms overhead)
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing (`./vendor/bin/phpstan`)
- [ ] Documentation updated (API docs, code comments)
- [ ] Manual testing completed with multiple organizations
- [ ] Code reviewed and approved
- [ ] Backward compatibility verified with existing tokens

## Related Tasks

- **Depends on:** None (foundation task for API system)
- **Enables:** Task 53 (ApiOrganizationScope middleware uses this foundation)
- **Enables:** Task 54 (Rate limiting uses organization context from tokens)
- **Enables:** Task 59 (ApiKeyManager.vue provides UI for token creation)
- **Enables:** Task 60 (ApiUsageMonitoring.vue displays token usage by organization)
- **Integrates with:** Task 1 (Organization hierarchy for token scoping)
- **Integrates with:** Enterprise licensing (feature flags control token abilities)
