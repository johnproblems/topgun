---
name: Integrate automatic infrastructure provisioning if capacity insufficient
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:54Z
github: https://github.com/johnproblems/topgun/issues/147
depends_on: [14, 36]
parallel: false
conflicts_with: []
---

# Task: Integrate automatic infrastructure provisioning if capacity insufficient

## Description

Implement an intelligent auto-scaling system that automatically provisions new cloud infrastructure when existing server capacity is insufficient for incoming deployment requests. This task creates a sophisticated capacity management integration that seamlessly combines the **CapacityManager** service (Task 36) with the **TerraformService** (Task 14) to ensure deployments never fail due to insufficient resources.

**The Capacity Challenge:**

In production environments, deployment failures due to insufficient server capacity are frustrating for users and create operational overhead:

1. **User initiates deployment** → CapacityManager validates server resources
2. **No suitable server found** → Deployment fails with "Insufficient capacity" error
3. **User must manually** → Provision new infrastructure via Terraform UI
4. **User must wait** → 5-10 minutes for server provisioning
5. **User must retry** → Re-initiate the same deployment
6. **Finally deploys** → After 15+ minutes of manual intervention

This task eliminates this friction by automating steps 3-5, transforming capacity failures into automatic provisioning triggers.

**The Solution:**

When CapacityManager determines no existing server can handle a deployment, the system automatically:

1. **Detects Insufficient Capacity**: CapacityManager returns null from `selectOptimalServer()`
2. **Triggers Auto-Provisioning**: Determines optimal server specifications based on deployment requirements
3. **Provisions Infrastructure**: Uses TerraformService to provision cloud infrastructure via pre-configured templates
4. **Registers New Server**: Automatically registers provisioned server with Coolify
5. **Retries Deployment**: Re-attempts deployment on the newly provisioned server
6. **Notifies User**: Real-time notifications about auto-provisioning progress

**Key Capabilities:**

- **Intelligent Provisioning Decisions**: Analyzes deployment requirements (CPU, RAM, disk) to determine optimal server size
- **Multi-Cloud Support**: Provisions on AWS, DigitalOcean, Hetzner, GCP, or Azure based on organization preferences
- **Cost Optimization**: Selects cheapest cloud provider that meets requirements
- **Organization Quotas**: Respects license-based server count limits before auto-provisioning
- **Graceful Degradation**: Falls back to "insufficient capacity" error if provisioning fails or quota exceeded
- **Asynchronous Processing**: Non-blocking queue-based provisioning with progress tracking
- **Audit Logging**: Complete audit trail of auto-provisioning decisions and outcomes

**Integration Architecture:**

This task integrates three critical systems:

1. **CapacityManager (Task 36)**: Capacity validation and server scoring
2. **TerraformService (Task 14)**: Infrastructure provisioning execution
3. **EnhancedDeploymentService (Task 32)**: Deployment orchestration

**Workflow:**

```
User initiates deployment
    ↓
EnhancedDeploymentService::deploy()
    ↓
CapacityManager::selectOptimalServer() → Returns null (insufficient capacity)
    ↓
AutoProvisioningService::provisionServerForDeployment()
    ↓
    ├─→ Check organization quota (max_servers from license)
    ├─→ Calculate required server specs (from deployment requirements)
    ├─→ Select cheapest cloud provider meeting requirements
    ├─→ Dispatch TerraformDeploymentJob (async provisioning)
    ├─→ Wait for server provisioning (with timeout)
    ├─→ Register new server with Coolify
    ├─→ Retry deployment on new server
    └─→ Notify user of success/failure
```

**Why This Task is Critical:**

Auto-provisioning transforms Coolify from a "manual infrastructure management platform" to a "self-healing elastic platform." Users no longer need to think about capacity planning—they simply deploy, and the system ensures resources are available. This is especially powerful for:

- **Bursty Traffic**: Automatically scale during traffic spikes
- **Multi-Tenant SaaS**: Each organization gets infinite elasticity within license quotas
- **Rapid Iteration**: Developers deploy continuously without capacity concerns
- **Cost Efficiency**: Provision only when needed, avoiding over-provisioning

The system respects organizational boundaries and license limits, ensuring enterprise control while providing cloud-native elasticity. This task completes the vision of intelligent, automated infrastructure management that adapts to application demands in real-time.

## Acceptance Criteria

- [ ] AutoProvisioningService implements capacity-aware provisioning logic
- [ ] Service checks organization license quota before provisioning (max_servers)
- [ ] Service calculates required server specifications from deployment requirements
- [ ] Service selects optimal cloud provider based on cost and availability
- [ ] Service integrates with TerraformService for infrastructure provisioning
- [ ] Service implements async provisioning with job queuing
- [ ] Service handles provisioning timeouts (max 10 minutes wait)
- [ ] Service automatically registers newly provisioned servers
- [ ] Service retries deployment on newly provisioned server
- [ ] EnhancedDeploymentService enhanced to call AutoProvisioningService
- [ ] CapacityManager integration: triggers auto-provisioning when selectOptimalServer() returns null
- [ ] Organization quota enforcement prevents unlimited auto-provisioning
- [ ] Real-time WebSocket notifications for provisioning progress
- [ ] Comprehensive error handling for provisioning failures
- [ ] Audit logging for all auto-provisioning decisions
- [ ] Fallback to manual provisioning if auto-provisioning fails
- [ ] Cost estimation shown before auto-provisioning
- [ ] User confirmation required for auto-provisioning (unless auto-approve enabled)

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/AutoProvisioningService.php` (new)
- `/home/topgun/topgun/app/Contracts/AutoProvisioningServiceInterface.php` (new)

**Enhanced Services:**
- `/home/topgun/topgun/app/Services/Enterprise/EnhancedDeploymentService.php` (modify)
- `/home/topgun/topgun/app/Services/Enterprise/CapacityManager.php` (modify - add hooks)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/AutoProvisionServerJob.php` (new)

**Events:**
- `/home/topgun/topgun/app/Events/Enterprise/AutoProvisioningTriggered.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/ServerAutoProvisioned.php` (new)

**Listeners:**
- `/home/topgun/topgun/app/Listeners/Enterprise/NotifyUserOfAutoProvisioning.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Enterprise/AutoProvisioningLog.php` (new)

**Database:**
- `/home/topgun/topgun/database/migrations/YYYY_MM_DD_create_auto_provisioning_logs_table.php` (new)

### Database Schema

**Auto-Provisioning Audit Log:**

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('auto_provisioning_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->cascadeOnDelete();
            $table->foreignId('application_id')->nullable()->constrained()->nullOnDelete();
            $table->foreignId('deployment_id')->nullable()->constrained()->nullOnDelete();
            $table->foreignId('terraform_deployment_id')->nullable()->constrained('terraform_deployments')->nullOnDelete();
            $table->foreignId('server_id')->nullable()->constrained()->nullOnDelete();

            $table->string('trigger_reason'); // 'insufficient_capacity', 'no_servers_available', 'load_balancing'
            $table->string('status'); // 'pending', 'provisioning', 'succeeded', 'failed', 'quota_exceeded', 'user_cancelled'

            // Provisioning decision metadata
            $table->json('required_specs'); // CPU, RAM, disk requirements
            $table->json('selected_provider'); // Cloud provider and region selected
            $table->decimal('estimated_cost', 10, 2)->nullable(); // Estimated monthly cost
            $table->boolean('user_approved')->default(false);

            // Provisioning outcome
            $table->timestamp('provisioning_started_at')->nullable();
            $table->timestamp('provisioning_completed_at')->nullable();
            $table->integer('provisioning_duration_seconds')->nullable();
            $table->text('failure_reason')->nullable();

            $table->timestamps();

            $table->index(['organization_id', 'status']);
            $table->index(['application_id', 'created_at']);
            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('auto_provisioning_logs');
    }
};
```

### AutoProvisioningService Implementation

**File:** `app/Services/Enterprise/AutoProvisioningService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\AutoProvisioningServiceInterface;
use App\Contracts\TerraformServiceInterface;
use App\Contracts\CapacityManagerInterface;
use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use App\Models\TerraformDeployment;
use App\Models\Enterprise\AutoProvisioningLog;
use App\Jobs\Enterprise\AutoProvisionServerJob;
use App\Events\Enterprise\AutoProvisioningTriggered;
use App\Events\Enterprise\ServerAutoProvisioned;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class AutoProvisioningService implements AutoProvisioningServiceInterface
{
    private const PROVISIONING_TIMEOUT_MINUTES = 10;
    private const MIN_SERVER_SPECS = [
        'cpu_cores' => 1,
        'memory_gb' => 1,
        'disk_gb' => 20,
    ];

    public function __construct(
        private TerraformServiceInterface $terraformService,
        private CapacityManagerInterface $capacityManager,
        private WhiteLabelService $whiteLabelService
    ) {}

    /**
     * Attempt to auto-provision server for deployment
     *
     * @param Application $application
     * @param array $deploymentRequirements
     * @return Server|null Returns provisioned server or null if provisioning fails/not allowed
     * @throws \Exception
     */
    public function provisionServerForDeployment(
        Application $application,
        array $deploymentRequirements
    ): ?Server {
        $organization = $application->organization;

        // Step 1: Check if auto-provisioning is enabled for organization
        if (!$this->isAutoProvisioningEnabled($organization)) {
            Log::info('Auto-provisioning disabled for organization', [
                'organization_id' => $organization->id,
                'application_id' => $application->id,
            ]);
            return null;
        }

        // Step 2: Validate organization quota
        if (!$this->hasAvailableQuota($organization)) {
            Log::warning('Auto-provisioning quota exceeded', [
                'organization_id' => $organization->id,
                'current_servers' => $organization->servers()->count(),
                'max_servers' => $organization->license?->max_servers,
            ]);

            $this->createProvisioningLog($organization, $application, 'quota_exceeded', $deploymentRequirements);
            return null;
        }

        // Step 3: Calculate required server specifications
        $requiredSpecs = $this->calculateRequiredSpecs($deploymentRequirements);

        // Step 4: Select optimal cloud provider
        $selectedProvider = $this->selectCloudProvider($organization, $requiredSpecs);

        if (!$selectedProvider) {
            Log::error('No cloud provider available for auto-provisioning', [
                'organization_id' => $organization->id,
                'required_specs' => $requiredSpecs,
            ]);
            return null;
        }

        // Step 5: Create provisioning log
        $provisioningLog = $this->createProvisioningLog(
            $organization,
            $application,
            'pending',
            $deploymentRequirements,
            $selectedProvider
        );

        // Step 6: Check if user approval required
        if ($this->requiresUserApproval($organization)) {
            event(new AutoProvisioningTriggered($organization, $application, $provisioningLog));

            Log::info('Auto-provisioning requires user approval', [
                'provisioning_log_id' => $provisioningLog->id,
            ]);

            // Wait for user approval (handled via separate approval endpoint)
            return null;
        }

        // Step 7: Trigger async provisioning job
        try {
            $server = $this->executeProvisioning($provisioningLog, $selectedProvider, $requiredSpecs);

            if ($server) {
                $provisioningLog->update([
                    'status' => 'succeeded',
                    'server_id' => $server->id,
                    'provisioning_completed_at' => now(),
                    'provisioning_duration_seconds' => now()->diffInSeconds($provisioningLog->provisioning_started_at),
                ]);

                event(new ServerAutoProvisioned($organization, $server, $application));

                Log::info('Auto-provisioning succeeded', [
                    'server_id' => $server->id,
                    'provisioning_log_id' => $provisioningLog->id,
                ]);

                return $server;
            }
        } catch (\Exception $e) {
            $provisioningLog->update([
                'status' => 'failed',
                'failure_reason' => $e->getMessage(),
            ]);

            Log::error('Auto-provisioning failed', [
                'error' => $e->getMessage(),
                'provisioning_log_id' => $provisioningLog->id,
            ]);

            throw $e;
        }

        return null;
    }

    /**
     * Execute synchronous provisioning (for approved requests)
     *
     * @param AutoProvisioningLog $log
     * @param array $provider
     * @param array $specs
     * @return Server|null
     */
    private function executeProvisioning(
        AutoProvisioningLog $log,
        array $provider,
        array $specs
    ): ?Server {
        $log->update([
            'status' => 'provisioning',
            'provisioning_started_at' => now(),
        ]);

        // Prepare Terraform configuration
        $terraformConfig = $this->buildTerraformConfig($provider, $specs, $log->organization);

        // Execute Terraform provisioning
        $terraformDeployment = $this->terraformService->provisionInfrastructure(
            $provider['provider'],
            $provider['region'],
            $terraformConfig
        );

        $log->update(['terraform_deployment_id' => $terraformDeployment->id]);

        // Wait for provisioning to complete (with timeout)
        $server = $this->waitForProvisioning($terraformDeployment, self::PROVISIONING_TIMEOUT_MINUTES);

        if (!$server) {
            throw new \Exception('Provisioning timed out after ' . self::PROVISIONING_TIMEOUT_MINUTES . ' minutes');
        }

        return $server;
    }

    /**
     * Check if auto-provisioning is enabled for organization
     *
     * @param Organization $organization
     * @return bool
     */
    private function isAutoProvisioningEnabled(Organization $organization): bool
    {
        $license = $organization->license;

        if (!$license) {
            return false;
        }

        // Check if license has auto_provisioning feature flag
        $features = $license->features ?? [];
        return $features['auto_provisioning'] ?? false;
    }

    /**
     * Check if organization has available server quota
     *
     * @param Organization $organization
     * @return bool
     */
    private function hasAvailableQuota(Organization $organization): bool
    {
        $license = $organization->license;

        if (!$license || !$license->max_servers) {
            return false; // No limit defined = no auto-provisioning
        }

        $currentServers = $organization->servers()->count();

        return $currentServers < $license->max_servers;
    }

    /**
     * Calculate required server specifications from deployment requirements
     *
     * @param array $requirements
     * @return array
     */
    private function calculateRequiredSpecs(array $requirements): array
    {
        $cpuCores = max($requirements['cpu_cores'] ?? 1, self::MIN_SERVER_SPECS['cpu_cores']);
        $memoryGb = max($requirements['memory_gb'] ?? 1, self::MIN_SERVER_SPECS['memory_gb']);
        $diskGb = max($requirements['disk_gb'] ?? 20, self::MIN_SERVER_SPECS['disk_gb']);

        // Add 20% buffer to requirements
        $bufferMultiplier = 1.2;

        return [
            'cpu_cores' => (int) ceil($cpuCores * $bufferMultiplier),
            'memory_gb' => (int) ceil($memoryGb * $bufferMultiplier),
            'disk_gb' => (int) ceil($diskGb * $bufferMultiplier),
        ];
    }

    /**
     * Select optimal cloud provider based on cost and availability
     *
     * @param Organization $organization
     * @param array $requiredSpecs
     * @return array|null ['provider' => 'aws', 'region' => 'us-east-1', 'instance_type' => 't3.small', 'estimated_cost' => 15.00]
     */
    private function selectCloudProvider(Organization $organization, array $requiredSpecs): ?array
    {
        // Get organization's configured cloud provider credentials
        $credentials = $organization->cloudProviderCredentials()
            ->where('is_active', true)
            ->get();

        if ($credentials->isEmpty()) {
            Log::warning('No cloud provider credentials configured', [
                'organization_id' => $organization->id,
            ]);
            return null;
        }

        $options = [];

        foreach ($credentials as $credential) {
            $instanceType = $this->findMatchingInstanceType($credential->provider, $requiredSpecs);

            if (!$instanceType) {
                continue;
            }

            $options[] = [
                'provider' => $credential->provider,
                'region' => $credential->default_region ?? $this->getDefaultRegion($credential->provider),
                'instance_type' => $instanceType['type'],
                'estimated_cost' => $instanceType['monthly_cost'],
                'credential_id' => $credential->id,
            ];
        }

        if (empty($options)) {
            return null;
        }

        // Sort by cost (cheapest first)
        usort($options, fn($a, $b) => $a['estimated_cost'] <=> $b['estimated_cost']);

        return $options[0]; // Return cheapest option
    }

    /**
     * Find matching instance type for provider based on requirements
     *
     * @param string $provider
     * @param array $requiredSpecs
     * @return array|null ['type' => 't3.small', 'monthly_cost' => 15.00]
     */
    private function findMatchingInstanceType(string $provider, array $requiredSpecs): ?array
    {
        // Instance type mapping (simplified - production would query pricing API)
        $instanceTypes = [
            'aws' => [
                ['type' => 't3.micro', 'cpu' => 2, 'memory' => 1, 'cost' => 7.50],
                ['type' => 't3.small', 'cpu' => 2, 'memory' => 2, 'cost' => 15.00],
                ['type' => 't3.medium', 'cpu' => 2, 'memory' => 4, 'cost' => 30.00],
                ['type' => 't3.large', 'cpu' => 2, 'memory' => 8, 'cost' => 60.00],
                ['type' => 't3.xlarge', 'cpu' => 4, 'memory' => 16, 'cost' => 120.00],
            ],
            'digitalocean' => [
                ['type' => 's-1vcpu-1gb', 'cpu' => 1, 'memory' => 1, 'cost' => 6.00],
                ['type' => 's-1vcpu-2gb', 'cpu' => 1, 'memory' => 2, 'cost' => 12.00],
                ['type' => 's-2vcpu-2gb', 'cpu' => 2, 'memory' => 2, 'cost' => 18.00],
                ['type' => 's-2vcpu-4gb', 'cpu' => 2, 'memory' => 4, 'cost' => 24.00],
            ],
            'hetzner' => [
                ['type' => 'cx11', 'cpu' => 1, 'memory' => 2, 'cost' => 3.50],
                ['type' => 'cx21', 'cpu' => 2, 'memory' => 4, 'cost' => 6.00],
                ['type' => 'cx31', 'cpu' => 2, 'memory' => 8, 'cost' => 11.00],
                ['type' => 'cx41', 'cpu' => 4, 'memory' => 16, 'cost' => 20.00],
            ],
        ];

        $providerTypes = $instanceTypes[$provider] ?? [];

        foreach ($providerTypes as $type) {
            if ($type['cpu'] >= $requiredSpecs['cpu_cores'] && $type['memory'] >= $requiredSpecs['memory_gb']) {
                return [
                    'type' => $type['type'],
                    'monthly_cost' => $type['cost'],
                ];
            }
        }

        return null;
    }

    /**
     * Build Terraform configuration for provisioning
     *
     * @param array $provider
     * @param array $specs
     * @param Organization $organization
     * @return array
     */
    private function buildTerraformConfig(array $provider, array $specs, Organization $organization): array
    {
        $credential = $organization->cloudProviderCredentials()->find($provider['credential_id']);

        return [
            'instance_type' => $provider['instance_type'],
            'region' => $provider['region'],
            'disk_size' => $specs['disk_gb'],
            'name' => "auto-{$organization->slug}-" . time(),
            'tags' => [
                'auto_provisioned' => 'true',
                'organization_id' => $organization->id,
                'managed_by' => 'coolify_enterprise',
            ],
            'credentials' => $credential->decrypted_credentials,
        ];
    }

    /**
     * Wait for Terraform provisioning to complete
     *
     * @param TerraformDeployment $deployment
     * @param int $timeoutMinutes
     * @return Server|null
     */
    private function waitForProvisioning(TerraformDeployment $deployment, int $timeoutMinutes): ?Server
    {
        $startTime = time();
        $timeout = $timeoutMinutes * 60;

        while (time() - $startTime < $timeout) {
            $deployment->refresh();

            if ($deployment->status === 'completed') {
                return $deployment->server;
            }

            if (in_array($deployment->status, ['failed', 'cancelled'])) {
                return null;
            }

            sleep(5); // Poll every 5 seconds
        }

        return null; // Timeout
    }

    /**
     * Check if user approval is required for auto-provisioning
     *
     * @param Organization $organization
     * @return bool
     */
    private function requiresUserApproval(Organization $organization): bool
    {
        $license = $organization->license;

        if (!$license) {
            return true; // Default to requiring approval
        }

        $features = $license->features ?? [];
        return !($features['auto_approve_provisioning'] ?? false);
    }

    /**
     * Create auto-provisioning audit log
     *
     * @param Organization $organization
     * @param Application $application
     * @param string $status
     * @param array $requirements
     * @param array|null $provider
     * @return AutoProvisioningLog
     */
    private function createProvisioningLog(
        Organization $organization,
        Application $application,
        string $status,
        array $requirements,
        ?array $provider = null
    ): AutoProvisioningLog {
        return AutoProvisioningLog::create([
            'organization_id' => $organization->id,
            'application_id' => $application->id,
            'trigger_reason' => 'insufficient_capacity',
            'status' => $status,
            'required_specs' => $this->calculateRequiredSpecs($requirements),
            'selected_provider' => $provider,
            'estimated_cost' => $provider['estimated_cost'] ?? null,
        ]);
    }

    /**
     * Get default region for cloud provider
     *
     * @param string $provider
     * @return string
     */
    private function getDefaultRegion(string $provider): string
    {
        return match($provider) {
            'aws' => 'us-east-1',
            'digitalocean' => 'nyc1',
            'hetzner' => 'nbg1',
            'gcp' => 'us-central1',
            'azure' => 'eastus',
            default => 'us-east-1',
        };
    }

    /**
     * Approve pending auto-provisioning request
     *
     * @param AutoProvisioningLog $log
     * @return Server|null
     */
    public function approveProvisioning(AutoProvisioningLog $log): ?Server
    {
        if ($log->status !== 'pending') {
            throw new \Exception('Provisioning request is not pending approval');
        }

        $log->update(['user_approved' => true]);

        return $this->executeProvisioning(
            $log,
            $log->selected_provider,
            $log->required_specs
        );
    }
}
```

### Service Interface

**File:** `app/Contracts/AutoProvisioningServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Application;
use App\Models\Server;
use App\Models\Enterprise\AutoProvisioningLog;

interface AutoProvisioningServiceInterface
{
    /**
     * Attempt to auto-provision server for deployment
     *
     * @param Application $application
     * @param array $deploymentRequirements
     * @return Server|null
     */
    public function provisionServerForDeployment(
        Application $application,
        array $deploymentRequirements
    ): ?Server;

    /**
     * Approve pending auto-provisioning request
     *
     * @param AutoProvisioningLog $log
     * @return Server|null
     */
    public function approveProvisioning(AutoProvisioningLog $log): ?Server;
}
```

### EnhancedDeploymentService Integration

**File:** `app/Services/Enterprise/EnhancedDeploymentService.php` (modify existing)

```php
public function deployWithStrategy(Application $application, string $strategy = 'standard'): Deployment
{
    // Existing capacity check
    $deploymentRequirements = $this->calculateDeploymentRequirements($application);
    $server = $this->capacityManager->selectOptimalServer(
        $application->team->servers,
        $deploymentRequirements
    );

    // NEW: Auto-provisioning integration
    if (!$server) {
        Log::info('No suitable server found, attempting auto-provisioning', [
            'application_id' => $application->id,
            'requirements' => $deploymentRequirements,
        ]);

        // Attempt auto-provisioning
        $server = $this->autoProvisioningService->provisionServerForDeployment(
            $application,
            $deploymentRequirements
        );

        if (!$server) {
            throw new InsufficientCapacityException(
                'No servers available with sufficient capacity. Auto-provisioning failed or requires approval.'
            );
        }

        Log::info('Server auto-provisioned successfully', [
            'server_id' => $server->id,
            'application_id' => $application->id,
        ]);
    }

    // Continue with deployment...
    return $this->executeDeployment($application, $server, $strategy);
}
```

### AutoProvisionServerJob (Async Alternative)

**File:** `app/Jobs/Enterprise/AutoProvisionServerJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\Enterprise\AutoProvisioningLog;
use App\Services\Enterprise\AutoProvisioningService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class AutoProvisionServerJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 2;
    public int $timeout = 900; // 15 minutes

    public function __construct(
        public AutoProvisioningLog $provisioningLog
    ) {
        $this->onQueue('infrastructure-provisioning');
    }

    public function handle(AutoProvisioningService $autoProvisioningService): void
    {
        try {
            $server = $autoProvisioningService->approveProvisioning($this->provisioningLog);

            if ($server) {
                Log::info('Auto-provisioning job completed successfully', [
                    'provisioning_log_id' => $this->provisioningLog->id,
                    'server_id' => $server->id,
                ]);
            } else {
                Log::warning('Auto-provisioning job completed but no server created', [
                    'provisioning_log_id' => $this->provisioningLog->id,
                ]);
            }
        } catch (\Exception $e) {
            Log::error('Auto-provisioning job failed', [
                'provisioning_log_id' => $this->provisioningLog->id,
                'error' => $e->getMessage(),
            ]);

            $this->provisioningLog->update([
                'status' => 'failed',
                'failure_reason' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    public function failed(\Throwable $exception): void
    {
        $this->provisioningLog->update([
            'status' => 'failed',
            'failure_reason' => $exception->getMessage(),
        ]);
    }

    public function tags(): array
    {
        return [
            'auto-provisioning',
            "organization:{$this->provisioningLog->organization_id}",
            "log:{$this->provisioningLog->id}",
        ];
    }
}
```

### Events and Listeners

**File:** `app/Events/Enterprise/AutoProvisioningTriggered.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Application;
use App\Models\Organization;
use App\Models\Enterprise\AutoProvisioningLog;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class AutoProvisioningTriggered
{
    use Dispatchable, SerializesModels;

    public function __construct(
        public Organization $organization,
        public Application $application,
        public AutoProvisioningLog $provisioningLog
    ) {}
}
```

**File:** `app/Events/Enterprise/ServerAutoProvisioned.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ServerAutoProvisioned implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public Organization $organization,
        public Server $server,
        public Application $application
    ) {}

    public function broadcastOn(): array
    {
        return [
            new Channel("organization.{$this->organization->id}.provisioning"),
        ];
    }

    public function broadcastAs(): string
    {
        return 'server.auto-provisioned';
    }

    public function broadcastWith(): array
    {
        return [
            'server_id' => $this->server->id,
            'server_name' => $this->server->name,
            'application_id' => $this->application->id,
            'message' => "New server '{$this->server->name}' auto-provisioned for deployment",
        ];
    }
}
```

**File:** `app/Listeners/Enterprise/NotifyUserOfAutoProvisioning.php`

```php
<?php

namespace App\Listeners\Enterprise;

use App\Events\Enterprise\AutoProvisioningTriggered;
use App\Notifications\Enterprise\AutoProvisioningApprovalRequired;
use Illuminate\Contracts\Queue\ShouldQueue;

class NotifyUserOfAutoProvisioning implements ShouldQueue
{
    public function handle(AutoProvisioningTriggered $event): void
    {
        $organization = $event->organization;
        $admins = $organization->users()->wherePivot('role', 'admin')->get();

        foreach ($admins as $admin) {
            $admin->notify(new AutoProvisioningApprovalRequired(
                $event->provisioningLog,
                $event->application
            ));
        }
    }
}
```

### Model

**File:** `app/Models/Enterprise/AutoProvisioningLog.php`

```php
<?php

namespace App\Models\Enterprise;

use App\Models\Application;
use App\Models\Organization;
use App\Models\Server;
use App\Models\TerraformDeployment;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class AutoProvisioningLog extends Model
{
    protected $fillable = [
        'organization_id',
        'application_id',
        'deployment_id',
        'terraform_deployment_id',
        'server_id',
        'trigger_reason',
        'status',
        'required_specs',
        'selected_provider',
        'estimated_cost',
        'user_approved',
        'provisioning_started_at',
        'provisioning_completed_at',
        'provisioning_duration_seconds',
        'failure_reason',
    ];

    protected $casts = [
        'required_specs' => 'array',
        'selected_provider' => 'array',
        'estimated_cost' => 'decimal:2',
        'user_approved' => 'boolean',
        'provisioning_started_at' => 'datetime',
        'provisioning_completed_at' => 'datetime',
    ];

    public function organization(): BelongsTo
    {
        return $this->belongsTo(Organization::class);
    }

    public function application(): BelongsTo
    {
        return $this->belongsTo(Application::class);
    }

    public function server(): BelongsTo
    {
        return $this->belongsTo(Server::class);
    }

    public function terraformDeployment(): BelongsTo
    {
        return $this->belongsTo(TerraformDeployment::class);
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isSucceeded(): bool
    {
        return $this->status === 'succeeded';
    }

    public function isFailed(): bool
    {
        return in_array($this->status, ['failed', 'quota_exceeded']);
    }
}
```

## Implementation Approach

### Step 1: Database Schema
1. Create migration for `auto_provisioning_logs` table
2. Run migration: `php artisan migrate`
3. Create `AutoProvisioningLog` model with relationships

### Step 2: Create AutoProvisioningService
1. Create `AutoProvisioningServiceInterface` in `app/Contracts/`
2. Implement `AutoProvisioningService` in `app/Services/Enterprise/`
3. Add core methods: `provisionServerForDeployment()`, `approveProvisioning()`
4. Implement quota checking logic
5. Implement spec calculation logic
6. Implement cloud provider selection logic

### Step 3: Integrate with EnhancedDeploymentService
1. Modify `EnhancedDeploymentService::deployWithStrategy()`
2. Add auto-provisioning call when `selectOptimalServer()` returns null
3. Add error handling for provisioning failures
4. Add logging for auto-provisioning decisions

### Step 4: Create Events and Listeners
1. Create `AutoProvisioningTriggered` event
2. Create `ServerAutoProvisioned` event (with WebSocket broadcasting)
3. Create `NotifyUserOfAutoProvisioning` listener
4. Register in `EventServiceProvider`

### Step 5: Create Background Job (Optional Async Path)
1. Create `AutoProvisionServerJob` for async provisioning
2. Add timeout and retry configuration
3. Add Horizon tags for monitoring
4. Test job dispatch and execution

### Step 6: Add License Feature Flags
1. Add `auto_provisioning` feature flag to license JSON structure
2. Add `auto_approve_provisioning` feature flag
3. Update license seeder with feature flags
4. Document feature flag usage

### Step 7: Create API Endpoints
1. Add approval endpoint: `POST /api/organizations/{org}/auto-provisioning/{log}/approve`
2. Add cancellation endpoint: `POST /api/organizations/{org}/auto-provisioning/{log}/cancel`
3. Add list endpoint: `GET /api/organizations/{org}/auto-provisioning-logs`
4. Add proper authorization policies

### Step 8: Testing
1. Unit test AutoProvisioningService methods
2. Test quota enforcement logic
3. Test provider selection algorithm
4. Integration test full provisioning workflow
5. Test approval workflow
6. Test error scenarios (quota exceeded, provisioning failure)

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/AutoProvisioningServiceTest.php`

```php
<?php

use App\Services\Enterprise\AutoProvisioningService;
use App\Models\Application;
use App\Models\Organization;
use App\Models\EnterpriseLicense;
use App\Models\CloudProviderCredential;

it('checks if auto-provisioning is enabled', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'features' => ['auto_provisioning' => true],
    ]);

    $service = app(AutoProvisioningService::class);

    expect(invade($service)->isAutoProvisioningEnabled($organization))->toBeTrue();
});

it('respects server quota limits', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'max_servers' => 5,
    ]);

    // Create 5 servers (at quota)
    Server::factory(5)->create(['organization_id' => $organization->id]);

    $service = app(AutoProvisioningService::class);

    expect(invade($service)->hasAvailableQuota($organization))->toBeFalse();
});

it('calculates required specs with buffer', function () {
    $service = app(AutoProvisioningService::class);

    $requirements = [
        'cpu_cores' => 2,
        'memory_gb' => 4,
        'disk_gb' => 50,
    ];

    $specs = invade($service)->calculateRequiredSpecs($requirements);

    // Should add 20% buffer
    expect($specs['cpu_cores'])->toBe(3);  // ceil(2 * 1.2)
    expect($specs['memory_gb'])->toBe(5);  // ceil(4 * 1.2)
    expect($specs['disk_gb'])->toBe(60);   // ceil(50 * 1.2)
});

it('selects cheapest cloud provider', function () {
    $organization = Organization::factory()->create();

    CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'aws',
        'is_active' => true,
    ]);

    CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'hetzner',
        'is_active' => true,
    ]);

    $service = app(AutoProvisioningService::class);

    $requiredSpecs = ['cpu_cores' => 2, 'memory_gb' => 4, 'disk_gb' => 50];
    $selected = invade($service)->selectCloudProvider($organization, $requiredSpecs);

    // Hetzner should be cheaper than AWS for same specs
    expect($selected['provider'])->toBe('hetzner');
});

it('returns null when no providers available', function () {
    $organization = Organization::factory()->create();
    $service = app(AutoProvisioningService::class);

    $requiredSpecs = ['cpu_cores' => 2, 'memory_gb' => 4, 'disk_gb' => 50];
    $selected = invade($service)->selectCloudProvider($organization, $requiredSpecs);

    expect($selected)->toBeNull();
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/AutoProvisioningIntegrationTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Organization;
use App\Models\EnterpriseLicense;
use App\Models\CloudProviderCredential;
use App\Services\Enterprise\AutoProvisioningService;
use App\Services\Enterprise\EnhancedDeploymentService;
use Illuminate\Support\Facades\Queue;

it('auto-provisions server when capacity insufficient', function () {
    Queue::fake();

    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'max_servers' => 10,
        'features' => [
            'auto_provisioning' => true,
            'auto_approve_provisioning' => true,
        ],
    ]);

    CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'digitalocean',
        'is_active' => true,
    ]);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $autoProvisioningService = app(AutoProvisioningService::class);

    $requirements = [
        'cpu_cores' => 2,
        'memory_gb' => 4,
        'disk_gb' => 50,
    ];

    $server = $autoProvisioningService->provisionServerForDeployment($application, $requirements);

    expect($server)->not->toBeNull();
    expect($server->organization_id)->toBe($organization->id);

    $this->assertDatabaseHas('auto_provisioning_logs', [
        'organization_id' => $organization->id,
        'application_id' => $application->id,
        'status' => 'succeeded',
    ]);
});

it('respects quota and returns null when quota exceeded', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'max_servers' => 2,
        'features' => ['auto_provisioning' => true],
    ]);

    // Create 2 servers (at quota)
    Server::factory(2)->create(['organization_id' => $organization->id]);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $autoProvisioningService = app(AutoProvisioningService::class);

    $server = $autoProvisioningService->provisionServerForDeployment($application, [
        'cpu_cores' => 1,
        'memory_gb' => 1,
        'disk_gb' => 20,
    ]);

    expect($server)->toBeNull();

    $this->assertDatabaseHas('auto_provisioning_logs', [
        'organization_id' => $organization->id,
        'status' => 'quota_exceeded',
    ]);
});

it('requires approval when auto_approve_provisioning is false', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'max_servers' => 10,
        'features' => [
            'auto_provisioning' => true,
            'auto_approve_provisioning' => false, // Requires approval
        ],
    ]);

    CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'aws',
        'is_active' => true,
    ]);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $autoProvisioningService = app(AutoProvisioningService::class);

    $server = $autoProvisioningService->provisionServerForDeployment($application, [
        'cpu_cores' => 1,
        'memory_gb' => 1,
        'disk_gb' => 20,
    ]);

    expect($server)->toBeNull(); // Waiting for approval

    $this->assertDatabaseHas('auto_provisioning_logs', [
        'organization_id' => $organization->id,
        'status' => 'pending',
        'user_approved' => false,
    ]);
});

it('integrates with EnhancedDeploymentService', function () {
    $organization = Organization::factory()->create();
    $license = EnterpriseLicense::factory()->create([
        'organization_id' => $organization->id,
        'max_servers' => 10,
        'features' => [
            'auto_provisioning' => true,
            'auto_approve_provisioning' => true,
        ],
    ]);

    CloudProviderCredential::factory()->create([
        'organization_id' => $organization->id,
        'provider' => 'hetzner',
        'is_active' => true,
    ]);

    $application = Application::factory()->create([
        'organization_id' => $organization->id,
    ]);

    $deploymentService = app(EnhancedDeploymentService::class);

    // Deploy when no servers exist (should auto-provision)
    $deployment = $deploymentService->deployWithStrategy($application);

    expect($deployment)->not->toBeNull();
    expect($deployment->server_id)->not->toBeNull();

    // Verify auto-provisioning log exists
    $this->assertDatabaseHas('auto_provisioning_logs', [
        'organization_id' => $organization->id,
        'application_id' => $application->id,
        'status' => 'succeeded',
    ]);
});
```

### API Tests

**File:** `tests/Feature/Api/AutoProvisioningApiTest.php`

```php
<?php

use App\Models\User;
use App\Models\Organization;
use App\Models\Enterprise\AutoProvisioningLog;

it('allows admin to approve provisioning request', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $log = AutoProvisioningLog::factory()->create([
        'organization_id' => $organization->id,
        'status' => 'pending',
    ]);

    $this->actingAs($user)
        ->postJson("/api/organizations/{$organization->id}/auto-provisioning/{$log->id}/approve")
        ->assertOk();

    $log->refresh();
    expect($log->user_approved)->toBeTrue();
});

it('lists auto-provisioning logs for organization', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    AutoProvisioningLog::factory(3)->create([
        'organization_id' => $organization->id,
    ]);

    $response = $this->actingAs($user)
        ->getJson("/api/organizations/{$organization->id}/auto-provisioning-logs")
        ->assertOk();

    expect($response->json('data'))->toHaveCount(3);
});
```

## Definition of Done

- [ ] AutoProvisioningService created with complete logic
- [ ] AutoProvisioningServiceInterface defined
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Database migration for auto_provisioning_logs table created and run
- [ ] AutoProvisioningLog model created with relationships
- [ ] EnhancedDeploymentService integration complete
- [ ] Auto-provisioning triggered when selectOptimalServer() returns null
- [ ] Organization quota enforcement implemented
- [ ] Required specs calculation with 20% buffer implemented
- [ ] Cloud provider selection algorithm (cheapest first) implemented
- [ ] Instance type matching logic implemented
- [ ] Terraform config generation implemented
- [ ] Provisioning timeout handling (10 minutes) implemented
- [ ] User approval workflow implemented
- [ ] AutoProvisioningTriggered event created
- [ ] ServerAutoProvisioned event created with broadcasting
- [ ] NotifyUserOfAutoProvisioning listener created
- [ ] Events registered in EventServiceProvider
- [ ] AutoProvisionServerJob created for async provisioning
- [ ] License feature flags added (auto_provisioning, auto_approve_provisioning)
- [ ] API endpoints for approval/cancellation created
- [ ] Authorization policies for auto-provisioning implemented
- [ ] Unit tests written (12+ tests, >90% coverage)
- [ ] Integration tests written (8+ tests)
- [ ] API tests written (4+ tests)
- [ ] Manual testing with real Terraform provisioning
- [ ] Code follows Laravel 12 and Coolify patterns
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] Documentation updated (service, API, workflow)
- [ ] Audit logging verified
- [ ] WebSocket notifications tested
- [ ] Code reviewed and approved
- [ ] Performance verified (provisioning < 10 minutes)

## Related Tasks

- **Depends on:** Task 14 (TerraformService infrastructure provisioning)
- **Depends on:** Task 36 (CapacityManager server selection logic)
- **Integrates with:** Task 32 (EnhancedDeploymentService deployment orchestration)
- **Integrates with:** Task 18 (TerraformDeploymentJob async provisioning)
- **Uses:** Task 12 (CloudProviderCredential for provider selection)
- **Triggers:** Task 19 (Server auto-registration after provisioning)
