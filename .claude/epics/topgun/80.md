---
name: Implement performance tests for multi-tenant operations
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:31Z
github: https://github.com/johnproblems/topgun/issues/187
depends_on: [76]
parallel: false
conflicts_with: []
---

# Task: Implement performance tests for multi-tenant operations

## Description

Implement comprehensive performance testing infrastructure for validating the Coolify Enterprise Transformation's multi-tenant architecture under realistic high-concurrency scenarios. This testing suite ensures the hierarchical organization system, resource monitoring, and infrastructure provisioning services maintain acceptable performance with thousands of organizations, users, and concurrent operations.

**The Multi-Tenant Performance Challenge:**

Traditional performance testing focuses on single-tenant load. Enterprise multi-tenancy introduces unique challenges:
1. **Cross-Organization Query Performance**: Validating organization-scoped queries don't degrade with thousands of organizations
2. **Data Isolation Overhead**: Testing global scope filtering doesn't create N+1 queries or table scans
3. **Hierarchical Organization Queries**: Ensuring parent-child traversal performs efficiently at scale
4. **Concurrent Resource Monitoring**: Validating real-time metric collection across hundreds of servers doesn't create bottlenecks
5. **Cache Contention**: Testing Redis caching strategies under high concurrent organization access
6. **License Validation Performance**: Ensuring license checks remain fast with thousands of concurrent validations
7. **Terraform Provisioning Concurrency**: Testing infrastructure provisioning queue doesn't deadlock with parallel operations
8. **API Rate Limiting Accuracy**: Validating tier-based rate limits work correctly under burst traffic

**Why This Task is Critical:**

Performance regression in multi-tenant systems is catastrophic. A poorly optimized organization-scoped query can turn a 10ms response into a 5-second timeout when scaled to production. Without comprehensive performance testing, these issues only surface after deploymentâ€”when they impact real users.

This task creates a performance validation framework that:
- **Prevents Regressions**: Fails CI/CD builds if performance degrades below thresholds
- **Validates Architecture**: Proves the organization hierarchy performs at scale
- **Identifies Bottlenecks**: Highlights optimization opportunities before production
- **Simulates Production**: Tests with realistic data volumes and concurrency patterns
- **Provides Benchmarks**: Establishes performance baselines for future optimization

**Integration Architecture:**

**Performance Testing Stack:**
- **Laravel Dusk**: Browser-based performance testing for Vue.js components
- **Pest Benchmarking**: Custom benchmarking helpers for service layer performance
- **Database Query Monitoring**: Query count and execution time tracking
- **Memory Profiling**: Heap allocation and memory leak detection
- **Redis Monitoring**: Cache hit rates and connection pool usage
- **Apache JMeter** (optional): API endpoint load testing for concurrent requests
- **Blackfire.io** (optional): Production-grade profiling integration

**Test Categories:**

1. **Database Query Performance**: Organization-scoped queries, eager loading, index usage
2. **Service Layer Performance**: WhiteLabelService, TerraformService, CapacityManager benchmarks
3. **API Performance**: Rate limiting, authentication, organization switching overhead
4. **Background Job Performance**: Queue throughput, job processing time, memory usage
5. **Real-Time Feature Performance**: WebSocket broadcasts, metric collection, dashboard updates
6. **Cache Performance**: Redis operations, cache hit rates, eviction patterns
7. **Concurrency Testing**: Simultaneous organization operations, race conditions, deadlocks
8. **Memory Leak Detection**: Long-running operation memory profiles, garbage collection

**Dependencies:**
- **Task 76 (Unit Tests)**: Provides test infrastructure and mocking capabilities
- **Task 22 (Resource Monitoring)**: Provides metric collection to test
- **Task 14 (TerraformService)**: Provides infrastructure provisioning to test
- **Task 3 (BrandingCacheService)**: Provides cache operations to test

**Expected Outcomes:**

- CI/CD pipeline fails if key operations exceed performance thresholds
- Developers receive immediate feedback on performance impact of changes
- Production scaling requirements are well-understood and documented
- Performance bottlenecks identified early in development cycle
- Realistic load testing validates system handles 10,000+ organizations

## Acceptance Criteria

- [ ] Performance test suite created in `tests/Performance/` directory
- [ ] Database query performance tests validate organization-scoped operations < 50ms
- [ ] Service layer benchmarks test all enterprise services (WhiteLabel, Terraform, Capacity, Payment)
- [ ] API endpoint performance tests validate < 200ms p95 response time
- [ ] Concurrency tests simulate 100+ simultaneous organization operations
- [ ] Memory leak detection tests run for 1000+ iterations without growth
- [ ] Cache performance tests validate > 90% cache hit rate for branding
- [ ] Background job throughput tests validate > 100 jobs/minute processing
- [ ] Real-time feature tests validate WebSocket updates < 1 second latency
- [ ] License validation performance tests validate < 10ms per check
- [ ] Organization hierarchy traversal tests validate < 100ms for 10-level depth
- [ ] Terraform provisioning concurrency tests validate parallel operations
- [ ] Performance test fixtures create realistic data volumes (1000+ orgs, 10000+ users)
- [ ] Automated performance regression detection in CI/CD pipeline
- [ ] Performance test results exported to metrics dashboard

## Technical Details

### File Paths

**Test Directory Structure:**
- `/home/topgun/topgun/tests/Performance/` (new directory)
- `/home/topgun/topgun/tests/Performance/Database/OrganizationQueryPerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Services/WhiteLabelServicePerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Services/TerraformServicePerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Services/CapacityManagerPerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Api/RateLimitingPerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Api/OrganizationSwitchingPerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Cache/BrandingCachePerformanceTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Jobs/BackgroundJobThroughputTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Concurrency/MultiTenantConcurrencyTest.php` (new)
- `/home/topgun/topgun/tests/Performance/Memory/MemoryLeakDetectionTest.php` (new)

**Support Infrastructure:**
- `/home/topgun/topgun/tests/Performance/PerformanceTestCase.php` (new - base test class)
- `/home/topgun/topgun/tests/Performance/Concerns/CreatesPerformanceFixtures.php` (new - trait)
- `/home/topgun/topgun/tests/Performance/Concerns/MeasuresPerformance.php` (new - trait)
- `/home/topgun/topgun/tests/Performance/Concerns/DetectsMemoryLeaks.php` (new - trait)

**Configuration:**
- `/home/topgun/topgun/config/performance.php` (new - performance thresholds)

**CI/CD Integration:**
- `/home/topgun/topgun/.github/workflows/performance-tests.yml` (new - GitHub Actions)

### Performance Test Infrastructure

**Base Test Case:**

**File:** `tests/Performance/PerformanceTestCase.php`

```php
<?php

namespace Tests\Performance;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\DB;
use Tests\TestCase;
use Tests\Performance\Concerns\CreatesPerformanceFixtures;
use Tests\Performance\Concerns\MeasuresPerformance;
use Tests\Performance\Concerns\DetectsMemoryLeaks;

abstract class PerformanceTestCase extends TestCase
{
    use RefreshDatabase;
    use CreatesPerformanceFixtures;
    use MeasuresPerformance;
    use DetectsMemoryLeaks;

    protected array $performanceMetrics = [];

    /**
     * Set up performance testing environment
     */
    protected function setUp(): void
    {
        parent::setUp();

        // Enable query logging for performance analysis
        DB::enableQueryLog();

        // Reset performance metrics
        $this->performanceMetrics = [
            'queries' => [],
            'memory_start' => memory_get_usage(true),
            'time_start' => microtime(true),
        ];
    }

    /**
     * Tear down and report performance metrics
     */
    protected function tearDown(): void
    {
        $this->recordPerformanceMetrics();
        parent::tearDown();
    }

    /**
     * Record final performance metrics
     */
    protected function recordPerformanceMetrics(): void
    {
        $this->performanceMetrics['queries'] = DB::getQueryLog();
        $this->performanceMetrics['memory_end'] = memory_get_usage(true);
        $this->performanceMetrics['time_end'] = microtime(true);

        $this->performanceMetrics['duration_ms'] = round(
            ($this->performanceMetrics['time_end'] - $this->performanceMetrics['time_start']) * 1000,
            2
        );

        $this->performanceMetrics['memory_mb'] = round(
            ($this->performanceMetrics['memory_end'] - $this->performanceMetrics['memory_start']) / 1024 / 1024,
            2
        );

        $this->performanceMetrics['query_count'] = count($this->performanceMetrics['queries']);

        // Optional: Write metrics to log or monitoring service
        // $this->reportMetrics($this->performanceMetrics);
    }

    /**
     * Get performance thresholds from config
     */
    protected function getThreshold(string $key): mixed
    {
        return config("performance.thresholds.{$key}");
    }
}
```

**Performance Measurement Trait:**

**File:** `tests/Performance/Concerns/MeasuresPerformance.php`

```php
<?php

namespace Tests\Performance\Concerns;

use Illuminate\Support\Facades\DB;

trait MeasuresPerformance
{
    /**
     * Assert query execution time is below threshold
     */
    protected function assertQueryTimeBelow(int $thresholdMs, callable $callback): void
    {
        DB::flushQueryLog();

        $startTime = microtime(true);
        $callback();
        $endTime = microtime(true);

        $durationMs = round(($endTime - $startTime) * 1000, 2);

        expect($durationMs)->toBeLessThan(
            $thresholdMs,
            "Query execution took {$durationMs}ms, expected < {$thresholdMs}ms"
        );
    }

    /**
     * Assert query count is below threshold
     */
    protected function assertQueryCountBelow(int $maxQueries, callable $callback): void
    {
        DB::flushQueryLog();

        $callback();

        $queryCount = count(DB::getQueryLog());

        expect($queryCount)->toBeLessThan(
            $maxQueries,
            "Query count was {$queryCount}, expected < {$maxQueries}"
        );
    }

    /**
     * Assert memory usage increase is below threshold
     */
    protected function assertMemoryIncreaseBelow(int $maxMb, callable $callback): void
    {
        $memoryBefore = memory_get_usage(true);

        $callback();

        $memoryAfter = memory_get_usage(true);
        $increaseMb = round(($memoryAfter - $memoryBefore) / 1024 / 1024, 2);

        expect($increaseMb)->toBeLessThan(
            $maxMb,
            "Memory increased by {$increaseMb}MB, expected < {$maxMb}MB"
        );
    }

    /**
     * Benchmark operation and return duration in milliseconds
     */
    protected function benchmark(callable $callback): float
    {
        $startTime = microtime(true);
        $callback();
        $endTime = microtime(true);

        return round(($endTime - $startTime) * 1000, 2);
    }

    /**
     * Run benchmark multiple times and return average duration
     */
    protected function benchmarkAverage(callable $callback, int $iterations = 100): float
    {
        $durations = [];

        for ($i = 0; $i < $iterations; $i++) {
            $durations[] = $this->benchmark($callback);
        }

        return round(array_sum($durations) / count($durations), 2);
    }

    /**
     * Assert average operation time is below threshold
     */
    protected function assertAverageTimeBelow(int $thresholdMs, callable $callback, int $iterations = 100): void
    {
        $averageMs = $this->benchmarkAverage($callback, $iterations);

        expect($averageMs)->toBeLessThan(
            $thresholdMs,
            "Average execution took {$averageMs}ms, expected < {$thresholdMs}ms"
        );
    }
}
```

**Performance Fixtures Trait:**

**File:** `tests/Performance/Concerns/CreatesPerformanceFixtures.php`

```php
<?php

namespace Tests\Performance\Concerns;

use App\Models\Organization;
use App\Models\User;
use App\Models\Server;
use App\Models\Application;
use App\Models\WhiteLabelConfig;
use App\Models\EnterpriseLicense;
use App\Models\ServerResourceMetric;

trait CreatesPerformanceFixtures
{
    /**
     * Create organization hierarchy with realistic scale
     *
     * @param int $organizationCount
     * @param int $usersPerOrg
     * @return \Illuminate\Support\Collection
     */
    protected function createOrganizationHierarchy(
        int $organizationCount = 1000,
        int $usersPerOrg = 10
    ): \Illuminate\Support\Collection {
        $organizations = collect();

        // Create top-level organizations
        for ($i = 0; $i < $organizationCount; $i++) {
            $org = Organization::factory()->create([
                'name' => "Organization {$i}",
                'slug' => "org-{$i}",
            ]);

            // Create users for organization
            $users = User::factory($usersPerOrg)->create();
            $org->users()->attach($users, ['role' => 'member']);

            // Create white-label config
            WhiteLabelConfig::factory()->create([
                'organization_id' => $org->id,
            ]);

            // Create license
            EnterpriseLicense::factory()->create([
                'organization_id' => $org->id,
            ]);

            $organizations->push($org);

            // Every 10th organization has a child
            if ($i % 10 === 0 && $i < $organizationCount - 1) {
                $childOrg = Organization::factory()->create([
                    'parent_id' => $org->id,
                    'name' => "Child of Organization {$i}",
                    'slug' => "org-{$i}-child",
                ]);

                $organizations->push($childOrg);
            }
        }

        return $organizations;
    }

    /**
     * Create servers with resource metrics
     *
     * @param int $serverCount
     * @param int $metricsPerServer
     * @return \Illuminate\Support\Collection
     */
    protected function createServersWithMetrics(
        int $serverCount = 100,
        int $metricsPerServer = 1000
    ): \Illuminate\Support\Collection {
        $servers = collect();

        $organizations = Organization::limit(10)->get();

        for ($i = 0; $i < $serverCount; $i++) {
            $server = Server::factory()->create([
                'organization_id' => $organizations->random()->id,
                'name' => "Server {$i}",
            ]);

            // Create time-series metrics
            for ($j = 0; $j < $metricsPerServer; $j++) {
                ServerResourceMetric::factory()->create([
                    'server_id' => $server->id,
                    'collected_at' => now()->subMinutes($j),
                ]);
            }

            $servers->push($server);
        }

        return $servers;
    }

    /**
     * Create applications for deployment testing
     *
     * @param int $applicationCount
     * @return \Illuminate\Support\Collection
     */
    protected function createApplications(int $applicationCount = 500): \Illuminate\Support\Collection
    {
        $applications = collect();

        $organizations = Organization::limit(10)->get();
        $servers = Server::limit(50)->get();

        for ($i = 0; $i < $applicationCount; $i++) {
            $app = Application::factory()->create([
                'organization_id' => $organizations->random()->id,
                'destination_id' => $servers->random()->id,
                'name' => "Application {$i}",
            ]);

            $applications->push($app);
        }

        return $applications;
    }

    /**
     * Seed database with realistic multi-tenant data
     */
    protected function seedPerformanceDatabase(): void
    {
        // Create 1000 organizations with users and configs
        $this->createOrganizationHierarchy(1000, 10);

        // Create 100 servers with metrics
        $this->createServersWithMetrics(100, 1000);

        // Create 500 applications
        $this->createApplications(500);
    }
}
```

**Memory Leak Detection Trait:**

**File:** `tests/Performance/Concerns/DetectsMemoryLeaks.php`

```php
<?php

namespace Tests\Performance\Concerns;

trait DetectsMemoryLeaks
{
    /**
     * Assert operation doesn't leak memory over iterations
     */
    protected function assertNoMemoryLeak(callable $callback, int $iterations = 1000): void
    {
        gc_collect_cycles(); // Clear any existing garbage

        $memorySnapshots = [];

        // Take memory snapshots every 100 iterations
        for ($i = 0; $i < $iterations; $i++) {
            $callback();

            if ($i % 100 === 0) {
                gc_collect_cycles();
                $memorySnapshots[] = memory_get_usage(true);
            }
        }

        // Calculate memory growth trend
        $firstSnapshot = $memorySnapshots[0];
        $lastSnapshot = end($memorySnapshots);
        $growthMb = round(($lastSnapshot - $firstSnapshot) / 1024 / 1024, 2);

        // Allow 10MB growth for reasonable allocations
        expect($growthMb)->toBeLessThan(
            10,
            "Memory leaked {$growthMb}MB over {$iterations} iterations"
        );
    }

    /**
     * Profile memory usage for operation
     */
    protected function profileMemory(callable $callback): array
    {
        gc_collect_cycles();

        $memoryBefore = memory_get_usage(true);
        $peakBefore = memory_get_peak_usage(true);

        $callback();

        gc_collect_cycles();

        $memoryAfter = memory_get_usage(true);
        $peakAfter = memory_get_peak_usage(true);

        return [
            'memory_before_mb' => round($memoryBefore / 1024 / 1024, 2),
            'memory_after_mb' => round($memoryAfter / 1024 / 1024, 2),
            'memory_increase_mb' => round(($memoryAfter - $memoryBefore) / 1024 / 1024, 2),
            'peak_mb' => round($peakAfter / 1024 / 1024, 2),
        ];
    }
}
```

### Database Query Performance Tests

**File:** `tests/Performance/Database/OrganizationQueryPerformanceTest.php`

```php
<?php

namespace Tests\Performance\Database;

use Tests\Performance\PerformanceTestCase;
use App\Models\Organization;
use App\Models\User;
use Illuminate\Support\Facades\DB;

class OrganizationQueryPerformanceTest extends PerformanceTestCase
{
    protected function setUp(): void
    {
        parent::setUp();

        // Seed realistic data volume
        $this->createOrganizationHierarchy(1000, 10);
    }

    /**
     * Test organization-scoped query performance
     */
    public function test_organization_scoped_queries_perform_efficiently(): void
    {
        $organization = Organization::first();

        // Assert scoped query is fast
        $this->assertQueryTimeBelow(50, function () use ($organization) {
            $users = $organization->users()->get();
        });
    }

    /**
     * Test hierarchical organization query performance
     */
    public function test_organization_hierarchy_traversal_is_efficient(): void
    {
        // Find organization with children
        $parentOrg = Organization::has('children')->first();

        // Assert hierarchy query is fast
        $this->assertQueryTimeBelow(100, function () use ($parentOrg) {
            $allChildren = $parentOrg->children()->get();
            $allDescendants = $parentOrg->descendants; // Assuming recursive relationship
        });
    }

    /**
     * Test organization listing performance with pagination
     */
    public function test_organization_listing_paginates_efficiently(): void
    {
        $user = User::first();

        // Assert paginated query is fast
        $this->assertQueryTimeBelow(75, function () use ($user) {
            $organizations = $user->organizations()->paginate(25);
        });

        // Assert no N+1 queries
        $this->assertQueryCountBelow(3, function () use ($user) {
            $organizations = $user->organizations()->with('whiteLabelConfig')->paginate(25);
        });
    }

    /**
     * Test global scope filtering performance
     */
    public function test_global_scope_filtering_uses_indexes(): void
    {
        $organization = Organization::first();

        // Query with organization scope should use index
        DB::flushQueryLog();

        User::where('organization_id', $organization->id)->get();

        $queries = DB::getQueryLog();
        $query = $queries[0]['query'];

        // Verify WHERE clause includes organization_id (index usage)
        expect($query)->toContain('organization_id');
    }

    /**
     * Test organization switching performance
     */
    public function test_organization_context_switching_is_fast(): void
    {
        $organizations = Organization::limit(100)->get();

        // Switching organization context should be fast
        $averageMs = $this->benchmarkAverage(function () use ($organizations) {
            $org = $organizations->random();

            // Simulate organization context switch
            session(['current_organization_id' => $org->id]);
            $users = $org->users()->count();
        }, 100);

        expect($averageMs)->toBeLessThan(
            25,
            "Organization switching took {$averageMs}ms on average"
        );
    }

    /**
     * Test bulk organization query performance
     */
    public function test_bulk_organization_queries_use_eager_loading(): void
    {
        // Assert bulk query with eager loading is efficient
        $this->assertQueryCountBelow(5, function () {
            $organizations = Organization::with([
                'whiteLabelConfig',
                'enterpriseLicense',
                'users' => fn($q) => $q->limit(10)
            ])->limit(100)->get();
        });
    }
}
```

### Service Layer Performance Tests

**File:** `tests/Performance/Services/WhiteLabelServicePerformanceTest.php`

```php
<?php

namespace Tests\Performance\Services;

use Tests\Performance\PerformanceTestCase;
use App\Services\Enterprise\WhiteLabelService;
use App\Models\Organization;

class WhiteLabelServicePerformanceTest extends PerformanceTestCase
{
    protected WhiteLabelService $service;

    protected function setUp(): void
    {
        parent::setUp();

        $this->service = app(WhiteLabelService::class);
        $this->createOrganizationHierarchy(100, 5);
    }

    /**
     * Test CSS generation performance
     */
    public function test_css_generation_completes_under_threshold(): void
    {
        $organization = Organization::has('whiteLabelConfig')->first();

        // CSS generation should be fast
        $durationMs = $this->benchmark(function () use ($organization) {
            $css = $this->service->generateCSS($organization);
        });

        expect($durationMs)->toBeLessThan(
            150,
            "CSS generation took {$durationMs}ms, expected < 150ms"
        );
    }

    /**
     * Test cached CSS retrieval performance
     */
    public function test_cached_css_retrieval_is_instant(): void
    {
        $organization = Organization::has('whiteLabelConfig')->first();

        // Pre-warm cache
        $this->service->generateCSS($organization);

        // Cached retrieval should be very fast
        $durationMs = $this->benchmark(function () use ($organization) {
            $css = $this->service->getCachedCSS($organization);
        });

        expect($durationMs)->toBeLessThan(
            10,
            "Cached CSS retrieval took {$durationMs}ms, expected < 10ms"
        );
    }

    /**
     * Test branding configuration retrieval performance
     */
    public function test_branding_config_retrieval_is_efficient(): void
    {
        $organization = Organization::has('whiteLabelConfig')->first();

        // Config retrieval should be fast
        $this->assertQueryTimeBelow(25, function () use ($organization) {
            $config = $this->service->getBrandingConfig($organization);
        });
    }

    /**
     * Test CSS generation doesn't leak memory
     */
    public function test_css_generation_doesnt_leak_memory(): void
    {
        $organizations = Organization::has('whiteLabelConfig')->limit(10)->get();

        $this->assertNoMemoryLeak(function () use ($organizations) {
            $org = $organizations->random();
            $css = $this->service->generateCSS($org);
            unset($css); // Explicit cleanup
        }, 1000);
    }
}
```

**File:** `tests/Performance/Services/CapacityManagerPerformanceTest.php`

```php
<?php

namespace Tests\Performance\Services;

use Tests\Performance\PerformanceTestCase;
use App\Services\Enterprise\CapacityManager;
use App\Models\Server;
use App\Models\Application;

class CapacityManagerPerformanceTest extends PerformanceTestCase
{
    protected CapacityManager $capacityManager;

    protected function setUp(): void
    {
        parent::setUp();

        $this->capacityManager = app(CapacityManager::class);
        $this->createServersWithMetrics(100, 500);
    }

    /**
     * Test server selection algorithm performance
     */
    public function test_optimal_server_selection_is_fast(): void
    {
        $servers = Server::limit(50)->get();
        $requirements = [
            'cpu_cores' => 2,
            'memory_mb' => 2048,
            'disk_gb' => 50,
        ];

        // Server selection should be very fast
        $durationMs = $this->benchmark(function () use ($servers, $requirements) {
            $server = $this->capacityManager->selectOptimalServer($servers, $requirements);
        });

        expect($durationMs)->toBeLessThan(
            50,
            "Server selection took {$durationMs}ms, expected < 50ms"
        );
    }

    /**
     * Test capacity validation performance
     */
    public function test_capacity_validation_is_efficient(): void
    {
        $server = Server::first();
        $application = Application::factory()->make();

        // Capacity check should be fast
        $durationMs = $this->benchmark(function () use ($server, $application) {
            $canHandle = $this->capacityManager->canServerHandleDeployment($server, $application);
        });

        expect($durationMs)->toBeLessThan(
            30,
            "Capacity validation took {$durationMs}ms, expected < 30ms"
        );
    }

    /**
     * Test resource metric aggregation performance
     */
    public function test_metric_aggregation_handles_large_datasets(): void
    {
        $server = Server::first();

        // Metric aggregation for 1000 data points should be reasonable
        $this->assertQueryTimeBelow(100, function () use ($server) {
            $metrics = $this->capacityManager->getAggregatedMetrics($server, 'last_hour');
        });
    }
}
```

### API Performance Tests

**File:** `tests/Performance/Api/RateLimitingPerformanceTest.php`

```php
<?php

namespace Tests\Performance\Api;

use Tests\Performance\PerformanceTestCase;
use App\Models\User;
use App\Models\Organization;
use Laravel\Sanctum\Sanctum;

class RateLimitingPerformanceTest extends PerformanceTestCase
{
    /**
     * Test rate limiting doesn't add significant overhead
     */
    public function test_rate_limiting_overhead_is_minimal(): void
    {
        $user = User::factory()->create();
        $organization = Organization::factory()->create();
        $organization->users()->attach($user, ['role' => 'admin']);

        Sanctum::actingAs($user);

        // Benchmark API request with rate limiting
        $withRateLimitMs = $this->benchmarkAverage(function () use ($organization) {
            $response = $this->getJson("/api/v1/organizations/{$organization->id}");
        }, 100);

        // Rate limiting should add < 10ms overhead
        expect($withRateLimitMs)->toBeLessThan(
            200,
            "API request with rate limiting took {$withRateLimitMs}ms"
        );
    }

    /**
     * Test concurrent rate limit checks
     */
    public function test_concurrent_rate_limit_checks_dont_deadlock(): void
    {
        $users = User::factory(10)->create();

        // Simulate concurrent requests (sequential for test purposes)
        $durations = [];

        foreach ($users as $user) {
            Sanctum::actingAs($user);

            $durationMs = $this->benchmark(function () {
                $response = $this->getJson('/api/v1/organizations');
            });

            $durations[] = $durationMs;
        }

        $averageMs = round(array_sum($durations) / count($durations), 2);

        expect($averageMs)->toBeLessThan(
            250,
            "Concurrent requests averaged {$averageMs}ms"
        );
    }
}
```

### Cache Performance Tests

**File:** `tests/Performance/Cache/BrandingCachePerformanceTest.php`

```php
<?php

namespace Tests\Performance\Cache;

use Tests\Performance\PerformanceTestCase;
use App\Services\Enterprise\BrandingCacheService;
use App\Models\Organization;
use Illuminate\Support\Facades\Cache;

class BrandingCachePerformanceTest extends PerformanceTestCase
{
    protected BrandingCacheService $cacheService;

    protected function setUp(): void
    {
        parent::setUp();

        $this->cacheService = app(BrandingCacheService::class);
        $this->createOrganizationHierarchy(100, 5);
    }

    /**
     * Test cache hit rate is acceptable
     */
    public function test_cache_hit_rate_exceeds_threshold(): void
    {
        $organizations = Organization::has('whiteLabelConfig')->limit(10)->get();

        // Pre-warm cache
        foreach ($organizations as $org) {
            $this->cacheService->setCachedCSS($org, 'test-css');
        }

        $hits = 0;
        $misses = 0;
        $iterations = 100;

        for ($i = 0; $i < $iterations; $i++) {
            $org = $organizations->random();
            $css = $this->cacheService->getCachedCSS($org);

            if ($css !== null) {
                $hits++;
            } else {
                $misses++;
            }
        }

        $hitRate = round(($hits / $iterations) * 100, 2);

        expect($hitRate)->toBeGreaterThan(
            90,
            "Cache hit rate was {$hitRate}%, expected > 90%"
        );
    }

    /**
     * Test cache operations are fast
     */
    public function test_cache_read_write_operations_are_fast(): void
    {
        $organization = Organization::has('whiteLabelConfig')->first();
        $testCss = str_repeat('test-css-content', 1000); // 14KB

        // Cache write should be fast
        $writeDurationMs = $this->benchmark(function () use ($organization, $testCss) {
            $this->cacheService->setCachedCSS($organization, $testCss);
        });

        expect($writeDurationMs)->toBeLessThan(25, "Cache write took {$writeDurationMs}ms");

        // Cache read should be very fast
        $readDurationMs = $this->benchmark(function () use ($organization) {
            $css = $this->cacheService->getCachedCSS($organization);
        });

        expect($readDurationMs)->toBeLessThan(10, "Cache read took {$readDurationMs}ms");
    }
}
```

### Concurrency Tests

**File:** `tests/Performance/Concurrency/MultiTenantConcurrencyTest.php`

```php
<?php

namespace Tests\Performance\Concurrency;

use Tests\Performance\PerformanceTestCase;
use App\Models\Organization;
use App\Models\User;
use App\Services\Enterprise\WhiteLabelService;
use Illuminate\Support\Facades\DB;

class MultiTenantConcurrencyTest extends PerformanceTestCase
{
    /**
     * Test concurrent organization operations
     */
    public function test_concurrent_organization_reads_dont_conflict(): void
    {
        $organizations = Organization::factory(10)->create();

        // Simulate concurrent reads (sequential for test environment)
        $durations = [];

        foreach ($organizations as $org) {
            $durationMs = $this->benchmark(function () use ($org) {
                $users = $org->users()->get();
                $config = $org->whiteLabelConfig;
            });

            $durations[] = $durationMs;
        }

        $averageMs = round(array_sum($durations) / count($durations), 2);

        expect($averageMs)->toBeLessThan(
            50,
            "Concurrent organization reads averaged {$averageMs}ms"
        );
    }

    /**
     * Test database transaction isolation
     */
    public function test_concurrent_writes_maintain_isolation(): void
    {
        $organization = Organization::factory()->create();
        $users = User::factory(5)->create();

        // Simulate concurrent user attachments
        DB::beginTransaction();

        try {
            foreach ($users as $user) {
                $organization->users()->attach($user, ['role' => 'member']);
            }

            DB::commit();

            // Verify all users were attached
            expect($organization->users()->count())->toBe(5);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }
}
```

### Memory Leak Detection Tests

**File:** `tests/Performance/Memory/MemoryLeakDetectionTest.php`

```php
<?php

namespace Tests\Performance\Memory;

use Tests\Performance\PerformanceTestCase;
use App\Services\Enterprise\WhiteLabelService;
use App\Models\Organization;

class MemoryLeakDetectionTest extends PerformanceTestCase
{
    /**
     * Test service operations don't leak memory
     */
    public function test_whitelabel_service_doesnt_leak_memory(): void
    {
        $service = app(WhiteLabelService::class);
        $organizations = Organization::has('whiteLabelConfig')->limit(10)->get();

        $this->assertNoMemoryLeak(function () use ($service, $organizations) {
            $org = $organizations->random();
            $css = $service->generateCSS($org);
            $config = $service->getBrandingConfig($org);

            // Force cleanup
            unset($css, $config);
        }, 1000);
    }

    /**
     * Test database query operations don't leak memory
     */
    public function test_database_queries_dont_leak_memory(): void
    {
        $this->assertNoMemoryLeak(function () {
            $users = User::with('organizations')->limit(100)->get();
            unset($users);
        }, 1000);
    }
}
```

### Configuration File

**File:** `config/performance.php`

```php
<?php

return [
    /**
     * Performance testing thresholds
     */
    'thresholds' => [
        // Database query performance (milliseconds)
        'database' => [
            'organization_scoped_query' => 50,
            'hierarchy_traversal' => 100,
            'paginated_listing' => 75,
            'bulk_eager_loading' => 150,
        ],

        // Service layer performance (milliseconds)
        'services' => [
            'css_generation' => 150,
            'cached_css_retrieval' => 10,
            'server_selection' => 50,
            'capacity_validation' => 30,
            'license_validation' => 10,
        ],

        // API performance (milliseconds)
        'api' => [
            'p95_response_time' => 200,
            'rate_limiting_overhead' => 10,
            'authentication_overhead' => 25,
        ],

        // Cache performance
        'cache' => [
            'hit_rate_percent' => 90,
            'read_operation_ms' => 10,
            'write_operation_ms' => 25,
        ],

        // Memory usage (megabytes)
        'memory' => [
            'operation_increase_mb' => 5,
            'leak_tolerance_mb' => 10,
        ],

        // Background job performance
        'jobs' => [
            'throughput_per_minute' => 100,
            'max_processing_time_ms' => 5000,
        ],
    ],

    /**
     * Performance test fixture sizes
     */
    'fixtures' => [
        'organizations' => env('PERF_TEST_ORGS', 1000),
        'users_per_org' => env('PERF_TEST_USERS_PER_ORG', 10),
        'servers' => env('PERF_TEST_SERVERS', 100),
        'metrics_per_server' => env('PERF_TEST_METRICS_PER_SERVER', 1000),
        'applications' => env('PERF_TEST_APPLICATIONS', 500),
    ],

    /**
     * Enable performance monitoring in tests
     */
    'monitoring' => [
        'enabled' => env('PERF_MONITORING_ENABLED', true),
        'export_metrics' => env('PERF_EXPORT_METRICS', false),
        'metrics_file' => storage_path('logs/performance-metrics.json'),
    ],
];
```

## Implementation Approach

### Step 1: Create Test Infrastructure
1. Create `tests/Performance/` directory structure
2. Create `PerformanceTestCase` base class
3. Create performance measurement traits
4. Create `config/performance.php` configuration file

### Step 2: Implement Database Performance Tests
1. Create `OrganizationQueryPerformanceTest`
2. Test organization-scoped queries
3. Test hierarchical traversal
4. Test pagination performance
5. Verify index usage

### Step 3: Implement Service Layer Tests
1. Create service performance tests for WhiteLabelService
2. Create tests for TerraformService
3. Create tests for CapacityManager
4. Create tests for PaymentService
5. Benchmark all critical service methods

### Step 4: Implement API Performance Tests
1. Create rate limiting performance tests
2. Test authentication overhead
3. Test organization switching
4. Benchmark API response times

### Step 5: Implement Cache Performance Tests
1. Create branding cache performance tests
2. Test cache hit rates
3. Test cache operation speed
4. Test cache invalidation performance

### Step 6: Implement Concurrency Tests
1. Create multi-tenant concurrency tests
2. Test database transaction isolation
3. Test concurrent API requests
4. Test race condition prevention

### Step 7: Implement Memory Leak Detection
1. Create memory leak detection tests
2. Test service operations for leaks
3. Test database queries for leaks
4. Test background jobs for leaks

### Step 8: CI/CD Integration
1. Create GitHub Actions workflow
2. Configure performance thresholds
3. Set up failure notifications
4. Export metrics to monitoring dashboard

### Step 9: Documentation
1. Document performance testing approach
2. Document how to run performance tests
3. Document threshold tuning
4. Create performance optimization guide

### Step 10: Baseline Establishment
1. Run performance tests on clean installation
2. Record baseline metrics
3. Set initial thresholds based on baselines
4. Create performance regression alerts

## Test Strategy

### Running Performance Tests

**Local Development:**
```bash
# Run all performance tests
php artisan test --testsuite=Performance

# Run specific performance test
php artisan test tests/Performance/Database/OrganizationQueryPerformanceTest.php

# Run with verbose output
php artisan test --testsuite=Performance -v

# Run with memory profiling
php artisan test --testsuite=Performance --coverage
```

**CI/CD Pipeline:**
```yaml
# .github/workflows/performance-tests.yml
name: Performance Tests

on:
  pull_request:
    branches: [main, v4.x]
  push:
    branches: [main, v4.x]

jobs:
  performance:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s

    steps:
      - uses: actions/checkout@v3

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.4'
          extensions: pdo_pgsql, redis

      - name: Install Dependencies
        run: composer install --no-interaction

      - name: Run Performance Tests
        run: php artisan test --testsuite=Performance

      - name: Check Performance Thresholds
        run: |
          # Parse metrics and fail if thresholds exceeded
          php artisan performance:validate-thresholds

      - name: Upload Performance Metrics
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: performance-metrics
          path: storage/logs/performance-metrics.json
```

### Unit Test Examples

```php
<?php

use Tests\Performance\PerformanceTestCase;
use App\Services\Enterprise\LicensingService;

class LicenseValidationPerformanceTest extends PerformanceTestCase
{
    public function test_license_validation_is_fast(): void
    {
        $service = app(LicensingService::class);
        $license = EnterpriseLicense::factory()->create();

        // Average validation should be < 10ms
        $this->assertAverageTimeBelow(10, function () use ($service, $license) {
            $result = $service->validateLicense($license->license_key);
        }, 100);
    }

    public function test_cached_license_validation_is_instant(): void
    {
        $service = app(LicensingService::class);
        $license = EnterpriseLicense::factory()->create();

        // Pre-warm cache
        $service->validateLicense($license->license_key);

        // Cached validation should be < 5ms
        $durationMs = $this->benchmark(function () use ($service, $license) {
            $result = $service->validateLicense($license->license_key);
        });

        expect($durationMs)->toBeLessThan(5);
    }
}
```

## Definition of Done

- [ ] Performance test directory structure created
- [ ] PerformanceTestCase base class implemented
- [ ] MeasuresPerformance trait implemented
- [ ] CreatesPerformanceFixtures trait implemented
- [ ] DetectsMemoryLeaks trait implemented
- [ ] config/performance.php created with thresholds
- [ ] Database query performance tests implemented (5+ tests)
- [ ] Service layer performance tests implemented (10+ tests)
- [ ] API performance tests implemented (5+ tests)
- [ ] Cache performance tests implemented (5+ tests)
- [ ] Concurrency tests implemented (3+ tests)
- [ ] Memory leak detection tests implemented (5+ tests)
- [ ] Performance fixtures create realistic data volumes
- [ ] CI/CD performance test workflow configured
- [ ] Performance threshold validation automated
- [ ] Baseline performance metrics established
- [ ] All performance tests passing
- [ ] Performance regression detection working in CI/CD
- [ ] Performance metrics exported to monitoring dashboard
- [ ] Documentation written for performance testing
- [ ] Performance optimization guide created
- [ ] Code follows Laravel testing best practices
- [ ] PHPStan level 5 passing for all test files
- [ ] Laravel Pint formatting applied
- [ ] Code reviewed and approved
- [ ] Performance tests run in under 10 minutes

## Related Tasks

- **Depends on:** Task 76 (Unit Tests for Enterprise Services)
- **Validates:** Task 22 (Resource Monitoring Performance)
- **Validates:** Task 14 (Terraform Service Performance)
- **Validates:** Task 3 (Branding Cache Performance)
- **Validates:** Task 26 (CapacityManager Performance)
- **Validates:** Task 54 (API Rate Limiting Performance)
- **Integrates with:** Task 81 (CI/CD Quality Gates)
