---
name: Integrate Stripe payment gateway with credit card and ACH support
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:00Z
github: https://github.com/johnproblems/topgun/issues/153
depends_on: [43]
parallel: false
conflicts_with: []
---

# Task: Integrate Stripe payment gateway with credit card and ACH support

## Description

Implement a comprehensive Stripe payment gateway integration as the flagship payment processor for the Coolify Enterprise platform. This integration provides credit card, ACH bank transfer, and SEPA debit payment processing capabilities through Stripe's unified API, enabling organizations to monetize their white-labeled Coolify instances with subscription-based billing.

The Stripe integration implements the `PaymentGatewayInterface` defined in Task 43, providing a standardized interface for payment operations while leveraging Stripe-specific features like:

1. **Multiple Payment Methods**: Credit cards (Visa, Mastercard, Amex), ACH bank transfers, SEPA Direct Debit
2. **Subscription Management**: Create, update, pause, resume, and cancel recurring subscriptions with proration
3. **Customer Portal**: Stripe-hosted customer portal for self-service billing management
4. **Webhook Processing**: Secure webhook handling for payment events (payment succeeded, subscription updated, etc.)
5. **3D Secure Support**: SCA compliance with Stripe's Payment Intents API
6. **Usage-Based Billing**: Metered billing for resource consumption tracking
7. **Automatic Tax Calculation**: Integration with Stripe Tax for global tax compliance
8. **Smart Retry Logic**: Stripe Smart Retries for failed subscription payments

**Why This Task Is Critical:**

Stripe is the world's leading online payment processor, powering millions of businesses globally with a 99.99% uptime SLA. This integration enables Coolify Enterprise to offer professional payment processing with minimal PCI compliance burden (Stripe handles card data, reducing PCI scope to SAQ-A). Without this gateway, organizations cannot accept payments, subscription renewals fail, and revenue operations break down. Stripe's extensive API coverage allows future expansion into international markets, alternative payment methods (Apple Pay, Google Pay, iDEAL), and advanced features like instant payouts and Connect for marketplace scenarios.

**Integration Architecture:**

- **Service Layer**: `StripePaymentGateway` implements `PaymentGatewayInterface` from Task 43
- **Database Models**: Uses `PaymentMethod`, `PaymentTransaction`, `OrganizationSubscription` from Task 42
- **Webhook System**: Dedicated controller for Stripe webhook events with HMAC signature validation
- **API Communication**: Stripe PHP SDK (`stripe/stripe-php`) for type-safe API interactions
- **Error Handling**: Comprehensive exception handling for declined payments, rate limits, network errors

**Key Features:**

- **Payment Intent Flow**: Modern payment processing with SCA compliance using Payment Intents API
- **Subscription Lifecycle**: Complete subscription management with prorated upgrades/downgrades
- **Customer Management**: Automatic Stripe customer creation and synchronization
- **Idempotency**: Built-in idempotency key support for safe payment retries
- **Metadata Tracking**: Organize payments with custom metadata (organization_id, user_id, plan_id)
- **Refund Handling**: Full and partial refund processing with reason tracking
- **Dispute Management**: Webhook handling for dispute lifecycle events

## Acceptance Criteria

- [ ] StripePaymentGateway class implements PaymentGatewayInterface with all required methods
- [ ] Credit card payment processing working with 3D Secure/SCA support
- [ ] ACH bank account payment processing with micro-deposit verification
- [ ] SEPA Direct Debit support for European customers
- [ ] Subscription creation with plan assignment and billing cycle configuration
- [ ] Subscription updates with proration calculation for mid-cycle changes
- [ ] Subscription cancellation with immediate or end-of-period options
- [ ] Customer portal integration for self-service billing management
- [ ] Webhook endpoint handling all critical Stripe events with HMAC validation
- [ ] Automatic payment method saving for future charges
- [ ] Usage-based billing with metered subscription items
- [ ] Comprehensive error handling for all Stripe API errors
- [ ] Idempotency key generation for safe payment retries
- [ ] Refund processing with partial and full refund support
- [ ] Payment transaction logging for audit trails
- [ ] Stripe customer creation and synchronization with Organization model
- [ ] Configuration validation for Stripe API keys on startup
- [ ] Unit tests covering all payment scenarios (>90% coverage)
- [ ] Integration tests with Stripe test mode API
- [ ] Webhook signature validation preventing unauthorized webhook processing

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/Payment/StripePaymentGateway.php` (implementation)
- `/home/topgun/topgun/app/Contracts/PaymentGatewayInterface.php` (interface - from Task 43)

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/StripeWebhookController.php` (webhook handler)

**Configuration:**
- `/home/topgun/topgun/config/payment.php` (payment gateway configuration - from Task 43)

**Models:**
- `/home/topgun/topgun/app/Models/PaymentMethod.php` (existing from Task 42)
- `/home/topgun/topgun/app/Models/PaymentTransaction.php` (existing from Task 42)
- `/home/topgun/topgun/app/Models/OrganizationSubscription.php` (existing from Task 42)

**Routes:**
- `/home/topgun/topgun/routes/webhooks.php` - Stripe webhook endpoint

### Service Interface (Reference)

From Task 43 - `PaymentGatewayInterface`:

```php
<?php

namespace App\Contracts;

use App\Models\Organization;
use App\Models\PaymentMethod;
use App\Models\OrganizationSubscription;

interface PaymentGatewayInterface
{
    /**
     * Create customer in payment gateway
     */
    public function createCustomer(Organization $organization, array $customerData): array;

    /**
     * Add payment method to customer
     */
    public function addPaymentMethod(Organization $organization, array $paymentData): PaymentMethod;

    /**
     * Process one-time payment
     */
    public function processPayment(
        Organization $organization,
        PaymentMethod $paymentMethod,
        float $amount,
        array $metadata = []
    ): array;

    /**
     * Create subscription
     */
    public function createSubscription(
        Organization $organization,
        PaymentMethod $paymentMethod,
        string $planId,
        array $options = []
    ): OrganizationSubscription;

    /**
     * Update subscription
     */
    public function updateSubscription(
        OrganizationSubscription $subscription,
        array $updates
    ): OrganizationSubscription;

    /**
     * Cancel subscription
     */
    public function cancelSubscription(
        OrganizationSubscription $subscription,
        bool $immediately = false
    ): OrganizationSubscription;

    /**
     * Process refund
     */
    public function refundPayment(
        string $transactionId,
        ?float $amount = null,
        string $reason = 'requested_by_customer'
    ): array;

    /**
     * Retrieve payment method details
     */
    public function getPaymentMethod(string $paymentMethodId): array;

    /**
     * Handle webhook from payment gateway
     */
    public function handleWebhook(array $payload, string $signature): void;

    /**
     * Verify webhook signature
     */
    public function verifyWebhookSignature(string $payload, string $signature): bool;

    /**
     * Get customer portal URL for self-service
     */
    public function getCustomerPortalUrl(Organization $organization, string $returnUrl): string;
}
```

### StripePaymentGateway Implementation

**File:** `app/Services/Enterprise/Payment/StripePaymentGateway.php`

```php
<?php

namespace App\Services\Enterprise\Payment;

use App\Contracts\PaymentGatewayInterface;
use App\Models\Organization;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use App\Models\OrganizationSubscription;
use App\Exceptions\PaymentException;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Stripe\StripeClient;
use Stripe\Exception\ApiErrorException;
use Stripe\Exception\SignatureVerificationException;
use Stripe\Webhook;

class StripePaymentGateway implements PaymentGatewayInterface
{
    private StripeClient $stripe;

    public function __construct()
    {
        $apiKey = config('payment.gateways.stripe.secret_key');

        if (!$apiKey) {
            throw new PaymentException('Stripe API key not configured');
        }

        $this->stripe = new StripeClient([
            'api_key' => $apiKey,
            'stripe_version' => '2024-11-20.acacia', // Use latest API version
        ]);
    }

    /**
     * Create customer in Stripe
     *
     * @param Organization $organization
     * @param array $customerData ['email', 'name', 'phone', 'address', 'tax_id']
     * @return array Stripe customer data
     * @throws PaymentException
     */
    public function createCustomer(Organization $organization, array $customerData): array
    {
        try {
            Log::info('Creating Stripe customer', [
                'organization_id' => $organization->id,
                'email' => $customerData['email'] ?? null,
            ]);

            $customer = $this->stripe->customers->create([
                'email' => $customerData['email'],
                'name' => $customerData['name'] ?? $organization->name,
                'phone' => $customerData['phone'] ?? null,
                'address' => $customerData['address'] ?? null,
                'tax_id' => $customerData['tax_id'] ?? null,
                'metadata' => [
                    'organization_id' => $organization->id,
                    'organization_name' => $organization->name,
                    'coolify_environment' => config('app.env'),
                ],
            ]);

            // Store Stripe customer ID on organization
            $organization->update([
                'stripe_customer_id' => $customer->id,
            ]);

            Log::info('Stripe customer created', [
                'organization_id' => $organization->id,
                'stripe_customer_id' => $customer->id,
            ]);

            return [
                'id' => $customer->id,
                'email' => $customer->email,
                'created_at' => $customer->created,
            ];

        } catch (ApiErrorException $e) {
            Log::error('Stripe customer creation failed', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
                'stripe_code' => $e->getStripeCode(),
            ]);

            throw new PaymentException(
                "Failed to create Stripe customer: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Add payment method to customer
     *
     * @param Organization $organization
     * @param array $paymentData ['type' => 'card'|'us_bank_account'|'sepa_debit', 'payment_method_id' => 'pm_xxx']
     * @return PaymentMethod
     * @throws PaymentException
     */
    public function addPaymentMethod(Organization $organization, array $paymentData): PaymentMethod
    {
        try {
            $stripeCustomerId = $this->ensureCustomerExists($organization);

            // Attach payment method to customer
            $stripePaymentMethod = $this->stripe->paymentMethods->attach(
                $paymentData['payment_method_id'],
                ['customer' => $stripeCustomerId]
            );

            // Set as default payment method
            $this->stripe->customers->update($stripeCustomerId, [
                'invoice_settings' => [
                    'default_payment_method' => $stripePaymentMethod->id,
                ],
            ]);

            // Store payment method in database
            $paymentMethod = PaymentMethod::create([
                'organization_id' => $organization->id,
                'gateway' => 'stripe',
                'gateway_payment_method_id' => $stripePaymentMethod->id,
                'type' => $stripePaymentMethod->type,
                'last_four' => $stripePaymentMethod->card->last4 ?? $stripePaymentMethod->us_bank_account->last4 ?? null,
                'brand' => $stripePaymentMethod->card->brand ?? $stripePaymentMethod->type,
                'expiry_month' => $stripePaymentMethod->card->exp_month ?? null,
                'expiry_year' => $stripePaymentMethod->card->exp_year ?? null,
                'is_default' => true,
                'metadata' => [
                    'stripe_customer_id' => $stripeCustomerId,
                    'stripe_payment_method_type' => $stripePaymentMethod->type,
                ],
            ]);

            Log::info('Payment method added', [
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'stripe_payment_method_id' => $stripePaymentMethod->id,
            ]);

            return $paymentMethod;

        } catch (ApiErrorException $e) {
            Log::error('Failed to add payment method', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to add payment method: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Process one-time payment using Payment Intent API
     *
     * @param Organization $organization
     * @param PaymentMethod $paymentMethod
     * @param float $amount Amount in dollars (will be converted to cents)
     * @param array $metadata Additional metadata for tracking
     * @return array Payment result
     * @throws PaymentException
     */
    public function processPayment(
        Organization $organization,
        PaymentMethod $paymentMethod,
        float $amount,
        array $metadata = []
    ): array {
        try {
            $stripeCustomerId = $this->ensureCustomerExists($organization);

            // Generate idempotency key for safe retries
            $idempotencyKey = $this->generateIdempotencyKey([
                'organization_id' => $organization->id,
                'amount' => $amount,
                'timestamp' => now()->timestamp,
            ]);

            Log::info('Creating payment intent', [
                'organization_id' => $organization->id,
                'amount' => $amount,
                'payment_method_id' => $paymentMethod->id,
            ]);

            // Create Payment Intent
            $paymentIntent = $this->stripe->paymentIntents->create([
                'amount' => $this->convertToStripeAmount($amount), // Convert dollars to cents
                'currency' => config('payment.default_currency', 'usd'),
                'customer' => $stripeCustomerId,
                'payment_method' => $paymentMethod->gateway_payment_method_id,
                'confirm' => true, // Automatically confirm the payment
                'automatic_payment_methods' => [
                    'enabled' => true,
                    'allow_redirects' => 'never', // API-only, no redirects
                ],
                'metadata' => array_merge($metadata, [
                    'organization_id' => $organization->id,
                    'payment_method_id' => $paymentMethod->id,
                ]),
            ], [
                'idempotency_key' => $idempotencyKey,
            ]);

            // Create transaction record
            $transaction = PaymentTransaction::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => 'stripe',
                'gateway_transaction_id' => $paymentIntent->id,
                'type' => 'payment',
                'status' => $this->mapStripeStatus($paymentIntent->status),
                'amount' => $amount,
                'currency' => $paymentIntent->currency,
                'metadata' => [
                    'stripe_payment_intent_id' => $paymentIntent->id,
                    'stripe_customer_id' => $stripeCustomerId,
                    'stripe_charge_id' => $paymentIntent->latest_charge ?? null,
                    'custom_metadata' => $metadata,
                ],
                'processed_at' => now(),
            ]);

            // Handle payment status
            if ($paymentIntent->status === 'succeeded') {
                Log::info('Payment succeeded', [
                    'organization_id' => $organization->id,
                    'payment_intent_id' => $paymentIntent->id,
                    'amount' => $amount,
                ]);

                return [
                    'success' => true,
                    'transaction_id' => $transaction->id,
                    'gateway_transaction_id' => $paymentIntent->id,
                    'amount' => $amount,
                    'status' => 'succeeded',
                ];

            } elseif ($paymentIntent->status === 'requires_action') {
                // 3D Secure authentication required
                Log::warning('Payment requires authentication', [
                    'payment_intent_id' => $paymentIntent->id,
                ]);

                return [
                    'success' => false,
                    'requires_action' => true,
                    'client_secret' => $paymentIntent->client_secret,
                    'status' => 'requires_action',
                ];

            } else {
                throw new PaymentException("Payment failed with status: {$paymentIntent->status}");
            }

        } catch (ApiErrorException $e) {
            Log::error('Payment processing failed', [
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
                'stripe_code' => $e->getStripeCode(),
            ]);

            // Create failed transaction record
            PaymentTransaction::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => 'stripe',
                'type' => 'payment',
                'status' => 'failed',
                'amount' => $amount,
                'currency' => config('payment.default_currency', 'usd'),
                'error_message' => $e->getMessage(),
                'processed_at' => now(),
            ]);

            throw new PaymentException(
                "Payment failed: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Create subscription with Stripe
     *
     * @param Organization $organization
     * @param PaymentMethod $paymentMethod
     * @param string $planId Stripe price ID (e.g., 'price_xxx')
     * @param array $options ['trial_days', 'quantity', 'metadata', 'proration_behavior']
     * @return OrganizationSubscription
     * @throws PaymentException
     */
    public function createSubscription(
        Organization $organization,
        PaymentMethod $paymentMethod,
        string $planId,
        array $options = []
    ): OrganizationSubscription {
        try {
            $stripeCustomerId = $this->ensureCustomerExists($organization);

            Log::info('Creating Stripe subscription', [
                'organization_id' => $organization->id,
                'plan_id' => $planId,
            ]);

            $subscriptionData = [
                'customer' => $stripeCustomerId,
                'items' => [
                    [
                        'price' => $planId,
                        'quantity' => $options['quantity'] ?? 1,
                    ],
                ],
                'default_payment_method' => $paymentMethod->gateway_payment_method_id,
                'metadata' => array_merge($options['metadata'] ?? [], [
                    'organization_id' => $organization->id,
                    'payment_method_id' => $paymentMethod->id,
                ]),
            ];

            // Add trial period if specified
            if (isset($options['trial_days']) && $options['trial_days'] > 0) {
                $subscriptionData['trial_period_days'] = $options['trial_days'];
            }

            // Proration behavior for mid-cycle changes
            if (isset($options['proration_behavior'])) {
                $subscriptionData['proration_behavior'] = $options['proration_behavior'];
            }

            // Create subscription in Stripe
            $stripeSubscription = $this->stripe->subscriptions->create($subscriptionData);

            // Create subscription record in database
            $subscription = OrganizationSubscription::create([
                'organization_id' => $organization->id,
                'payment_method_id' => $paymentMethod->id,
                'gateway' => 'stripe',
                'gateway_subscription_id' => $stripeSubscription->id,
                'plan_id' => $planId,
                'status' => $this->mapSubscriptionStatus($stripeSubscription->status),
                'quantity' => $options['quantity'] ?? 1,
                'trial_ends_at' => $stripeSubscription->trial_end ?
                    now()->createFromTimestamp($stripeSubscription->trial_end) : null,
                'current_period_start' => now()->createFromTimestamp($stripeSubscription->current_period_start),
                'current_period_end' => now()->createFromTimestamp($stripeSubscription->current_period_end),
                'metadata' => [
                    'stripe_subscription_id' => $stripeSubscription->id,
                    'stripe_customer_id' => $stripeCustomerId,
                    'stripe_price_id' => $planId,
                ],
            ]);

            Log::info('Subscription created', [
                'organization_id' => $organization->id,
                'subscription_id' => $subscription->id,
                'stripe_subscription_id' => $stripeSubscription->id,
            ]);

            return $subscription;

        } catch (ApiErrorException $e) {
            Log::error('Subscription creation failed', [
                'organization_id' => $organization->id,
                'plan_id' => $planId,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to create subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Update subscription (change plan, quantity, etc.)
     *
     * @param OrganizationSubscription $subscription
     * @param array $updates ['plan_id', 'quantity', 'proration_behavior']
     * @return OrganizationSubscription
     * @throws PaymentException
     */
    public function updateSubscription(
        OrganizationSubscription $subscription,
        array $updates
    ): OrganizationSubscription {
        try {
            Log::info('Updating Stripe subscription', [
                'subscription_id' => $subscription->id,
                'stripe_subscription_id' => $subscription->gateway_subscription_id,
                'updates' => $updates,
            ]);

            $stripeSubscription = $this->stripe->subscriptions->retrieve(
                $subscription->gateway_subscription_id
            );

            $updateData = [];

            // Update plan (price)
            if (isset($updates['plan_id'])) {
                $updateData['items'] = [
                    [
                        'id' => $stripeSubscription->items->data[0]->id,
                        'price' => $updates['plan_id'],
                    ],
                ];
            }

            // Update quantity
            if (isset($updates['quantity'])) {
                $updateData['items'] = [
                    [
                        'id' => $stripeSubscription->items->data[0]->id,
                        'quantity' => $updates['quantity'],
                    ],
                ];
            }

            // Proration behavior
            if (isset($updates['proration_behavior'])) {
                $updateData['proration_behavior'] = $updates['proration_behavior'];
            } else {
                $updateData['proration_behavior'] = 'create_prorations'; // Default: prorate charges
            }

            // Update in Stripe
            $updatedSubscription = $this->stripe->subscriptions->update(
                $subscription->gateway_subscription_id,
                $updateData
            );

            // Update local database record
            $subscription->update([
                'plan_id' => $updates['plan_id'] ?? $subscription->plan_id,
                'quantity' => $updates['quantity'] ?? $subscription->quantity,
                'status' => $this->mapSubscriptionStatus($updatedSubscription->status),
                'current_period_start' => now()->createFromTimestamp($updatedSubscription->current_period_start),
                'current_period_end' => now()->createFromTimestamp($updatedSubscription->current_period_end),
            ]);

            Log::info('Subscription updated', [
                'subscription_id' => $subscription->id,
            ]);

            return $subscription->fresh();

        } catch (ApiErrorException $e) {
            Log::error('Subscription update failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to update subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Cancel subscription
     *
     * @param OrganizationSubscription $subscription
     * @param bool $immediately Cancel immediately or at period end
     * @return OrganizationSubscription
     * @throws PaymentException
     */
    public function cancelSubscription(
        OrganizationSubscription $subscription,
        bool $immediately = false
    ): OrganizationSubscription {
        try {
            Log::info('Canceling Stripe subscription', [
                'subscription_id' => $subscription->id,
                'immediately' => $immediately,
            ]);

            if ($immediately) {
                // Cancel immediately
                $this->stripe->subscriptions->cancel(
                    $subscription->gateway_subscription_id
                );

                $subscription->update([
                    'status' => 'cancelled',
                    'cancelled_at' => now(),
                    'ends_at' => now(),
                ]);

            } else {
                // Cancel at period end
                $this->stripe->subscriptions->update(
                    $subscription->gateway_subscription_id,
                    ['cancel_at_period_end' => true]
                );

                $subscription->update([
                    'status' => 'active', // Still active until period ends
                    'cancelled_at' => now(),
                    'ends_at' => $subscription->current_period_end,
                ]);
            }

            Log::info('Subscription cancelled', [
                'subscription_id' => $subscription->id,
            ]);

            return $subscription->fresh();

        } catch (ApiErrorException $e) {
            Log::error('Subscription cancellation failed', [
                'subscription_id' => $subscription->id,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Failed to cancel subscription: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Refund payment (full or partial)
     *
     * @param string $transactionId Local transaction ID
     * @param float|null $amount Amount to refund (null = full refund)
     * @param string $reason Refund reason
     * @return array Refund result
     * @throws PaymentException
     */
    public function refundPayment(
        string $transactionId,
        ?float $amount = null,
        string $reason = 'requested_by_customer'
    ): array {
        try {
            $transaction = PaymentTransaction::findOrFail($transactionId);

            Log::info('Processing refund', [
                'transaction_id' => $transactionId,
                'amount' => $amount,
                'reason' => $reason,
            ]);

            $refundData = [
                'payment_intent' => $transaction->gateway_transaction_id,
                'reason' => $this->mapRefundReason($reason),
            ];

            // Partial refund
            if ($amount !== null) {
                $refundData['amount'] = $this->convertToStripeAmount($amount);
            }

            // Create refund in Stripe
            $refund = $this->stripe->refunds->create($refundData);

            // Create refund transaction record
            $refundTransaction = PaymentTransaction::create([
                'organization_id' => $transaction->organization_id,
                'payment_method_id' => $transaction->payment_method_id,
                'gateway' => 'stripe',
                'gateway_transaction_id' => $refund->id,
                'type' => 'refund',
                'status' => $this->mapStripeStatus($refund->status),
                'amount' => -($amount ?? $transaction->amount), // Negative amount for refunds
                'currency' => $refund->currency,
                'metadata' => [
                    'original_transaction_id' => $transactionId,
                    'stripe_refund_id' => $refund->id,
                    'reason' => $reason,
                ],
                'processed_at' => now(),
            ]);

            Log::info('Refund processed', [
                'refund_transaction_id' => $refundTransaction->id,
                'stripe_refund_id' => $refund->id,
            ]);

            return [
                'success' => true,
                'refund_id' => $refundTransaction->id,
                'gateway_refund_id' => $refund->id,
                'amount' => $amount ?? $transaction->amount,
                'status' => $refund->status,
            ];

        } catch (ApiErrorException $e) {
            Log::error('Refund failed', [
                'transaction_id' => $transactionId,
                'error' => $e->getMessage(),
            ]);

            throw new PaymentException(
                "Refund failed: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Get payment method details from Stripe
     *
     * @param string $paymentMethodId Stripe payment method ID
     * @return array Payment method details
     * @throws PaymentException
     */
    public function getPaymentMethod(string $paymentMethodId): array
    {
        try {
            $paymentMethod = $this->stripe->paymentMethods->retrieve($paymentMethodId);

            return [
                'id' => $paymentMethod->id,
                'type' => $paymentMethod->type,
                'card' => $paymentMethod->card ? [
                    'brand' => $paymentMethod->card->brand,
                    'last4' => $paymentMethod->card->last4,
                    'exp_month' => $paymentMethod->card->exp_month,
                    'exp_year' => $paymentMethod->card->exp_year,
                    'country' => $paymentMethod->card->country,
                ] : null,
                'us_bank_account' => $paymentMethod->us_bank_account ? [
                    'bank_name' => $paymentMethod->us_bank_account->bank_name,
                    'last4' => $paymentMethod->us_bank_account->last4,
                    'account_type' => $paymentMethod->us_bank_account->account_type,
                ] : null,
            ];

        } catch (ApiErrorException $e) {
            throw new PaymentException(
                "Failed to retrieve payment method: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    /**
     * Handle incoming Stripe webhook
     *
     * @param array $payload Raw webhook payload
     * @param string $signature Stripe signature header
     * @return void
     * @throws PaymentException
     */
    public function handleWebhook(array $payload, string $signature): void
    {
        // Signature verification handled in verifyWebhookSignature()

        $event = $payload['type'] ?? null;

        if (!$event) {
            Log::warning('Webhook received without event type', ['payload' => $payload]);
            return;
        }

        Log::info('Processing Stripe webhook', ['event' => $event]);

        // Route to appropriate handler
        match ($event) {
            'payment_intent.succeeded' => $this->handlePaymentSucceeded($payload['data']['object']),
            'payment_intent.payment_failed' => $this->handlePaymentFailed($payload['data']['object']),
            'customer.subscription.created' => $this->handleSubscriptionCreated($payload['data']['object']),
            'customer.subscription.updated' => $this->handleSubscriptionUpdated($payload['data']['object']),
            'customer.subscription.deleted' => $this->handleSubscriptionDeleted($payload['data']['object']),
            'invoice.payment_succeeded' => $this->handleInvoicePaymentSucceeded($payload['data']['object']),
            'invoice.payment_failed' => $this->handleInvoicePaymentFailed($payload['data']['object']),
            'charge.refunded' => $this->handleChargeRefunded($payload['data']['object']),
            'charge.dispute.created' => $this->handleDisputeCreated($payload['data']['object']),
            default => Log::info('Unhandled Stripe webhook event', ['event' => $event]),
        };
    }

    /**
     * Verify Stripe webhook signature (HMAC validation)
     *
     * @param string $payload Raw webhook payload
     * @param string $signature Stripe-Signature header
     * @return bool
     */
    public function verifyWebhookSignature(string $payload, string $signature): bool
    {
        try {
            $webhookSecret = config('payment.gateways.stripe.webhook_secret');

            if (!$webhookSecret) {
                Log::error('Stripe webhook secret not configured');
                return false;
            }

            Webhook::constructEvent($payload, $signature, $webhookSecret);

            return true;

        } catch (SignatureVerificationException $e) {
            Log::error('Stripe webhook signature verification failed', [
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Get Stripe customer portal URL
     *
     * @param Organization $organization
     * @param string $returnUrl URL to redirect after portal session
     * @return string Portal URL
     * @throws PaymentException
     */
    public function getCustomerPortalUrl(Organization $organization, string $returnUrl): string
    {
        try {
            $stripeCustomerId = $this->ensureCustomerExists($organization);

            $session = $this->stripe->billingPortal->sessions->create([
                'customer' => $stripeCustomerId,
                'return_url' => $returnUrl,
            ]);

            return $session->url;

        } catch (ApiErrorException $e) {
            throw new PaymentException(
                "Failed to create customer portal session: {$e->getMessage()}",
                $e->getCode(),
                $e
            );
        }
    }

    // Private helper methods

    private function ensureCustomerExists(Organization $organization): string
    {
        if (!$organization->stripe_customer_id) {
            $customer = $this->createCustomer($organization, [
                'email' => $organization->users()->first()->email ?? "org-{$organization->id}@coolify.io",
                'name' => $organization->name,
            ]);

            return $customer['id'];
        }

        return $organization->stripe_customer_id;
    }

    private function convertToStripeAmount(float $amount): int
    {
        // Convert dollars to cents
        return (int) round($amount * 100);
    }

    private function generateIdempotencyKey(array $data): string
    {
        return 'coolify_' . md5(json_encode($data));
    }

    private function mapStripeStatus(string $stripeStatus): string
    {
        return match ($stripeStatus) {
            'succeeded' => 'completed',
            'processing' => 'processing',
            'requires_action' => 'pending',
            'requires_payment_method' => 'pending',
            'canceled' => 'cancelled',
            'failed' => 'failed',
            default => $stripeStatus,
        };
    }

    private function mapSubscriptionStatus(string $stripeStatus): string
    {
        return match ($stripeStatus) {
            'active' => 'active',
            'past_due' => 'past_due',
            'unpaid' => 'unpaid',
            'canceled' => 'cancelled',
            'incomplete' => 'pending',
            'incomplete_expired' => 'failed',
            'trialing' => 'trialing',
            default => $stripeStatus,
        };
    }

    private function mapRefundReason(string $reason): string
    {
        return match ($reason) {
            'duplicate' => 'duplicate',
            'fraudulent' => 'fraudulent',
            'requested_by_customer' => 'requested_by_customer',
            default => 'requested_by_customer',
        };
    }

    // Webhook event handlers

    private function handlePaymentSucceeded(array $paymentIntent): void
    {
        $transaction = PaymentTransaction::where('gateway_transaction_id', $paymentIntent['id'])->first();

        if ($transaction) {
            $transaction->update(['status' => 'completed']);
        }

        Log::info('Payment succeeded webhook processed', [
            'payment_intent_id' => $paymentIntent['id'],
        ]);
    }

    private function handlePaymentFailed(array $paymentIntent): void
    {
        $transaction = PaymentTransaction::where('gateway_transaction_id', $paymentIntent['id'])->first();

        if ($transaction) {
            $transaction->update([
                'status' => 'failed',
                'error_message' => $paymentIntent['last_payment_error']['message'] ?? 'Payment failed',
            ]);
        }

        Log::warning('Payment failed webhook processed', [
            'payment_intent_id' => $paymentIntent['id'],
            'error' => $paymentIntent['last_payment_error']['message'] ?? 'Unknown error',
        ]);
    }

    private function handleSubscriptionCreated(array $subscription): void
    {
        Log::info('Subscription created webhook', [
            'subscription_id' => $subscription['id'],
        ]);

        // Subscription already created in createSubscription(), just log
    }

    private function handleSubscriptionUpdated(array $subscription): void
    {
        $localSubscription = OrganizationSubscription::where(
            'gateway_subscription_id',
            $subscription['id']
        )->first();

        if ($localSubscription) {
            $localSubscription->update([
                'status' => $this->mapSubscriptionStatus($subscription['status']),
                'current_period_start' => now()->createFromTimestamp($subscription['current_period_start']),
                'current_period_end' => now()->createFromTimestamp($subscription['current_period_end']),
            ]);
        }

        Log::info('Subscription updated webhook processed', [
            'subscription_id' => $subscription['id'],
        ]);
    }

    private function handleSubscriptionDeleted(array $subscription): void
    {
        $localSubscription = OrganizationSubscription::where(
            'gateway_subscription_id',
            $subscription['id']
        )->first();

        if ($localSubscription) {
            $localSubscription->update([
                'status' => 'cancelled',
                'cancelled_at' => now(),
                'ends_at' => now(),
            ]);
        }

        Log::info('Subscription deleted webhook processed', [
            'subscription_id' => $subscription['id'],
        ]);
    }

    private function handleInvoicePaymentSucceeded(array $invoice): void
    {
        Log::info('Invoice payment succeeded', [
            'invoice_id' => $invoice['id'],
            'subscription_id' => $invoice['subscription'] ?? null,
        ]);

        // Update subscription if exists
        if ($invoice['subscription']) {
            $subscription = OrganizationSubscription::where(
                'gateway_subscription_id',
                $invoice['subscription']
            )->first();

            if ($subscription) {
                $subscription->update(['status' => 'active']);
            }
        }
    }

    private function handleInvoicePaymentFailed(array $invoice): void
    {
        Log::warning('Invoice payment failed', [
            'invoice_id' => $invoice['id'],
            'subscription_id' => $invoice['subscription'] ?? null,
        ]);

        // Update subscription to past_due if exists
        if ($invoice['subscription']) {
            $subscription = OrganizationSubscription::where(
                'gateway_subscription_id',
                $invoice['subscription']
            )->first();

            if ($subscription) {
                $subscription->update(['status' => 'past_due']);
            }
        }
    }

    private function handleChargeRefunded(array $charge): void
    {
        Log::info('Charge refunded webhook', [
            'charge_id' => $charge['id'],
            'refunded' => $charge['refunded'],
        ]);

        // Refund already handled in refundPayment(), just log
    }

    private function handleDisputeCreated(array $dispute): void
    {
        Log::warning('Dispute created', [
            'dispute_id' => $dispute['id'],
            'charge_id' => $dispute['charge'],
            'reason' => $dispute['reason'],
            'amount' => $dispute['amount'],
        ]);

        // TODO: Notify admins about dispute
    }
}
```

### StripeWebhookController

**File:** `app/Http/Controllers/Enterprise/StripeWebhookController.php`

```php
<?php

namespace App\Http\Controllers\Enterprise;

use App\Http\Controllers\Controller;
use App\Contracts\PaymentGatewayInterface;
use App\Services\Enterprise\Payment\StripePaymentGateway;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;

class StripeWebhookController extends Controller
{
    public function __construct(
        private StripePaymentGateway $stripe
    ) {}

    /**
     * Handle incoming Stripe webhook
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function handle(Request $request): JsonResponse
    {
        $payload = $request->getContent();
        $signature = $request->header('Stripe-Signature');

        if (!$signature) {
            Log::warning('Stripe webhook received without signature');
            return response()->json(['error' => 'No signature'], 400);
        }

        // Verify webhook signature
        if (!$this->stripe->verifyWebhookSignature($payload, $signature)) {
            Log::error('Stripe webhook signature verification failed', [
                'signature' => $signature,
            ]);

            return response()->json(['error' => 'Invalid signature'], 401);
        }

        try {
            $payloadArray = json_decode($payload, true);

            // Handle webhook event
            $this->stripe->handleWebhook($payloadArray, $signature);

            Log::info('Stripe webhook processed successfully', [
                'event_type' => $payloadArray['type'] ?? 'unknown',
            ]);

            return response()->json(['success' => true]);

        } catch (\Exception $e) {
            Log::error('Stripe webhook processing failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            // Return 200 to prevent Stripe from retrying
            // We log the error for manual investigation
            return response()->json(['success' => false, 'error' => $e->getMessage()]);
        }
    }
}
```

### Routes

**File:** `routes/webhooks.php`

```php
<?php

use App\Http\Controllers\Enterprise\StripeWebhookController;
use Illuminate\Support\Facades\Route;

// Stripe webhook endpoint (no auth middleware - verified via signature)
Route::post('/webhooks/stripe', [StripeWebhookController::class, 'handle'])
    ->name('webhooks.stripe');
```

### Configuration Updates

**File:** `config/payment.php` (add Stripe configuration)

```php
<?php

return [
    'default_gateway' => env('PAYMENT_DEFAULT_GATEWAY', 'stripe'),

    'default_currency' => env('PAYMENT_DEFAULT_CURRENCY', 'usd'),

    'gateways' => [
        'stripe' => [
            'enabled' => env('STRIPE_ENABLED', true),
            'secret_key' => env('STRIPE_SECRET_KEY'),
            'publishable_key' => env('STRIPE_PUBLISHABLE_KEY'),
            'webhook_secret' => env('STRIPE_WEBHOOK_SECRET'),
            'api_version' => '2024-11-20.acacia',
        ],

        'paypal' => [
            'enabled' => env('PAYPAL_ENABLED', false),
            'client_id' => env('PAYPAL_CLIENT_ID'),
            'client_secret' => env('PAYPAL_CLIENT_SECRET'),
            'mode' => env('PAYPAL_MODE', 'sandbox'), // 'sandbox' or 'live'
        ],
    ],
];
```

### Dependencies

Add Stripe PHP SDK to `composer.json`:

```bash
composer require stripe/stripe-php
```

### Environment Variables

Add to `.env`:

```bash
# Stripe Configuration
STRIPE_ENABLED=true
STRIPE_SECRET_KEY=sk_test_xxx  # Use sk_live_xxx for production
STRIPE_PUBLISHABLE_KEY=pk_test_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx  # From Stripe Dashboard â†’ Webhooks
```

## Implementation Approach

### Step 1: Install Dependencies
```bash
composer require stripe/stripe-php
```

### Step 2: Update Configuration
1. Add Stripe configuration to `config/payment.php`
2. Add environment variables to `.env` and `.env.example`
3. Document Stripe API key requirements

### Step 3: Create StripePaymentGateway Service
1. Create `app/Services/Enterprise/Payment/StripePaymentGateway.php`
2. Implement all methods from `PaymentGatewayInterface`
3. Add comprehensive error handling with try-catch blocks
4. Implement private helper methods for common operations

### Step 4: Implement Core Payment Methods
1. `createCustomer()` - Stripe customer creation with metadata
2. `addPaymentMethod()` - Payment method attachment with default setting
3. `processPayment()` - Payment Intent API with 3D Secure support
4. Implement idempotency key generation for safe retries

### Step 5: Implement Subscription Methods
1. `createSubscription()` - Subscription creation with trial support
2. `updateSubscription()` - Plan changes with proration
3. `cancelSubscription()` - Immediate or end-of-period cancellation
4. Map Stripe subscription statuses to local statuses

### Step 6: Implement Webhook System
1. Create `StripeWebhookController`
2. Implement webhook signature verification using Stripe SDK
3. Add webhook event handlers for all critical events
4. Create webhook route in `routes/webhooks.php`

### Step 7: Add Customer Portal
1. Implement `getCustomerPortalUrl()` method
2. Create Billing Portal session with return URL
3. Test portal functionality in Stripe Dashboard

### Step 8: Testing
1. Unit tests for all service methods with Stripe API mocking
2. Integration tests using Stripe test mode API
3. Webhook tests with signature validation
4. Test all payment scenarios (success, failure, 3D Secure)

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/StripePaymentGatewayTest.php`

```php
<?php

use App\Services\Enterprise\Payment\StripePaymentGateway;
use App\Models\Organization;
use App\Models\PaymentMethod;
use App\Models\OrganizationSubscription;
use Stripe\StripeClient;
use Illuminate\Support\Facades\Config;

beforeEach(function () {
    Config::set('payment.gateways.stripe.secret_key', 'sk_test_mock');
    Config::set('payment.gateways.stripe.webhook_secret', 'whsec_mock');

    $this->gateway = app(StripePaymentGateway::class);
});

it('creates Stripe customer', function () {
    $organization = Organization::factory()->create();

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('customers->create')
            ->once()
            ->andReturn((object) [
                'id' => 'cus_test123',
                'email' => 'test@example.com',
                'created' => now()->timestamp,
            ]);
    });

    $customer = $this->gateway->createCustomer($organization, [
        'email' => 'test@example.com',
        'name' => 'Test Organization',
    ]);

    expect($customer)
        ->toHaveKey('id', 'cus_test123')
        ->and($organization->fresh()->stripe_customer_id)->toBe('cus_test123');
});

it('processes payment with Payment Intent', function () {
    $organization = Organization::factory()->create(['stripe_customer_id' => 'cus_test123']);
    $paymentMethod = PaymentMethod::factory()->create([
        'organization_id' => $organization->id,
        'gateway_payment_method_id' => 'pm_test123',
    ]);

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('paymentIntents->create')
            ->once()
            ->andReturn((object) [
                'id' => 'pi_test123',
                'status' => 'succeeded',
                'currency' => 'usd',
                'latest_charge' => 'ch_test123',
            ]);
    });

    $result = $this->gateway->processPayment($organization, $paymentMethod, 99.99);

    expect($result)
        ->toHaveKey('success', true)
        ->toHaveKey('amount', 99.99)
        ->toHaveKey('status', 'succeeded');

    $this->assertDatabaseHas('payment_transactions', [
        'organization_id' => $organization->id,
        'gateway_transaction_id' => 'pi_test123',
        'status' => 'completed',
        'amount' => 99.99,
    ]);
});

it('creates subscription with trial period', function () {
    $organization = Organization::factory()->create(['stripe_customer_id' => 'cus_test123']);
    $paymentMethod = PaymentMethod::factory()->create([
        'organization_id' => $organization->id,
        'gateway_payment_method_id' => 'pm_test123',
    ]);

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('subscriptions->create')
            ->once()
            ->andReturn((object) [
                'id' => 'sub_test123',
                'status' => 'trialing',
                'trial_end' => now()->addDays(14)->timestamp,
                'current_period_start' => now()->timestamp,
                'current_period_end' => now()->addMonth()->timestamp,
            ]);
    });

    $subscription = $this->gateway->createSubscription(
        $organization,
        $paymentMethod,
        'price_test123',
        ['trial_days' => 14]
    );

    expect($subscription)
        ->toBeInstanceOf(OrganizationSubscription::class)
        ->status->toBe('trialing')
        ->and($subscription->trial_ends_at)->not->toBeNull();
});

it('updates subscription plan with proration', function () {
    $subscription = OrganizationSubscription::factory()->create([
        'gateway_subscription_id' => 'sub_test123',
        'plan_id' => 'price_old',
    ]);

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('subscriptions->retrieve')
            ->once()
            ->andReturn((object) [
                'id' => 'sub_test123',
                'items' => (object) [
                    'data' => [
                        (object) ['id' => 'si_test123'],
                    ],
                ],
            ]);

        $mock->shouldReceive('subscriptions->update')
            ->once()
            ->andReturn((object) [
                'id' => 'sub_test123',
                'status' => 'active',
                'current_period_start' => now()->timestamp,
                'current_period_end' => now()->addMonth()->timestamp,
            ]);
    });

    $updated = $this->gateway->updateSubscription($subscription, [
        'plan_id' => 'price_new',
        'proration_behavior' => 'create_prorations',
    ]);

    expect($updated->plan_id)->toBe('price_new');
});

it('cancels subscription immediately', function () {
    $subscription = OrganizationSubscription::factory()->create([
        'gateway_subscription_id' => 'sub_test123',
        'status' => 'active',
    ]);

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('subscriptions->cancel')
            ->once()
            ->andReturn((object) [
                'id' => 'sub_test123',
                'status' => 'canceled',
            ]);
    });

    $cancelled = $this->gateway->cancelSubscription($subscription, immediately: true);

    expect($cancelled->status)->toBe('cancelled')
        ->and($cancelled->cancelled_at)->not->toBeNull()
        ->and($cancelled->ends_at)->not->toBeNull();
});

it('processes refund', function () {
    $transaction = PaymentTransaction::factory()->create([
        'gateway_transaction_id' => 'pi_test123',
        'amount' => 99.99,
    ]);

    // Mock Stripe API
    $this->mock(StripeClient::class, function ($mock) {
        $mock->shouldReceive('refunds->create')
            ->once()
            ->andReturn((object) [
                'id' => 're_test123',
                'status' => 'succeeded',
                'currency' => 'usd',
            ]);
    });

    $result = $this->gateway->refundPayment($transaction->id, amount: 49.99);

    expect($result)
        ->toHaveKey('success', true)
        ->toHaveKey('amount', 49.99);

    $this->assertDatabaseHas('payment_transactions', [
        'gateway_transaction_id' => 're_test123',
        'type' => 'refund',
        'amount' => -49.99,
    ]);
});

it('verifies webhook signature correctly', function () {
    $payload = json_encode(['type' => 'payment_intent.succeeded', 'data' => []]);
    $secret = 'whsec_test';
    $timestamp = time();

    Config::set('payment.gateways.stripe.webhook_secret', $secret);

    // Create valid signature
    $signedPayload = "{$timestamp}.{$payload}";
    $signature = hash_hmac('sha256', $signedPayload, $secret);
    $header = "t={$timestamp},v1={$signature}";

    $result = $this->gateway->verifyWebhookSignature($payload, $header);

    expect($result)->toBeTrue();
});

it('converts dollars to cents correctly', function () {
    $gateway = new StripePaymentGateway();
    $reflection = new \ReflectionClass($gateway);
    $method = $reflection->getMethod('convertToStripeAmount');
    $method->setAccessible(true);

    expect($method->invoke($gateway, 99.99))->toBe(9999)
        ->and($method->invoke($gateway, 100.00))->toBe(10000)
        ->and($method->invoke($gateway, 1.50))->toBe(150);
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/StripeIntegrationTest.php`

```php
<?php

use App\Services\Enterprise\Payment\StripePaymentGateway;
use App\Models\Organization;
use App\Models\PaymentMethod;
use Illuminate\Support\Facades\Config;

it('completes full payment workflow with Stripe test mode', function () {
    // Use Stripe test keys
    Config::set('payment.gateways.stripe.secret_key', env('STRIPE_TEST_SECRET_KEY'));
    Config::set('payment.gateways.stripe.publishable_key', env('STRIPE_TEST_PUBLISHABLE_KEY'));

    $organization = Organization::factory()->create();
    $gateway = app(StripePaymentGateway::class);

    // Create customer
    $customer = $gateway->createCustomer($organization, [
        'email' => 'test@example.com',
        'name' => 'Test Organization',
    ]);

    expect($customer)->toHaveKey('id')
        ->and($organization->fresh()->stripe_customer_id)->not->toBeNull();

    // Add test payment method (use Stripe test card)
    $paymentMethod = $gateway->addPaymentMethod($organization, [
        'payment_method_id' => 'pm_card_visa', // Stripe test card
        'type' => 'card',
    ]);

    expect($paymentMethod)->toBeInstanceOf(PaymentMethod::class)
        ->and($paymentMethod->gateway)->toBe('stripe');

    // Process payment
    $result = $gateway->processPayment($organization, $paymentMethod, 50.00);

    expect($result)->toHaveKey('success', true)
        ->toHaveKey('status', 'succeeded');
})->skip(!env('STRIPE_TEST_SECRET_KEY'), 'Stripe test keys not configured');

it('handles webhook events correctly', function () {
    $payload = [
        'type' => 'payment_intent.succeeded',
        'data' => [
            'object' => [
                'id' => 'pi_test123',
                'status' => 'succeeded',
            ],
        ],
    ];

    $transaction = PaymentTransaction::factory()->create([
        'gateway_transaction_id' => 'pi_test123',
        'status' => 'processing',
    ]);

    $gateway = app(StripePaymentGateway::class);

    // Mock signature verification
    $this->partialMock(StripePaymentGateway::class, function ($mock) {
        $mock->shouldReceive('verifyWebhookSignature')->andReturn(true);
    });

    $gateway->handleWebhook($payload, 'mock_signature');

    $transaction->refresh();
    expect($transaction->status)->toBe('completed');
});
```

### Webhook Tests

**File:** `tests/Feature/Enterprise/StripeWebhookTest.php`

```php
<?php

use App\Models\PaymentTransaction;
use App\Models\OrganizationSubscription;

it('processes payment succeeded webhook', function () {
    $transaction = PaymentTransaction::factory()->create([
        'gateway_transaction_id' => 'pi_webhook_test',
        'status' => 'processing',
    ]);

    $payload = [
        'type' => 'payment_intent.succeeded',
        'data' => [
            'object' => [
                'id' => 'pi_webhook_test',
                'status' => 'succeeded',
            ],
        ],
    ];

    $signature = 'valid_signature'; // Mock signature

    // Mock webhook verification
    $this->partialMock(StripePaymentGateway::class, function ($mock) {
        $mock->shouldReceive('verifyWebhookSignature')->andReturn(true);
    });

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $signature,
    ])->assertOk();

    $transaction->refresh();
    expect($transaction->status)->toBe('completed');
});

it('rejects webhook with invalid signature', function () {
    $payload = ['type' => 'payment_intent.succeeded', 'data' => []];

    $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => 'invalid_signature',
    ])->assertStatus(401);
});
```

## Definition of Done

- [ ] StripePaymentGateway class created implementing PaymentGatewayInterface
- [ ] Stripe PHP SDK installed (`stripe/stripe-php`)
- [ ] Configuration added to `config/payment.php` with Stripe settings
- [ ] Environment variables documented in `.env.example`
- [ ] `createCustomer()` method implemented with metadata
- [ ] `addPaymentMethod()` method implemented with default setting
- [ ] `processPayment()` method implemented using Payment Intent API
- [ ] 3D Secure/SCA support working with Payment Intents
- [ ] `createSubscription()` method implemented with trial support
- [ ] `updateSubscription()` method implemented with proration
- [ ] `cancelSubscription()` method implemented (immediate + end-of-period)
- [ ] `refundPayment()` method implemented (full + partial refunds)
- [ ] `getPaymentMethod()` method implemented
- [ ] `getCustomerPortalUrl()` method implemented
- [ ] StripeWebhookController created with signature verification
- [ ] Webhook signature verification working with HMAC validation
- [ ] Webhook event handlers implemented for all critical events
- [ ] Webhook route registered in `routes/webhooks.php`
- [ ] Idempotency key generation implemented for safe retries
- [ ] Error handling comprehensive with Stripe-specific exceptions
- [ ] Payment transaction logging working for all operations
- [ ] Stripe customer creation and synchronization with Organization
- [ ] Service registered in `EnterpriseServiceProvider`
- [ ] Unit tests written (15+ tests, >90% coverage)
- [ ] Integration tests written with Stripe test mode (5+ tests)
- [ ] Webhook tests written with signature validation (5+ tests)
- [ ] Manual testing completed with Stripe Dashboard
- [ ] Code follows Laravel 12 and PSR-12 standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Documentation updated with Stripe setup instructions
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 43 (PaymentGatewayInterface and factory pattern)
- **Depends on:** Task 42 (Database schema for payments and subscriptions)
- **Integrates with:** Task 46 (PaymentService orchestration layer)
- **Integrates with:** Task 47 (Webhook handling system)
- **Parallel with:** Task 45 (PayPal gateway integration)
- **Used by:** Task 50 (Vue.js payment components)
- **Tested by:** Task 51 (Payment testing infrastructure)
