---
name: Implement Terraform state file encryption, storage, and backup mechanism
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:36Z
github: https://github.com/johnproblems/topgun/issues/127
depends_on: [14]
parallel: false
conflicts_with: []
---

# Task: Implement Terraform state file encryption, storage, and backup mechanism

## Description

Implement a comprehensive Terraform state file management system that securely stores, encrypts, and backs up infrastructure state files. This system is critical for maintaining infrastructure consistency, enabling team collaboration, and providing disaster recovery capabilities for the Terraform-driven provisioning system.

**The State File Challenge:**

Terraform state files contain the complete representation of managed infrastructure including:
- Resource IDs (server instance IDs, IP addresses, security group IDs)
- Sensitive data (private keys, database passwords, API tokens)
- Dependency graph for infrastructure components
- Resource metadata critical for updates and destruction

Without proper state management, organizations face:
1. **Lost Infrastructure Tracking**: Cannot update or destroy previously created resources
2. **Security Risks**: State files in plain text expose credentials and infrastructure details
3. **Team Conflicts**: Multiple users modifying state simultaneously causes corruption
4. **Disaster Scenarios**: Accidental deletion means permanent loss of infrastructure mapping

**The Solution Architecture:**

This task implements a multi-layered state management system:

1. **AES-256 Encryption**: All state files encrypted at rest using Laravel's encryption with key rotation support
2. **Database Storage**: Encrypted state stored in `terraform_deployments.state_file` JSONB column with versioning
3. **S3-Compatible Backup**: Automatic backup to object storage (MinIO, AWS S3, DigitalOcean Spaces) with retention policies
4. **State Locking**: Redis-based distributed locks prevent concurrent modifications and corruption
5. **Version Control**: Maintain state file history for rollback capabilities
6. **Checksum Verification**: SHA-256 checksums ensure state file integrity
7. **Automatic Recovery**: Restore from backup on corruption detection

**Integration Points:**

- **TerraformService (Task 14)**: Consumes state management for all Terraform operations
- **TerraformDeploymentJob (Task 18)**: Uses locking during async provisioning
- **CloudProviderCredentials**: Encrypted alongside state files using same key management
- **Organization Scoping**: All state files organization-scoped with cascade deletion

**Why This Task is Critical:**

State file management is the foundation of reliable infrastructure automation. Without it, Terraform becomes a one-way toolâ€”you can create infrastructure but never safely update or destroy it. This implementation ensures organizations can confidently provision, modify, and tear down infrastructure with complete visibility and rollback capabilities. The encryption and backup layers provide enterprise-grade security and disaster recovery that's essential for production deployments.

## Acceptance Criteria

- [ ] State files encrypted with AES-256 before database storage
- [ ] Encrypted state stored in `terraform_deployments.state_file` JSONB column
- [ ] State file versioning implemented with rollback capability
- [ ] S3-compatible backup configured for all state file changes
- [ ] State locking mechanism using Redis prevents concurrent modifications
- [ ] SHA-256 checksum verification on all state read/write operations
- [ ] Automatic backup on state file updates with configurable retention
- [ ] State file corruption detection and automatic recovery from backup
- [ ] Key rotation capability for encryption keys without state loss
- [ ] Support for multiple backup storage backends (MinIO, AWS S3, DigitalOcean Spaces)
- [ ] State file compression before encryption to reduce storage costs
- [ ] Backup pruning based on retention policy (default: 30 versions, 90 days)
- [ ] Manual state file export/import for migrations
- [ ] Integration with TerraformService for transparent state management
- [ ] Organization-scoped state files with proper access control

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/TerraformStateManager.php` (new)
- `/home/topgun/topgun/app/Contracts/TerraformStateManagerInterface.php` (new)

**Storage Backends:**
- `/home/topgun/topgun/app/Services/Enterprise/StateStorage/S3StateStorage.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/StateStorage/MinioStateStorage.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/StateStorage/StateStorageInterface.php` (new)

**Artisan Commands:**
- `/home/topgun/topgun/app/Console/Commands/TerraformStateBackup.php` (new)
- `/home/topgun/topgun/app/Console/Commands/TerraformStateRestore.php` (new)
- `/home/topgun/topgun/app/Console/Commands/TerraformStatePrune.php` (new)

**Database Migration:**
- `/home/topgun/topgun/database/migrations/2025_xx_xx_add_state_file_columns_to_terraform_deployments.php` (new)

**Configuration:**
- `/home/topgun/topgun/config/terraform.php` (enhance existing)

### Database Schema Enhancement

**Migration File:** `database/migrations/2025_xx_xx_add_state_file_columns_to_terraform_deployments.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('terraform_deployments', function (Blueprint $table) {
            // Current state file (encrypted)
            $table->binary('state_file')->nullable()->after('output_data');

            // State file versioning
            $table->integer('state_version')->default(0)->after('state_file');
            $table->string('state_checksum', 64)->nullable()->after('state_version'); // SHA-256

            // State locking
            $table->string('state_lock_id', 36)->nullable()->after('state_checksum');
            $table->timestamp('state_locked_at')->nullable()->after('state_lock_id');
            $table->string('state_locked_by')->nullable()->after('state_locked_at'); // User email

            // Backup tracking
            $table->string('last_backup_path')->nullable()->after('state_locked_by');
            $table->timestamp('last_backup_at')->nullable()->after('last_backup_path');
            $table->integer('backup_version_count')->default(0)->after('last_backup_at');

            // Compression metadata
            $table->boolean('state_compressed')->default(true)->after('backup_version_count');
            $table->integer('state_size_bytes')->nullable()->after('state_compressed');

            // Indexes for performance
            $table->index('state_lock_id');
            $table->index('state_checksum');
            $table->index(['organization_id', 'state_version']);
        });

        // State file version history table
        Schema::create('terraform_state_versions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('terraform_deployment_id')->constrained()->cascadeOnDelete();
            $table->foreignId('organization_id')->constrained()->cascadeOnDelete();

            // Versioned state data
            $table->integer('version')->unsigned();
            $table->binary('state_file'); // Encrypted and compressed
            $table->string('checksum', 64); // SHA-256
            $table->integer('size_bytes');

            // Metadata
            $table->string('created_by')->nullable(); // User email
            $table->text('change_summary')->nullable(); // Terraform plan summary
            $table->string('backup_path')->nullable(); // S3/MinIO path

            $table->timestamps();

            // Indexes
            $table->unique(['terraform_deployment_id', 'version']);
            $table->index('checksum');
            $table->index('created_at'); // For pruning old versions
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('terraform_state_versions');

        Schema::table('terraform_deployments', function (Blueprint $table) {
            $table->dropColumn([
                'state_file',
                'state_version',
                'state_checksum',
                'state_lock_id',
                'state_locked_at',
                'state_locked_by',
                'last_backup_path',
                'last_backup_at',
                'backup_version_count',
                'state_compressed',
                'state_size_bytes',
            ]);
        });
    }
};
```

### TerraformStateManager Implementation

**File:** `app/Services/Enterprise/TerraformStateManager.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\TerraformStateManagerInterface;
use App\Models\TerraformDeployment;
use App\Models\TerraformStateVersion;
use App\Services\Enterprise\StateStorage\StateStorageInterface;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class TerraformStateManager implements TerraformStateManagerInterface
{
    private const LOCK_TTL = 300; // 5 minutes
    private const MAX_LOCK_RETRIES = 3;
    private const COMPRESSION_THRESHOLD = 1024; // Compress if > 1KB

    public function __construct(
        private StateStorageInterface $storage
    ) {}

    /**
     * Save Terraform state file with encryption, versioning, and backup
     *
     * @param TerraformDeployment $deployment
     * @param string $stateContent Raw Terraform state JSON
     * @param string|null $changeSummary Optional description of changes
     * @return bool
     * @throws \Exception
     */
    public function saveState(
        TerraformDeployment $deployment,
        string $stateContent,
        ?string $changeSummary = null
    ): bool {
        $lockId = $this->acquireLock($deployment);

        try {
            // Validate state file format
            $stateData = json_decode($stateContent, true);
            if (!$stateData || !isset($stateData['version'])) {
                throw new \InvalidArgumentException('Invalid Terraform state file format');
            }

            // Compress if beneficial
            $compressed = $this->shouldCompress($stateContent);
            $stateToStore = $compressed ? gzcompress($stateContent, 9) : $stateContent;

            // Encrypt state file
            $encryptedState = Crypt::encryptString($stateToStore);

            // Calculate checksum (before encryption)
            $checksum = hash('sha256', $stateContent);

            // Increment version
            $newVersion = $deployment->state_version + 1;

            // Backup to object storage
            $backupPath = $this->backupToStorage($deployment, $stateContent, $newVersion);

            // Save to database
            DB::transaction(function () use (
                $deployment,
                $encryptedState,
                $checksum,
                $newVersion,
                $backupPath,
                $compressed,
                $stateContent,
                $changeSummary
            ) {
                // Update current state
                $deployment->update([
                    'state_file' => $encryptedState,
                    'state_version' => $newVersion,
                    'state_checksum' => $checksum,
                    'state_compressed' => $compressed,
                    'state_size_bytes' => strlen($stateContent),
                    'last_backup_path' => $backupPath,
                    'last_backup_at' => now(),
                    'backup_version_count' => $deployment->backup_version_count + 1,
                ]);

                // Create version history entry
                TerraformStateVersion::create([
                    'terraform_deployment_id' => $deployment->id,
                    'organization_id' => $deployment->organization_id,
                    'version' => $newVersion,
                    'state_file' => $encryptedState,
                    'checksum' => $checksum,
                    'size_bytes' => strlen($stateContent),
                    'created_by' => auth()->user()?->email,
                    'change_summary' => $changeSummary,
                    'backup_path' => $backupPath,
                ]);
            });

            Log::info('Terraform state saved successfully', [
                'deployment_id' => $deployment->id,
                'version' => $newVersion,
                'size_bytes' => strlen($stateContent),
                'compressed' => $compressed,
                'checksum' => substr($checksum, 0, 8),
            ]);

            return true;
        } finally {
            $this->releaseLock($deployment, $lockId);
        }
    }

    /**
     * Load Terraform state file with decryption and verification
     *
     * @param TerraformDeployment $deployment
     * @param int|null $version Specific version to load, null for latest
     * @return string|null Raw Terraform state JSON
     * @throws \Exception
     */
    public function loadState(TerraformDeployment $deployment, ?int $version = null): ?string
    {
        if ($version !== null) {
            return $this->loadVersionedState($deployment, $version);
        }

        if (!$deployment->state_file) {
            return null;
        }

        try {
            // Decrypt state
            $decrypted = Crypt::decryptString($deployment->state_file);

            // Decompress if needed
            $stateContent = $deployment->state_compressed
                ? gzuncompress($decrypted)
                : $decrypted;

            // Verify checksum
            $actualChecksum = hash('sha256', $stateContent);
            if ($actualChecksum !== $deployment->state_checksum) {
                Log::error('State file checksum mismatch - possible corruption', [
                    'deployment_id' => $deployment->id,
                    'expected' => $deployment->state_checksum,
                    'actual' => $actualChecksum,
                ]);

                // Attempt recovery from backup
                return $this->recoverFromBackup($deployment);
            }

            return $stateContent;
        } catch (\Exception $e) {
            Log::error('Failed to load Terraform state', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            // Attempt recovery from backup
            return $this->recoverFromBackup($deployment);
        }
    }

    /**
     * Load specific version of state file
     *
     * @param TerraformDeployment $deployment
     * @param int $version
     * @return string|null
     */
    private function loadVersionedState(TerraformDeployment $deployment, int $version): ?string
    {
        $stateVersion = TerraformStateVersion::where('terraform_deployment_id', $deployment->id)
            ->where('version', $version)
            ->first();

        if (!$stateVersion) {
            Log::warning('State version not found', [
                'deployment_id' => $deployment->id,
                'version' => $version,
            ]);
            return null;
        }

        try {
            $decrypted = Crypt::decryptString($stateVersion->state_file);

            // Determine if compressed based on size difference
            // Versioned states always compress if beneficial
            $stateContent = @gzuncompress($decrypted);
            if ($stateContent === false) {
                $stateContent = $decrypted; // Not compressed
            }

            // Verify checksum
            $actualChecksum = hash('sha256', $stateContent);
            if ($actualChecksum !== $stateVersion->checksum) {
                throw new \RuntimeException('Version checksum mismatch');
            }

            return $stateContent;
        } catch (\Exception $e) {
            Log::error('Failed to load versioned state', [
                'deployment_id' => $deployment->id,
                'version' => $version,
                'error' => $e->getMessage(),
            ]);

            return null;
        }
    }

    /**
     * Acquire distributed lock for state modifications
     *
     * @param TerraformDeployment $deployment
     * @return string Lock ID
     * @throws \RuntimeException
     */
    private function acquireLock(TerraformDeployment $deployment): string
    {
        $lockId = (string) Str::uuid();
        $lockKey = "terraform:state:lock:{$deployment->id}";

        for ($attempt = 0; $attempt < self::MAX_LOCK_RETRIES; $attempt++) {
            if (Cache::add($lockKey, $lockId, self::LOCK_TTL)) {
                // Update database lock info
                $deployment->update([
                    'state_lock_id' => $lockId,
                    'state_locked_at' => now(),
                    'state_locked_by' => auth()->user()?->email ?? 'system',
                ]);

                Log::debug('State lock acquired', [
                    'deployment_id' => $deployment->id,
                    'lock_id' => $lockId,
                ]);

                return $lockId;
            }

            // Lock exists, wait and retry
            sleep(pow(2, $attempt)); // Exponential backoff
        }

        throw new \RuntimeException(
            "Failed to acquire state lock for deployment {$deployment->id} after " .
            self::MAX_LOCK_RETRIES . " attempts"
        );
    }

    /**
     * Release distributed lock
     *
     * @param TerraformDeployment $deployment
     * @param string $lockId
     * @return void
     */
    private function releaseLock(TerraformDeployment $deployment, string $lockId): void
    {
        $lockKey = "terraform:state:lock:{$deployment->id}";

        // Only release if we own the lock
        if (Cache::get($lockKey) === $lockId) {
            Cache::forget($lockKey);

            $deployment->update([
                'state_lock_id' => null,
                'state_locked_at' => null,
                'state_locked_by' => null,
            ]);

            Log::debug('State lock released', [
                'deployment_id' => $deployment->id,
                'lock_id' => $lockId,
            ]);
        }
    }

    /**
     * Backup state file to object storage
     *
     * @param TerraformDeployment $deployment
     * @param string $stateContent
     * @param int $version
     * @return string Backup path
     */
    private function backupToStorage(
        TerraformDeployment $deployment,
        string $stateContent,
        int $version
    ): string {
        $path = sprintf(
            'terraform-states/org-%d/deployment-%d/v%d-state.json',
            $deployment->organization_id,
            $deployment->id,
            $version
        );

        $this->storage->put($path, $stateContent);

        Log::info('State backed up to object storage', [
            'deployment_id' => $deployment->id,
            'version' => $version,
            'path' => $path,
        ]);

        return $path;
    }

    /**
     * Recover state from latest backup
     *
     * @param TerraformDeployment $deployment
     * @return string|null
     */
    private function recoverFromBackup(TerraformDeployment $deployment): ?string
    {
        if (!$deployment->last_backup_path) {
            Log::error('No backup available for recovery', [
                'deployment_id' => $deployment->id,
            ]);
            return null;
        }

        try {
            $stateContent = $this->storage->get($deployment->last_backup_path);

            Log::warning('State recovered from backup', [
                'deployment_id' => $deployment->id,
                'backup_path' => $deployment->last_backup_path,
            ]);

            // Re-save recovered state
            $this->saveState($deployment, $stateContent, 'Recovered from backup');

            return $stateContent;
        } catch (\Exception $e) {
            Log::error('Failed to recover from backup', [
                'deployment_id' => $deployment->id,
                'backup_path' => $deployment->last_backup_path,
                'error' => $e->getMessage(),
            ]);

            return null;
        }
    }

    /**
     * Determine if state should be compressed
     *
     * @param string $content
     * @return bool
     */
    private function shouldCompress(string $content): bool
    {
        if (strlen($content) < self::COMPRESSION_THRESHOLD) {
            return false;
        }

        // Test compression ratio
        $compressed = gzcompress($content, 9);
        $ratio = strlen($compressed) / strlen($content);

        return $ratio < 0.9; // Compress if saves 10%+
    }

    /**
     * Prune old state versions based on retention policy
     *
     * @param TerraformDeployment $deployment
     * @param int $keepVersions Number of versions to keep
     * @param int $keepDays Keep versions from last N days
     * @return int Number of versions pruned
     */
    public function pruneVersions(
        TerraformDeployment $deployment,
        int $keepVersions = 30,
        int $keepDays = 90
    ): int {
        $cutoffDate = now()->subDays($keepDays);

        $toPrune = TerraformStateVersion::where('terraform_deployment_id', $deployment->id)
            ->where('created_at', '<', $cutoffDate)
            ->orderBy('version', 'desc')
            ->skip($keepVersions)
            ->get();

        $count = 0;

        foreach ($toPrune as $version) {
            // Delete from object storage
            if ($version->backup_path) {
                try {
                    $this->storage->delete($version->backup_path);
                } catch (\Exception $e) {
                    Log::warning('Failed to delete backup during pruning', [
                        'path' => $version->backup_path,
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            // Delete from database
            $version->delete();
            $count++;
        }

        Log::info('State versions pruned', [
            'deployment_id' => $deployment->id,
            'pruned_count' => $count,
        ]);

        return $count;
    }

    /**
     * Rollback to specific state version
     *
     * @param TerraformDeployment $deployment
     * @param int $version
     * @return bool
     */
    public function rollbackToVersion(TerraformDeployment $deployment, int $version): bool
    {
        $stateContent = $this->loadVersionedState($deployment, $version);

        if (!$stateContent) {
            return false;
        }

        return $this->saveState(
            $deployment,
            $stateContent,
            "Rolled back to version {$version}"
        );
    }

    /**
     * Export state file for manual backup or migration
     *
     * @param TerraformDeployment $deployment
     * @param int|null $version
     * @return string Raw state JSON
     */
    public function exportState(TerraformDeployment $deployment, ?int $version = null): string
    {
        $state = $this->loadState($deployment, $version);

        if (!$state) {
            throw new \RuntimeException('No state file available for export');
        }

        return $state;
    }

    /**
     * Import state file from external source
     *
     * @param TerraformDeployment $deployment
     * @param string $stateContent
     * @return bool
     */
    public function importState(TerraformDeployment $deployment, string $stateContent): bool
    {
        return $this->saveState($deployment, $stateContent, 'Imported from external source');
    }
}
```

### State Storage Interface and Implementations

**File:** `app/Services/Enterprise/StateStorage/StateStorageInterface.php`

```php
<?php

namespace App\Services\Enterprise\StateStorage;

interface StateStorageInterface
{
    /**
     * Store content at path
     *
     * @param string $path
     * @param string $content
     * @return bool
     */
    public function put(string $path, string $content): bool;

    /**
     * Retrieve content from path
     *
     * @param string $path
     * @return string
     * @throws \Exception
     */
    public function get(string $path): string;

    /**
     * Delete content at path
     *
     * @param string $path
     * @return bool
     */
    public function delete(string $path): bool;

    /**
     * Check if path exists
     *
     * @param string $path
     * @return bool
     */
    public function exists(string $path): bool;
}
```

**File:** `app/Services/Enterprise/StateStorage/S3StateStorage.php`

```php
<?php

namespace App\Services\Enterprise\StateStorage;

use Illuminate\Support\Facades\Storage;

class S3StateStorage implements StateStorageInterface
{
    private string $disk;

    public function __construct(?string $disk = null)
    {
        $this->disk = $disk ?? config('terraform.state_backup_disk', 's3');
    }

    public function put(string $path, string $content): bool
    {
        return Storage::disk($this->disk)->put($path, $content);
    }

    public function get(string $path): string
    {
        return Storage::disk($this->disk)->get($path);
    }

    public function delete(string $path): bool
    {
        return Storage::disk($this->disk)->delete($path);
    }

    public function exists(string $path): bool
    {
        return Storage::disk($this->disk)->exists($path);
    }
}
```

## Implementation Approach

### Step 1: Database Migration
1. Create migration for state file columns in terraform_deployments
2. Create terraform_state_versions table for version history
3. Add indexes for performance and locking queries
4. Run migration in development environment

### Step 2: Create State Storage Abstraction
1. Define StateStorageInterface
2. Implement S3StateStorage using Laravel Storage facade
3. Implement MinioStateStorage (similar to S3 but different configuration)
4. Register storage implementation in service provider

### Step 3: Implement TerraformStateManager Service
1. Create service class with interface
2. Implement saveState() with encryption and compression
3. Implement loadState() with decryption and checksum verification
4. Implement distributed locking using Redis
5. Implement backup to object storage
6. Add error recovery from backup

### Step 4: Add Versioning and Rollback
1. Create version history on each state save
2. Implement loadVersionedState() for historical access
3. Implement rollbackToVersion() functionality
4. Add pruning logic for old versions

### Step 5: Create Artisan Commands
1. `terraform:state-backup` - Manual backup trigger
2. `terraform:state-restore` - Restore from specific backup
3. `terraform:state-prune` - Prune old versions
4. Add commands to scheduler for automatic pruning

### Step 6: Integration with TerraformService
1. Update TerraformService to use TerraformStateManager
2. Pass state file path to Terraform commands
3. Save state after successful Terraform operations
4. Load state before Terraform operations

### Step 7: Configuration
1. Add state backup settings to config/terraform.php
2. Configure S3/MinIO credentials in config/filesystems.php
3. Add retention policy configuration
4. Set compression thresholds

### Step 8: Testing
1. Unit test encryption/decryption
2. Unit test compression logic
3. Test state locking mechanism
4. Test backup and recovery
5. Test versioning and rollback
6. Integration test with TerraformService

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/TerraformStateManagerTest.php`

```php
<?php

use App\Models\TerraformDeployment;
use App\Services\Enterprise\TerraformStateManager;
use App\Services\Enterprise\StateStorage\StateStorageInterface;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Crypt;

beforeEach(function () {
    $this->storage = Mockery::mock(StateStorageInterface::class);
    $this->stateManager = new TerraformStateManager($this->storage);
});

it('encrypts state file before saving', function () {
    $deployment = TerraformDeployment::factory()->create();
    $stateContent = json_encode(['version' => 4, 'terraform_version' => '1.5.0']);

    $this->storage->shouldReceive('put')->once()->andReturn(true);

    $this->stateManager->saveState($deployment, $stateContent);

    $deployment->refresh();

    expect($deployment->state_file)->not->toBe($stateContent);
    expect(Crypt::decryptString($deployment->state_file))->toContain('version');
});

it('calculates and stores checksum', function () {
    $deployment = TerraformDeployment::factory()->create();
    $stateContent = json_encode(['version' => 4]);

    $this->storage->shouldReceive('put')->andReturn(true);

    $this->stateManager->saveState($deployment, $stateContent);

    $deployment->refresh();

    $expectedChecksum = hash('sha256', $stateContent);
    expect($deployment->state_checksum)->toBe($expectedChecksum);
});

it('increments version on each save', function () {
    $deployment = TerraformDeployment::factory()->create(['state_version' => 5]);
    $stateContent = json_encode(['version' => 4]);

    $this->storage->shouldReceive('put')->andReturn(true);

    $this->stateManager->saveState($deployment, $stateContent);

    $deployment->refresh();
    expect($deployment->state_version)->toBe(6);
});

it('acquires and releases lock during save', function () {
    $deployment = TerraformDeployment::factory()->create();
    $stateContent = json_encode(['version' => 4]);

    $this->storage->shouldReceive('put')->andReturn(true);

    Cache::shouldReceive('add')->once()->andReturn(true);
    Cache::shouldReceive('get')->once()->andReturn('some-lock-id');
    Cache::shouldReceive('forget')->once();

    $this->stateManager->saveState($deployment, $stateContent);

    $deployment->refresh();
    expect($deployment->state_lock_id)->toBeNull();
});

it('verifies checksum when loading state', function () {
    $stateContent = json_encode(['version' => 4]);
    $checksum = hash('sha256', $stateContent);

    $deployment = TerraformDeployment::factory()->create([
        'state_file' => Crypt::encryptString($stateContent),
        'state_checksum' => $checksum,
        'state_compressed' => false,
    ]);

    $loaded = $this->stateManager->loadState($deployment);

    expect($loaded)->toBe($stateContent);
});

it('recovers from backup on checksum mismatch', function () {
    $stateContent = json_encode(['version' => 4]);

    $deployment = TerraformDeployment::factory()->create([
        'state_file' => Crypt::encryptString($stateContent),
        'state_checksum' => 'invalid-checksum',
        'last_backup_path' => 'backup/path/state.json',
    ]);

    $this->storage->shouldReceive('get')
        ->with('backup/path/state.json')
        ->andReturn($stateContent);

    $this->storage->shouldReceive('put')->andReturn(true);

    $loaded = $this->stateManager->loadState($deployment);

    expect($loaded)->toBe($stateContent);
});

it('compresses state if beneficial', function () {
    $deployment = TerraformDeployment::factory()->create();

    // Large state that benefits from compression
    $largeState = json_encode([
        'version' => 4,
        'resources' => array_fill(0, 100, ['type' => 'aws_instance', 'name' => 'server']),
    ]);

    $this->storage->shouldReceive('put')->andReturn(true);

    $this->stateManager->saveState($deployment, $largeState);

    $deployment->refresh();
    expect($deployment->state_compressed)->toBeTrue();
});

it('prunes old versions based on retention policy', function () {
    $deployment = TerraformDeployment::factory()->create();

    // Create 50 old versions
    for ($i = 1; $i <= 50; $i++) {
        TerraformStateVersion::factory()->create([
            'terraform_deployment_id' => $deployment->id,
            'organization_id' => $deployment->organization_id,
            'version' => $i,
            'created_at' => now()->subDays(100),
        ]);
    }

    $this->storage->shouldReceive('delete')->times(20); // Keep 30, prune 20

    $pruned = $this->stateManager->pruneVersions($deployment, keepVersions: 30);

    expect($pruned)->toBe(20);
});

it('rolls back to specific version', function () {
    $deployment = TerraformDeployment::factory()->create();

    $oldStateContent = json_encode(['version' => 4, 'resources' => []]);

    TerraformStateVersion::factory()->create([
        'terraform_deployment_id' => $deployment->id,
        'organization_id' => $deployment->organization_id,
        'version' => 5,
        'state_file' => Crypt::encryptString($oldStateContent),
        'checksum' => hash('sha256', $oldStateContent),
    ]);

    $this->storage->shouldReceive('put')->andReturn(true);

    $result = $this->stateManager->rollbackToVersion($deployment, 5);

    expect($result)->toBeTrue();
});
```

### Integration Tests

**File:** `tests/Feature/TerraformStateManagementTest.php`

```php
<?php

use App\Models\TerraformDeployment;
use App\Models\TerraformStateVersion;
use App\Services\Enterprise\TerraformStateManager;
use Illuminate\Support\Facades\Storage;

it('saves and retrieves state file end-to-end', function () {
    Storage::fake('s3');

    $deployment = TerraformDeployment::factory()->create();
    $stateManager = app(TerraformStateManager::class);

    $stateContent = json_encode([
        'version' => 4,
        'terraform_version' => '1.5.0',
        'resources' => [
            ['type' => 'aws_instance', 'name' => 'web', 'id' => 'i-12345'],
        ],
    ]);

    // Save state
    $saved = $stateManager->saveState($deployment, $stateContent, 'Initial state');
    expect($saved)->toBeTrue();

    // Verify backup created
    $deployment->refresh();
    expect($deployment->last_backup_path)->not->toBeNull();
    Storage::disk('s3')->assertExists($deployment->last_backup_path);

    // Load state
    $loaded = $stateManager->loadState($deployment);
    expect($loaded)->toBe($stateContent);

    // Verify version history
    expect(TerraformStateVersion::where('terraform_deployment_id', $deployment->id)->count())
        ->toBe(1);
});

it('handles concurrent state modifications with locking', function () {
    $deployment = TerraformDeployment::factory()->create();
    $stateManager = app(TerraformStateManager::class);

    $state1 = json_encode(['version' => 4, 'serial' => 1]);
    $state2 = json_encode(['version' => 4, 'serial' => 2]);

    // First save should succeed
    $result1 = $stateManager->saveState($deployment, $state1);
    expect($result1)->toBeTrue();

    // Concurrent save should eventually succeed after lock is released
    $result2 = $stateManager->saveState($deployment, $state2);
    expect($result2)->toBeTrue();

    $deployment->refresh();
    expect($deployment->state_version)->toBe(2);
});
```

## Definition of Done

- [ ] Database migration created for state file columns
- [ ] terraform_state_versions table created for version history
- [ ] TerraformStateManagerInterface created
- [ ] TerraformStateManager service implemented
- [ ] State files encrypted with AES-256 before storage
- [ ] SHA-256 checksum verification implemented
- [ ] State file compression implemented with threshold logic
- [ ] Redis-based distributed locking implemented
- [ ] StateStorageInterface created
- [ ] S3StateStorage implementation created
- [ ] MinioStateStorage implementation created
- [ ] Backup to object storage implemented
- [ ] Automatic recovery from backup on corruption
- [ ] State versioning implemented
- [ ] Rollback to previous version capability added
- [ ] Version pruning logic implemented
- [ ] terraform:state-backup command created
- [ ] terraform:state-restore command created
- [ ] terraform:state-prune command created
- [ ] Configuration added to config/terraform.php
- [ ] Integration with TerraformService completed
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written for end-to-end flows
- [ ] Lock contention tests written
- [ ] Documentation added to service methods
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Manual testing with real Terraform operations
- [ ] Code reviewed and approved
