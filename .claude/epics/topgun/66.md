---
name: Implement DomainRegistrarService with core methods
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:19Z
github: https://github.com/johnproblems/topgun/issues/174
depends_on: [64, 65]
parallel: false
conflicts_with: []
---

# Task: Implement DomainRegistrarService with core methods

## Description

Create a comprehensive domain registrar service that provides unified interfaces for domain availability checking, registration, renewal, transfer, and DNS management across multiple domain registrars (Namecheap, AWS Route53 Domains). This service abstracts the complexity of different registrar APIs behind a consistent interface, enabling organizations to manage their domains directly through Coolify Enterprise's white-label platform.

**The Business Problem:**

Enterprise customers deploying white-labeled Coolify instances need professional domain management without leaving the platform. Currently, they must:
1. Purchase domains manually through external registrars
2. Configure DNS records separately in multiple control panels
3. Track renewal dates across different systems
4. Manage SSL certificates with manual domain verification

This fragmented workflow creates friction, increases errors, and undermines the "all-in-one platform" value proposition of the white-label system.

**The Technical Solution:**

The `DomainRegistrarService` provides a unified abstraction layer over multiple domain registrar APIs. Using the **Factory Pattern**, it instantiates the appropriate registrar implementation (Namecheap, Route53) based on organization preferences or default configuration. The service handles:

1. **Domain Availability Checking**: Real-time WHOIS lookups across registrars
2. **Domain Registration**: Automated purchase with organization billing details
3. **Domain Renewal**: Programmatic renewal before expiration
4. **Domain Transfer**: Initiate transfers from external registrars
5. **Domain Information Retrieval**: WHOIS data, nameservers, expiration dates
6. **Error Handling**: Standardized error responses across different registrar APIs
7. **Pricing Retrieval**: TLD pricing for cost estimation

**Key Capabilities:**

- **Multi-Registrar Support**: Namecheap and AWS Route53 Domains with extensible architecture
- **Unified Interface**: Consistent method signatures regardless of underlying registrar
- **Credential Management**: Encrypted storage of API keys per organization (Task 64)
- **Error Standardization**: Translate registrar-specific errors to common error types
- **Rate Limiting**: Prevent API abuse and respect registrar limits
- **Domain Locking**: Automatic transfer lock for security
- **Auto-Renewal Management**: Configure auto-renewal preferences
- **Nameserver Management**: Update nameservers for DNS delegation
- **Contact Information**: Manage registrant, admin, technical contacts
- **Audit Logging**: Track all domain operations for compliance

**Integration Architecture:**

**Upstream Dependencies:**
- **Task 64 (Namecheap Integration)**: Provides Namecheap API client implementation
- **Task 65 (Route53 Domains Integration)**: Provides AWS Route53 Domains API client implementation
- **Task 62 (Database Schema)**: Provides `organization_domains` table for domain tracking

**Downstream Consumers:**
- **Task 67 (DnsManagementService)**: Consumes domain records for DNS automation
- **Task 68 (SSL Certificate Service)**: Triggers SSL provisioning after domain registration
- **Task 69 (Domain Verification)**: Uses domain registration data for ownership verification
- **Task 70 (DomainManager.vue)**: UI for domain operations

**Service Architecture Pattern:**

This task follows Coolify Enterprise's **Interface-First Service Pattern**:

1. **Interface Definition**: `DomainRegistrarServiceInterface` in `app/Contracts/`
2. **Service Implementation**: `DomainRegistrarService` in `app/Services/Enterprise/`
3. **Factory Pattern**: `DomainRegistrarFactory` creates registrar-specific clients
4. **Client Implementations**: `NamecheapClient`, `Route53DomainsClient` in `app/Services/Enterprise/DomainRegistrars/`
5. **Service Provider Registration**: Bind interface to implementation in `EnterpriseServiceProvider`

**Why This Task is Critical:**

Domain management is a cornerstone of the white-label experience. Organizations need to:
- Register custom domains for their branded platforms
- Automate DNS configuration for deployed applications
- Manage domain renewals without manual intervention
- Provision SSL certificates automatically

Without domain registrar integration, these tasks require external tools and manual processes, fragmenting the user experience and reducing platform value. By integrating domain registration directly into Coolify, we complete the "infrastructure-to-application" automation story, making Coolify Enterprise a truly comprehensive deployment platform.

The service also enables **future revenue opportunities**: Organizations can purchase domains through Coolify with markup, creating a white-label domain registration business model.

## Acceptance Criteria

- [ ] DomainRegistrarServiceInterface created with all core methods
- [ ] DomainRegistrarService implementation with factory pattern
- [ ] DomainRegistrarFactory creates appropriate registrar clients
- [ ] Method: `checkAvailability(string $domain, string $tld): DomainAvailability`
- [ ] Method: `registerDomain(DomainRegistrationRequest $request): DomainRegistration`
- [ ] Method: `renewDomain(OrganizationDomain $domain, int $years): DomainRenewal`
- [ ] Method: `transferDomain(DomainTransferRequest $request): DomainTransfer`
- [ ] Method: `getDomainInfo(OrganizationDomain $domain): DomainInfo`
- [ ] Method: `updateNameservers(OrganizationDomain $domain, array $nameservers): bool`
- [ ] Method: `setAutoRenewal(OrganizationDomain $domain, bool $enabled): bool`
- [ ] Method: `lockDomain(OrganizationDomain $domain, bool $locked): bool`
- [ ] Method: `getPricing(string $tld): DomainPricing`
- [ ] Error handling with RegistrarException standardization
- [ ] Integration with encrypted CloudProviderCredential model (Task 64, 65)
- [ ] Rate limiting middleware for API calls
- [ ] Comprehensive logging of all domain operations
- [ ] Unit tests for all service methods (>90% coverage)
- [ ] Integration tests with registrar API mocking

## Technical Details

### File Paths

**Service Interface:**
- `/home/topgun/topgun/app/Contracts/DomainRegistrarServiceInterface.php` (new)

**Service Implementation:**
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrarService.php` (new)

**Factory:**
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrars/DomainRegistrarFactory.php` (new)

**Registrar Clients:**
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrars/NamecheapClient.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrars/Route53DomainsClient.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/DomainRegistrars/BaseRegistrarClient.php` (abstract base)

**Data Transfer Objects:**
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainAvailability.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainRegistrationRequest.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainRegistration.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainRenewal.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainTransferRequest.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainTransfer.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainInfo.php` (new)
- `/home/topgun/topgun/app/DataTransferObjects/DomainRegistration/DomainPricing.php` (new)

**Exceptions:**
- `/home/topgun/topgun/app/Exceptions/Enterprise/RegistrarException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Enterprise/DomainNotAvailableException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Enterprise/RegistrarApiException.php` (new)
- `/home/topgun/topgun/app/Exceptions/Enterprise/InvalidDomainException.php` (new)

**Service Provider:**
- `/home/topgun/topgun/app/Providers/EnterpriseServiceProvider.php` (modify)

**Tests:**
- `/home/topgun/topgun/tests/Unit/Services/DomainRegistrarServiceTest.php` (new)
- `/home/topgun/topgun/tests/Feature/Enterprise/DomainRegistrationTest.php` (new)

### Database Schema Reference

This service reads from existing tables created in Task 62:

```sql
-- organization_domains table (created in Task 62)
CREATE TABLE organization_domains (
    id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    organization_id BIGINT UNSIGNED NOT NULL,
    domain VARCHAR(255) NOT NULL,
    tld VARCHAR(50) NOT NULL,
    registrar VARCHAR(50) NOT NULL, -- 'namecheap', 'route53', etc.
    registrar_domain_id VARCHAR(255), -- External registrar's domain ID
    status VARCHAR(50) NOT NULL, -- 'active', 'pending', 'expired', 'transferred'
    registered_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,
    auto_renew BOOLEAN DEFAULT false,
    locked BOOLEAN DEFAULT true,
    nameservers JSON,
    registrant_contact JSON, -- Contact information
    metadata JSON, -- Registrar-specific metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY unique_domain (domain, tld),
    FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE,
    INDEX idx_org_domains (organization_id),
    INDEX idx_expires_at (expires_at),
    INDEX idx_status (status)
);
```

### Service Interface

**File:** `app/Contracts/DomainRegistrarServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\DataTransferObjects\DomainRegistration\DomainAvailability;
use App\DataTransferObjects\DomainRegistration\DomainInfo;
use App\DataTransferObjects\DomainRegistration\DomainPricing;
use App\DataTransferObjects\DomainRegistration\DomainRegistration;
use App\DataTransferObjects\DomainRegistration\DomainRegistrationRequest;
use App\DataTransferObjects\DomainRegistration\DomainRenewal;
use App\DataTransferObjects\DomainRegistration\DomainTransfer;
use App\DataTransferObjects\DomainRegistration\DomainTransferRequest;
use App\Models\Organization;
use App\Models\OrganizationDomain;

interface DomainRegistrarServiceInterface
{
    /**
     * Check if a domain is available for registration
     *
     * @param string $domain Domain name without TLD (e.g., 'example')
     * @param string $tld Top-level domain (e.g., 'com', 'net', 'org')
     * @param Organization $organization
     * @return DomainAvailability
     * @throws \App\Exceptions\Enterprise\InvalidDomainException
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function checkAvailability(
        string $domain,
        string $tld,
        Organization $organization
    ): DomainAvailability;

    /**
     * Register a new domain
     *
     * @param DomainRegistrationRequest $request
     * @param Organization $organization
     * @return DomainRegistration
     * @throws \App\Exceptions\Enterprise\DomainNotAvailableException
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function registerDomain(
        DomainRegistrationRequest $request,
        Organization $organization
    ): DomainRegistration;

    /**
     * Renew an existing domain
     *
     * @param OrganizationDomain $domain
     * @param int $years Number of years to renew
     * @return DomainRenewal
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function renewDomain(
        OrganizationDomain $domain,
        int $years = 1
    ): DomainRenewal;

    /**
     * Transfer a domain from another registrar
     *
     * @param DomainTransferRequest $request
     * @param Organization $organization
     * @return DomainTransfer
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function transferDomain(
        DomainTransferRequest $request,
        Organization $organization
    ): DomainTransfer;

    /**
     * Get detailed domain information
     *
     * @param OrganizationDomain $domain
     * @return DomainInfo
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function getDomainInfo(OrganizationDomain $domain): DomainInfo;

    /**
     * Update domain nameservers
     *
     * @param OrganizationDomain $domain
     * @param array<string> $nameservers Array of nameserver hostnames
     * @return bool
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function updateNameservers(
        OrganizationDomain $domain,
        array $nameservers
    ): bool;

    /**
     * Enable or disable automatic renewal
     *
     * @param OrganizationDomain $domain
     * @param bool $enabled
     * @return bool
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function setAutoRenewal(
        OrganizationDomain $domain,
        bool $enabled
    ): bool;

    /**
     * Lock or unlock domain for transfer protection
     *
     * @param OrganizationDomain $domain
     * @param bool $locked
     * @return bool
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function lockDomain(
        OrganizationDomain $domain,
        bool $locked
    ): bool;

    /**
     * Get pricing for a specific TLD
     *
     * @param string $tld Top-level domain (e.g., 'com')
     * @param Organization $organization
     * @return DomainPricing
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function getPricing(
        string $tld,
        Organization $organization
    ): DomainPricing;

    /**
     * Get EPP/authorization code for domain transfer
     *
     * @param OrganizationDomain $domain
     * @return string
     * @throws \App\Exceptions\Enterprise\RegistrarApiException
     */
    public function getAuthCode(OrganizationDomain $domain): string;
}
```

### Service Implementation

**File:** `app/Services/Enterprise/DomainRegistrarService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\DomainRegistrarServiceInterface;
use App\DataTransferObjects\DomainRegistration\DomainAvailability;
use App\DataTransferObjects\DomainRegistration\DomainInfo;
use App\DataTransferObjects\DomainRegistration\DomainPricing;
use App\DataTransferObjects\DomainRegistration\DomainRegistration;
use App\DataTransferObjects\DomainRegistration\DomainRegistrationRequest;
use App\DataTransferObjects\DomainRegistration\DomainRenewal;
use App\DataTransferObjects\DomainRegistration\DomainTransfer;
use App\DataTransferObjects\DomainRegistration\DomainTransferRequest;
use App\Exceptions\Enterprise\InvalidDomainException;
use App\Exceptions\Enterprise\RegistrarException;
use App\Models\Organization;
use App\Models\OrganizationDomain;
use App\Services\Enterprise\DomainRegistrars\DomainRegistrarFactory;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class DomainRegistrarService implements DomainRegistrarServiceInterface
{
    public function __construct(
        private DomainRegistrarFactory $registrarFactory
    ) {}

    /**
     * Check domain availability across registrars
     */
    public function checkAvailability(
        string $domain,
        string $tld,
        Organization $organization
    ): DomainAvailability {
        $this->validateDomainName($domain, $tld);

        $fullDomain = "{$domain}.{$tld}";
        $cacheKey = "domain_availability:{$fullDomain}";

        // Cache availability checks for 5 minutes to reduce API calls
        return Cache::remember($cacheKey, 300, function () use ($domain, $tld, $organization, $fullDomain) {
            try {
                $client = $this->registrarFactory->make($organization);

                $isAvailable = $client->checkAvailability($domain, $tld);
                $pricing = $client->getPricing($tld);

                Log::info("Domain availability checked", [
                    'domain' => $fullDomain,
                    'available' => $isAvailable,
                    'registrar' => $client->getName(),
                ]);

                return new DomainAvailability(
                    domain: $fullDomain,
                    available: $isAvailable,
                    price: $pricing->registrationPrice,
                    registrar: $client->getName(),
                );
            } catch (\Exception $e) {
                Log::error("Domain availability check failed", [
                    'domain' => $fullDomain,
                    'error' => $e->getMessage(),
                ]);

                throw new RegistrarException(
                    "Failed to check domain availability: {$e->getMessage()}",
                    previous: $e
                );
            }
        });
    }

    /**
     * Register a new domain
     */
    public function registerDomain(
        DomainRegistrationRequest $request,
        Organization $organization
    ): DomainRegistration {
        $fullDomain = "{$request->domain}.{$request->tld}";

        try {
            $client = $this->registrarFactory->make($organization);

            // Check availability first
            $isAvailable = $client->checkAvailability($request->domain, $request->tld);

            if (!$isAvailable) {
                throw new \App\Exceptions\Enterprise\DomainNotAvailableException(
                    "Domain {$fullDomain} is not available for registration"
                );
            }

            // Register domain via client
            $registrationResult = $client->registerDomain(
                domain: $request->domain,
                tld: $request->tld,
                years: $request->years,
                contacts: $request->contacts,
                nameservers: $request->nameservers,
                autoRenew: $request->autoRenew ?? false,
            );

            // Store in database
            $organizationDomain = OrganizationDomain::create([
                'organization_id' => $organization->id,
                'domain' => $request->domain,
                'tld' => $request->tld,
                'registrar' => $client->getName(),
                'registrar_domain_id' => $registrationResult['domain_id'],
                'status' => 'active',
                'registered_at' => now(),
                'expires_at' => $registrationResult['expires_at'],
                'auto_renew' => $request->autoRenew ?? false,
                'locked' => true, // Default to locked for security
                'nameservers' => $request->nameservers,
                'registrant_contact' => $request->contacts,
                'metadata' => $registrationResult['metadata'] ?? [],
            ]);

            Log::info("Domain registered successfully", [
                'domain' => $fullDomain,
                'organization_id' => $organization->id,
                'registrar' => $client->getName(),
                'expires_at' => $registrationResult['expires_at'],
            ]);

            // Clear availability cache
            Cache::forget("domain_availability:{$fullDomain}");

            return new DomainRegistration(
                domain: $organizationDomain,
                transactionId: $registrationResult['transaction_id'] ?? null,
                cost: $registrationResult['cost'],
                message: "Domain {$fullDomain} registered successfully",
            );
        } catch (\Exception $e) {
            Log::error("Domain registration failed", [
                'domain' => $fullDomain,
                'organization_id' => $organization->id,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to register domain {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Renew an existing domain
     */
    public function renewDomain(
        OrganizationDomain $domain,
        int $years = 1
    ): DomainRenewal {
        $fullDomain = "{$domain->domain}.{$domain->tld}";

        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $renewalResult = $client->renewDomain(
                domainId: $domain->registrar_domain_id,
                years: $years
            );

            // Update expiration date
            $domain->update([
                'expires_at' => $renewalResult['expires_at'],
            ]);

            Log::info("Domain renewed successfully", [
                'domain' => $fullDomain,
                'years' => $years,
                'new_expiration' => $renewalResult['expires_at'],
            ]);

            return new DomainRenewal(
                domain: $domain,
                yearsAdded: $years,
                newExpirationDate: $renewalResult['expires_at'],
                cost: $renewalResult['cost'],
                transactionId: $renewalResult['transaction_id'] ?? null,
            );
        } catch (\Exception $e) {
            Log::error("Domain renewal failed", [
                'domain' => $fullDomain,
                'years' => $years,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to renew domain {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Transfer a domain from another registrar
     */
    public function transferDomain(
        DomainTransferRequest $request,
        Organization $organization
    ): DomainTransfer {
        $fullDomain = "{$request->domain}.{$request->tld}";

        try {
            $client = $this->registrarFactory->make($organization);

            $transferResult = $client->transferDomain(
                domain: $request->domain,
                tld: $request->tld,
                authCode: $request->authCode,
                contacts: $request->contacts,
            );

            // Store in database with 'pending' status
            $organizationDomain = OrganizationDomain::create([
                'organization_id' => $organization->id,
                'domain' => $request->domain,
                'tld' => $request->tld,
                'registrar' => $client->getName(),
                'registrar_domain_id' => $transferResult['domain_id'],
                'status' => 'pending_transfer',
                'registered_at' => now(),
                'expires_at' => $transferResult['estimated_completion'] ?? now()->addDays(7),
                'auto_renew' => false,
                'locked' => false, // Unlocked during transfer
                'registrant_contact' => $request->contacts,
                'metadata' => [
                    'transfer_initiated_at' => now(),
                    'auth_code_used' => true,
                    ...$transferResult['metadata'] ?? [],
                ],
            ]);

            Log::info("Domain transfer initiated", [
                'domain' => $fullDomain,
                'organization_id' => $organization->id,
                'transfer_id' => $transferResult['transfer_id'],
            ]);

            return new DomainTransfer(
                domain: $organizationDomain,
                transferId: $transferResult['transfer_id'],
                status: 'pending',
                estimatedCompletionDate: $transferResult['estimated_completion'] ?? now()->addDays(7),
            );
        } catch (\Exception $e) {
            Log::error("Domain transfer failed", [
                'domain' => $fullDomain,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to transfer domain {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Get detailed domain information
     */
    public function getDomainInfo(OrganizationDomain $domain): DomainInfo
    {
        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $info = $client->getDomainInfo($domain->registrar_domain_id);

            // Update local database with fresh data
            $domain->update([
                'expires_at' => $info['expires_at'],
                'nameservers' => $info['nameservers'],
                'locked' => $info['locked'],
                'auto_renew' => $info['auto_renew'],
            ]);

            return new DomainInfo(
                domain: $domain,
                nameservers: $info['nameservers'],
                locked: $info['locked'],
                autoRenew: $info['auto_renew'],
                expiresAt: $info['expires_at'],
                createdAt: $info['created_at'] ?? $domain->registered_at,
                updatedAt: $info['updated_at'] ?? $domain->updated_at,
            );
        } catch (\Exception $e) {
            Log::error("Failed to get domain info", [
                'domain' => "{$domain->domain}.{$domain->tld}",
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to retrieve domain information: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Update domain nameservers
     */
    public function updateNameservers(
        OrganizationDomain $domain,
        array $nameservers
    ): bool {
        $fullDomain = "{$domain->domain}.{$domain->tld}";

        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $success = $client->updateNameservers(
                domainId: $domain->registrar_domain_id,
                nameservers: $nameservers
            );

            if ($success) {
                $domain->update([
                    'nameservers' => $nameservers,
                ]);

                Log::info("Domain nameservers updated", [
                    'domain' => $fullDomain,
                    'nameservers' => $nameservers,
                ]);
            }

            return $success;
        } catch (\Exception $e) {
            Log::error("Failed to update nameservers", [
                'domain' => $fullDomain,
                'nameservers' => $nameservers,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to update nameservers for {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Enable or disable automatic renewal
     */
    public function setAutoRenewal(
        OrganizationDomain $domain,
        bool $enabled
    ): bool {
        $fullDomain = "{$domain->domain}.{$domain->tld}";

        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $success = $client->setAutoRenewal(
                domainId: $domain->registrar_domain_id,
                enabled: $enabled
            );

            if ($success) {
                $domain->update(['auto_renew' => $enabled]);

                Log::info("Domain auto-renewal updated", [
                    'domain' => $fullDomain,
                    'auto_renew' => $enabled,
                ]);
            }

            return $success;
        } catch (\Exception $e) {
            Log::error("Failed to set auto-renewal", [
                'domain' => $fullDomain,
                'enabled' => $enabled,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to update auto-renewal for {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Lock or unlock domain for transfer protection
     */
    public function lockDomain(
        OrganizationDomain $domain,
        bool $locked
    ): bool {
        $fullDomain = "{$domain->domain}.{$domain->tld}";

        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $success = $client->lockDomain(
                domainId: $domain->registrar_domain_id,
                locked: $locked
            );

            if ($success) {
                $domain->update(['locked' => $locked]);

                Log::info("Domain lock status updated", [
                    'domain' => $fullDomain,
                    'locked' => $locked,
                ]);
            }

            return $success;
        } catch (\Exception $e) {
            Log::error("Failed to update domain lock", [
                'domain' => $fullDomain,
                'locked' => $locked,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to update domain lock for {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Get pricing for a specific TLD
     */
    public function getPricing(
        string $tld,
        Organization $organization
    ): DomainPricing {
        $cacheKey = "domain_pricing:{$tld}";

        // Cache pricing for 1 hour
        return Cache::remember($cacheKey, 3600, function () use ($tld, $organization) {
            try {
                $client = $this->registrarFactory->make($organization);

                $pricing = $client->getPricing($tld);

                return new DomainPricing(
                    tld: $tld,
                    registrationPrice: $pricing->registrationPrice,
                    renewalPrice: $pricing->renewalPrice,
                    transferPrice: $pricing->transferPrice,
                    currency: $pricing->currency,
                    registrar: $client->getName(),
                );
            } catch (\Exception $e) {
                Log::error("Failed to get domain pricing", [
                    'tld' => $tld,
                    'error' => $e->getMessage(),
                ]);

                throw new RegistrarException(
                    "Failed to retrieve pricing for .{$tld}: {$e->getMessage()}",
                    previous: $e
                );
            }
        });
    }

    /**
     * Get EPP/authorization code for domain transfer
     */
    public function getAuthCode(OrganizationDomain $domain): string
    {
        $fullDomain = "{$domain->domain}.{$domain->tld}";

        try {
            $client = $this->registrarFactory->makeForDomain($domain);

            $authCode = $client->getAuthCode($domain->registrar_domain_id);

            Log::info("Auth code retrieved", [
                'domain' => $fullDomain,
            ]);

            return $authCode;
        } catch (\Exception $e) {
            Log::error("Failed to get auth code", [
                'domain' => $fullDomain,
                'error' => $e->getMessage(),
            ]);

            throw new RegistrarException(
                "Failed to retrieve auth code for {$fullDomain}: {$e->getMessage()}",
                previous: $e
            );
        }
    }

    /**
     * Validate domain name format
     *
     * @param string $domain
     * @param string $tld
     * @return void
     * @throws InvalidDomainException
     */
    private function validateDomainName(string $domain, string $tld): void
    {
        // Domain name validation rules
        if (empty($domain) || empty($tld)) {
            throw new InvalidDomainException("Domain name and TLD cannot be empty");
        }

        if (strlen($domain) < 1 || strlen($domain) > 63) {
            throw new InvalidDomainException("Domain name must be 1-63 characters");
        }

        if (!preg_match('/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i', $domain)) {
            throw new InvalidDomainException("Invalid domain name format");
        }

        if (!preg_match('/^[a-z]{2,}$/i', $tld)) {
            throw new InvalidDomainException("Invalid TLD format");
        }
    }
}
```

### Factory Pattern Implementation

**File:** `app/Services/Enterprise/DomainRegistrars/DomainRegistrarFactory.php`

```php
<?php

namespace App\Services\Enterprise\DomainRegistrars;

use App\Models\Organization;
use App\Models\OrganizationDomain;
use App\Exceptions\Enterprise\RegistrarException;

class DomainRegistrarFactory
{
    /**
     * Create registrar client for organization
     *
     * @param Organization $organization
     * @return BaseRegistrarClient
     * @throws RegistrarException
     */
    public function make(Organization $organization): BaseRegistrarClient
    {
        $preferredRegistrar = $organization->whiteLabelConfig?->preferred_registrar
            ?? config('enterprise.domain.default_registrar', 'namecheap');

        return $this->makeByName($preferredRegistrar, $organization);
    }

    /**
     * Create registrar client for existing domain
     *
     * @param OrganizationDomain $domain
     * @return BaseRegistrarClient
     * @throws RegistrarException
     */
    public function makeForDomain(OrganizationDomain $domain): BaseRegistrarClient
    {
        return $this->makeByName($domain->registrar, $domain->organization);
    }

    /**
     * Create registrar client by name
     *
     * @param string $registrar
     * @param Organization $organization
     * @return BaseRegistrarClient
     * @throws RegistrarException
     */
    private function makeByName(string $registrar, Organization $organization): BaseRegistrarClient
    {
        return match (strtolower($registrar)) {
            'namecheap' => new NamecheapClient($organization),
            'route53' => new Route53DomainsClient($organization),
            default => throw new RegistrarException("Unsupported registrar: {$registrar}"),
        };
    }
}
```

### Base Registrar Client (Abstract)

**File:** `app/Services/Enterprise/DomainRegistrars/BaseRegistrarClient.php`

```php
<?php

namespace App\Services\Enterprise\DomainRegistrars;

use App\Models\Organization;
use App\Models\CloudProviderCredential;

abstract class BaseRegistrarClient
{
    protected CloudProviderCredential $credentials;

    public function __construct(protected Organization $organization)
    {
        $this->loadCredentials();
    }

    /**
     * Get registrar name
     */
    abstract public function getName(): string;

    /**
     * Check domain availability
     */
    abstract public function checkAvailability(string $domain, string $tld): bool;

    /**
     * Register a domain
     */
    abstract public function registerDomain(
        string $domain,
        string $tld,
        int $years,
        array $contacts,
        array $nameservers,
        bool $autoRenew
    ): array;

    /**
     * Renew a domain
     */
    abstract public function renewDomain(string $domainId, int $years): array;

    /**
     * Transfer a domain
     */
    abstract public function transferDomain(
        string $domain,
        string $tld,
        string $authCode,
        array $contacts
    ): array;

    /**
     * Get domain information
     */
    abstract public function getDomainInfo(string $domainId): array;

    /**
     * Update nameservers
     */
    abstract public function updateNameservers(string $domainId, array $nameservers): bool;

    /**
     * Set auto-renewal
     */
    abstract public function setAutoRenewal(string $domainId, bool $enabled): bool;

    /**
     * Lock/unlock domain
     */
    abstract public function lockDomain(string $domainId, bool $locked): bool;

    /**
     * Get pricing
     */
    abstract public function getPricing(string $tld): object;

    /**
     * Get auth code
     */
    abstract public function getAuthCode(string $domainId): string;

    /**
     * Load API credentials for this registrar
     */
    protected function loadCredentials(): void
    {
        $this->credentials = CloudProviderCredential::where('organization_id', $this->organization->id)
            ->where('provider', $this->getName())
            ->firstOrFail();
    }
}
```

### Data Transfer Objects

**File:** `app/DataTransferObjects/DomainRegistration/DomainAvailability.php`

```php
<?php

namespace App\DataTransferObjects\DomainRegistration;

readonly class DomainAvailability
{
    public function __construct(
        public string $domain,
        public bool $available,
        public float $price,
        public string $registrar,
    ) {}
}
```

**File:** `app/DataTransferObjects/DomainRegistration/DomainRegistration.php`

```php
<?php

namespace App\DataTransferObjects\DomainRegistration;

use App\Models\OrganizationDomain;

readonly class DomainRegistration
{
    public function __construct(
        public OrganizationDomain $domain,
        public ?string $transactionId,
        public float $cost,
        public string $message,
    ) {}
}
```

**File:** `app/DataTransferObjects/DomainRegistration/DomainPricing.php`

```php
<?php

namespace App\DataTransferObjects\DomainRegistration;

readonly class DomainPricing
{
    public function __construct(
        public string $tld,
        public float $registrationPrice,
        public float $renewalPrice,
        public float $transferPrice,
        public string $currency,
        public string $registrar,
    ) {}
}
```

### Exception Classes

**File:** `app/Exceptions/Enterprise/RegistrarException.php`

```php
<?php

namespace App\Exceptions\Enterprise;

use Exception;

class RegistrarException extends Exception
{
    //
}
```

**File:** `app/Exceptions/Enterprise/DomainNotAvailableException.php`

```php
<?php

namespace App\Exceptions\Enterprise;

class DomainNotAvailableException extends RegistrarException
{
    //
}
```

## Implementation Approach

### Step 1: Create Service Interface
1. Create `DomainRegistrarServiceInterface` in `app/Contracts/`
2. Define all method signatures with type hints
3. Add comprehensive PHPDoc blocks
4. Define return types and exceptions

### Step 2: Create Data Transfer Objects
1. Create DTOs directory: `app/DataTransferObjects/DomainRegistration/`
2. Implement `DomainAvailability` DTO
3. Implement `DomainRegistration` DTO
4. Implement `DomainRenewal` DTO
5. Implement `DomainTransfer` DTO
6. Implement `DomainInfo` DTO
7. Implement `DomainPricing` DTO
8. Use readonly properties for immutability

### Step 3: Create Exception Classes
1. Create `RegistrarException` base class
2. Create `DomainNotAvailableException`
3. Create `RegistrarApiException`
4. Create `InvalidDomainException`
5. Add to `app/Exceptions/Handler.php` for proper error handling

### Step 4: Implement Base Registrar Client
1. Create abstract `BaseRegistrarClient` class
2. Define abstract methods for all operations
3. Implement credential loading logic
4. Add rate limiting helpers
5. Add error logging methods

### Step 5: Implement Factory Pattern
1. Create `DomainRegistrarFactory`
2. Implement `make(Organization)` for new registrations
3. Implement `makeForDomain(OrganizationDomain)` for existing domains
4. Add registrar name matching logic
5. Throw exception for unsupported registrars

### Step 6: Implement DomainRegistrarService
1. Create service implementation
2. Implement all interface methods
3. Add caching for availability checks and pricing
4. Add comprehensive error handling
5. Add audit logging for all operations
6. Integrate with factory for client creation

### Step 7: Register Service Provider
1. Add binding in `EnterpriseServiceProvider`
2. Register as singleton for performance
3. Add configuration publishing

### Step 8: Create Configuration
1. Add `config/enterprise.php` domain section
2. Define default registrar
3. Define rate limiting settings
4. Define caching TTLs

### Step 9: Testing
1. Create unit tests for service methods
2. Mock registrar clients for isolated testing
3. Create integration tests with registrar API mocking
4. Test error handling and edge cases
5. Test caching behavior

### Step 10: Documentation
1. Add service usage examples
2. Document all DTOs
3. Add error handling guide
4. Create API integration examples

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/DomainRegistrarServiceTest.php`

```php
<?php

use App\Services\Enterprise\DomainRegistrarService;
use App\Services\Enterprise\DomainRegistrars\DomainRegistrarFactory;
use App\Services\Enterprise\DomainRegistrars\NamecheapClient;
use App\Models\Organization;
use App\Models\OrganizationDomain;
use App\DataTransferObjects\DomainRegistration\DomainRegistrationRequest;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    $this->organization = Organization::factory()->create();
    $this->factory = $this->mock(DomainRegistrarFactory::class);
    $this->service = new DomainRegistrarService($this->factory);
});

it('checks domain availability', function () {
    $client = $this->mock(NamecheapClient::class);
    $client->shouldReceive('checkAvailability')
        ->with('example', 'com')
        ->once()
        ->andReturn(true);

    $client->shouldReceive('getPricing')
        ->with('com')
        ->once()
        ->andReturn((object) [
            'registrationPrice' => 12.99,
            'currency' => 'USD',
        ]);

    $client->shouldReceive('getName')
        ->andReturn('namecheap');

    $this->factory->shouldReceive('make')
        ->with($this->organization)
        ->once()
        ->andReturn($client);

    $availability = $this->service->checkAvailability('example', 'com', $this->organization);

    expect($availability->domain)->toBe('example.com');
    expect($availability->available)->toBeTrue();
    expect($availability->price)->toBe(12.99);
});

it('registers a domain successfully', function () {
    $client = $this->mock(NamecheapClient::class);

    $client->shouldReceive('checkAvailability')
        ->andReturn(true);

    $client->shouldReceive('registerDomain')
        ->once()
        ->andReturn([
            'domain_id' => 'NC-12345',
            'expires_at' => now()->addYear(),
            'cost' => 12.99,
            'transaction_id' => 'TXN-789',
        ]);

    $client->shouldReceive('getName')
        ->andReturn('namecheap');

    $this->factory->shouldReceive('make')
        ->andReturn($client);

    $request = new DomainRegistrationRequest(
        domain: 'example',
        tld: 'com',
        years: 1,
        contacts: ['email' => 'admin@example.com'],
        nameservers: ['ns1.example.com', 'ns2.example.com'],
    );

    $registration = $this->service->registerDomain($request, $this->organization);

    expect($registration->domain)->toBeInstanceOf(OrganizationDomain::class);
    expect($registration->cost)->toBe(12.99);

    $this->assertDatabaseHas('organization_domains', [
        'domain' => 'example',
        'tld' => 'com',
        'organization_id' => $this->organization->id,
        'registrar' => 'namecheap',
    ]);
});

it('throws exception for unavailable domain', function () {
    $client = $this->mock(NamecheapClient::class);

    $client->shouldReceive('checkAvailability')
        ->andReturn(false);

    $client->shouldReceive('getName')
        ->andReturn('namecheap');

    $this->factory->shouldReceive('make')
        ->andReturn($client);

    $request = new DomainRegistrationRequest(
        domain: 'google',
        tld: 'com',
        years: 1,
        contacts: [],
        nameservers: [],
    );

    $this->service->registerDomain($request, $this->organization);
})->throws(\App\Exceptions\Enterprise\DomainNotAvailableException::class);

it('renews a domain', function () {
    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $this->organization->id,
        'registrar' => 'namecheap',
        'expires_at' => now()->addMonths(6),
    ]);

    $client = $this->mock(NamecheapClient::class);

    $client->shouldReceive('renewDomain')
        ->with($domain->registrar_domain_id, 1)
        ->once()
        ->andReturn([
            'expires_at' => now()->addMonths(18),
            'cost' => 12.99,
            'transaction_id' => 'TXN-RENEW-123',
        ]);

    $this->factory->shouldReceive('makeForDomain')
        ->with($domain)
        ->andReturn($client);

    $renewal = $this->service->renewDomain($domain, 1);

    expect($renewal->yearsAdded)->toBe(1);
    expect($renewal->cost)->toBe(12.99);

    $domain->refresh();
    expect($domain->expires_at)->toBeGreaterThan(now()->addMonths(17));
});

it('validates domain name format', function () {
    $this->service->checkAvailability('invalid domain!', 'com', $this->organization);
})->throws(\App\Exceptions\Enterprise\InvalidDomainException::class);

it('caches availability checks', function () {
    Cache::shouldReceive('remember')
        ->once()
        ->andReturn((object) [
            'domain' => 'example.com',
            'available' => true,
            'price' => 12.99,
            'registrar' => 'namecheap',
        ]);

    $this->service->checkAvailability('example', 'com', $this->organization);

    // Second call should use cache
    $this->service->checkAvailability('example', 'com', $this->organization);
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/DomainRegistrationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Services\Enterprise\DomainRegistrarService;
use App\DataTransferObjects\DomainRegistration\DomainRegistrationRequest;

it('registers domain end-to-end', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Mock registrar API calls here
    // ... (implementation depends on Task 64, 65)

    $service = app(DomainRegistrarService::class);

    $request = new DomainRegistrationRequest(
        domain: 'testdomain',
        tld: 'com',
        years: 1,
        contacts: [
            'registrant' => [
                'first_name' => 'John',
                'last_name' => 'Doe',
                'email' => 'john@example.com',
            ],
        ],
        nameservers: ['ns1.example.com', 'ns2.example.com'],
    );

    $registration = $service->registerDomain($request, $organization);

    expect($registration->domain->domain)->toBe('testdomain');
    expect($registration->domain->status)->toBe('active');
});
```

## Definition of Done

- [ ] DomainRegistrarServiceInterface created with all method signatures
- [ ] DomainRegistrarService implementation complete
- [ ] DomainRegistrarFactory created with factory pattern
- [ ] BaseRegistrarClient abstract class created
- [ ] All DTOs created (8 total)
- [ ] All exception classes created (4 total)
- [ ] Service registered in EnterpriseServiceProvider
- [ ] Configuration file created for domain settings
- [ ] Domain name validation implemented
- [ ] Caching for availability checks implemented
- [ ] Caching for pricing implemented
- [ ] Comprehensive error handling implemented
- [ ] Audit logging for all operations implemented
- [ ] Unit tests written (12+ tests, >90% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Mocking strategy for registrar APIs documented
- [ ] PHPDoc blocks complete for all methods
- [ ] Code follows Laravel 12 service pattern
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Code reviewed and approved
- [ ] Documentation updated with usage examples

## Related Tasks

- **Depends on:** Task 64 (Namecheap API integration)
- **Depends on:** Task 65 (Route53 Domains API integration)
- **Depends on:** Task 62 (Database schema for domains)
- **Integrates with:** Task 67 (DnsManagementService)
- **Integrates with:** Task 68 (SSL certificate provisioning)
- **Integrates with:** Task 69 (Domain ownership verification)
- **Used by:** Task 70 (DomainManager.vue UI)
