---
name: Extend existing ResourcesCheck pattern with enhanced metrics
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:42Z
github: https://github.com/johnproblems/topgun/issues/133
depends_on: [22]
parallel: false
conflicts_with: []
---

# Task: Extend existing ResourcesCheck pattern with enhanced metrics

## Description
Enhance the existing `app/Actions/Server/ResourcesCheck.php` to collect comprehensive resource metrics (CPU, memory, disk, network, load average) from all connected servers via SSH. This extends Coolify's existing container status checking with detailed resource monitoring for capacity planning and intelligent deployment decisions.

## Technical Approach

### Current ResourcesCheck Implementation Analysis

**Existing Pattern** (`app/Actions/Server/ResourcesCheck.php`):
```php
public function handle()
{
    $seconds = 60;
    try {
        Application::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        ServiceApplication::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        // ... updates all resource types
    } catch (\Throwable $e) {
        return handleError($e);
    }
}
```

**Enhancement Strategy**:
- Preserve existing container status checking logic
- Add new metric collection phase
- Use existing `ExecuteRemoteCommand` trait pattern
- Collect metrics from all active servers
- Store in `server_resource_metrics` table (from Task 22)

### SSH Commands for Metric Collection

#### 1. CPU Metrics
```bash
# Combined command for all CPU metrics
cat /proc/stat | grep '^cpu ' | awk '{usage=($2+$4)*100/($2+$4+$5)} END {printf "%.2f", usage}'; \
cat /proc/loadavg | awk '{print $1,$2,$3}'; \
nproc
```

**Output parsing:**
```
45.32          # CPU usage percentage
0.15 0.25 0.30 # Load averages (1min, 5min, 15min)
4              # Number of CPU cores
```

#### 2. Memory Metrics
```bash
free -b | grep Mem | awk '{print $2,$3,$7}'
```

**Output:**
```
8589934592 4294967296 3221225472  # total, used, available (bytes)
```

#### 3. Disk Metrics
```bash
df -B1 / | tail -n1 | awk '{print $2,$3,$4}'
```

**Output:**
```
53687091200 21474836480 32212254720  # total, used, available (bytes)
```

#### 4. Network Metrics (deltas)
```bash
cat /proc/net/dev | grep -E 'eth0|ens|enp' | head -n1 | awk '{print $2,$10}'
```

**Output:**
```
123456789 987654321  # rx_bytes, tx_bytes (cumulative)
```

#### 5. Container Statistics
```bash
docker ps --format '{{.State}}' | grep -c running; docker ps -a --format '{{.State}}' | wc -l
```

**Output:**
```
5   # running containers
12  # total containers
```

### Enhanced ResourcesCheck Implementation

```php
<?php

namespace App\Actions\Server;

use App\Models\Application;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use App\Models\ServiceApplication;
use App\Models\ServiceDatabase;
use App\Models\StandaloneClickhouse;
use App\Models\StandaloneDragonfly;
use App\Models\StandaloneKeydb;
use App\Models\StandaloneMariadb;
use App\Models\StandaloneMongodb;
use App\Models\StandaloneMysql;
use App\Models\StandalonePostgresql;
use App\Models\StandaloneRedis;
use App\Traits\ExecuteRemoteCommand;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Lorisleiva\Actions\Concerns\AsAction;

class ResourcesCheck
{
    use AsAction, ExecuteRemoteCommand;

    public function handle(): void
    {
        $seconds = 60;

        try {
            // PHASE 1: Existing container status checking (preserve)
            $this->updateContainerStatuses($seconds);

            // PHASE 2: NEW - Collect resource metrics from all servers
            $this->collectServerMetrics();
        } catch (\Throwable $e) {
            return handleError($e);
        }
    }

    /**
     * Update container statuses (existing logic preserved)
     */
    protected function updateContainerStatuses(int $seconds): void
    {
        Application::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        ServiceApplication::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        ServiceDatabase::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandalonePostgresql::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneRedis::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneMongodb::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneMysql::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneMariadb::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneKeydb::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneDragonfly::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
        StandaloneClickhouse::where('last_online_at', '<', now()->subSeconds($seconds))
            ->update(['status' => 'exited']);
    }

    /**
     * Collect resource metrics from all active servers
     */
    protected function collectServerMetrics(): void
    {
        $servers = Server::where('validation_logs', 'OK')
            ->whereNotNull('ip')
            ->get();

        foreach ($servers as $server) {
            try {
                $this->collectMetricsForServer($server);
            } catch (\Throwable $e) {
                Log::warning("Failed to collect metrics for server {$server->id}: {$e->getMessage()}");
                // Continue with next server
            }
        }
    }

    /**
     * Collect all metrics for a single server
     */
    protected function collectMetricsForServer(Server $server): void
    {
        // Execute metric collection commands via SSH
        $cpuMetrics = $this->collectCpuMetrics($server);
        $memoryMetrics = $this->collectMemoryMetrics($server);
        $diskMetrics = $this->collectDiskMetrics($server);
        $networkMetrics = $this->collectNetworkMetrics($server);
        $containerMetrics = $this->collectContainerMetrics($server);

        // Store metrics in database
        $metric = ServerResourceMetric::create([
            'server_id' => $server->id,
            ...$cpuMetrics,
            ...$memoryMetrics,
            ...$diskMetrics,
            ...$networkMetrics,
            ...$containerMetrics,
            'collected_at' => now(),
        ]);

        // Update server's current snapshot for quick dashboard access
        $server->update([
            'current_cpu_usage' => $cpuMetrics['cpu_usage_percent'],
            'current_memory_usage' => $memoryMetrics['memory_usage_percent'],
            'current_disk_usage' => $diskMetrics['disk_usage_percent'],
            'last_metrics_at' => now(),
        ]);

        // Cache latest metrics (60 second TTL)
        Cache::put(
            "server:{$server->id}:metrics:latest",
            $metric->toArray(),
            config('monitoring.cache_ttl.latest_metrics', 60)
        );
    }

    /**
     * Collect CPU metrics via SSH
     */
    protected function collectCpuMetrics(Server $server): array
    {
        $command = <<<'BASH'
cat /proc/stat | grep '^cpu ' | awk '{usage=($2+$4)*100/($2+$4+$5)} END {printf "%.2f\n", usage}'
cat /proc/loadavg | awk '{print $1,$2,$3}'
nproc
BASH;

        $output = $this->execute_remote_command(
            ['command' => $command],
            $server
        );

        $lines = explode("\n", trim($output));

        $cpuUsage = (float) ($lines[0] ?? 0);
        $loadAvg = explode(' ', $lines[1] ?? '0 0 0');
        $cores = (int) ($lines[2] ?? 1);

        return [
            'cpu_usage_percent' => round($cpuUsage, 2),
            'cpu_load_1min' => (float) ($loadAvg[0] ?? 0),
            'cpu_load_5min' => (float) ($loadAvg[1] ?? 0),
            'cpu_load_15min' => (float) ($loadAvg[2] ?? 0),
            'cpu_cores' => $cores,
        ];
    }

    /**
     * Collect memory metrics via SSH
     */
    protected function collectMemoryMetrics(Server $server): array
    {
        $command = "free -b | grep Mem | awk '{print \$2,\$3,\$7}'";

        $output = $this->execute_remote_command(
            ['command' => $command],
            $server
        );

        $values = explode(' ', trim($output));

        $total = (int) ($values[0] ?? 0);
        $used = (int) ($values[1] ?? 0);
        $available = (int) ($values[2] ?? 0);
        $usagePercent = $total > 0 ? round(($used / $total) * 100, 2) : 0;

        return [
            'memory_total_bytes' => $total,
            'memory_used_bytes' => $used,
            'memory_available_bytes' => $available,
            'memory_usage_percent' => $usagePercent,
        ];
    }

    /**
     * Collect disk metrics via SSH
     */
    protected function collectDiskMetrics(Server $server): array
    {
        $command = "df -B1 / | tail -n1 | awk '{print \$2,\$3,\$4}'";

        $output = $this->execute_remote_command(
            ['command' => $command],
            $server
        );

        $values = explode(' ', trim($output));

        $total = (int) ($values[0] ?? 0);
        $used = (int) ($values[1] ?? 0);
        $available = (int) ($values[2] ?? 0);
        $usagePercent = $total > 0 ? round(($used / $total) * 100, 2) : 0;

        // TODO: Collect disk I/O metrics (requires storing previous values for delta)
        return [
            'disk_total_bytes' => $total,
            'disk_used_bytes' => $used,
            'disk_available_bytes' => $available,
            'disk_usage_percent' => $usagePercent,
            'disk_read_bytes' => null, // Future enhancement
            'disk_write_bytes' => null, // Future enhancement
        ];
    }

    /**
     * Collect network metrics via SSH
     */
    protected function collectNetworkMetrics(Server $server): array
    {
        $command = "cat /proc/net/dev | grep -E 'eth0|ens|enp' | head -n1 | awk '{print \$2,\$10}'";

        $output = $this->execute_remote_command(
            ['command' => $command],
            $server
        );

        $values = explode(' ', trim($output));

        // TODO: Calculate deltas by comparing with previous reading
        return [
            'network_rx_bytes' => null, // Future: delta calculation
            'network_tx_bytes' => null, // Future: delta calculation
        ];
    }

    /**
     * Collect Docker container statistics via SSH
     */
    protected function collectContainerMetrics(Server $server): array
    {
        $command = "docker ps --format '{{.State}}' | grep -c running; docker ps -a --format '{{.State}}' | wc -l";

        $output = $this->execute_remote_command(
            ['command' => $command],
            $server
        );

        $lines = explode("\n", trim($output));

        return [
            'running_containers' => (int) ($lines[0] ?? 0),
            'total_containers' => (int) ($lines[1] ?? 0),
        ];
    }
}
```

## Error Handling Strategy

### SSH Connection Failures
```php
protected function collectMetricsForServer(Server $server): void
{
    if (!$server->isSshReachable()) {
        Log::warning("Server {$server->id} is not SSH reachable, skipping metrics");
        return;
    }

    // Timeout for metric collection: 10 seconds
    try {
        $this->execute_remote_command(
            ['command' => $command, 'timeout' => 10],
            $server
        );
    } catch (\Exception $e) {
        // Log and continue - don't block other servers
        Log::error("Metric collection failed for server {$server->id}: {$e->getMessage()}");
        throw $e;
    }
}
```

### Malformed Output Handling
- Use null coalescing operators for parsing
- Validate numeric ranges (CPU 0-100%, etc.)
- Log warnings for unexpected values
- Continue processing other metrics

## Performance Considerations

### Parallel Execution (Future Enhancement)
```php
// Execute SSH commands in parallel using Laravel's Process::pool()
use Illuminate\Support\Facades\Process;

$results = Process::pool(function ($pool) use ($servers) {
    foreach ($servers as $server) {
        $pool->command("ssh {$server->ip} '{$command}'");
    }
})->start()->wait();
```

### Timeout Configuration
- **SSH Connection Timeout**: 5 seconds
- **Command Execution Timeout**: 10 seconds per server
- **Total Job Timeout**: 5 minutes (for 100+ servers)

## Redis Caching Integration

**Cache latest metrics immediately after collection:**
```php
Cache::put("server:{$server->id}:metrics:latest", $metric->toArray(), 60);
```

**Invalidate on-demand for real-time dashboards:**
```php
// Triggered by ResourceMonitoringJob every 30 seconds
Cache::tags(['server-metrics'])->flush();
```

## Testing Strategy

### Unit Tests
```php
// tests/Unit/Actions/ResourcesCheckTest.php
use App\Actions\Server\ResourcesCheck;
use App\Models\Server;
use App\Models\ServerResourceMetric;
use Illuminate\Support\Facades\Cache;

it('collects CPU metrics correctly', function () {
    $server = Server::factory()->create();

    $action = new ResourcesCheck();
    $metrics = $action->collectCpuMetrics($server);

    expect($metrics)->toHaveKeys([
        'cpu_usage_percent', 'cpu_load_1min', 'cpu_load_5min',
        'cpu_load_15min', 'cpu_cores'
    ]);
    expect($metrics['cpu_usage_percent'])->toBeGreaterThanOrEqual(0);
    expect($metrics['cpu_usage_percent'])->toBeLessThanOrEqual(100);
});

it('handles SSH failures gracefully', function () {
    $server = Server::factory()->create(['ip' => '192.0.2.1']); // Non-existent

    $action = new ResourcesCheck();

    // Should not throw exception
    expect(fn() => $action->collectMetricsForServer($server))->not->toThrow();
});

it('caches latest metrics', function () {
    $server = Server::factory()->create();
    $action = new ResourcesCheck();

    $action->collectMetricsForServer($server);

    $cached = Cache::get("server:{$server->id}:metrics:latest");
    expect($cached)->not->toBeNull();
    expect($cached['cpu_usage_percent'])->toBeNumeric();
});
```

### Feature Tests
```php
// tests/Feature/Metrics/MetricCollectionTest.php
use App\Actions\Server\ResourcesCheck;
use App\Models\Server;
use App\Models\ServerResourceMetric;

it('creates metric record in database', function () {
    $server = Server::factory()->create();

    (new ResourcesCheck())->handle();

    $this->assertDatabaseHas('server_resource_metrics', [
        'server_id' => $server->id,
    ]);
});

it('updates server current usage snapshot', function () {
    $server = Server::factory()->create([
        'current_cpu_usage' => null,
        'last_metrics_at' => null,
    ]);

    (new ResourcesCheck())->handle();

    $server->refresh();
    expect($server->current_cpu_usage)->not->toBeNull();
    expect($server->last_metrics_at)->not->toBeNull();
});

it('preserves existing container status logic', function () {
    $application = Application::factory()->create([
        'last_online_at' => now()->subMinutes(2),
        'status' => 'running',
    ]);

    (new ResourcesCheck())->handle();

    $application->refresh();
    expect($application->status)->toBe('exited');
});
```

### Integration Tests with Mocked SSH
```php
use App\Traits\ExecuteRemoteCommand;
use Mockery;

it('parses SSH output correctly', function () {
    $server = Server::factory()->create();

    // Mock SSH response
    $mockOutput = "45.32\n0.15 0.25 0.30\n4";

    $action = Mockery::mock(ResourcesCheck::class)->makePartial();
    $action->shouldReceive('execute_remote_command')
        ->andReturn($mockOutput);

    $metrics = $action->collectCpuMetrics($server);

    expect($metrics['cpu_usage_percent'])->toBe(45.32);
    expect($metrics['cpu_cores'])->toBe(4);
});
```

## Acceptance Criteria
- [ ] ResourcesCheck preserves existing container status logic
- [ ] New collectServerMetrics() method added
- [ ] All 5 metric types collected (CPU, memory, disk, network, containers)
- [ ] Metrics stored in server_resource_metrics table
- [ ] Server current_* fields updated for quick access
- [ ] Redis caching implemented with 60s TTL
- [ ] SSH failures logged but don't block other servers
- [ ] ExecuteRemoteCommand trait used for SSH
- [ ] Timeout configuration prevents job hangs
- [ ] Unit tests cover all metric collection methods
- [ ] Feature tests verify end-to-end flow
- [ ] Integration tests mock SSH responses

## Technical Details
- Size: M
- Estimated hours: 10-14
- Extends existing Lorisleiva Action pattern
- Uses ExecuteRemoteCommand trait (existing)
- SSH command optimization

## Dependencies
- [ ] Task 22 (server_resource_metrics table)
- [ ] Existing ExecuteRemoteCommand trait
- [ ] Server model with SSH connectivity

## Performance Benchmarks
- **Single server metric collection**: < 3 seconds
- **100 servers sequential**: < 5 minutes (acceptable for 30s interval)
- **Future parallel execution**: < 30 seconds for 100 servers

## Configuration Updates

```php
// config/monitoring.php (additions)
return [
    // ... existing config
    'ssh_timeout' => env('METRICS_SSH_TIMEOUT', 10), // seconds
    'collection_parallel' => env('METRICS_PARALLEL', false), // Future feature
    'skip_unreachable_servers' => env('METRICS_SKIP_UNREACHABLE', true),
];
```

## Definition of Done
- [ ] ResourcesCheck enhanced with metric collection
- [ ] All SSH commands optimized for speed
- [ ] Error handling prevents cascading failures
- [ ] Caching reduces database load for dashboards
- [ ] Server snapshot fields updated
- [ ] Unit and feature tests passing
- [ ] Code passes PHPStan level 5
- [ ] Code formatted with Laravel Pint
- [ ] Existing functionality not broken
- [ ] Performance acceptable for 30s interval
