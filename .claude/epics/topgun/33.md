---
name: Implement rolling update deployment strategy
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:51Z
github: https://github.com/johnproblems/topgun/issues/143
depends_on: [32]
parallel: false
conflicts_with: []
---

# Task: Implement rolling update deployment strategy

## Description

Implement a sophisticated rolling update deployment strategy for zero-downtime application deployments in Coolify Enterprise. This feature enables applications to be updated incrementally across multiple server instances in controlled batches, ensuring high availability and automatic rollback capabilities if health checks fail during the deployment process.

Rolling updates are critical for enterprise applications that require continuous availability. Unlike traditional "big bang" deployments that update all instances simultaneously (causing downtime), or blue-green deployments that require double the resources, rolling updates provide a balanced approach by:

1. **Minimizing Resource Overhead**: Update existing instances incrementally without requiring duplicate infrastructure
2. **Ensuring Zero Downtime**: Maintain service availability by keeping healthy instances serving traffic during updates
3. **Providing Safety Mechanisms**: Health checks validate each batch before proceeding, with automatic rollback on failures
4. **Configurable Risk Management**: Adjustable batch sizes allow organizations to balance deployment speed vs. risk tolerance
5. **Load Balancer Integration**: Seamlessly remove unhealthy instances from load balancers during updates

This task integrates with the enhanced deployment infrastructure by:
- **Building on EnhancedDeploymentService (Task 32)**: Extends the base deployment service with rolling update logic
- **Using CapacityManager (Task 26)**: Validates sufficient capacity exists before starting updates
- **Leveraging ResourceMonitor (Task 25)**: Monitors instance health during deployment process
- **Coordinating with Load Balancers**: Integrates with Traefik/Nginx proxy for traffic management
- **Providing Vue.js UI**: Deployment configuration and real-time progress visualization

**Why this task is important:** For enterprise customers running customer-facing applications, downtime is unacceptable. Rolling updates enable continuous deployment of bug fixes, security patches, and new features without interrupting service. This is a foundational enterprise feature that differentiates Coolify Enterprise from the community edition, which primarily supports simple redeploy workflows.

**Real-World Use Cases:**
- E-commerce platform deploying checkout flow updates during peak shopping hours
- SaaS application updating payment processing logic without customer disruption
- Multi-tenant platform deploying tenant-specific customizations without global downtime
- API service updating authentication logic while maintaining active user sessions

## Acceptance Criteria

- [ ] Rolling update strategy implemented in EnhancedDeploymentService with configurable batch sizes
- [ ] Health check system validates each instance before marking batch as successful
- [ ] Automatic rollback mechanism triggers on consecutive health check failures
- [ ] Support for multiple batch size configurations: 1-at-a-time, 25%, 50%, all-at-once
- [ ] Load balancer drain mechanism removes unhealthy instances from traffic rotation
- [ ] Wait interval between batches is configurable (default: 30 seconds)
- [ ] Pre-deployment validation ensures minimum healthy instances remain during updates
- [ ] Deployment job tracks progress per-batch with status updates
- [ ] WebSocket broadcasting sends real-time deployment progress to UI
- [ ] Rollback preserves previous Docker images/tags for instant recovery
- [ ] Support for custom health check endpoints (default: /, custom: /health, /ready)
- [ ] Integration with Application model supports both single-server and multi-server applications
- [ ] Database records track deployment history with batch-level granularity
- [ ] Error handling provides detailed failure reasons (health check timeout, container start failure, etc.)
- [ ] Performance requirement: batch deployment completion within 60 seconds

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/EnhancedDeploymentService.php` (enhance existing from Task 32)
- `/home/topgun/topgun/app/Contracts/EnhancedDeploymentServiceInterface.php` (enhance existing)

**Strategy Implementation:**
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/RollingUpdateStrategy.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/Deployment/HealthCheckService.php` (new)
- `/home/topgun/topgun/app/Contracts/DeploymentStrategyInterface.php` (new)

**Background Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/RollingUpdateDeploymentJob.php` (new)
- `/home/topgun/topgun/app/Jobs/Enterprise/HealthCheckBatchJob.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Enterprise/DeploymentBatch.php` (new)
- `/home/topgun/topgun/app/Models/Enterprise/Deployment.php` (enhance existing)

**Database Migrations:**
- `/home/topgun/topgun/database/migrations/YYYY_MM_DD_create_deployment_batches_table.php` (new)
- `/home/topgun/topgun/database/migrations/YYYY_MM_DD_add_rolling_update_fields_to_deployments.php` (new)

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/DeploymentController.php` (enhance existing)

**Routes:**
- `/home/topgun/topgun/routes/api.php` (add rolling update endpoints)

### Database Schema

#### New Table: deployment_batches

Tracks each batch in a rolling update deployment:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('deployment_batches', function (Blueprint $table) {
            $table->id();
            $table->foreignId('deployment_id')
                ->constrained('deployments')
                ->onDelete('cascade');
            $table->integer('batch_number'); // 1, 2, 3...
            $table->integer('total_batches'); // Total batches in deployment
            $table->json('server_ids'); // Array of server IDs in this batch
            $table->integer('target_instance_count'); // Expected instances per server
            $table->enum('status', [
                'pending',
                'in_progress',
                'health_checking',
                'completed',
                'failed',
                'rolled_back'
            ])->default('pending');
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->integer('successful_instances')->default(0);
            $table->integer('failed_instances')->default(0);
            $table->json('health_check_results')->nullable(); // Detailed health check logs
            $table->text('failure_reason')->nullable();
            $table->timestamps();

            $table->index(['deployment_id', 'batch_number']);
            $table->index('status');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('deployment_batches');
    }
};
```

#### Enhanced Table: deployments

Add rolling update configuration fields:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('deployments', function (Blueprint $table) {
            // Rolling update configuration
            $table->enum('deployment_strategy', [
                'simple',
                'rolling',
                'blue_green',
                'canary'
            ])->default('simple')->after('status');

            $table->integer('batch_size')->nullable()
                ->comment('Percentage or absolute number of instances per batch');
            $table->boolean('batch_size_is_percentage')->default(true)
                ->comment('True if batch_size is percentage, false if absolute count');
            $table->integer('wait_interval')->default(30)
                ->comment('Seconds to wait between batches');
            $table->integer('health_check_timeout')->default(120)
                ->comment('Seconds to wait for health checks');
            $table->string('health_check_path')->default('/')
                ->comment('HTTP path for health checks');
            $table->integer('health_check_interval')->default(5)
                ->comment('Seconds between health check attempts');
            $table->integer('max_health_check_retries')->default(10);
            $table->integer('minimum_healthy_instances')->default(1)
                ->comment('Minimum instances that must remain healthy');

            // Rollback configuration
            $table->boolean('auto_rollback_on_failure')->default(true);
            $table->integer('failure_threshold')->default(2)
                ->comment('Consecutive batch failures before rollback');
            $table->string('previous_docker_image')->nullable()
                ->comment('Docker image to rollback to');
            $table->string('previous_docker_tag')->nullable();

            // Progress tracking
            $table->integer('total_batches')->default(0);
            $table->integer('completed_batches')->default(0);
            $table->integer('failed_batches')->default(0);

            $table->index('deployment_strategy');
        });
    }

    public function down(): void
    {
        Schema::table('deployments', function (Blueprint $table) {
            $table->dropColumn([
                'deployment_strategy',
                'batch_size',
                'batch_size_is_percentage',
                'wait_interval',
                'health_check_timeout',
                'health_check_path',
                'health_check_interval',
                'max_health_check_retries',
                'minimum_healthy_instances',
                'auto_rollback_on_failure',
                'failure_threshold',
                'previous_docker_image',
                'previous_docker_tag',
                'total_batches',
                'completed_batches',
                'failed_batches',
            ]);
        });
    }
};
```

### Core Implementation: RollingUpdateStrategy

**File:** `app/Services/Enterprise/Deployment/RollingUpdateStrategy.php`

```php
<?php

namespace App\Services\Enterprise\Deployment;

use App\Contracts\DeploymentStrategyInterface;
use App\Models\Application;
use App\Models\Enterprise\Deployment;
use App\Models\Enterprise\DeploymentBatch;
use App\Models\Server;
use App\Services\Enterprise\CapacityManager;
use App\Jobs\Enterprise\HealthCheckBatchJob;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class RollingUpdateStrategy implements DeploymentStrategyInterface
{
    public function __construct(
        private HealthCheckService $healthCheckService,
        private CapacityManager $capacityManager
    ) {}

    /**
     * Execute rolling update deployment
     *
     * @param Application $application
     * @param Deployment $deployment
     * @param array $config Configuration: batch_size, wait_interval, health_check_path, etc.
     * @return bool Success status
     */
    public function deploy(Application $application, Deployment $deployment, array $config = []): bool
    {
        Log::info("Starting rolling update for application: {$application->name}", [
            'deployment_id' => $deployment->id,
            'config' => $config
        ]);

        try {
            // Step 1: Validate pre-deployment conditions
            $this->validatePreDeployment($application, $deployment);

            // Step 2: Get all servers and instances for this application
            $servers = $this->getApplicationServers($application);

            if ($servers->isEmpty()) {
                throw new \RuntimeException('No servers available for deployment');
            }

            // Step 3: Store previous image for rollback capability
            $this->storePreviousDeployment($application, $deployment);

            // Step 4: Calculate batches based on configuration
            $batches = $this->calculateBatches($servers, $config);

            $deployment->update([
                'total_batches' => count($batches),
                'batch_size' => $config['batch_size'] ?? 25,
                'batch_size_is_percentage' => $config['batch_size_is_percentage'] ?? true,
                'wait_interval' => $config['wait_interval'] ?? 30,
                'health_check_path' => $config['health_check_path'] ?? '/',
                'health_check_timeout' => $config['health_check_timeout'] ?? 120,
            ]);

            Log::info("Calculated {$deployment->total_batches} batches for rolling update");

            // Step 5: Execute batches sequentially
            $consecutiveFailures = 0;
            $failureThreshold = $deployment->failure_threshold ?? 2;

            foreach ($batches as $batchNumber => $batchServers) {
                Log::info("Processing batch {$batchNumber} of {$deployment->total_batches}");

                // Create deployment batch record
                $deploymentBatch = $this->createDeploymentBatch(
                    $deployment,
                    $batchNumber,
                    count($batches),
                    $batchServers
                );

                // Execute batch deployment
                $batchSuccess = $this->deployBatch(
                    $application,
                    $deployment,
                    $deploymentBatch,
                    $batchServers
                );

                if (!$batchSuccess) {
                    $consecutiveFailures++;
                    $deployment->increment('failed_batches');

                    Log::error("Batch {$batchNumber} failed (consecutive failures: {$consecutiveFailures})");

                    // Check if we've hit failure threshold
                    if ($consecutiveFailures >= $failureThreshold && $deployment->auto_rollback_on_failure) {
                        Log::warning("Failure threshold reached. Initiating automatic rollback.");
                        $this->rollbackDeployment($application, $deployment);
                        return false;
                    }
                } else {
                    // Reset consecutive failures on success
                    $consecutiveFailures = 0;
                    $deployment->increment('completed_batches');

                    Log::info("Batch {$batchNumber} completed successfully");

                    // Wait before next batch (except for last batch)
                    if ($batchNumber < count($batches)) {
                        $waitSeconds = $deployment->wait_interval;
                        Log::info("Waiting {$waitSeconds} seconds before next batch");
                        sleep($waitSeconds);
                    }
                }
            }

            // Step 6: Final validation - all batches should be successful
            if ($deployment->failed_batches > 0) {
                Log::error("Deployment completed with {$deployment->failed_batches} failed batches");
                $deployment->update(['status' => 'completed_with_errors']);
                return false;
            }

            $deployment->update(['status' => 'completed']);
            Log::info("Rolling update completed successfully for application: {$application->name}");

            return true;

        } catch (\Exception $e) {
            Log::error("Rolling update failed: {$e->getMessage()}", [
                'application_id' => $application->id,
                'deployment_id' => $deployment->id,
                'exception' => $e
            ]);

            $deployment->update([
                'status' => 'failed',
                'failure_reason' => $e->getMessage()
            ]);

            // Attempt rollback if enabled
            if ($deployment->auto_rollback_on_failure) {
                $this->rollbackDeployment($application, $deployment);
            }

            return false;
        }
    }

    /**
     * Validate pre-deployment conditions
     */
    private function validatePreDeployment(Application $application, Deployment $deployment): void
    {
        // Check minimum healthy instances requirement
        $currentHealthyInstances = $this->healthCheckService->getHealthyInstanceCount($application);
        $minimumRequired = $deployment->minimum_healthy_instances ?? 1;

        if ($currentHealthyInstances < $minimumRequired) {
            throw new \RuntimeException(
                "Insufficient healthy instances. Current: {$currentHealthyInstances}, Minimum required: {$minimumRequired}"
            );
        }

        // Validate capacity using CapacityManager
        $servers = $this->getApplicationServers($application);
        foreach ($servers as $server) {
            if (!$this->capacityManager->canServerHandleDeployment($server, $application)) {
                throw new \RuntimeException("Server {$server->name} has insufficient capacity for deployment");
            }
        }

        Log::info("Pre-deployment validation passed", [
            'healthy_instances' => $currentHealthyInstances,
            'minimum_required' => $minimumRequired
        ]);
    }

    /**
     * Get servers where application is deployed
     */
    private function getApplicationServers(Application $application): Collection
    {
        // For multi-server applications, get all destination servers
        // For single-server applications, return the primary server
        return $application->destination->server
            ? collect([$application->destination->server])
            : collect();
    }

    /**
     * Store previous deployment information for rollback
     */
    private function storePreviousDeployment(Application $application, Deployment $deployment): void
    {
        // Get current Docker image and tag
        $currentImage = $application->docker_image ?? $application->git_repository;
        $currentTag = $application->docker_tag ?? $application->git_branch ?? 'latest';

        $deployment->update([
            'previous_docker_image' => $currentImage,
            'previous_docker_tag' => $currentTag
        ]);

        Log::info("Stored previous deployment for rollback", [
            'image' => $currentImage,
            'tag' => $currentTag
        ]);
    }

    /**
     * Calculate deployment batches based on configuration
     *
     * @param Collection $servers Collection of Server models
     * @param array $config Deployment configuration
     * @return array Array of batches, each containing server IDs
     */
    private function calculateBatches(Collection $servers, array $config): array
    {
        $batchSize = $config['batch_size'] ?? 25; // Default: 25%
        $isPercentage = $config['batch_size_is_percentage'] ?? true;

        $totalServers = $servers->count();

        if ($isPercentage) {
            // Calculate absolute count from percentage
            $serversPerBatch = max(1, (int) ceil($totalServers * ($batchSize / 100)));
        } else {
            // Use absolute count
            $serversPerBatch = max(1, (int) $batchSize);
        }

        // Split servers into batches
        $batches = [];
        $serverIds = $servers->pluck('id')->toArray();

        foreach (array_chunk($serverIds, $serversPerBatch) as $index => $batchServerIds) {
            $batches[$index + 1] = $batchServerIds; // 1-indexed batch numbers
        }

        Log::info("Calculated batches", [
            'total_servers' => $totalServers,
            'servers_per_batch' => $serversPerBatch,
            'total_batches' => count($batches),
            'batch_size_config' => $batchSize,
            'is_percentage' => $isPercentage
        ]);

        return $batches;
    }

    /**
     * Create deployment batch record
     */
    private function createDeploymentBatch(
        Deployment $deployment,
        int $batchNumber,
        int $totalBatches,
        array $serverIds
    ): DeploymentBatch {
        return DeploymentBatch::create([
            'deployment_id' => $deployment->id,
            'batch_number' => $batchNumber,
            'total_batches' => $totalBatches,
            'server_ids' => $serverIds,
            'target_instance_count' => 1, // Can be configured per application
            'status' => 'pending'
        ]);
    }

    /**
     * Deploy single batch to specified servers
     *
     * @param Application $application
     * @param Deployment $deployment
     * @param DeploymentBatch $batch
     * @param array $serverIds Server IDs in this batch
     * @return bool Success status
     */
    private function deployBatch(
        Application $application,
        Deployment $deployment,
        DeploymentBatch $batch,
        array $serverIds
    ): bool {
        $batch->update([
            'status' => 'in_progress',
            'started_at' => now()
        ]);

        try {
            $servers = Server::whereIn('id', $serverIds)->get();

            // Step 1: Remove old containers from load balancer (drain)
            foreach ($servers as $server) {
                $this->drainServerFromLoadBalancer($application, $server);
            }

            // Step 2: Deploy new version to each server in batch
            $deploymentResults = [];
            foreach ($servers as $server) {
                $success = $this->deployToServer($application, $server, $deployment);
                $deploymentResults[$server->id] = $success;

                if ($success) {
                    $batch->increment('successful_instances');
                } else {
                    $batch->increment('failed_instances');
                }
            }

            // Step 3: Wait for containers to start
            sleep(10);

            // Step 4: Perform health checks
            $batch->update(['status' => 'health_checking']);

            $healthCheckResults = $this->performBatchHealthChecks($application, $servers, $deployment);

            $batch->update([
                'health_check_results' => $healthCheckResults
            ]);

            // Step 5: Evaluate health check results
            $allHealthy = collect($healthCheckResults)->every(fn($result) => $result['healthy'] === true);

            if ($allHealthy) {
                // Step 6: Add new containers back to load balancer
                foreach ($servers as $server) {
                    $this->addServerToLoadBalancer($application, $server);
                }

                $batch->update([
                    'status' => 'completed',
                    'completed_at' => now()
                ]);

                Log::info("Batch {$batch->batch_number} deployed successfully");
                return true;

            } else {
                // Health checks failed
                $failedServers = collect($healthCheckResults)
                    ->filter(fn($result) => $result['healthy'] === false)
                    ->keys();

                $batch->update([
                    'status' => 'failed',
                    'completed_at' => now(),
                    'failure_reason' => "Health checks failed for servers: " . $failedServers->implode(', ')
                ]);

                Log::error("Batch {$batch->batch_number} health checks failed", [
                    'failed_servers' => $failedServers->toArray()
                ]);

                // Rollback this batch
                $this->rollbackBatch($application, $deployment, $batch, $servers);

                return false;
            }

        } catch (\Exception $e) {
            $batch->update([
                'status' => 'failed',
                'completed_at' => now(),
                'failure_reason' => $e->getMessage()
            ]);

            Log::error("Batch deployment failed with exception", [
                'batch_number' => $batch->batch_number,
                'error' => $e->getMessage()
            ]);

            return false;
        }
    }

    /**
     * Deploy application to single server
     */
    private function deployToServer(Application $application, Server $server, Deployment $deployment): bool
    {
        try {
            Log::info("Deploying to server: {$server->name}");

            // Use Coolify's existing ExecuteRemoteCommand trait pattern
            $deployScript = $this->generateDeployScript($application, $deployment);

            $result = instant_remote_process([
                $deployScript
            ], $server);

            if ($result->exitCode() !== 0) {
                Log::error("Deployment script failed on server: {$server->name}", [
                    'exit_code' => $result->exitCode(),
                    'output' => $result->output()
                ]);
                return false;
            }

            Log::info("Deployment to server {$server->name} completed successfully");
            return true;

        } catch (\Exception $e) {
            Log::error("Failed to deploy to server {$server->name}: {$e->getMessage()}");
            return false;
        }
    }

    /**
     * Generate deployment script for server
     */
    private function generateDeployScript(Application $application, Deployment $deployment): string
    {
        // Generate Docker commands based on application type
        $imageName = $deployment->docker_image ?? $application->docker_image;
        $imageTag = $deployment->docker_tag ?? $application->docker_tag ?? 'latest';
        $containerName = "coolify-{$application->uuid}";

        return <<<BASH
#!/bin/bash
set -e

# Pull new image
docker pull {$imageName}:{$imageTag}

# Stop old container
docker stop {$containerName} || true
docker rm {$containerName} || true

# Start new container
docker run -d \
    --name {$containerName} \
    --restart unless-stopped \
    -p 80:80 \
    {$imageName}:{$imageTag}

echo "Deployment completed successfully"
BASH;
    }

    /**
     * Perform health checks on all servers in batch
     */
    private function performBatchHealthChecks(
        Application $application,
        Collection $servers,
        Deployment $deployment
    ): array {
        $results = [];
        $healthCheckPath = $deployment->health_check_path;
        $timeout = $deployment->health_check_timeout;
        $interval = $deployment->health_check_interval ?? 5;
        $maxRetries = $deployment->max_health_check_retries ?? 10;

        foreach ($servers as $server) {
            $results[$server->id] = $this->healthCheckService->checkServerHealth(
                $application,
                $server,
                $healthCheckPath,
                $timeout,
                $interval,
                $maxRetries
            );
        }

        return $results;
    }

    /**
     * Remove server from load balancer (drain connections)
     */
    private function drainServerFromLoadBalancer(Application $application, Server $server): void
    {
        Log::info("Draining server from load balancer", [
            'server' => $server->name,
            'application' => $application->name
        ]);

        // This integrates with Coolify's existing proxy configuration
        // For Traefik/Nginx, we would update the configuration to remove this backend

        // Simplified implementation - actual implementation would depend on proxy type
        try {
            if ($application->destination->server->proxy->type === 'traefik') {
                // Update Traefik configuration to mark server as down
                $this->updateTraefikConfig($application, $server, 'down');
            }
        } catch (\Exception $e) {
            Log::warning("Failed to drain server from load balancer: {$e->getMessage()}");
        }
    }

    /**
     * Add server back to load balancer
     */
    private function addServerToLoadBalancer(Application $application, Server $server): void
    {
        Log::info("Adding server back to load balancer", [
            'server' => $server->name,
            'application' => $application->name
        ]);

        try {
            if ($application->destination->server->proxy->type === 'traefik') {
                // Update Traefik configuration to mark server as up
                $this->updateTraefikConfig($application, $server, 'up');
            }
        } catch (\Exception $e) {
            Log::warning("Failed to add server to load balancer: {$e->getMessage()}");
        }
    }

    /**
     * Update Traefik configuration for server
     */
    private function updateTraefikConfig(Application $application, Server $server, string $status): void
    {
        // Placeholder for actual Traefik configuration update
        // Would interact with Coolify's existing proxy configuration system
        Log::debug("Traefik config update: {$status}", [
            'server' => $server->name,
            'application' => $application->name
        ]);
    }

    /**
     * Rollback entire deployment
     */
    private function rollbackDeployment(Application $application, Deployment $deployment): void
    {
        Log::warning("Rolling back entire deployment", [
            'deployment_id' => $deployment->id,
            'application' => $application->name
        ]);

        try {
            $servers = $this->getApplicationServers($application);

            foreach ($servers as $server) {
                $this->rollbackServerDeployment($application, $server, $deployment);
            }

            $deployment->update([
                'status' => 'rolled_back',
                'completed_at' => now()
            ]);

            Log::info("Deployment rolled back successfully");

        } catch (\Exception $e) {
            Log::error("Rollback failed: {$e->getMessage()}");
            $deployment->update([
                'status' => 'rollback_failed',
                'failure_reason' => "Rollback failed: {$e->getMessage()}"
            ]);
        }
    }

    /**
     * Rollback single batch
     */
    private function rollbackBatch(
        Application $application,
        Deployment $deployment,
        DeploymentBatch $batch,
        Collection $servers
    ): void {
        Log::warning("Rolling back batch {$batch->batch_number}");

        foreach ($servers as $server) {
            $this->rollbackServerDeployment($application, $server, $deployment);
        }

        $batch->update(['status' => 'rolled_back']);
    }

    /**
     * Rollback deployment on single server
     */
    private function rollbackServerDeployment(Application $application, Server $server, Deployment $deployment): void
    {
        $previousImage = $deployment->previous_docker_image;
        $previousTag = $deployment->previous_docker_tag;

        if (!$previousImage || !$previousTag) {
            Log::error("Cannot rollback: no previous image stored");
            return;
        }

        Log::info("Rolling back server: {$server->name}", [
            'previous_image' => $previousImage,
            'previous_tag' => $previousTag
        ]);

        $rollbackScript = $this->generateRollbackScript($application, $previousImage, $previousTag);

        try {
            instant_remote_process([$rollbackScript], $server);
            Log::info("Server {$server->name} rolled back successfully");
        } catch (\Exception $e) {
            Log::error("Rollback failed for server {$server->name}: {$e->getMessage()}");
        }
    }

    /**
     * Generate rollback script
     */
    private function generateRollbackScript(Application $application, string $previousImage, string $previousTag): string
    {
        $containerName = "coolify-{$application->uuid}";

        return <<<BASH
#!/bin/bash
set -e

echo "Rolling back to {$previousImage}:{$previousTag}"

# Stop current container
docker stop {$containerName} || true
docker rm {$containerName} || true

# Start previous version
docker run -d \
    --name {$containerName} \
    --restart unless-stopped \
    -p 80:80 \
    {$previousImage}:{$previousTag}

echo "Rollback completed successfully"
BASH;
    }
}
```

### Health Check Service Implementation

**File:** `app/Services/Enterprise/Deployment/HealthCheckService.php`

```php
<?php

namespace App\Services\Enterprise\Deployment;

use App\Models\Application;
use App\Models\Server;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class HealthCheckService
{
    /**
     * Check server health for application
     *
     * @param Application $application
     * @param Server $server
     * @param string $healthCheckPath HTTP path to check (e.g., /, /health)
     * @param int $timeout Total timeout in seconds
     * @param int $interval Interval between retries in seconds
     * @param int $maxRetries Maximum number of retry attempts
     * @return array Health check result with status and details
     */
    public function checkServerHealth(
        Application $application,
        Server $server,
        string $healthCheckPath = '/',
        int $timeout = 120,
        int $interval = 5,
        int $maxRetries = 10
    ): array {
        $startTime = time();
        $attempts = 0;

        // Determine application URL
        $url = $this->getApplicationUrl($application, $server, $healthCheckPath);

        Log::info("Starting health check", [
            'url' => $url,
            'timeout' => $timeout,
            'max_retries' => $maxRetries
        ]);

        while ($attempts < $maxRetries && (time() - $startTime) < $timeout) {
            $attempts++;

            try {
                $response = Http::timeout(10)->get($url);

                if ($response->successful()) {
                    Log::info("Health check passed", [
                        'url' => $url,
                        'attempts' => $attempts,
                        'status_code' => $response->status()
                    ]);

                    return [
                        'healthy' => true,
                        'status_code' => $response->status(),
                        'attempts' => $attempts,
                        'elapsed_time' => time() - $startTime,
                        'message' => 'Health check passed'
                    ];
                }

                Log::debug("Health check attempt {$attempts} failed", [
                    'status_code' => $response->status()
                ]);

            } catch (\Exception $e) {
                Log::debug("Health check attempt {$attempts} exception: {$e->getMessage()}");
            }

            // Wait before next attempt (except for last attempt)
            if ($attempts < $maxRetries && (time() - $startTime) < $timeout) {
                sleep($interval);
            }
        }

        // All attempts failed
        Log::error("Health check failed after {$attempts} attempts", [
            'url' => $url,
            'elapsed_time' => time() - $startTime
        ]);

        return [
            'healthy' => false,
            'status_code' => null,
            'attempts' => $attempts,
            'elapsed_time' => time() - $startTime,
            'message' => "Health check failed after {$attempts} attempts"
        ];
    }

    /**
     * Get health status for entire application (all instances)
     */
    public function getHealthyInstanceCount(Application $application): int
    {
        // Query application instances across all servers
        // This would integrate with Coolify's existing server/container tracking

        // Simplified implementation
        return 1; // Placeholder
    }

    /**
     * Determine application URL for health checks
     */
    private function getApplicationUrl(Application $application, Server $server, string $healthCheckPath): string
    {
        // Use application's configured domain/port or fallback to server IP
        $domain = $application->fqdn ?? $server->ip;
        $port = $application->ports_exposes ?? 80;
        $protocol = $application->is_https_enabled ? 'https' : 'http';

        return "{$protocol}://{$domain}:{$port}{$healthCheckPath}";
    }
}
```

### Deployment Strategy Interface

**File:** `app/Contracts/DeploymentStrategyInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Application;
use App\Models\Enterprise\Deployment;

interface DeploymentStrategyInterface
{
    /**
     * Execute deployment using this strategy
     *
     * @param Application $application Application to deploy
     * @param Deployment $deployment Deployment record
     * @param array $config Strategy-specific configuration
     * @return bool Success status
     */
    public function deploy(Application $application, Deployment $deployment, array $config = []): bool;
}
```

### Background Job Implementation

**File:** `app/Jobs/Enterprise/RollingUpdateDeploymentJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Models\Application;
use App\Models\Enterprise\Deployment;
use App\Services\Enterprise\Deployment\RollingUpdateStrategy;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class RollingUpdateDeploymentJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $timeout = 3600; // 1 hour timeout
    public int $tries = 1; // Don't retry failed deployments

    /**
     * Create a new job instance
     */
    public function __construct(
        public Application $application,
        public Deployment $deployment,
        public array $config = []
    ) {}

    /**
     * Execute the job
     */
    public function handle(RollingUpdateStrategy $strategy): void
    {
        Log::info("Starting rolling update deployment job", [
            'application_id' => $this->application->id,
            'deployment_id' => $this->deployment->id
        ]);

        try {
            $this->deployment->update(['status' => 'in_progress']);

            $success = $strategy->deploy($this->application, $this->deployment, $this->config);

            if ($success) {
                Log::info("Rolling update deployment job completed successfully");
                $this->deployment->update(['status' => 'completed']);
            } else {
                Log::error("Rolling update deployment job failed");
                $this->deployment->update(['status' => 'failed']);
            }

        } catch (\Exception $e) {
            Log::error("Rolling update deployment job exception: {$e->getMessage()}", [
                'exception' => $e
            ]);

            $this->deployment->update([
                'status' => 'failed',
                'failure_reason' => $e->getMessage()
            ]);

            throw $e;
        }
    }

    /**
     * Handle job failure
     */
    public function failed(\Throwable $exception): void
    {
        Log::error("Rolling update deployment job failed permanently", [
            'application_id' => $this->application->id,
            'deployment_id' => $this->deployment->id,
            'exception' => $exception->getMessage()
        ]);

        $this->deployment->update([
            'status' => 'failed',
            'failure_reason' => "Job failed: {$exception->getMessage()}"
        ]);
    }
}
```

### Model: DeploymentBatch

**File:** `app/Models/Enterprise/DeploymentBatch.php`

```php
<?php

namespace App\Models\Enterprise;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class DeploymentBatch extends Model
{
    use HasFactory;

    protected $fillable = [
        'deployment_id',
        'batch_number',
        'total_batches',
        'server_ids',
        'target_instance_count',
        'status',
        'started_at',
        'completed_at',
        'successful_instances',
        'failed_instances',
        'health_check_results',
        'failure_reason',
    ];

    protected $casts = [
        'server_ids' => 'array',
        'health_check_results' => 'array',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
    ];

    /**
     * Get the deployment this batch belongs to
     */
    public function deployment(): BelongsTo
    {
        return $this->belongsTo(Deployment::class);
    }

    /**
     * Check if batch is in progress
     */
    public function isInProgress(): bool
    {
        return in_array($this->status, ['in_progress', 'health_checking']);
    }

    /**
     * Check if batch completed successfully
     */
    public function isSuccessful(): bool
    {
        return $this->status === 'completed';
    }

    /**
     * Check if batch failed
     */
    public function isFailed(): bool
    {
        return in_array($this->status, ['failed', 'rolled_back']);
    }

    /**
     * Get duration in seconds
     */
    public function getDurationAttribute(): ?int
    {
        if (!$this->started_at || !$this->completed_at) {
            return null;
        }

        return $this->completed_at->diffInSeconds($this->started_at);
    }
}
```

## Implementation Approach

### Step 1: Database Migrations
1. Create `deployment_batches` table migration
2. Create migration to add rolling update fields to `deployments` table
3. Run migrations: `php artisan migrate`
4. Create database indexes for performance

### Step 2: Create Strategy Interface and Health Check Service
1. Create `DeploymentStrategyInterface` in `app/Contracts/`
2. Implement `HealthCheckService` in `app/Services/Enterprise/Deployment/`
3. Add unit tests for health check logic with various scenarios

### Step 3: Implement Rolling Update Strategy
1. Create `RollingUpdateStrategy` implementing `DeploymentStrategyInterface`
2. Implement batch calculation logic
3. Implement batch deployment with health checks
4. Add rollback mechanisms
5. Integrate with load balancer drain/undrain functionality

### Step 4: Create Background Job
1. Create `RollingUpdateDeploymentJob` for async execution
2. Add job to appropriate queue (`deployment` queue)
3. Configure queue workers and retry logic
4. Add job failure handling

### Step 5: Create Models and Factories
1. Create `DeploymentBatch` model with relationships
2. Create factory for `DeploymentBatch` testing
3. Update `Deployment` model with new fields and accessors
4. Add model scopes for querying by status

### Step 6: Integrate with EnhancedDeploymentService
1. Modify `EnhancedDeploymentService::deployWithStrategy()` to support 'rolling' strategy
2. Add configuration validation for rolling update parameters
3. Dispatch `RollingUpdateDeploymentJob` when rolling strategy selected

### Step 7: Add API Endpoints
1. Create route: `POST /api/deployments/{deployment}/rolling-update`
2. Add controller method: `DeploymentController::configureRollingUpdate()`
3. Add endpoint: `GET /api/deployments/{deployment}/batches` (get batch progress)
4. Add validation for rolling update configuration

### Step 8: Testing
1. Unit test `RollingUpdateStrategy` with mocked servers
2. Unit test `HealthCheckService` with HTTP mocking
3. Integration test full rolling update workflow
4. Test rollback scenarios (health check failures, timeouts)
5. Test batch size calculations (percentage and absolute)
6. Browser test for UI interaction (Task 39)

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Enterprise/RollingUpdateStrategyTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Server;
use App\Models\Enterprise\Deployment;
use App\Services\Enterprise\Deployment\RollingUpdateStrategy;
use App\Services\Enterprise\Deployment\HealthCheckService;
use App\Services\Enterprise\CapacityManager;

beforeEach(function () {
    $this->healthCheckService = Mockery::mock(HealthCheckService::class);
    $this->capacityManager = Mockery::mock(CapacityManager::class);

    $this->strategy = new RollingUpdateStrategy(
        $this->healthCheckService,
        $this->capacityManager
    );
});

it('calculates batches with percentage-based sizing', function () {
    $servers = Server::factory()->count(10)->make();
    $config = [
        'batch_size' => 25, // 25%
        'batch_size_is_percentage' => true
    ];

    $batches = invade($this->strategy)->calculateBatches($servers, $config);

    // 10 servers * 25% = 2.5, rounded up to 3 servers per batch
    // Should create 4 batches: [3, 3, 3, 1]
    expect($batches)->toHaveCount(4);
    expect(count($batches[1]))->toBe(3);
    expect(count($batches[2]))->toBe(3);
    expect(count($batches[3]))->toBe(3);
    expect(count($batches[4]))->toBe(1);
});

it('calculates batches with absolute count sizing', function () {
    $servers = Server::factory()->count(10)->make();
    $config = [
        'batch_size' => 2, // 2 servers per batch
        'batch_size_is_percentage' => false
    ];

    $batches = invade($this->strategy)->calculateBatches($servers, $config);

    // Should create 5 batches of 2 servers each
    expect($batches)->toHaveCount(5);
    expect(count($batches[1]))->toBe(2);
    expect(count($batches[5]))->toBe(2);
});

it('validates pre-deployment conditions', function () {
    $application = Application::factory()->create();
    $deployment = Deployment::factory()->create([
        'minimum_healthy_instances' => 2
    ]);

    $this->healthCheckService
        ->shouldReceive('getHealthyInstanceCount')
        ->with($application)
        ->once()
        ->andReturn(3); // 3 healthy instances available

    $this->capacityManager
        ->shouldReceive('canServerHandleDeployment')
        ->andReturn(true);

    // Should not throw exception
    invade($this->strategy)->validatePreDeployment($application, $deployment);

    expect(true)->toBeTrue();
});

it('throws exception when insufficient healthy instances', function () {
    $application = Application::factory()->create();
    $deployment = Deployment::factory()->create([
        'minimum_healthy_instances' => 5
    ]);

    $this->healthCheckService
        ->shouldReceive('getHealthyInstanceCount')
        ->with($application)
        ->once()
        ->andReturn(2); // Only 2 healthy, but need 5

    expect(fn() => invade($this->strategy)->validatePreDeployment($application, $deployment))
        ->toThrow(\RuntimeException::class, 'Insufficient healthy instances');
});

it('stores previous deployment for rollback', function () {
    $application = Application::factory()->create([
        'docker_image' => 'myapp',
        'docker_tag' => 'v1.0.0'
    ]);
    $deployment = Deployment::factory()->create();

    invade($this->strategy)->storePreviousDeployment($application, $deployment);

    $deployment->refresh();
    expect($deployment->previous_docker_image)->toBe('myapp');
    expect($deployment->previous_docker_tag)->toBe('v1.0.0');
});
```

**File:** `tests/Unit/Enterprise/HealthCheckServiceTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Server;
use App\Services\Enterprise\Deployment\HealthCheckService;
use Illuminate\Support\Facades\Http;

beforeEach(function () {
    $this->service = new HealthCheckService();
});

it('passes health check on successful HTTP response', function () {
    $application = Application::factory()->create(['fqdn' => 'app.example.com']);
    $server = Server::factory()->create();

    Http::fake([
        'http://app.example.com:80/' => Http::response('OK', 200)
    ]);

    $result = $this->service->checkServerHealth(
        $application,
        $server,
        '/',
        30, // timeout
        1,  // interval
        5   // max retries
    );

    expect($result['healthy'])->toBeTrue();
    expect($result['status_code'])->toBe(200);
    expect($result['attempts'])->toBe(1);
});

it('retries health check on initial failures', function () {
    $application = Application::factory()->create(['fqdn' => 'app.example.com']);
    $server = Server::factory()->create();

    Http::fake([
        'http://app.example.com:80/' => Http::sequence()
            ->push('', 500) // First attempt fails
            ->push('', 500) // Second attempt fails
            ->push('OK', 200) // Third attempt succeeds
    ]);

    $result = $this->service->checkServerHealth(
        $application,
        $server,
        '/',
        30,
        1,
        5
    );

    expect($result['healthy'])->toBeTrue();
    expect($result['attempts'])->toBe(3);
});

it('fails health check after max retries exceeded', function () {
    $application = Application::factory()->create(['fqdn' => 'app.example.com']);
    $server = Server::factory()->create();

    Http::fake([
        '*' => Http::response('Error', 500)
    ]);

    $result = $this->service->checkServerHealth(
        $application,
        $server,
        '/',
        10, // timeout
        1,  // interval
        3   // max retries
    );

    expect($result['healthy'])->toBeFalse();
    expect($result['attempts'])->toBe(3);
    expect($result['message'])->toContain('failed after 3 attempts');
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/RollingUpdateDeploymentTest.php`

```php
<?php

use App\Models\Application;
use App\Models\Server;
use App\Models\Enterprise\Deployment;
use App\Jobs\Enterprise\RollingUpdateDeploymentJob;
use Illuminate\Support\Facades\Queue;

it('creates deployment batches for rolling update', function () {
    Queue::fake();

    $application = Application::factory()->create();
    $servers = Server::factory()->count(4)->create();

    $deployment = Deployment::factory()->create([
        'application_id' => $application->id,
        'deployment_strategy' => 'rolling',
        'batch_size' => 50, // 50% = 2 servers per batch
        'batch_size_is_percentage' => true
    ]);

    // Dispatch rolling update job
    RollingUpdateDeploymentJob::dispatch($application, $deployment);

    Queue::assertPushed(RollingUpdateDeploymentJob::class);
});

it('executes rolling update with health checks', function () {
    $application = Application::factory()->create([
        'docker_image' => 'nginx',
        'docker_tag' => 'latest'
    ]);

    $server = Server::factory()->create();

    $deployment = Deployment::factory()->create([
        'application_id' => $application->id,
        'deployment_strategy' => 'rolling',
        'batch_size' => 100, // Deploy to all servers at once for test
        'health_check_path' => '/health',
        'auto_rollback_on_failure' => false
    ]);

    // Mock health check service
    $healthCheckService = Mockery::mock(HealthCheckService::class);
    $healthCheckService->shouldReceive('getHealthyInstanceCount')->andReturn(1);
    $healthCheckService->shouldReceive('checkServerHealth')->andReturn([
        'healthy' => true,
        'status_code' => 200
    ]);
    $this->app->instance(HealthCheckService::class, $healthCheckService);

    // Execute deployment
    $job = new RollingUpdateDeploymentJob($application, $deployment);
    $job->handle(app(RollingUpdateStrategy::class));

    // Verify deployment batches created
    $batches = $deployment->batches;
    expect($batches)->not->toBeEmpty();
    expect($batches->first()->status)->toBe('completed');
});

it('rolls back deployment on health check failures', function () {
    $application = Application::factory()->create([
        'docker_image' => 'nginx',
        'docker_tag' => 'v2.0'
    ]);

    $server = Server::factory()->create();

    $deployment = Deployment::factory()->create([
        'application_id' => $application->id,
        'deployment_strategy' => 'rolling',
        'batch_size' => 100,
        'auto_rollback_on_failure' => true,
        'failure_threshold' => 1,
        'previous_docker_image' => 'nginx',
        'previous_docker_tag' => 'v1.0'
    ]);

    // Mock health check to fail
    $healthCheckService = Mockery::mock(HealthCheckService::class);
    $healthCheckService->shouldReceive('getHealthyInstanceCount')->andReturn(1);
    $healthCheckService->shouldReceive('checkServerHealth')->andReturn([
        'healthy' => false,
        'status_code' => 500
    ]);
    $this->app->instance(HealthCheckService::class, $healthCheckService);

    // Execute deployment
    $job = new RollingUpdateDeploymentJob($application, $deployment);
    $job->handle(app(RollingUpdateStrategy::class));

    $deployment->refresh();
    expect($deployment->status)->toBe('rolled_back');
});
```

## Definition of Done

- [ ] `deployment_batches` database table created with migrations
- [ ] `deployments` table enhanced with rolling update fields
- [ ] DeploymentStrategyInterface created
- [ ] HealthCheckService implemented with HTTP health checks
- [ ] RollingUpdateStrategy implemented with batch deployment logic
- [ ] Batch calculation supports both percentage and absolute count sizing
- [ ] Health check system validates instances before proceeding to next batch
- [ ] Automatic rollback mechanism implemented and tested
- [ ] Load balancer drain/undrain integration implemented
- [ ] RollingUpdateDeploymentJob created for async execution
- [ ] DeploymentBatch model created with relationships
- [ ] Deployment model updated with rolling update accessors
- [ ] API endpoints created for rolling update configuration
- [ ] Pre-deployment validation ensures minimum healthy instances
- [ ] Previous deployment storage for rollback capability
- [ ] Unit tests written for RollingUpdateStrategy (15+ tests, >90% coverage)
- [ ] Unit tests written for HealthCheckService (8+ tests)
- [ ] Integration tests written for full deployment workflow (10+ tests)
- [ ] Rollback scenarios tested comprehensively
- [ ] Code follows Laravel 12 and Coolify coding standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing with zero errors
- [ ] Documentation updated with rolling update configuration examples
- [ ] WebSocket broadcasting implemented for real-time progress (Task 31)
- [ ] Code reviewed and approved
- [ ] Manual testing with multi-server application completed

## Related Tasks

- **Depends on:** Task 32 (EnhancedDeploymentService foundation)
- **Integrates with:** Task 26 (CapacityManager for pre-deployment validation)
- **Integrates with:** Task 25 (SystemResourceMonitor for instance health)
- **Integrates with:** Task 31 (WebSocket broadcasting for real-time updates)
- **Used by:** Task 39 (DeploymentManager.vue UI for configuration)
- **Parallel with:** Task 34 (Blue-green deployment strategy)
- **Parallel with:** Task 35 (Canary deployment strategy)
