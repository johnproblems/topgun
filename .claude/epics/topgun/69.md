---
name: Implement domain ownership verification
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:22Z
github: https://github.com/johnproblems/topgun/issues/177
depends_on: [66]
parallel: false
conflicts_with: []
---

# Task: Implement domain ownership verification

## Description

Implement a comprehensive domain ownership verification system that allows organizations to prove they control a custom domain before it can be used for white-label branding or application deployment. This security-critical feature prevents domain hijacking and ensures only authorized organizations can bind custom domains to their Coolify instance.

The verification system supports two industry-standard verification methods:

1. **DNS TXT Record Verification** - Organizations add a unique TXT record to their domain's DNS configuration containing a verification token. Coolify queries DNS servers to validate the token's presence, confirming domain control.

2. **File Upload Verification** - Organizations upload a verification file to a specific path on their web server (e.g., `/.well-known/coolify-verification.txt`). Coolify makes an HTTP request to the URL and validates the file contents against the expected token.

Both methods provide cryptographically secure proof of domain ownership by requiring the organization to demonstrate control over either the domain's DNS configuration or the web server hosting the domain.

**Integration with White-Label System:**
- Extends DomainRegistrarService (Task 66) with verification capabilities
- Required before custom domain can be set in WhiteLabelConfig
- Used by ApplicationDomainBinding to validate domain ownership before deployment
- Provides security foundation for SSL certificate provisioning (Task 68)
- Integrates with DomainManager.vue for user-friendly verification workflows

**Security Considerations:**
- Verification tokens are cryptographically random (32 bytes, base64 encoded)
- Tokens expire after 7 days to prevent replay attacks
- DNS verification queries authoritative nameservers to prevent cache poisoning
- File verification uses HTTPS with certificate validation
- Multiple verification attempts rate-limited to prevent abuse
- Audit log tracks all verification attempts for security monitoring

**Why this task is critical:** Domain verification is a fundamental security requirement for any multi-tenant platform. Without proper verification, malicious actors could potentially:
- Claim ownership of domains they don't control
- Intercept traffic intended for legitimate domain owners
- Deploy applications using other organizations' domains
- Obtain SSL certificates for domains they don't own

This task implements the security controls necessary to prevent these attack vectors while providing a seamless user experience through two flexible verification methods.

## Acceptance Criteria

- [ ] DomainVerificationService created with both verification methods
- [ ] DNS TXT record verification implemented with authoritative nameserver querying
- [ ] File upload verification implemented with HTTPS validation
- [ ] Verification token generation uses cryptographically secure randomness
- [ ] Verification tokens expire after configurable period (default: 7 days)
- [ ] Verification status tracked in database with timestamps
- [ ] Failed verification attempts logged with reason
- [ ] Rate limiting implemented (max 5 verification attempts per 10 minutes per domain)
- [ ] DNS verification supports custom DNS resolvers (Google DNS, Cloudflare DNS)
- [ ] File verification validates HTTPS certificates
- [ ] Verification results cached for 1 hour to reduce DNS/HTTP requests
- [ ] Automatic re-verification scheduled for verified domains (every 30 days)
- [ ] Vue.js component displays verification instructions for both methods
- [ ] Real-time verification status updates via WebSocket
- [ ] Comprehensive error messages for common verification failures

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/DomainVerificationService.php` (new)
- `/home/topgun/topgun/app/Contracts/DomainVerificationServiceInterface.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Enterprise/OrganizationDomain.php` (modify - add verification columns)

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/DomainController.php` (modify)

**Vue Components:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/Domain/DomainVerification.vue` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/Domain/VerificationMethodSelector.vue` (new)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/VerifyDomainOwnershipJob.php` (new)
- `/home/topgun/topgun/app/Jobs/Enterprise/RevalidateDomainOwnershipJob.php` (new)

### Database Schema Enhancement

Add verification-related columns to `organization_domains` table:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('organization_domains', function (Blueprint $table) {
            $table->string('verification_method')->nullable()->after('status');
            // 'dns_txt' or 'file_upload'

            $table->string('verification_token', 64)->nullable();
            // Cryptographically random token for verification

            $table->timestamp('verification_token_expires_at')->nullable();
            // Token expiration timestamp (default: 7 days from generation)

            $table->string('verification_status')->default('pending');
            // 'pending', 'verified', 'failed', 'expired'

            $table->timestamp('verified_at')->nullable();
            // Timestamp when domain was successfully verified

            $table->timestamp('last_verification_attempt_at')->nullable();
            // Track last verification attempt for rate limiting

            $table->integer('verification_attempts')->default(0);
            // Count failed attempts for rate limiting

            $table->text('verification_error')->nullable();
            // Last verification error message

            $table->timestamp('next_revalidation_at')->nullable();
            // Scheduled revalidation timestamp (30 days after verification)

            $table->index(['verification_status', 'verified_at']);
            $table->index(['next_revalidation_at']);
        });
    }

    public function down(): void
    {
        Schema::table('organization_domains', function (Blueprint $table) {
            $table->dropColumn([
                'verification_method',
                'verification_token',
                'verification_token_expires_at',
                'verification_status',
                'verified_at',
                'last_verification_attempt_at',
                'verification_attempts',
                'verification_error',
                'next_revalidation_at',
            ]);
        });
    }
};
```

### Service Interface

**File:** `app/Contracts/DomainVerificationServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\OrganizationDomain;

interface DomainVerificationServiceInterface
{
    /**
     * Generate verification token for domain
     *
     * @param OrganizationDomain $domain
     * @param string $method Verification method ('dns_txt' or 'file_upload')
     * @return string Generated verification token
     */
    public function generateVerificationToken(
        OrganizationDomain $domain,
        string $method
    ): string;

    /**
     * Verify domain ownership via DNS TXT record
     *
     * @param OrganizationDomain $domain
     * @return array Verification result with status and details
     */
    public function verifyViaDnsTxt(OrganizationDomain $domain): array;

    /**
     * Verify domain ownership via file upload
     *
     * @param OrganizationDomain $domain
     * @return array Verification result with status and details
     */
    public function verifyViaFileUpload(OrganizationDomain $domain): array;

    /**
     * Verify domain using configured method
     *
     * @param OrganizationDomain $domain
     * @return array Verification result
     */
    public function verifyDomain(OrganizationDomain $domain): array;

    /**
     * Check if verification token is valid (not expired)
     *
     * @param OrganizationDomain $domain
     * @return bool
     */
    public function isTokenValid(OrganizationDomain $domain): bool;

    /**
     * Get verification instructions for domain
     *
     * @param OrganizationDomain $domain
     * @return array Instructions with token, record details, file path
     */
    public function getVerificationInstructions(OrganizationDomain $domain): array;

    /**
     * Schedule revalidation for verified domain
     *
     * @param OrganizationDomain $domain
     * @return void
     */
    public function scheduleRevalidation(OrganizationDomain $domain): void;
}
```

### Service Implementation

**File:** `app/Services/Enterprise/DomainVerificationService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\DomainVerificationServiceInterface;
use App\Models\OrganizationDomain;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Str;

class DomainVerificationService implements DomainVerificationServiceInterface
{
    private const TOKEN_LENGTH = 32;
    private const TOKEN_EXPIRATION_DAYS = 7;
    private const REVALIDATION_DAYS = 30;
    private const MAX_ATTEMPTS = 5;
    private const RATE_LIMIT_MINUTES = 10;
    private const TXT_RECORD_PREFIX = 'coolify-verification';
    private const FILE_PATH = '/.well-known/coolify-verification.txt';

    /**
     * DNS resolvers for verification
     */
    private const DNS_RESOLVERS = [
        '8.8.8.8',     // Google DNS
        '1.1.1.1',     // Cloudflare DNS
        '208.67.222.222', // OpenDNS
    ];

    /**
     * Generate verification token for domain
     */
    public function generateVerificationToken(
        OrganizationDomain $domain,
        string $method
    ): string {
        // Validate method
        if (!in_array($method, ['dns_txt', 'file_upload'])) {
            throw new \InvalidArgumentException("Invalid verification method: {$method}");
        }

        // Check rate limiting
        if ($this->isRateLimited($domain)) {
            throw new \Exception(
                'Too many verification attempts. Please wait ' . self::RATE_LIMIT_MINUTES . ' minutes.'
            );
        }

        // Generate cryptographically secure token
        $token = Str::random(self::TOKEN_LENGTH);
        $expiresAt = now()->addDays(self::TOKEN_EXPIRATION_DAYS);

        // Update domain with verification details
        $domain->update([
            'verification_method' => $method,
            'verification_token' => $token,
            'verification_token_expires_at' => $expiresAt,
            'verification_status' => 'pending',
            'verification_attempts' => 0,
            'verification_error' => null,
        ]);

        Log::info('Verification token generated for domain', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
            'method' => $method,
            'expires_at' => $expiresAt,
        ]);

        return $token;
    }

    /**
     * Verify domain ownership via DNS TXT record
     */
    public function verifyViaDnsTxt(OrganizationDomain $domain): array
    {
        Log::info('Starting DNS TXT verification', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
        ]);

        // Check if token is valid
        if (!$this->isTokenValid($domain)) {
            return $this->markVerificationFailed(
                $domain,
                'Verification token has expired. Please generate a new token.'
            );
        }

        // Check rate limiting
        if ($this->isRateLimited($domain)) {
            return $this->markVerificationFailed(
                $domain,
                'Too many verification attempts. Please wait before trying again.'
            );
        }

        // Construct expected TXT record value
        $expectedValue = self::TXT_RECORD_PREFIX . '=' . $domain->verification_token;
        $recordName = '_' . self::TXT_RECORD_PREFIX . '.' . $domain->domain;

        // Check cache first
        $cacheKey = "domain_verification:dns:{$domain->id}";
        if (Cache::has($cacheKey)) {
            $cachedResult = Cache::get($cacheKey);
            if ($cachedResult['verified']) {
                return $this->markVerificationSuccess($domain);
            }
        }

        // Query DNS records using multiple resolvers for reliability
        $txtRecords = $this->queryDnsTxtRecords($recordName);

        // Check if expected token is present
        $verified = false;
        foreach ($txtRecords as $record) {
            if (trim($record) === $expectedValue) {
                $verified = true;
                break;
            }
        }

        if ($verified) {
            // Cache successful verification
            Cache::put($cacheKey, ['verified' => true], now()->addHour());

            return $this->markVerificationSuccess($domain);
        }

        // Verification failed
        $errorMessage = empty($txtRecords)
            ? "No TXT records found for {$recordName}. Please ensure the DNS record is created and propagated."
            : "TXT record found but token does not match. Expected: {$expectedValue}";

        return $this->markVerificationFailed($domain, $errorMessage);
    }

    /**
     * Verify domain ownership via file upload
     */
    public function verifyViaFileUpload(OrganizationDomain $domain): array
    {
        Log::info('Starting file upload verification', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
        ]);

        // Check if token is valid
        if (!$this->isTokenValid($domain)) {
            return $this->markVerificationFailed(
                $domain,
                'Verification token has expired. Please generate a new token.'
            );
        }

        // Check rate limiting
        if ($this->isRateLimited($domain)) {
            return $this->markVerificationFailed(
                $domain,
                'Too many verification attempts. Please wait before trying again.'
            );
        }

        // Construct verification URL
        $verificationUrl = 'https://' . $domain->domain . self::FILE_PATH;

        // Check cache first
        $cacheKey = "domain_verification:file:{$domain->id}";
        if (Cache::has($cacheKey)) {
            $cachedResult = Cache::get($cacheKey);
            if ($cachedResult['verified']) {
                return $this->markVerificationSuccess($domain);
            }
        }

        try {
            // Make HTTP request to verification URL
            $response = Http::timeout(10)
                ->withOptions([
                    'verify' => true, // Validate SSL certificates
                    'allow_redirects' => false, // Don't follow redirects
                ])
                ->get($verificationUrl);

            // Check if request was successful
            if (!$response->successful()) {
                return $this->markVerificationFailed(
                    $domain,
                    "Failed to fetch verification file. HTTP status: {$response->status()}"
                );
            }

            // Verify file contents match token
            $fileContent = trim($response->body());
            $expectedContent = $domain->verification_token;

            if ($fileContent !== $expectedContent) {
                return $this->markVerificationFailed(
                    $domain,
                    "Verification file content does not match token. Expected: {$expectedContent}, Got: {$fileContent}"
                );
            }

            // Cache successful verification
            Cache::put($cacheKey, ['verified' => true], now()->addHour());

            return $this->markVerificationSuccess($domain);

        } catch (\Exception $e) {
            Log::error('File upload verification failed', [
                'domain_id' => $domain->id,
                'error' => $e->getMessage(),
            ]);

            return $this->markVerificationFailed(
                $domain,
                "Failed to fetch verification file: {$e->getMessage()}"
            );
        }
    }

    /**
     * Verify domain using configured method
     */
    public function verifyDomain(OrganizationDomain $domain): array
    {
        if (!$domain->verification_method) {
            throw new \Exception('No verification method configured for domain');
        }

        return match ($domain->verification_method) {
            'dns_txt' => $this->verifyViaDnsTxt($domain),
            'file_upload' => $this->verifyViaFileUpload($domain),
            default => throw new \Exception('Invalid verification method'),
        };
    }

    /**
     * Check if verification token is valid (not expired)
     */
    public function isTokenValid(OrganizationDomain $domain): bool
    {
        if (!$domain->verification_token || !$domain->verification_token_expires_at) {
            return false;
        }

        return now()->isBefore($domain->verification_token_expires_at);
    }

    /**
     * Get verification instructions for domain
     */
    public function getVerificationInstructions(OrganizationDomain $domain): array
    {
        if (!$domain->verification_method || !$domain->verification_token) {
            throw new \Exception('Verification method and token must be generated first');
        }

        $instructions = [
            'domain' => $domain->domain,
            'method' => $domain->verification_method,
            'token' => $domain->verification_token,
            'expires_at' => $domain->verification_token_expires_at?->toIso8601String(),
            'status' => $domain->verification_status,
        ];

        if ($domain->verification_method === 'dns_txt') {
            $instructions['dns_instructions'] = [
                'record_type' => 'TXT',
                'record_name' => '_' . self::TXT_RECORD_PREFIX . '.' . $domain->domain,
                'record_value' => self::TXT_RECORD_PREFIX . '=' . $domain->verification_token,
                'ttl' => 3600,
                'instructions' => [
                    '1. Log in to your DNS provider (e.g., Cloudflare, Route53, Namecheap)',
                    '2. Navigate to DNS management for ' . $domain->domain,
                    '3. Add a new TXT record with the following details:',
                    '   - Name: _' . self::TXT_RECORD_PREFIX,
                    '   - Type: TXT',
                    '   - Value: ' . self::TXT_RECORD_PREFIX . '=' . $domain->verification_token,
                    '   - TTL: 3600 (1 hour)',
                    '4. Wait for DNS propagation (usually 5-30 minutes)',
                    '5. Click "Verify Domain" to complete verification',
                ],
            ];
        } else {
            $instructions['file_instructions'] = [
                'file_path' => self::FILE_PATH,
                'file_content' => $domain->verification_token,
                'full_url' => 'https://' . $domain->domain . self::FILE_PATH,
                'instructions' => [
                    '1. Create a file named "coolify-verification.txt"',
                    '2. Add the following content to the file (no extra spaces or newlines):',
                    '   ' . $domain->verification_token,
                    '3. Upload the file to your web server at:',
                    '   ' . self::FILE_PATH,
                    '4. Ensure the file is accessible via HTTPS:',
                    '   https://' . $domain->domain . self::FILE_PATH,
                    '5. Click "Verify Domain" to complete verification',
                ],
            ];
        }

        return $instructions;
    }

    /**
     * Schedule revalidation for verified domain
     */
    public function scheduleRevalidation(OrganizationDomain $domain): void
    {
        if ($domain->verification_status !== 'verified') {
            throw new \Exception('Only verified domains can be scheduled for revalidation');
        }

        $nextRevalidation = now()->addDays(self::REVALIDATION_DAYS);

        $domain->update([
            'next_revalidation_at' => $nextRevalidation,
        ]);

        Log::info('Domain revalidation scheduled', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
            'next_revalidation_at' => $nextRevalidation,
        ]);
    }

    /**
     * Query DNS TXT records using multiple resolvers
     *
     * @param string $recordName
     * @return array
     */
    private function queryDnsTxtRecords(string $recordName): array
    {
        $txtRecords = [];

        // Try each resolver
        foreach (self::DNS_RESOLVERS as $resolver) {
            try {
                $records = dns_get_record($recordName, DNS_TXT);

                if ($records !== false) {
                    foreach ($records as $record) {
                        if (isset($record['txt'])) {
                            $txtRecords[] = $record['txt'];
                        }
                    }

                    // If we found records, no need to try other resolvers
                    if (!empty($txtRecords)) {
                        break;
                    }
                }
            } catch (\Exception $e) {
                Log::warning('DNS query failed for resolver', [
                    'resolver' => $resolver,
                    'record_name' => $recordName,
                    'error' => $e->getMessage(),
                ]);
                continue;
            }
        }

        return array_unique($txtRecords);
    }

    /**
     * Mark verification as successful
     *
     * @param OrganizationDomain $domain
     * @return array
     */
    private function markVerificationSuccess(OrganizationDomain $domain): array
    {
        $domain->update([
            'verification_status' => 'verified',
            'verified_at' => now(),
            'verification_attempts' => 0,
            'verification_error' => null,
            'last_verification_attempt_at' => now(),
        ]);

        // Schedule revalidation
        $this->scheduleRevalidation($domain);

        Log::info('Domain verified successfully', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
            'method' => $domain->verification_method,
        ]);

        return [
            'verified' => true,
            'message' => 'Domain ownership verified successfully',
            'verified_at' => $domain->verified_at->toIso8601String(),
        ];
    }

    /**
     * Mark verification as failed
     *
     * @param OrganizationDomain $domain
     * @param string $errorMessage
     * @return array
     */
    private function markVerificationFailed(
        OrganizationDomain $domain,
        string $errorMessage
    ): array {
        $domain->increment('verification_attempts');
        $domain->update([
            'verification_status' => 'failed',
            'verification_error' => $errorMessage,
            'last_verification_attempt_at' => now(),
        ]);

        Log::warning('Domain verification failed', [
            'domain_id' => $domain->id,
            'domain' => $domain->domain,
            'error' => $errorMessage,
            'attempts' => $domain->verification_attempts,
        ]);

        return [
            'verified' => false,
            'message' => $errorMessage,
            'attempts' => $domain->verification_attempts,
            'max_attempts' => self::MAX_ATTEMPTS,
        ];
    }

    /**
     * Check if domain is rate limited
     *
     * @param OrganizationDomain $domain
     * @return bool
     */
    private function isRateLimited(OrganizationDomain $domain): bool
    {
        if ($domain->verification_attempts >= self::MAX_ATTEMPTS) {
            $lastAttempt = $domain->last_verification_attempt_at;

            if ($lastAttempt && $lastAttempt->addMinutes(self::RATE_LIMIT_MINUTES)->isFuture()) {
                return true;
            }

            // Reset attempts if rate limit window has passed
            $domain->update(['verification_attempts' => 0]);
        }

        return false;
    }
}
```

### Background Jobs

**File:** `app/Jobs/Enterprise/VerifyDomainOwnershipJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\DomainVerificationServiceInterface;
use App\Models\OrganizationDomain;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class VerifyDomainOwnershipJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        private OrganizationDomain $domain
    ) {}

    public function handle(DomainVerificationServiceInterface $verificationService): void
    {
        try {
            $result = $verificationService->verifyDomain($this->domain);

            // Broadcast verification result via WebSocket
            broadcast(new \App\Events\DomainVerificationCompleted(
                $this->domain,
                $result
            ));

            Log::info('Domain verification job completed', [
                'domain_id' => $this->domain->id,
                'verified' => $result['verified'],
            ]);

        } catch (\Exception $e) {
            Log::error('Domain verification job failed', [
                'domain_id' => $this->domain->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

**File:** `app/Jobs/Enterprise/RevalidateDomainOwnershipJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\DomainVerificationServiceInterface;
use App\Models\OrganizationDomain;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class RevalidateDomainOwnershipJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function handle(DomainVerificationServiceInterface $verificationService): void
    {
        // Find all domains due for revalidation
        $domains = OrganizationDomain::query()
            ->where('verification_status', 'verified')
            ->whereNotNull('next_revalidation_at')
            ->where('next_revalidation_at', '<=', now())
            ->get();

        Log::info('Revalidating domains', [
            'count' => $domains->count(),
        ]);

        foreach ($domains as $domain) {
            try {
                $result = $verificationService->verifyDomain($domain);

                if (!$result['verified']) {
                    // Send notification to organization admin
                    // Domain verification failed during revalidation
                    Log::warning('Domain revalidation failed', [
                        'domain_id' => $domain->id,
                        'domain' => $domain->domain,
                    ]);
                }

            } catch (\Exception $e) {
                Log::error('Domain revalidation error', [
                    'domain_id' => $domain->id,
                    'error' => $e->getMessage(),
                ]);
            }
        }
    }
}
```

### Controller Enhancement

**File:** `app/Http/Controllers/Enterprise/DomainController.php` (additions)

```php
/**
 * Generate verification token for domain
 */
public function generateVerificationToken(
    Request $request,
    Organization $organization,
    OrganizationDomain $domain
): RedirectResponse {
    $this->authorize('update', $organization);

    $request->validate([
        'verification_method' => 'required|in:dns_txt,file_upload',
    ]);

    $verificationService = app(DomainVerificationServiceInterface::class);

    try {
        $token = $verificationService->generateVerificationToken(
            $domain,
            $request->input('verification_method')
        );

        return back()->with('success', 'Verification token generated successfully');

    } catch (\Exception $e) {
        return back()->with('error', $e->getMessage());
    }
}

/**
 * Verify domain ownership
 */
public function verifyDomain(
    Organization $organization,
    OrganizationDomain $domain
): RedirectResponse {
    $this->authorize('update', $organization);

    // Dispatch verification job
    VerifyDomainOwnershipJob::dispatch($domain);

    return back()->with('info', 'Domain verification in progress. You will be notified when complete.');
}

/**
 * Get verification instructions
 */
public function verificationInstructions(
    Organization $organization,
    OrganizationDomain $domain
): JsonResponse {
    $this->authorize('view', $organization);

    $verificationService = app(DomainVerificationServiceInterface::class);

    try {
        $instructions = $verificationService->getVerificationInstructions($domain);

        return response()->json($instructions);

    } catch (\Exception $e) {
        return response()->json(['error' => $e->getMessage()], 400);
    }
}
```

### Vue.js Component

**File:** `resources/js/Components/Enterprise/Domain/DomainVerification.vue`

```vue
<script setup>
import { ref, computed, onMounted } from 'vue'
import { useForm } from '@inertiajs/vue3'
import VerificationMethodSelector from './VerificationMethodSelector.vue'

const props = defineProps({
  domain: Object,
  organizationId: Number,
})

const emit = defineEmits(['verified'])

const verificationMethod = ref(props.domain.verification_method || 'dns_txt')
const instructions = ref(null)
const isVerifying = ref(false)

const form = useForm({
  verification_method: verificationMethod.value,
})

const isVerified = computed(() => props.domain.verification_status === 'verified')
const isPending = computed(() => props.domain.verification_status === 'pending')
const hasFailed = computed(() => props.domain.verification_status === 'failed')

const generateToken = () => {
  form.post(
    route('enterprise.domains.verification.generate', {
      organization: props.organizationId,
      domain: props.domain.id,
    }),
    {
      onSuccess: () => {
        fetchInstructions()
      },
    }
  )
}

const fetchInstructions = async () => {
  const response = await axios.get(
    route('enterprise.domains.verification.instructions', {
      organization: props.organizationId,
      domain: props.domain.id,
    })
  )
  instructions.value = response.data
}

const verifyDomain = () => {
  isVerifying.value = true

  form.post(
    route('enterprise.domains.verification.verify', {
      organization: props.organizationId,
      domain: props.domain.id,
    }),
    {
      onSuccess: () => {
        // WebSocket will handle status updates
      },
      onFinish: () => {
        isVerifying.value = false
      },
    }
  )
}

onMounted(() => {
  if (props.domain.verification_token) {
    fetchInstructions()
  }

  // Listen for WebSocket verification updates
  Echo.private(`organization.${props.organizationId}`)
    .listen('.domain.verification.completed', (event) => {
      if (event.domain.id === props.domain.id) {
        if (event.result.verified) {
          emit('verified', event.domain)
        }
      }
    })
})
</script>

<template>
  <div class="domain-verification">
    <!-- Verification Status Badge -->
    <div class="status-badge" :class="domain.verification_status">
      <span v-if="isVerified" class="text-green-600">✓ Verified</span>
      <span v-else-if="isPending" class="text-yellow-600">⏳ Pending Verification</span>
      <span v-else-if="hasFailed" class="text-red-600">✗ Verification Failed</span>
    </div>

    <!-- Method Selection (if not yet started) -->
    <div v-if="!domain.verification_token" class="method-selection">
      <h3 class="text-lg font-semibold mb-4">Choose Verification Method</h3>

      <VerificationMethodSelector
        v-model="verificationMethod"
        @update:model-value="form.verification_method = $event"
      />

      <button
        class="btn btn-primary mt-4"
        @click="generateToken"
        :disabled="form.processing"
      >
        Generate Verification Token
      </button>
    </div>

    <!-- Verification Instructions -->
    <div v-else class="verification-instructions">
      <!-- DNS TXT Instructions -->
      <div v-if="instructions?.method === 'dns_txt'" class="dns-instructions">
        <h3 class="text-lg font-semibold mb-4">DNS TXT Record Verification</h3>

        <div class="instruction-box">
          <p class="mb-2 font-medium">Add this TXT record to your DNS:</p>

          <div class="code-block">
            <div class="code-line">
              <span class="label">Name:</span>
              <code>{{ instructions.dns_instructions.record_name }}</code>
            </div>
            <div class="code-line">
              <span class="label">Type:</span>
              <code>TXT</code>
            </div>
            <div class="code-line">
              <span class="label">Value:</span>
              <code>{{ instructions.dns_instructions.record_value }}</code>
            </div>
          </div>

          <div class="step-list mt-4">
            <p
              v-for="(step, index) in instructions.dns_instructions.instructions"
              :key="index"
              class="step"
            >
              {{ step }}
            </p>
          </div>
        </div>
      </div>

      <!-- File Upload Instructions -->
      <div v-else-if="instructions?.method === 'file_upload'" class="file-instructions">
        <h3 class="text-lg font-semibold mb-4">File Upload Verification</h3>

        <div class="instruction-box">
          <p class="mb-2 font-medium">Upload a verification file to your server:</p>

          <div class="code-block">
            <div class="code-line">
              <span class="label">File Path:</span>
              <code>{{ instructions.file_instructions.file_path }}</code>
            </div>
            <div class="code-line">
              <span class="label">File Content:</span>
              <code>{{ instructions.file_instructions.file_content }}</code>
            </div>
            <div class="code-line">
              <span class="label">Verify URL:</span>
              <code>{{ instructions.file_instructions.full_url }}</code>
            </div>
          </div>

          <div class="step-list mt-4">
            <p
              v-for="(step, index) in instructions.file_instructions.instructions"
              :key="index"
              class="step"
            >
              {{ step }}
            </p>
          </div>
        </div>
      </div>

      <!-- Verify Button -->
      <div class="actions mt-6">
        <button
          class="btn btn-primary"
          @click="verifyDomain"
          :disabled="isVerifying || isVerified"
        >
          <span v-if="isVerifying">Verifying...</span>
          <span v-else-if="isVerified">Verified ✓</span>
          <span v-else>Verify Domain</span>
        </button>

        <button
          v-if="hasFailed"
          class="btn btn-secondary ml-2"
          @click="generateToken"
        >
          Generate New Token
        </button>
      </div>

      <!-- Error Message -->
      <div v-if="domain.verification_error" class="error-message mt-4">
        <p class="text-red-600">{{ domain.verification_error }}</p>
      </div>

      <!-- Token Expiration -->
      <div v-if="instructions?.expires_at" class="expiration-notice mt-4">
        <p class="text-sm text-gray-600">
          Token expires: {{ new Date(instructions.expires_at).toLocaleString() }}
        </p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.instruction-box {
  @apply bg-gray-50 dark:bg-gray-800 p-4 rounded-lg;
}

.code-block {
  @apply bg-gray-900 text-green-400 p-4 rounded font-mono text-sm;
}

.code-line {
  @apply mb-2;
}

.label {
  @apply text-gray-400 mr-2;
}

.step-list .step {
  @apply mb-2 text-sm;
}

.status-badge {
  @apply inline-block px-3 py-1 rounded-full text-sm font-medium mb-4;
}
</style>
```

### Routes

```php
// routes/web.php
Route::middleware(['auth', 'organization'])->group(function () {
    // Domain verification routes
    Route::post(
        '/enterprise/organizations/{organization}/domains/{domain}/verification/generate',
        [DomainController::class, 'generateVerificationToken']
    )->name('enterprise.domains.verification.generate');

    Route::post(
        '/enterprise/organizations/{organization}/domains/{domain}/verification/verify',
        [DomainController::class, 'verifyDomain']
    )->name('enterprise.domains.verification.verify');

    Route::get(
        '/enterprise/organizations/{organization}/domains/{domain}/verification/instructions',
        [DomainController::class, 'verificationInstructions']
    )->name('enterprise.domains.verification.instructions');
});
```

### Scheduled Task

Add to `app/Console/Kernel.php`:

```php
protected function schedule(Schedule $schedule): void
{
    // Revalidate verified domains every day
    $schedule->job(new RevalidateDomainOwnershipJob)
        ->daily()
        ->at('03:00');
}
```

## Implementation Approach

### Step 1: Create Database Migration
1. Create migration for verification columns in `organization_domains` table
2. Add indexes for performance
3. Run migration: `php artisan migrate`

### Step 2: Create Service Interface and Implementation
1. Create `DomainVerificationServiceInterface` in `app/Contracts/`
2. Implement `DomainVerificationService` in `app/Services/Enterprise/`
3. Register service in `EnterpriseServiceProvider`

### Step 3: Implement DNS TXT Verification
1. Add `verifyViaDnsTxt()` method
2. Implement DNS querying with multiple resolvers
3. Add caching for verification results
4. Test with real DNS records

### Step 4: Implement File Upload Verification
1. Add `verifyViaFileUpload()` method
2. Implement HTTPS request with certificate validation
3. Add error handling for common failure scenarios
4. Test with real web server

### Step 5: Add Background Jobs
1. Create `VerifyDomainOwnershipJob` for async verification
2. Create `RevalidateDomainOwnershipJob` for scheduled revalidation
3. Add WebSocket event broadcasting
4. Schedule revalidation job in Kernel

### Step 6: Enhance Controller
1. Add routes for verification endpoints
2. Implement token generation endpoint
3. Add verification trigger endpoint
4. Add instructions retrieval endpoint

### Step 7: Build Vue.js Component
1. Create `DomainVerification.vue` with method selection
2. Add instructions display for both methods
3. Implement real-time status updates via WebSocket
4. Add error handling and user feedback

### Step 8: Testing
1. Unit tests for service methods
2. Integration tests for complete verification workflows
3. Test rate limiting and token expiration
4. Browser tests for Vue component

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/DomainVerificationServiceTest.php`

```php
<?php

use App\Services\Enterprise\DomainVerificationService;
use App\Models\OrganizationDomain;
use App\Models\Organization;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;

beforeEach(function () {
    $this->service = app(DomainVerificationService::class);
});

it('generates cryptographically secure verification token', function () {
    $organization = Organization::factory()->create();
    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
    ]);

    $token = $this->service->generateVerificationToken($domain, 'dns_txt');

    expect($token)
        ->toBeString()
        ->toHaveLength(32);

    $domain->refresh();
    expect($domain->verification_token)->toBe($token)
        ->and($domain->verification_method)->toBe('dns_txt')
        ->and($domain->verification_token_expires_at)->not->toBeNull();
});

it('validates verification token expiration', function () {
    $domain = OrganizationDomain::factory()->create([
        'verification_token' => 'test-token',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    expect($this->service->isTokenValid($domain))->toBeTrue();

    $domain->update(['verification_token_expires_at' => now()->subDay()]);

    expect($this->service->isTokenValid($domain))->toBeFalse();
});

it('enforces rate limiting on verification attempts', function () {
    $domain = OrganizationDomain::factory()->create([
        'verification_attempts' => 5,
        'last_verification_attempt_at' => now(),
    ]);

    expect(fn() => $this->service->verifyDomain($domain))
        ->toThrow(\Exception::class, 'Too many verification attempts');
});

it('verifies domain via DNS TXT record successfully', function () {
    $domain = OrganizationDomain::factory()->create([
        'domain' => 'example.com',
        'verification_method' => 'dns_txt',
        'verification_token' => 'test-token-123',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    // Mock DNS lookup
    // Note: In real tests, you'd mock dns_get_record() or use a testing DNS server

    $result = $this->service->verifyViaDnsTxt($domain);

    // This test would need actual DNS records or mocking
    expect($result)->toHaveKey('verified');
});

it('verifies domain via file upload successfully', function () {
    Http::fake([
        'https://example.com/.well-known/coolify-verification.txt' => Http::response('test-token-123', 200),
    ]);

    $domain = OrganizationDomain::factory()->create([
        'domain' => 'example.com',
        'verification_method' => 'file_upload',
        'verification_token' => 'test-token-123',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $result = $this->service->verifyViaFileUpload($domain);

    expect($result['verified'])->toBeTrue();

    $domain->refresh();
    expect($domain->verification_status)->toBe('verified')
        ->and($domain->verified_at)->not->toBeNull();
});

it('fails verification when file content does not match', function () {
    Http::fake([
        'https://example.com/.well-known/coolify-verification.txt' => Http::response('wrong-token', 200),
    ]);

    $domain = OrganizationDomain::factory()->create([
        'domain' => 'example.com',
        'verification_method' => 'file_upload',
        'verification_token' => 'correct-token',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $result = $this->service->verifyViaFileUpload($domain);

    expect($result['verified'])->toBeFalse()
        ->and($result['message'])->toContain('does not match');
});

it('caches successful verification results', function () {
    Http::fake([
        'https://example.com/.well-known/coolify-verification.txt' => Http::response('test-token', 200),
    ]);

    $domain = OrganizationDomain::factory()->create([
        'domain' => 'example.com',
        'verification_method' => 'file_upload',
        'verification_token' => 'test-token',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $this->service->verifyViaFileUpload($domain);

    // Second verification should use cache
    $cacheKey = "domain_verification:file:{$domain->id}";
    expect(Cache::has($cacheKey))->toBeTrue();
});

it('generates verification instructions for DNS method', function () {
    $domain = OrganizationDomain::factory()->create([
        'domain' => 'example.com',
        'verification_method' => 'dns_txt',
        'verification_token' => 'test-token',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $instructions = $this->service->getVerificationInstructions($domain);

    expect($instructions)
        ->toHaveKeys(['domain', 'method', 'token', 'dns_instructions'])
        ->and($instructions['dns_instructions']['record_name'])->toBe('_coolify-verification.example.com')
        ->and($instructions['dns_instructions']['record_value'])->toContain('test-token');
});

it('schedules revalidation after successful verification', function () {
    $domain = OrganizationDomain::factory()->create([
        'verification_status' => 'verified',
        'verified_at' => now(),
    ]);

    $this->service->scheduleRevalidation($domain);

    $domain->refresh();
    expect($domain->next_revalidation_at)->not->toBeNull()
        ->and($domain->next_revalidation_at)->toBeAfter(now()->addDays(29));
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/DomainVerificationTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\OrganizationDomain;
use App\Models\User;
use Illuminate\Support\Facades\Http;

it('allows admin to generate verification token', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
    ]);

    $this->actingAs($user)
        ->post(route('enterprise.domains.verification.generate', [
            'organization' => $organization,
            'domain' => $domain,
        ]), [
            'verification_method' => 'dns_txt',
        ])
        ->assertRedirect()
        ->assertSessionHas('success');

    $domain->refresh();
    expect($domain->verification_token)->not->toBeNull()
        ->and($domain->verification_method)->toBe('dns_txt');
});

it('completes full verification workflow via file upload', function () {
    Http::fake([
        'https://example.com/.well-known/coolify-verification.txt' => Http::response('test-token-123', 200),
    ]);

    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
        'verification_method' => 'file_upload',
        'verification_token' => 'test-token-123',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $this->actingAs($user)
        ->post(route('enterprise.domains.verification.verify', [
            'organization' => $organization,
            'domain' => $domain,
        ]))
        ->assertRedirect()
        ->assertSessionHas('info');

    // Job will be dispatched
    $this->expectsJobs(\App\Jobs\Enterprise\VerifyDomainOwnershipJob::class);
});

it('returns verification instructions via API', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $domain = OrganizationDomain::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
        'verification_method' => 'dns_txt',
        'verification_token' => 'test-token',
        'verification_token_expires_at' => now()->addDays(7),
    ]);

    $this->actingAs($user)
        ->getJson(route('enterprise.domains.verification.instructions', [
            'organization' => $organization,
            'domain' => $domain,
        ]))
        ->assertOk()
        ->assertJsonStructure([
            'domain',
            'method',
            'token',
            'dns_instructions',
        ]);
});
```

## Definition of Done

- [ ] Database migration created for verification columns
- [ ] Migration run successfully with indexes
- [ ] DomainVerificationServiceInterface created
- [ ] DomainVerificationService implemented with all methods
- [ ] Service registered in EnterpriseServiceProvider
- [ ] DNS TXT verification implemented with multi-resolver support
- [ ] File upload verification implemented with HTTPS validation
- [ ] Verification token generation uses secure randomness
- [ ] Token expiration enforced (7 days default)
- [ ] Rate limiting implemented (5 attempts per 10 minutes)
- [ ] Verification result caching implemented (1 hour)
- [ ] VerifyDomainOwnershipJob created for async verification
- [ ] RevalidateDomainOwnershipJob created for scheduled revalidation
- [ ] WebSocket event broadcasting for real-time updates
- [ ] Controller endpoints created (generate, verify, instructions)
- [ ] Routes registered in web.php
- [ ] DomainVerification.vue component created
- [ ] VerificationMethodSelector.vue component created
- [ ] Instructions display for both verification methods
- [ ] Real-time status updates working via WebSocket
- [ ] Unit tests written (12+ tests, >90% coverage)
- [ ] Integration tests written (5+ tests)
- [ ] Browser tests written for Vue component
- [ ] Rate limiting tested
- [ ] Token expiration tested
- [ ] DNS verification tested with mock records
- [ ] File verification tested with HTTP mocking
- [ ] Code follows Laravel 12 and Coolify standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Documentation updated
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 66 (DomainRegistrarService provides domain model)
- **Required by:** Task 68 (SSL provisioning requires verified domains)
- **Used by:** Task 70 (DomainManager.vue displays verification status)
- **Integrates with:** White-label system (custom domain configuration)
- **Integrates with:** ApplicationDomainBinding (validates ownership before deployment)
