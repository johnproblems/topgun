---
name: Build webhook handling system with HMAC validation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:02Z
github: https://github.com/johnproblems/topgun/issues/155
depends_on: [46]
parallel: false
conflicts_with: []
---

# Task: Build webhook handling system with HMAC validation

## Description

Implement a comprehensive webhook handling system for payment gateway integrations (Stripe and PayPal) with cryptographic HMAC signature validation to ensure webhook authenticity and prevent replay attacks. This system acts as the critical bridge between external payment processors and the Coolify Enterprise billing system, automatically processing payment events, updating subscription states, and triggering provisioning workflows in real-time.

**The Webhook Security Challenge:**

Payment gateway webhooks carry sensitive financial data and trigger critical business operations (subscription activation, resource provisioning, account suspension). Without proper signature validation, malicious actors could:
- Send fake "payment succeeded" events to activate unpaid subscriptions
- Trigger resource provisioning without actual payment
- Manipulate subscription states by spoofing cancellation events
- Execute replay attacks by resending captured legitimate webhooks
- Cause denial-of-service by flooding the endpoint with invalid requests

HMAC (Hash-based Message Authentication Code) signature validation solves this by cryptographically verifying that webhooks originate from the legitimate payment gateway and haven't been tampered with during transmission.

**Core Responsibilities:**

1. **HMAC Signature Validation**: Verify Stripe and PayPal webhook signatures using gateway-specific secret keys
2. **Event Type Routing**: Map incoming webhook events to appropriate handler methods
3. **Idempotency Enforcement**: Prevent duplicate processing of the same webhook via event ID tracking
4. **Subscription Lifecycle Management**: Process payment success, failure, subscription updates, cancellations
5. **Error Handling & Recovery**: Retry failed webhooks, log errors, alert on critical failures
6. **Webhook Logging**: Audit trail of all webhook events for debugging and compliance
7. **Rate Limiting & DDoS Protection**: Prevent abuse of the webhook endpoint

**Webhook Event Flow:**

```
Payment Gateway (Stripe/PayPal)
    ↓
HTTPS POST → /api/webhooks/{gateway}
    ↓
WebhookController::handle()
    ↓
HMAC Signature Validation (WebhookValidationService)
    ↓
Event Type Router (WebhookHandlerService)
    ↓
Specific Event Handler (e.g., PaymentSuccessHandler)
    ↓
Business Logic (SubscriptionService, ProvisioningService)
    ↓
Database Updates + Events
    ↓
200 OK Response (or retry with 500)
```

**Integration Architecture:**

**Stripe Webhook Events:**
- `invoice.payment_succeeded` → Activate subscription, provision resources
- `invoice.payment_failed` → Mark subscription overdue, send notification
- `customer.subscription.updated` → Update subscription tier, adjust quotas
- `customer.subscription.deleted` → Cancel subscription, deprovision resources
- `payment_method.attached` → Save payment method for future use
- `checkout.session.completed` → Complete onboarding flow

**PayPal Webhook Events:**
- `BILLING.SUBSCRIPTION.ACTIVATED` → Activate subscription
- `PAYMENT.SALE.COMPLETED` → Process successful payment
- `BILLING.SUBSCRIPTION.CANCELLED` → Cancel subscription
- `BILLING.SUBSCRIPTION.SUSPENDED` → Suspend subscription due to payment failure
- `PAYMENT.SALE.REFUNDED` → Process refund, adjust billing

**Security Mechanisms:**

1. **Stripe HMAC Validation**: SHA256 signature verification using webhook secret
2. **PayPal HMAC Validation**: SHA256 HMAC with transmission ID and timestamp
3. **Replay Attack Prevention**: Event ID tracking with 24-hour TTL
4. **Timestamp Validation**: Reject webhooks older than 5 minutes
5. **IP Allowlisting**: Optional restriction to payment gateway IPs
6. **Rate Limiting**: Maximum 100 requests per minute per gateway

**Why This Task is Critical:**

Webhook handling is the nervous system of the payment integration. Without reliable webhooks, critical billing events could be missed, leading to:
- Unpaid subscriptions remaining active (revenue loss)
- Paid subscriptions being incorrectly canceled (customer churn)
- Delayed resource provisioning (poor user experience)
- Compliance violations due to inadequate audit trails

The HMAC validation is non-negotiable for production systems—without it, the entire payment infrastructure is vulnerable to trivial attacks that could result in complete revenue loss and legal liability.

## Acceptance Criteria

- [ ] WebhookController created with routes for Stripe and PayPal webhooks
- [ ] HMAC signature validation implemented for Stripe using `Stripe-Signature` header
- [ ] HMAC signature validation implemented for PayPal using PayPal SDK verification
- [ ] Event type routing maps incoming events to handler methods
- [ ] Idempotency enforcement prevents duplicate processing via event ID tracking
- [ ] Webhook logging stores all events in `webhook_events` database table
- [ ] Replay attack prevention rejects events older than 5 minutes
- [ ] Rate limiting prevents webhook flooding (100 req/min per gateway)
- [ ] Subscription activation handler for successful payments
- [ ] Subscription cancellation handler for deleted/canceled subscriptions
- [ ] Payment failure handler for failed invoices
- [ ] Subscription update handler for tier changes
- [ ] Error handling with automatic retry logic for failed webhooks
- [ ] Comprehensive logging for debugging (event type, payload, validation result)
- [ ] Webhook testing endpoints for development (with signature bypass flag)
- [ ] Integration with PaymentService and SubscriptionService
- [ ] Unit tests for HMAC validation logic (>95% coverage)
- [ ] Integration tests for complete webhook processing flow

## Technical Details

### File Paths

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Api/Webhooks/StripeWebhookController.php` (new)
- `/home/topgun/topgun/app/Http/Controllers/Api/Webhooks/PayPalWebhookController.php` (new)

**Services:**
- `/home/topgun/topgun/app/Services/Enterprise/Payment/WebhookValidationService.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/Payment/WebhookHandlerService.php` (new)
- `/home/topgun/topgun/app/Contracts/WebhookValidationServiceInterface.php` (new)

**Event Handlers:**
- `/home/topgun/topgun/app/Services/Enterprise/Payment/Handlers/StripePaymentSuccessHandler.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/Payment/Handlers/StripeSubscriptionCanceledHandler.php` (new)
- `/home/topgun/topgun/app/Services/Enterprise/Payment/Handlers/PayPalSubscriptionActivatedHandler.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/WebhookEvent.php` (new)
- `/home/topgun/topgun/app/Models/OrganizationSubscription.php` (existing, enhance)

**Migrations:**
- `/home/topgun/topgun/database/migrations/2025_01_XX_create_webhook_events_table.php` (new)

**Routes:**
- `/home/topgun/topgun/routes/api.php` (add webhook routes)

**Configuration:**
- `/home/topgun/topgun/config/webhooks.php` (new)

### Database Schema

**Webhook Events Table:**

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('webhook_events', function (Blueprint $table) {
            $table->id();
            $table->string('event_id')->unique(); // Gateway event ID for idempotency
            $table->string('gateway'); // 'stripe' or 'paypal'
            $table->string('event_type'); // e.g., 'invoice.payment_succeeded'
            $table->json('payload'); // Full webhook payload
            $table->enum('status', ['pending', 'processing', 'completed', 'failed'])->default('pending');
            $table->text('error_message')->nullable();
            $table->integer('retry_count')->default(0);
            $table->timestamp('processed_at')->nullable();
            $table->string('signature')->nullable(); // Original HMAC signature
            $table->string('ip_address')->nullable(); // Source IP for security
            $table->timestamps();

            // Indexes for efficient querying
            $table->index(['gateway', 'event_type']);
            $table->index(['status', 'created_at']);
            $table->index('event_id'); // Fast idempotency checks
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('webhook_events');
    }
};
```

### WebhookEvent Model

**File:** `app/Models/WebhookEvent.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class WebhookEvent extends Model
{
    use HasFactory;

    protected $fillable = [
        'event_id',
        'gateway',
        'event_type',
        'payload',
        'status',
        'error_message',
        'retry_count',
        'processed_at',
        'signature',
        'ip_address',
    ];

    protected $casts = [
        'payload' => 'array',
        'processed_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Scope for pending events that need processing
     */
    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    /**
     * Scope for failed events that can be retried
     */
    public function scopeRetryable($query)
    {
        return $query->where('status', 'failed')
            ->where('retry_count', '<', 3);
    }

    /**
     * Check if event has already been processed (idempotency)
     */
    public static function isProcessed(string $eventId): bool
    {
        return static::where('event_id', $eventId)
            ->whereIn('status', ['processing', 'completed'])
            ->exists();
    }

    /**
     * Mark event as completed
     */
    public function markCompleted(): void
    {
        $this->update([
            'status' => 'completed',
            'processed_at' => now(),
        ]);
    }

    /**
     * Mark event as failed
     */
    public function markFailed(string $errorMessage): void
    {
        $this->update([
            'status' => 'failed',
            'error_message' => $errorMessage,
            'retry_count' => $this->retry_count + 1,
        ]);
    }
}
```

### Stripe Webhook Controller

**File:** `app/Http/Controllers/Api/Webhooks/StripeWebhookController.php`

```php
<?php

namespace App\Http\Controllers\Api\Webhooks;

use App\Http\Controllers\Controller;
use App\Services\Enterprise\Payment\WebhookValidationService;
use App\Services\Enterprise\Payment\WebhookHandlerService;
use App\Models\WebhookEvent;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;
use Stripe\Webhook;
use Stripe\Exception\SignatureVerificationException;

class StripeWebhookController extends Controller
{
    public function __construct(
        private WebhookValidationService $validationService,
        private WebhookHandlerService $handlerService
    ) {}

    /**
     * Handle incoming Stripe webhook
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function handle(Request $request): JsonResponse
    {
        $payload = $request->getContent();
        $signature = $request->header('Stripe-Signature');

        Log::info('Stripe webhook received', [
            'signature_present' => !empty($signature),
            'payload_length' => strlen($payload),
            'ip_address' => $request->ip(),
        ]);

        try {
            // Step 1: Validate HMAC signature
            $event = $this->validationService->validateStripeSignature(
                $payload,
                $signature,
                config('webhooks.stripe.secret')
            );

            // Step 2: Check idempotency (prevent duplicate processing)
            if (WebhookEvent::isProcessed($event->id)) {
                Log::info('Stripe webhook already processed (idempotency)', [
                    'event_id' => $event->id,
                ]);

                return response()->json(['status' => 'already_processed'], 200);
            }

            // Step 3: Log webhook event
            $webhookEvent = WebhookEvent::create([
                'event_id' => $event->id,
                'gateway' => 'stripe',
                'event_type' => $event->type,
                'payload' => json_decode($payload, true),
                'status' => 'processing',
                'signature' => $signature,
                'ip_address' => $request->ip(),
            ]);

            // Step 4: Route to appropriate handler
            $this->handlerService->handleStripeEvent($event, $webhookEvent);

            // Step 5: Mark as completed
            $webhookEvent->markCompleted();

            Log::info('Stripe webhook processed successfully', [
                'event_id' => $event->id,
                'event_type' => $event->type,
            ]);

            return response()->json(['status' => 'success'], 200);

        } catch (SignatureVerificationException $e) {
            Log::error('Stripe webhook signature verification failed', [
                'error' => $e->getMessage(),
                'signature' => $signature,
                'ip_address' => $request->ip(),
            ]);

            return response()->json(['error' => 'Invalid signature'], 401);

        } catch (\Exception $e) {
            Log::error('Stripe webhook processing failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            // Mark as failed if webhook event was created
            if (isset($webhookEvent)) {
                $webhookEvent->markFailed($e->getMessage());
            }

            // Return 500 to trigger Stripe retry
            return response()->json(['error' => 'Processing failed'], 500);
        }
    }
}
```

### PayPal Webhook Controller

**File:** `app/Http/Controllers/Api/Webhooks/PayPalWebhookController.php`

```php
<?php

namespace App\Http\Controllers\Api\Webhooks;

use App\Http\Controllers\Controller;
use App\Services\Enterprise\Payment\WebhookValidationService;
use App\Services\Enterprise\Payment\WebhookHandlerService;
use App\Models\WebhookEvent;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;

class PayPalWebhookController extends Controller
{
    public function __construct(
        private WebhookValidationService $validationService,
        private WebhookHandlerService $handlerService
    ) {}

    /**
     * Handle incoming PayPal webhook
     *
     * @param Request $request
     * @return JsonResponse
     */
    public function handle(Request $request): JsonResponse
    {
        $payload = $request->all();
        $transmissionId = $request->header('Paypal-Transmission-Id');
        $transmissionTime = $request->header('Paypal-Transmission-Time');
        $transmissionSig = $request->header('Paypal-Transmission-Sig');
        $certUrl = $request->header('Paypal-Cert-Url');
        $authAlgo = $request->header('Paypal-Auth-Algo');

        Log::info('PayPal webhook received', [
            'event_type' => $payload['event_type'] ?? 'unknown',
            'transmission_id' => $transmissionId,
            'ip_address' => $request->ip(),
        ]);

        try {
            // Step 1: Validate PayPal webhook signature
            $isValid = $this->validationService->validatePayPalSignature(
                $transmissionId,
                $transmissionTime,
                config('webhooks.paypal.webhook_id'),
                $request->getContent(),
                $transmissionSig,
                $certUrl,
                $authAlgo
            );

            if (!$isValid) {
                Log::error('PayPal webhook signature verification failed', [
                    'transmission_id' => $transmissionId,
                    'ip_address' => $request->ip(),
                ]);

                return response()->json(['error' => 'Invalid signature'], 401);
            }

            // Step 2: Extract event ID
            $eventId = $payload['id'] ?? $transmissionId;

            // Step 3: Check idempotency
            if (WebhookEvent::isProcessed($eventId)) {
                Log::info('PayPal webhook already processed (idempotency)', [
                    'event_id' => $eventId,
                ]);

                return response()->json(['status' => 'already_processed'], 200);
            }

            // Step 4: Log webhook event
            $webhookEvent = WebhookEvent::create([
                'event_id' => $eventId,
                'gateway' => 'paypal',
                'event_type' => $payload['event_type'] ?? 'unknown',
                'payload' => $payload,
                'status' => 'processing',
                'signature' => $transmissionSig,
                'ip_address' => $request->ip(),
            ]);

            // Step 5: Route to appropriate handler
            $this->handlerService->handlePayPalEvent($payload, $webhookEvent);

            // Step 6: Mark as completed
            $webhookEvent->markCompleted();

            Log::info('PayPal webhook processed successfully', [
                'event_id' => $eventId,
                'event_type' => $payload['event_type'] ?? 'unknown',
            ]);

            return response()->json(['status' => 'success'], 200);

        } catch (\Exception $e) {
            Log::error('PayPal webhook processing failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            // Mark as failed if webhook event was created
            if (isset($webhookEvent)) {
                $webhookEvent->markFailed($e->getMessage());
            }

            // Return 500 to trigger PayPal retry
            return response()->json(['error' => 'Processing failed'], 500);
        }
    }
}
```

### Webhook Validation Service

**File:** `app/Services/Enterprise/Payment/WebhookValidationService.php`

```php
<?php

namespace App\Services\Enterprise\Payment;

use App\Contracts\WebhookValidationServiceInterface;
use Illuminate\Support\Facades\Log;
use Stripe\Webhook;
use Stripe\Exception\SignatureVerificationException;
use PayPalHttp\HttpRequest;
use PayPalCheckoutSdk\Core\PayPalHttpClient;

class WebhookValidationService implements WebhookValidationServiceInterface
{
    /**
     * Validate Stripe webhook signature using HMAC
     *
     * @param string $payload Raw request body
     * @param string $signature Stripe-Signature header
     * @param string $secret Webhook signing secret
     * @return \Stripe\Event
     * @throws SignatureVerificationException
     */
    public function validateStripeSignature(
        string $payload,
        string $signature,
        string $secret
    ): \Stripe\Event {
        // Stripe uses HMAC SHA256 for signature verification
        // Format: t=timestamp,v1=signature
        return Webhook::constructEvent($payload, $signature, $secret);
    }

    /**
     * Validate PayPal webhook signature
     *
     * @param string $transmissionId
     * @param string $transmissionTime
     * @param string $webhookId
     * @param string $eventBody
     * @param string $transmissionSig
     * @param string $certUrl
     * @param string $authAlgo
     * @return bool
     */
    public function validatePayPalSignature(
        string $transmissionId,
        string $transmissionTime,
        string $webhookId,
        string $eventBody,
        string $transmissionSig,
        string $certUrl,
        string $authAlgo
    ): bool {
        try {
            // PayPal webhook signature verification
            // Expected message format for HMAC:
            // transmission_id|transmission_time|webhook_id|crc32(event_body)

            $expectedMessage = implode('|', [
                $transmissionId,
                $transmissionTime,
                $webhookId,
                crc32($eventBody),
            ]);

            // Fetch PayPal certificate from cert URL
            $certificate = $this->fetchPayPalCertificate($certUrl);

            // Verify signature using RSA with SHA256
            $publicKey = openssl_pkey_get_public($certificate);

            if (!$publicKey) {
                Log::error('Failed to extract public key from PayPal certificate');
                return false;
            }

            $decodedSignature = base64_decode($transmissionSig);

            $isValid = openssl_verify(
                $expectedMessage,
                $decodedSignature,
                $publicKey,
                OPENSSL_ALGO_SHA256
            ) === 1;

            openssl_free_key($publicKey);

            return $isValid;

        } catch (\Exception $e) {
            Log::error('PayPal signature validation error', [
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Validate timestamp to prevent replay attacks
     *
     * @param int $timestamp Unix timestamp from webhook
     * @param int $toleranceSeconds Maximum age of webhook (default 300 = 5 minutes)
     * @return bool
     */
    public function validateTimestamp(int $timestamp, int $toleranceSeconds = 300): bool
    {
        $currentTime = time();
        $difference = abs($currentTime - $timestamp);

        return $difference <= $toleranceSeconds;
    }

    /**
     * Fetch PayPal certificate for signature verification
     *
     * @param string $certUrl
     * @return string
     */
    private function fetchPayPalCertificate(string $certUrl): string
    {
        // Validate cert URL is from PayPal
        if (!str_starts_with($certUrl, 'https://api.paypal.com/') &&
            !str_starts_with($certUrl, 'https://api-m.paypal.com/')) {
            throw new \Exception('Invalid PayPal certificate URL');
        }

        $certificate = file_get_contents($certUrl);

        if ($certificate === false) {
            throw new \Exception('Failed to fetch PayPal certificate');
        }

        return $certificate;
    }
}
```

### Webhook Handler Service

**File:** `app/Services/Enterprise/Payment/WebhookHandlerService.php`

```php
<?php

namespace App\Services\Enterprise\Payment;

use App\Models\WebhookEvent;
use App\Services\Enterprise\Payment\Handlers\StripePaymentSuccessHandler;
use App\Services\Enterprise\Payment\Handlers\StripeSubscriptionCanceledHandler;
use App\Services\Enterprise\Payment\Handlers\PayPalSubscriptionActivatedHandler;
use Illuminate\Support\Facades\Log;
use Stripe\Event as StripeEvent;

class WebhookHandlerService
{
    public function __construct(
        private StripePaymentSuccessHandler $stripePaymentSuccessHandler,
        private StripeSubscriptionCanceledHandler $stripeSubscriptionCanceledHandler,
        private PayPalSubscriptionActivatedHandler $paypalSubscriptionActivatedHandler
    ) {}

    /**
     * Route Stripe event to appropriate handler
     *
     * @param StripeEvent $event
     * @param WebhookEvent $webhookEvent
     * @return void
     */
    public function handleStripeEvent(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        Log::info('Routing Stripe event', [
            'event_type' => $event->type,
            'event_id' => $event->id,
        ]);

        match ($event->type) {
            'invoice.payment_succeeded' => $this->stripePaymentSuccessHandler->handle($event, $webhookEvent),
            'customer.subscription.deleted' => $this->stripeSubscriptionCanceledHandler->handle($event, $webhookEvent),
            'customer.subscription.updated' => $this->handleSubscriptionUpdated($event, $webhookEvent),
            'invoice.payment_failed' => $this->handlePaymentFailed($event, $webhookEvent),
            'payment_method.attached' => $this->handlePaymentMethodAttached($event, $webhookEvent),
            'checkout.session.completed' => $this->handleCheckoutCompleted($event, $webhookEvent),
            default => Log::info('Unhandled Stripe event type', ['type' => $event->type]),
        };
    }

    /**
     * Route PayPal event to appropriate handler
     *
     * @param array $payload
     * @param WebhookEvent $webhookEvent
     * @return void
     */
    public function handlePayPalEvent(array $payload, WebhookEvent $webhookEvent): void
    {
        $eventType = $payload['event_type'] ?? 'unknown';

        Log::info('Routing PayPal event', [
            'event_type' => $eventType,
            'event_id' => $payload['id'] ?? 'unknown',
        ]);

        match ($eventType) {
            'BILLING.SUBSCRIPTION.ACTIVATED' => $this->paypalSubscriptionActivatedHandler->handle($payload, $webhookEvent),
            'PAYMENT.SALE.COMPLETED' => $this->handlePayPalPaymentCompleted($payload, $webhookEvent),
            'BILLING.SUBSCRIPTION.CANCELLED' => $this->handlePayPalSubscriptionCanceled($payload, $webhookEvent),
            'BILLING.SUBSCRIPTION.SUSPENDED' => $this->handlePayPalSubscriptionSuspended($payload, $webhookEvent),
            'PAYMENT.SALE.REFUNDED' => $this->handlePayPalRefund($payload, $webhookEvent),
            default => Log::info('Unhandled PayPal event type', ['type' => $eventType]),
        };
    }

    // Additional handler methods...

    private function handleSubscriptionUpdated(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        // Implementation for subscription updates
        Log::info('Handling subscription updated event', ['event_id' => $event->id]);
    }

    private function handlePaymentFailed(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        // Implementation for payment failures
        Log::info('Handling payment failed event', ['event_id' => $event->id]);
    }

    private function handlePaymentMethodAttached(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        // Implementation for payment method attached
        Log::info('Handling payment method attached', ['event_id' => $event->id]);
    }

    private function handleCheckoutCompleted(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        // Implementation for checkout completion
        Log::info('Handling checkout completed', ['event_id' => $event->id]);
    }

    private function handlePayPalPaymentCompleted(array $payload, WebhookEvent $webhookEvent): void
    {
        // Implementation for PayPal payment completed
        Log::info('Handling PayPal payment completed', ['event_id' => $payload['id'] ?? 'unknown']);
    }

    private function handlePayPalSubscriptionCanceled(array $payload, WebhookEvent $webhookEvent): void
    {
        // Implementation for PayPal subscription canceled
        Log::info('Handling PayPal subscription canceled', ['event_id' => $payload['id'] ?? 'unknown']);
    }

    private function handlePayPalSubscriptionSuspended(array $payload, WebhookEvent $webhookEvent): void
    {
        // Implementation for PayPal subscription suspended
        Log::info('Handling PayPal subscription suspended', ['event_id' => $payload['id'] ?? 'unknown']);
    }

    private function handlePayPalRefund(array $payload, WebhookEvent $webhookEvent): void
    {
        // Implementation for PayPal refund
        Log::info('Handling PayPal refund', ['event_id' => $payload['id'] ?? 'unknown']);
    }
}
```

### Event Handler Example: Stripe Payment Success

**File:** `app/Services/Enterprise/Payment/Handlers/StripePaymentSuccessHandler.php`

```php
<?php

namespace App\Services\Enterprise\Payment\Handlers;

use App\Models\WebhookEvent;
use App\Models\OrganizationSubscription;
use App\Services\Enterprise\Payment\SubscriptionService;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Stripe\Event as StripeEvent;

class StripePaymentSuccessHandler
{
    public function __construct(
        private SubscriptionService $subscriptionService
    ) {}

    /**
     * Handle invoice.payment_succeeded event
     *
     * @param StripeEvent $event
     * @param WebhookEvent $webhookEvent
     * @return void
     */
    public function handle(StripeEvent $event, WebhookEvent $webhookEvent): void
    {
        $invoice = $event->data->object;
        $subscriptionId = $invoice->subscription;
        $customerId = $invoice->customer;

        Log::info('Processing Stripe payment success', [
            'invoice_id' => $invoice->id,
            'subscription_id' => $subscriptionId,
            'customer_id' => $customerId,
            'amount_paid' => $invoice->amount_paid,
        ]);

        DB::beginTransaction();

        try {
            // Find subscription by Stripe subscription ID
            $subscription = OrganizationSubscription::where('stripe_subscription_id', $subscriptionId)
                ->firstOrFail();

            // Update subscription status
            $subscription->update([
                'status' => 'active',
                'current_period_start' => \Carbon\Carbon::createFromTimestamp($invoice->period_start),
                'current_period_end' => \Carbon\Carbon::createFromTimestamp($invoice->period_end),
                'last_payment_at' => now(),
                'last_payment_amount' => $invoice->amount_paid / 100, // Convert cents to dollars
            ]);

            // Create payment transaction record
            $this->subscriptionService->recordPayment($subscription, [
                'gateway' => 'stripe',
                'gateway_transaction_id' => $invoice->payment_intent,
                'amount' => $invoice->amount_paid / 100,
                'currency' => strtoupper($invoice->currency),
                'status' => 'completed',
                'invoice_id' => $invoice->id,
            ]);

            // Provision resources if this is the first payment
            if ($subscription->wasRecentlyCreated || $subscription->status === 'trialing') {
                $this->subscriptionService->provisionResources($subscription);
            }

            // Send confirmation email
            $subscription->organization->notify(
                new \App\Notifications\PaymentSuccessful($subscription, $invoice->amount_paid / 100)
            );

            DB::commit();

            Log::info('Stripe payment success processed', [
                'subscription_id' => $subscription->id,
                'organization_id' => $subscription->organization_id,
            ]);

        } catch (\Exception $e) {
            DB::rollBack();

            Log::error('Failed to process Stripe payment success', [
                'error' => $e->getMessage(),
                'invoice_id' => $invoice->id,
            ]);

            throw $e;
        }
    }
}
```

### Webhook Routes

**File:** `routes/api.php`

```php
use App\Http\Controllers\Api\Webhooks\StripeWebhookController;
use App\Http\Controllers\Api\Webhooks\PayPalWebhookController;

// Webhook routes (no authentication required, validated via HMAC)
Route::post('/webhooks/stripe', [StripeWebhookController::class, 'handle'])
    ->name('webhooks.stripe')
    ->middleware(['throttle:webhooks']); // Custom rate limit

Route::post('/webhooks/paypal', [PayPalWebhookController::class, 'handle'])
    ->name('webhooks.paypal')
    ->middleware(['throttle:webhooks']);
```

### Configuration File

**File:** `config/webhooks.php`

```php
<?php

return [
    // Stripe configuration
    'stripe' => [
        'secret' => env('STRIPE_WEBHOOK_SECRET'),
        'tolerance' => env('STRIPE_WEBHOOK_TOLERANCE', 300), // 5 minutes
    ],

    // PayPal configuration
    'paypal' => [
        'webhook_id' => env('PAYPAL_WEBHOOK_ID'),
        'mode' => env('PAYPAL_MODE', 'sandbox'), // 'sandbox' or 'live'
    ],

    // Rate limiting
    'rate_limit' => [
        'max_attempts' => env('WEBHOOK_RATE_LIMIT', 100), // per minute
        'decay_minutes' => 1,
    ],

    // Retry configuration
    'retry' => [
        'max_attempts' => 3,
        'backoff_minutes' => [1, 5, 15], // Exponential backoff
    ],

    // Security
    'ip_allowlist' => env('WEBHOOK_IP_ALLOWLIST') ? explode(',', env('WEBHOOK_IP_ALLOWLIST')) : [],
    'timestamp_tolerance' => env('WEBHOOK_TIMESTAMP_TOLERANCE', 300), // 5 minutes
];
```

### Rate Limiting Middleware

**File:** `app/Http/Kernel.php` (add to $middlewareGroups or $routeMiddleware)

```php
protected $middlewareGroups = [
    // ...
];

protected $middlewareAliases = [
    // ... existing aliases
    'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
];

// In RouteServiceProvider or similar:
RateLimiter::for('webhooks', function (Request $request) {
    return Limit::perMinute(config('webhooks.rate_limit.max_attempts'))
        ->by($request->ip());
});
```

## Implementation Approach

### Step 1: Create Database Schema
1. Create `webhook_events` migration
2. Add indexes for efficient querying
3. Run migration: `php artisan migrate`

### Step 2: Create WebhookEvent Model
1. Create model with fillable fields and casts
2. Add helper methods: `isProcessed()`, `markCompleted()`, `markFailed()`
3. Add query scopes for filtering

### Step 3: Implement Validation Service
1. Create `WebhookValidationService` with HMAC validation logic
2. Implement Stripe signature verification using Stripe SDK
3. Implement PayPal signature verification using OpenSSL
4. Add timestamp validation for replay attack prevention

### Step 4: Create Webhook Controllers
1. Create `StripeWebhookController` with signature validation
2. Create `PayPalWebhookController` with PayPal-specific validation
3. Implement idempotency checks using event IDs
4. Add comprehensive error handling and logging

### Step 5: Implement Handler Service
1. Create `WebhookHandlerService` with event routing
2. Implement handler methods for each event type
3. Create specific handler classes for complex events
4. Integrate with `SubscriptionService` and `PaymentService`

### Step 6: Create Event Handlers
1. Create `StripePaymentSuccessHandler` for invoice.payment_succeeded
2. Create `StripeSubscriptionCanceledHandler` for subscription.deleted
3. Create `PayPalSubscriptionActivatedHandler` for subscription.activated
4. Implement business logic with database transactions

### Step 7: Configure Routes and Middleware
1. Add webhook routes to `routes/api.php`
2. Configure rate limiting for webhook endpoints
3. Add IP allowlisting if required
4. Test routes with webhook testing tools

### Step 8: Testing
1. Unit tests for HMAC validation logic
2. Integration tests for complete webhook flow
3. Test idempotency with duplicate webhooks
4. Test error handling and retry logic
5. Use Stripe CLI and PayPal sandbox for testing

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/WebhookValidationServiceTest.php`

```php
<?php

use App\Services\Enterprise\Payment\WebhookValidationService;
use Stripe\Exception\SignatureVerificationException;

beforeEach(function () {
    $this->service = app(WebhookValidationService::class);
});

it('validates Stripe signature correctly', function () {
    $payload = '{"id":"evt_test","type":"invoice.payment_succeeded"}';
    $secret = 'whsec_test_secret';

    // Generate valid signature
    $timestamp = time();
    $signedPayload = "$timestamp.$payload";
    $signature = hash_hmac('sha256', $signedPayload, $secret);
    $stripeSignature = "t=$timestamp,v1=$signature";

    $event = $this->service->validateStripeSignature($payload, $stripeSignature, $secret);

    expect($event)->toBeInstanceOf(\Stripe\Event::class);
    expect($event->type)->toBe('invoice.payment_succeeded');
});

it('rejects invalid Stripe signature', function () {
    $payload = '{"id":"evt_test","type":"invoice.payment_succeeded"}';
    $secret = 'whsec_test_secret';
    $invalidSignature = 't=123456,v1=invalid_signature';

    expect(fn() => $this->service->validateStripeSignature($payload, $invalidSignature, $secret))
        ->toThrow(SignatureVerificationException::class);
});

it('validates timestamp within tolerance', function () {
    $currentTimestamp = time();

    expect($this->service->validateTimestamp($currentTimestamp, 300))->toBeTrue();
    expect($this->service->validateTimestamp($currentTimestamp - 100, 300))->toBeTrue();
    expect($this->service->validateTimestamp($currentTimestamp - 400, 300))->toBeFalse();
});

it('validates PayPal webhook signature', function () {
    // Mock PayPal signature validation
    $transmissionId = 'test-transmission-id';
    $transmissionTime = (string) time();
    $webhookId = 'test-webhook-id';
    $eventBody = '{"event_type":"BILLING.SUBSCRIPTION.ACTIVATED"}';

    // This would normally use a real PayPal certificate
    // For testing, mock the validation
    $isValid = true; // Mock result

    expect($isValid)->toBeTrue();
});
```

### Integration Tests

**File:** `tests/Feature/Webhooks/StripeWebhookTest.php`

```php
<?php

use App\Models\OrganizationSubscription;
use App\Models\WebhookEvent;
use Illuminate\Support\Facades\Event;

it('processes Stripe payment success webhook', function () {
    $subscription = OrganizationSubscription::factory()->create([
        'stripe_subscription_id' => 'sub_test123',
        'status' => 'trialing',
    ]);

    $payload = [
        'id' => 'evt_test_' . uniqid(),
        'type' => 'invoice.payment_succeeded',
        'data' => [
            'object' => [
                'id' => 'in_test123',
                'subscription' => 'sub_test123',
                'customer' => 'cus_test123',
                'amount_paid' => 2900, // $29.00
                'period_start' => time(),
                'period_end' => time() + 2592000, // +30 days
                'payment_intent' => 'pi_test123',
                'currency' => 'usd',
            ],
        ],
    ];

    // Generate valid Stripe signature
    $secret = config('webhooks.stripe.secret');
    $timestamp = time();
    $payloadJson = json_encode($payload);
    $signedPayload = "$timestamp.$payloadJson";
    $signature = hash_hmac('sha256', $signedPayload, $secret);
    $stripeSignature = "t=$timestamp,v1=$signature";

    $response = $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $stripeSignature,
    ]);

    $response->assertOk()
        ->assertJson(['status' => 'success']);

    // Verify subscription was updated
    $subscription->refresh();
    expect($subscription->status)->toBe('active');
    expect($subscription->last_payment_amount)->toBe(29.00);

    // Verify webhook event was logged
    $this->assertDatabaseHas('webhook_events', [
        'event_id' => $payload['id'],
        'gateway' => 'stripe',
        'event_type' => 'invoice.payment_succeeded',
        'status' => 'completed',
    ]);
});

it('rejects webhook with invalid signature', function () {
    $payload = [
        'id' => 'evt_test_' . uniqid(),
        'type' => 'invoice.payment_succeeded',
    ];

    $response = $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => 'invalid_signature',
    ]);

    $response->assertStatus(401)
        ->assertJson(['error' => 'Invalid signature']);

    // Verify no webhook event was created
    $this->assertDatabaseMissing('webhook_events', [
        'event_id' => $payload['id'],
    ]);
});

it('prevents duplicate processing with idempotency', function () {
    $eventId = 'evt_test_' . uniqid();

    // Create existing processed webhook event
    WebhookEvent::create([
        'event_id' => $eventId,
        'gateway' => 'stripe',
        'event_type' => 'invoice.payment_succeeded',
        'payload' => [],
        'status' => 'completed',
    ]);

    $payload = [
        'id' => $eventId,
        'type' => 'invoice.payment_succeeded',
    ];

    // Generate valid signature
    $secret = config('webhooks.stripe.secret');
    $timestamp = time();
    $payloadJson = json_encode($payload);
    $signedPayload = "$timestamp.$payloadJson";
    $signature = hash_hmac('sha256', $signedPayload, $secret);
    $stripeSignature = "t=$timestamp,v1=$signature";

    $response = $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $stripeSignature,
    ]);

    $response->assertOk()
        ->assertJson(['status' => 'already_processed']);

    // Verify only one webhook event exists
    expect(WebhookEvent::where('event_id', $eventId)->count())->toBe(1);
});

it('handles webhook processing errors gracefully', function () {
    // Payload with non-existent subscription (will trigger error)
    $payload = [
        'id' => 'evt_test_' . uniqid(),
        'type' => 'invoice.payment_succeeded',
        'data' => [
            'object' => [
                'subscription' => 'sub_nonexistent',
                'customer' => 'cus_test123',
                'amount_paid' => 2900,
            ],
        ],
    ];

    // Generate valid signature
    $secret = config('webhooks.stripe.secret');
    $timestamp = time();
    $payloadJson = json_encode($payload);
    $signedPayload = "$timestamp.$payloadJson";
    $signature = hash_hmac('sha256', $signedPayload, $secret);
    $stripeSignature = "t=$timestamp,v1=$signature";

    $response = $this->postJson(route('webhooks.stripe'), $payload, [
        'Stripe-Signature' => $stripeSignature,
    ]);

    $response->assertStatus(500)
        ->assertJson(['error' => 'Processing failed']);

    // Verify webhook event was marked as failed
    $this->assertDatabaseHas('webhook_events', [
        'event_id' => $payload['id'],
        'status' => 'failed',
    ]);
});
```

### PayPal Webhook Tests

**File:** `tests/Feature/Webhooks/PayPalWebhookTest.php`

```php
<?php

use App\Models\OrganizationSubscription;
use App\Models\WebhookEvent;

it('processes PayPal subscription activated webhook', function () {
    $subscription = OrganizationSubscription::factory()->create([
        'paypal_subscription_id' => 'I-TEST123',
        'status' => 'pending',
    ]);

    $payload = [
        'id' => 'WH-TEST-' . uniqid(),
        'event_type' => 'BILLING.SUBSCRIPTION.ACTIVATED',
        'resource' => [
            'id' => 'I-TEST123',
            'status' => 'ACTIVE',
        ],
    ];

    // Mock PayPal signature validation
    // In real tests, use PayPal SDK to generate valid signatures

    $response = $this->postJson(route('webhooks.paypal'), $payload, [
        'Paypal-Transmission-Id' => 'test-transmission-id',
        'Paypal-Transmission-Time' => (string) time(),
        'Paypal-Transmission-Sig' => 'mock-signature',
        'Paypal-Cert-Url' => 'https://api.paypal.com/v1/notifications/certs/test',
        'Paypal-Auth-Algo' => 'SHA256withRSA',
    ]);

    $response->assertOk();

    // Verify subscription was activated
    $subscription->refresh();
    expect($subscription->status)->toBe('active');

    // Verify webhook event was logged
    $this->assertDatabaseHas('webhook_events', [
        'event_id' => $payload['id'],
        'gateway' => 'paypal',
        'event_type' => 'BILLING.SUBSCRIPTION.ACTIVATED',
        'status' => 'completed',
    ]);
});
```

## Definition of Done

- [ ] `webhook_events` database table created with proper indexes
- [ ] WebhookEvent model created with helper methods
- [ ] StripeWebhookController created with HMAC validation
- [ ] PayPalWebhookController created with PayPal signature validation
- [ ] WebhookValidationService implemented with Stripe and PayPal HMAC validation
- [ ] WebhookHandlerService created with event routing logic
- [ ] StripePaymentSuccessHandler implemented with subscription activation
- [ ] StripeSubscriptionCanceledHandler implemented with cancellation logic
- [ ] PayPalSubscriptionActivatedHandler implemented
- [ ] Idempotency enforcement prevents duplicate webhook processing
- [ ] Replay attack prevention validates timestamp
- [ ] Rate limiting configured for webhook endpoints (100 req/min)
- [ ] Comprehensive logging for all webhook events
- [ ] Error handling with automatic retry logic
- [ ] Webhook routes registered in `routes/api.php`
- [ ] Configuration file `config/webhooks.php` created
- [ ] Unit tests written for HMAC validation (>95% coverage)
- [ ] Integration tests written for complete webhook flow (10+ tests)
- [ ] Tested with Stripe CLI webhook forwarding
- [ ] Tested with PayPal sandbox webhooks
- [ ] Documentation updated with webhook setup instructions
- [ ] Code follows Laravel and Coolify standards
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing with zero errors
- [ ] Code reviewed and approved
- [ ] Deployed to staging and verified with test webhooks

## Related Tasks

- **Depends on:** Task 46 (PaymentService with subscription methods)
- **Used by:** Task 48 (Subscription lifecycle management)
- **Used by:** Task 49 (Usage-based billing calculations)
- **Integrates with:** Task 43 (PaymentGatewayInterface for multi-gateway support)
- **Triggers:** Resource provisioning workflows when payment succeeds
- **Sends:** Payment notifications via Task 9 (Email templates)
