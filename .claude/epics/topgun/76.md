---
name: Write unit tests for all enterprise services
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:28Z
github: https://github.com/johnproblems/topgun/issues/183
depends_on: [72, 73, 74, 75]
parallel: false
conflicts_with: []
---

# Task: Write unit tests for all enterprise services

## Description

Implement comprehensive unit tests for all enterprise service classes using Pest PHP, covering WhiteLabelService, TerraformService, CapacityManager, SystemResourceMonitor, PaymentService, DomainRegistrarService, and all other enterprise-tier functionality. This task establishes the testing foundation that ensures code quality, prevents regressions, and enables confident refactoring throughout the enterprise transformation.

**Testing Philosophy for Enterprise Systems:**

Enterprise software must meet higher reliability standards than hobby projects. A single bug in licensing validation could allow unauthorized access to premium features. A flaw in Terraform state management could corrupt production infrastructure. A race condition in capacity calculations could overload servers and cause outages. These aren't theoretical risks—they're production realities that testing prevents.

Unit tests form the first line of defense by isolating each service method and verifying its behavior under all conditions: happy paths, error paths, edge cases, and boundary conditions. Unlike integration tests that verify entire workflows, unit tests pinpoint exactly where logic fails, making debugging trivial and development velocity high.

**Scope of Testing:**

This task creates unit tests for **14 enterprise service classes** across six functional domains:

1. **White-Label Services (3 services)**
   - WhiteLabelService: CSS generation, branding configuration, favicon management
   - BrandingCacheService: Redis caching layer for performance
   - FaviconGeneratorService: Multi-size favicon generation from source images

2. **Infrastructure Services (3 services)**
   - TerraformService: Infrastructure provisioning orchestration
   - TerraformStateManager: State file encryption, storage, backup
   - CloudProviderAdapter: Multi-cloud API abstraction layer

3. **Resource Management Services (2 services)**
   - CapacityManager: Server selection and capacity scoring
   - SystemResourceMonitor: Metrics collection and aggregation

4. **Payment Services (2 services)**
   - PaymentService: Multi-gateway payment processing
   - SubscriptionManager: Subscription lifecycle management

5. **Domain Services (2 services)**
   - DomainRegistrarService: Domain registration and management
   - DnsManagementService: Automated DNS record management

6. **Deployment Services (2 services)**
   - EnhancedDeploymentService: Advanced deployment strategies
   - DeploymentStrategyFactory: Strategy pattern implementation

**Total Estimated Tests:** 350-450 individual test cases across all services

**Integration with Testing Traits:**

This task builds upon the test infrastructure created in Tasks 72-75:
- **OrganizationTestingTrait** - Provides organization hierarchy creation and context switching
- **LicenseTestingTrait** - Provides license validation and feature flag testing
- **TerraformTestingTrait** - Provides mock Terraform CLI execution
- **PaymentTestingTrait** - Provides payment gateway simulation

These traits eliminate repetitive test setup code and ensure consistency across the test suite.

**Why This Task is Critical:**

Unit tests are not optional for enterprise software—they're essential infrastructure that pays dividends throughout the project lifecycle:

1. **Regression Prevention**: Every test is a guard against future bugs. When refactoring TerraformService in 6 months, these tests ensure nothing breaks.

2. **Living Documentation**: Tests document expected behavior better than comments. They show exactly how to use each method with real examples.

3. **Confident Refactoring**: With 90%+ test coverage, developers can refactor aggressively knowing tests will catch mistakes.

4. **Debugging Speed**: When a test fails, you know exactly which method broke and can fix it in minutes instead of hours.

5. **Code Quality Enforcement**: Hard-to-test code is usually poorly designed. Writing tests forces cleaner architecture.

6. **CI/CD Quality Gates**: Automated test runs prevent broken code from reaching production.

Without comprehensive unit tests, enterprise software becomes fragile legacy code that nobody dares to change. With excellent test coverage, the codebase remains maintainable and evolvable for years.

## Acceptance Criteria

- [ ] Unit tests written for WhiteLabelService (40+ tests)
- [ ] Unit tests written for BrandingCacheService (25+ tests)
- [ ] Unit tests written for FaviconGeneratorService (30+ tests)
- [ ] Unit tests written for TerraformService (50+ tests)
- [ ] Unit tests written for TerraformStateManager (35+ tests)
- [ ] Unit tests written for CloudProviderAdapter (20+ tests per provider: AWS, DO, Hetzner)
- [ ] Unit tests written for CapacityManager (40+ tests)
- [ ] Unit tests written for SystemResourceMonitor (30+ tests)
- [ ] Unit tests written for PaymentService (45+ tests)
- [ ] Unit tests written for SubscriptionManager (35+ tests)
- [ ] Unit tests written for DomainRegistrarService (40+ tests)
- [ ] Unit tests written for DnsManagementService (30+ tests)
- [ ] Unit tests written for EnhancedDeploymentService (45+ tests)
- [ ] Unit tests written for DeploymentStrategyFactory (20+ tests)
- [ ] All tests use Pest PHP syntax and conventions
- [ ] All tests utilize OrganizationTestingTrait where applicable
- [ ] All tests utilize LicenseTestingTrait for license validation tests
- [ ] All tests utilize TerraformTestingTrait for infrastructure tests
- [ ] All tests utilize PaymentTestingTrait for payment tests
- [ ] Mocking implemented for external dependencies (HTTP clients, Terraform binary, payment gateways)
- [ ] Test coverage reports generated showing >90% line coverage
- [ ] All edge cases and error conditions tested
- [ ] Parameterized tests (datasets) used for repetitive scenarios
- [ ] Performance assertions for critical operations
- [ ] Concurrency and thread-safety tests for shared resources
- [ ] Tests execute in <60 seconds total (parallel execution)
- [ ] No database state leakage between tests (RefreshDatabase trait)
- [ ] PHPStan level 5 passing on all test files

## Technical Details

### File Paths

**Test Directory Structure:**
```
tests/
├── Unit/
│   └── Services/
│       └── Enterprise/
│           ├── WhiteLabelServiceTest.php
│           ├── BrandingCacheServiceTest.php
│           ├── FaviconGeneratorServiceTest.php
│           ├── TerraformServiceTest.php
│           ├── TerraformStateManagerTest.php
│           ├── CloudProviderAdapterTest.php
│           ├── CapacityManagerTest.php
│           ├── SystemResourceMonitorTest.php
│           ├── PaymentServiceTest.php
│           ├── SubscriptionManagerTest.php
│           ├── DomainRegistrarServiceTest.php
│           ├── DnsManagementServiceTest.php
│           ├── EnhancedDeploymentServiceTest.php
│           └── DeploymentStrategyFactoryTest.php
├── Traits/
│   ├── OrganizationTestingTrait.php (Task 72)
│   ├── LicenseTestingTrait.php (Task 73)
│   ├── TerraformTestingTrait.php (Task 74)
│   └── PaymentTestingTrait.php (Task 75)
└── Helpers/
    ├── MockTerraformBinary.php
    ├── MockPaymentGateway.php
    └── MockDnsProvider.php
```

**Configuration:**
- `/home/topgun/topgun/phpunit.xml` - PHPUnit configuration with coverage settings
- `/home/topgun/topgun/tests/Pest.php` - Pest global configuration and helpers

### WhiteLabelService Unit Tests

**File:** `tests/Unit/Services/Enterprise/WhiteLabelServiceTest.php`

```php
<?php

use App\Services\Enterprise\WhiteLabelService;
use App\Contracts\BrandingCacheServiceInterface;
use App\Models\Organization;
use App\Models\WhiteLabelConfig;
use Illuminate\Support\Facades\Storage;
use Tests\Traits\OrganizationTestingTrait;

uses(OrganizationTestingTrait::class);

beforeEach(function () {
    Storage::fake('public');

    $this->cacheService = Mockery::mock(BrandingCacheServiceInterface::class);
    $this->service = new WhiteLabelService($this->cacheService);

    $this->organization = $this->createOrganization();
    $this->config = WhiteLabelConfig::factory()->create([
        'organization_id' => $this->organization->id,
        'primary_color' => '#3b82f6',
        'secondary_color' => '#8b5cf6',
        'accent_color' => '#10b981',
        'font_family' => 'Inter, sans-serif',
        'platform_name' => 'Acme Cloud',
    ]);
});

describe('CSS Generation', function () {
    it('generates valid CSS with organization colors', function () {
        $css = $this->service->generateCSS($this->organization);

        expect($css)
            ->toContain('--color-primary: #3b82f6')
            ->toContain('--color-secondary: #8b5cf6')
            ->toContain('--color-accent: #10b981')
            ->toContain('--font-family-primary: Inter, sans-serif');
    });

    it('generates dark mode CSS variants', function () {
        $css = $this->service->generateCSS($this->organization);

        expect($css)
            ->toContain('@media (prefers-color-scheme: dark)')
            ->toContain('--color-primary-dark:');
    });

    it('falls back to default theme when config is missing', function () {
        $orgWithoutConfig = $this->createOrganization();

        $css = $this->service->generateCSS($orgWithoutConfig);

        expect($css)
            ->toContain('--color-primary: #3b82f6') // Default Coolify blue
            ->not->toBeEmpty();
    });

    it('sanitizes CSS to prevent injection attacks', function () {
        $this->config->update([
            'primary_color' => '#ff0000; } body { display: none; } /*',
        ]);

        $css = $this->service->generateCSS($this->organization);

        expect($css)
            ->not->toContain('display: none')
            ->not->toContain('} body {');
    });

    it('generates minified CSS in production', function () {
        app()->detectEnvironment(fn () => 'production');

        $css = $this->service->generateCSS($this->organization);

        expect($css)
            ->not->toContain('  ') // No double spaces
            ->not->toContain("\n\n"); // No blank lines
    });

    it('includes custom CSS when provided', function () {
        $this->config->update([
            'custom_css' => '.custom-class { background: red; }',
        ]);

        $css = $this->service->generateCSS($this->organization);

        expect($css)->toContain('.custom-class { background: red; }');
    });

    it('caches generated CSS', function () {
        $this->cacheService->shouldReceive('getCachedCSS')
            ->once()
            ->with($this->organization)
            ->andReturn(null);

        $this->cacheService->shouldReceive('setCachedCSS')
            ->once()
            ->with($this->organization, Mockery::type('string'));

        $this->service->generateCSS($this->organization);
    });

    it('returns cached CSS if available', function () {
        $cachedCSS = ':root { --cached: true; }';

        $this->cacheService->shouldReceive('getCachedCSS')
            ->once()
            ->with($this->organization)
            ->andReturn($cachedCSS);

        $css = $this->service->generateCSS($this->organization);

        expect($css)->toBe($cachedCSS);
    });
});

describe('Branding Configuration', function () {
    it('retrieves complete branding configuration', function () {
        $config = $this->service->getBrandingConfig($this->organization);

        expect($config)
            ->toHaveKeys([
                'platform_name',
                'primary_color',
                'secondary_color',
                'accent_color',
                'font_family',
                'logo_url',
                'favicon_url',
            ])
            ->platform_name->toBe('Acme Cloud');
    });

    it('includes logo URLs in configuration', function () {
        $this->config->update([
            'primary_logo_path' => 'branding/1/logos/logo.png',
        ]);

        $config = $this->service->getBrandingConfig($this->organization);

        expect($config['logo_url'])->toContain('branding/1/logos/logo.png');
    });

    it('handles missing logo gracefully', function () {
        $config = $this->service->getBrandingConfig($this->organization);

        expect($config['logo_url'])->toBeNull();
    });

    it('validates color format', function () {
        $isValid = $this->service->validateColor('#3b82f6');
        $isInvalid = $this->service->validateColor('not-a-color');

        expect($isValid)->toBeTrue();
        expect($isInvalid)->toBeFalse();
    });

    it('validates color format with various inputs', function (string $color, bool $expected) {
        $result = $this->service->validateColor($color);
        expect($result)->toBe($expected);
    })->with([
        ['#ffffff', true],
        ['#000000', true],
        ['#3b82f6', true],
        ['#FFF', false], // Must be 6 characters
        ['#GGGGGG', false], // Invalid hex
        ['rgb(255,0,0)', false], // Not hex format
        ['', false],
        ['#12345', false], // Too short
    ]);
});

describe('Email Branding Variables', function () {
    it('generates email branding variables', function () {
        $vars = $this->service->getEmailBrandingVars($this->organization);

        expect($vars)
            ->toHaveKeys([
                'platform_name',
                'primary_color',
                'logo_url',
                'support_email',
                'platform_url',
            ])
            ->platform_name->toBe('Acme Cloud');
    });

    it('uses default values for missing email config', function () {
        $orgWithoutConfig = $this->createOrganization();

        $vars = $this->service->getEmailBrandingVars($orgWithoutConfig);

        expect($vars['platform_name'])->toBe('Coolify');
        expect($vars['primary_color'])->toBe('#3b82f6');
    });

    it('includes organization-specific support email', function () {
        $this->config->update([
            'support_email' => 'support@acme.com',
        ]);

        $vars = $this->service->getEmailBrandingVars($this->organization);

        expect($vars['support_email'])->toBe('support@acme.com');
    });
});

describe('Favicon Management', function () {
    it('retrieves all favicon URLs', function () {
        $this->config->update([
            'favicon_16_path' => 'branding/1/favicons/favicon-16x16.png',
            'favicon_32_path' => 'branding/1/favicons/favicon-32x32.png',
            'favicon_180_path' => 'branding/1/favicons/apple-touch-icon.png',
        ]);

        $urls = $this->service->getFaviconUrls($this->organization);

        expect($urls)
            ->toHaveKeys(['favicon_16', 'favicon_32', 'apple_touch_icon'])
            ->favicon_16->toContain('favicon-16x16.png');
    });

    it('returns empty array when no favicons exist', function () {
        $orgWithoutFavicons = $this->createOrganization();

        $urls = $this->service->getFaviconUrls($orgWithoutFavicons);

        expect($urls)->toBeEmpty();
    });

    it('generates favicon meta tags HTML', function () {
        $this->config->update([
            'favicon_16_path' => 'branding/1/favicons/favicon-16x16.png',
        ]);

        $html = $this->service->getFaviconMetaTags($this->organization);

        expect($html)
            ->toContain('<link rel="icon"')
            ->toContain('sizes="16x16"')
            ->toContain('favicon-16x16.png');
    });
});

describe('Cache Invalidation', function () {
    it('clears branding cache when configuration updated', function () {
        $this->cacheService->shouldReceive('clearBrandingCache')
            ->once()
            ->with($this->organization);

        $this->service->clearCache($this->organization);
    });

    it('clears cache for all organizations', function () {
        $orgs = Organization::factory(3)->create();

        $this->cacheService->shouldReceive('clearAllBrandingCache')
            ->once();

        $this->service->clearAllCache();
    });
});

describe('Performance', function () {
    it('generates CSS in under 100ms', function () {
        $start = microtime(true);

        $this->service->generateCSS($this->organization);

        $duration = (microtime(true) - $start) * 1000;

        expect($duration)->toBeLessThan(100);
    });

    it('handles concurrent requests safely', function () {
        // Simulate concurrent CSS generation
        $results = [];

        for ($i = 0; $i < 10; $i++) {
            $results[] = $this->service->generateCSS($this->organization);
        }

        // All results should be identical
        expect(array_unique($results))->toHaveCount(1);
    });
});

describe('Error Handling', function () {
    it('throws exception for invalid organization', function () {
        $invalidOrg = new Organization(['id' => 99999]);

        expect(fn () => $this->service->generateCSS($invalidOrg))
            ->toThrow(\Exception::class, 'Organization not found');
    });

    it('logs errors when CSS generation fails', function () {
        Log::shouldReceive('error')
            ->once()
            ->with('CSS generation failed', Mockery::type('array'));

        // Force an error condition
        $this->service->generateCSS($this->organization);
    });
});
```

### TerraformService Unit Tests

**File:** `tests/Unit/Services/Enterprise/TerraformServiceTest.php`

```php
<?php

use App\Services\Enterprise\TerraformService;
use App\Models\TerraformDeployment;
use App\Models\CloudProviderCredential;
use App\Exceptions\TerraformException;
use Illuminate\Support\Facades\Process;
use Tests\Traits\TerraformTestingTrait;
use Tests\Traits\OrganizationTestingTrait;

uses(TerraformTestingTrait::class, OrganizationTestingTrait::class);

beforeEach(function () {
    $this->service = app(TerraformService::class);
    $this->organization = $this->createOrganization();

    $this->credential = CloudProviderCredential::factory()->aws()->create([
        'organization_id' => $this->organization->id,
    ]);

    $this->deployment = TerraformDeployment::factory()->create([
        'organization_id' => $this->organization->id,
        'cloud_provider_credential_id' => $this->credential->id,
    ]);

    $this->mockTerraformBinary();
});

describe('Infrastructure Provisioning', function () {
    it('executes terraform init successfully', function () {
        Process::fake([
            'terraform version*' => Process::result('1.5.7'),
            'terraform init*' => Process::result('Terraform initialized'),
        ]);

        $output = $this->service->init($this->deployment);

        expect($output)->toContain('Terraform initialized');

        Process::assertRan('terraform init');
    });

    it('executes terraform plan successfully', function () {
        Process::fake([
            'terraform plan*' => Process::result('Plan: 3 to add, 0 to change, 0 to destroy'),
        ]);

        $output = $this->service->plan($this->deployment);

        expect($output)->toContain('Plan: 3 to add');
    });

    it('executes terraform apply successfully', function () {
        Process::fake([
            'terraform apply*' => Process::result('Apply complete! Resources: 3 added'),
        ]);

        $output = $this->service->apply($this->deployment);

        expect($output)->toContain('Apply complete');
    });

    it('provisions complete infrastructure workflow', function () {
        $this->fakeTerraformWorkflow();

        $result = $this->service->provisionInfrastructure(
            $this->credential,
            [
                'instance_type' => 't3.medium',
                'region' => 'us-east-1',
            ]
        );

        expect($result)
            ->toBeInstanceOf(TerraformDeployment::class)
            ->status->toBe('completed');
    });

    it('stores terraform state after apply', function () {
        $this->fakeTerraformWorkflow();

        $deployment = $this->service->provisionInfrastructure($this->credential, []);

        expect($deployment->state_file)->not->toBeNull();
        expect($deployment->state_file_checksum)->not->toBeNull();
    });

    it('parses terraform outputs correctly', function () {
        Process::fake([
            'terraform output*' => Process::result('{"server_ip": {"value": "1.2.3.4"}}'),
        ]);

        $outputs = $this->service->getOutputs($this->deployment);

        expect($outputs)
            ->toHaveKey('server_ip', '1.2.3.4');
    });

    it('handles terraform init failure gracefully', function () {
        Process::fake([
            'terraform init*' => Process::result('Error: Plugin download failed', 1),
        ]);

        expect(fn () => $this->service->init($this->deployment))
            ->toThrow(TerraformException::class, 'Plugin download failed');
    });

    it('retries failed operations up to 3 times', function () {
        $attempt = 0;

        Process::fake([
            'terraform apply*' => function () use (&$attempt) {
                $attempt++;
                if ($attempt < 3) {
                    return Process::result('Error: Timeout', 1);
                }
                return Process::result('Apply complete');
            },
        ]);

        $output = $this->service->apply($this->deployment);

        expect($attempt)->toBe(3);
        expect($output)->toContain('Apply complete');
    });
});

describe('Infrastructure Destruction', function () {
    it('destroys infrastructure successfully', function () {
        Process::fake([
            'terraform destroy*' => Process::result('Destroy complete'),
        ]);

        $result = $this->service->destroyInfrastructure($this->deployment);

        expect($result)->toBeTrue();

        $this->deployment->refresh();
        expect($this->deployment->status)->toBe('destroyed');
    });

    it('handles destruction errors', function () {
        Process::fake([
            'terraform destroy*' => Process::result('Error: Resource still in use', 1),
        ]);

        expect(fn () => $this->service->destroyInfrastructure($this->deployment))
            ->toThrow(TerraformException::class);
    });

    it('force destroys infrastructure when specified', function () {
        Process::fake([
            'terraform destroy*' => Process::result('Destroy complete'),
        ]);

        $result = $this->service->destroyInfrastructure($this->deployment, force: true);

        expect($result)->toBeTrue();

        Process::assertRan(function ($command) {
            return str_contains($command, '-force');
        });
    });
});

describe('State Management', function () {
    it('encrypts state file before storing', function () {
        $plainState = '{"version": 4, "terraform_version": "1.5.7"}';

        $encrypted = invade($this->service)->encryptStateFile($plainState);

        expect($encrypted)->not->toBe($plainState);
        expect(strlen($encrypted))->toBeGreaterThan(strlen($plainState));
    });

    it('decrypts state file correctly', function () {
        $plainState = '{"version": 4, "terraform_version": "1.5.7"}';

        $encrypted = invade($this->service)->encryptStateFile($plainState);
        $decrypted = invade($this->service)->decryptStateFile($encrypted);

        expect($decrypted)->toBe($plainState);
    });

    it('backs up state to S3 after apply', function () {
        Storage::fake('s3');

        $this->fakeTerraformWorkflow();

        $deployment = $this->service->provisionInfrastructure($this->credential, []);

        $s3Path = "terraform/states/{$this->organization->id}/{$deployment->uuid}.tfstate";
        Storage::disk('s3')->assertExists($s3Path);
    });

    it('refreshes state from cloud provider', function () {
        Process::fake([
            'terraform refresh*' => Process::result('Refresh complete'),
        ]);

        $result = $this->service->refreshState($this->deployment);

        expect($result)->toBeTrue();
    });

    it('validates state file checksum', function () {
        $this->deployment->update([
            'state_file' => encrypt('{"version": 4}'),
            'state_file_checksum' => hash('sha256', '{"version": 4}'),
        ]);

        $isValid = $this->service->validateStateChecksum($this->deployment);

        expect($isValid)->toBeTrue();
    });
});

describe('Template Validation', function () {
    it('validates terraform template syntax', function () {
        Process::fake([
            'terraform validate*' => Process::result('{"valid": true}'),
        ]);

        $result = $this->service->validateTemplate('/path/to/template.tf');

        expect($result)
            ->toHaveKey('valid', true)
            ->toHaveKey('errors', []);
    });

    it('detects invalid terraform syntax', function () {
        Process::fake([
            'terraform validate*' => Process::result('{"valid": false, "diagnostics": [{"detail": "Syntax error"}]}'),
        ]);

        $result = $this->service->validateTemplate('/path/to/bad-template.tf');

        expect($result)
            ->valid->toBeFalse()
            ->errors->not->toBeEmpty();
    });
});

describe('Cloud Provider Integration', function () {
    it('generates AWS provider configuration', function () {
        $config = invade($this->service)->getProviderCredentialsAsVariables($this->credential);

        expect($config)
            ->toHaveKeys(['aws_access_key_id', 'aws_secret_access_key', 'aws_region']);
    });

    it('generates DigitalOcean provider configuration', function () {
        $doCredential = CloudProviderCredential::factory()->digitalocean()->create([
            'organization_id' => $this->organization->id,
        ]);

        $config = invade($this->service)->getProviderCredentialsAsVariables($doCredential);

        expect($config)->toHaveKey('do_token');
    });

    it('generates Hetzner provider configuration', function () {
        $hetznerCredential = CloudProviderCredential::factory()->hetzner()->create([
            'organization_id' => $this->organization->id,
        ]);

        $config = invade($this->service)->getProviderCredentialsAsVariables($hetznerCredential);

        expect($config)->toHaveKey('hcloud_token');
    });
});

describe('Workspace Management', function () {
    it('creates workspace directory structure', function () {
        Storage::fake('local');

        $workspaceDir = invade($this->service)->prepareWorkspace(
            $this->deployment,
            $this->credential,
            ['instance_type' => 't3.medium']
        );

        expect($workspaceDir)->toBeDirectory();
        expect(file_exists("{$workspaceDir}/terraform.tfvars"))->toBeTrue();
    });

    it('cleans up workspace after completion', function () {
        $workspaceDir = storage_path("app/terraform/workspaces/test-workspace");
        mkdir($workspaceDir, 0755, true);
        file_put_contents("{$workspaceDir}/test.tf", 'resource "test" {}');

        invade($this->service)->cleanupWorkspace($workspaceDir);

        expect(file_exists($workspaceDir))->toBeFalse();
    });

    it('restores workspace from deployment state', function () {
        $this->deployment->update([
            'state_file' => encrypt('{"version": 4}'),
        ]);

        $workspaceDir = invade($this->service)->restoreWorkspace($this->deployment);

        expect($workspaceDir)->toBeDirectory();
        expect(file_exists("{$workspaceDir}/terraform.tfstate"))->toBeTrue();
    });
});

describe('Error Handling', function () {
    it('handles missing terraform binary gracefully', function () {
        Process::fake([
            'terraform version*' => Process::result('', 127), // Command not found
        ]);

        expect(fn () => $this->service->getTerraformVersion())
            ->toThrow(TerraformException::class, 'Terraform binary not found');
    });

    it('logs terraform errors with context', function () {
        Log::shouldReceive('error')
            ->once()
            ->with('Terraform provisioning failed', Mockery::type('array'));

        Process::fake([
            'terraform init*' => Process::result('Error: Failed', 1),
        ]);

        try {
            $this->service->init($this->deployment);
        } catch (TerraformException $e) {
            // Expected
        }
    });

    it('handles concurrent provisioning requests', function () {
        // Create 5 deployments simultaneously
        $deployments = TerraformDeployment::factory(5)->create([
            'organization_id' => $this->organization->id,
            'cloud_provider_credential_id' => $this->credential->id,
        ]);

        $this->fakeTerraformWorkflow();

        // Simulate concurrent execution
        foreach ($deployments as $deployment) {
            $result = $this->service->provisionInfrastructure($this->credential, []);
            expect($result->status)->toBe('completed');
        }
    });
});

describe('Performance', function () {
    it('completes terraform init in under 60 seconds', function () {
        Process::fake([
            'terraform init*' => Process::result('Terraform initialized'),
        ]);

        $start = microtime(true);
        $this->service->init($this->deployment);
        $duration = microtime(true) - $start;

        expect($duration)->toBeLessThan(60);
    });

    it('parses large state files efficiently', function () {
        $largeState = json_encode([
            'version' => 4,
            'resources' => array_fill(0, 1000, [
                'type' => 'aws_instance',
                'name' => 'server',
                'instances' => [['attributes' => ['id' => 'i-12345']]],
            ]),
        ]);

        $start = microtime(true);
        $identifiers = invade($this->service)->extractResourceIdentifiers($largeState);
        $duration = microtime(true) - $start;

        expect($duration)->toBeLessThan(1); // < 1 second
        expect($identifiers)->toHaveCount(1000);
    });
});
```

### CapacityManager Unit Tests

**File:** `tests/Unit/Services/Enterprise/CapacityManagerTest.php`

```php
<?php

use App\Services\Enterprise\CapacityManager;
use App\Models\Server;
use App\Models\Organization;
use App\Models\ServerResourceMetric;
use Illuminate\Support\Collection;
use Tests\Traits\OrganizationTestingTrait;

uses(OrganizationTestingTrait::class);

beforeEach(function () {
    $this->service = app(CapacityManager::class);
    $this->organization = $this->createOrganization();
});

describe('Server Selection', function () {
    it('selects server with highest capacity score', function () {
        $servers = collect([
            Server::factory()->create([
                'organization_id' => $this->organization->id,
                'name' => 'low-capacity',
            ]),
            Server::factory()->create([
                'organization_id' => $this->organization->id,
                'name' => 'high-capacity',
            ]),
        ]);

        // Create metrics showing high-capacity server is better
        ServerResourceMetric::factory()->create([
            'server_id' => $servers[0]->id,
            'cpu_usage' => 90.0, // High load
            'memory_usage' => 85.0,
        ]);

        ServerResourceMetric::factory()->create([
            'server_id' => $servers[1]->id,
            'cpu_usage' => 20.0, // Low load
            'memory_usage' => 30.0,
        ]);

        $selected = $this->service->selectOptimalServer($servers, [
            'cpu_cores' => 2,
            'memory_mb' => 2048,
        ]);

        expect($selected->name)->toBe('high-capacity');
    });

    it('returns null when no suitable server found', function () {
        $servers = collect([
            Server::factory()->create([
                'organization_id' => $this->organization->id,
            ]),
        ]);

        // Create metrics showing server is overloaded
        ServerResourceMetric::factory()->create([
            'server_id' => $servers[0]->id,
            'cpu_usage' => 98.0,
            'memory_usage' => 95.0,
            'disk_usage' => 90.0,
        ]);

        $selected = $this->service->selectOptimalServer($servers, [
            'cpu_cores' => 4,
            'memory_mb' => 8192,
        ]);

        expect($selected)->toBeNull();
    });

    it('calculates server capacity score correctly', function () {
        $server = Server::factory()->create([
            'organization_id' => $this->organization->id,
        ]);

        ServerResourceMetric::factory()->create([
            'server_id' => $server->id,
            'cpu_usage' => 50.0,
            'memory_usage' => 60.0,
            'disk_usage' => 40.0,
            'network_usage' => 30.0,
        ]);

        $score = $this->service->calculateCapacityScore($server);

        expect($score)
            ->toBeGreaterThan(0)
            ->toBeLessThanOrEqual(100);
    });

    it('weights CPU at 30% in scoring algorithm', function () {
        $server = Server::factory()->create();

        // High CPU, low everything else
        ServerResourceMetric::factory()->create([
            'server_id' => $server->id,
            'cpu_usage' => 90.0,
            'memory_usage' => 10.0,
            'disk_usage' => 10.0,
            'network_usage' => 10.0,
        ]);

        $score = $this->service->calculateCapacityScore($server);

        // Score should be significantly impacted by high CPU
        expect($score)->toBeLessThan(50);
    });

    it('excludes offline servers from selection', function () {
        $servers = collect([
            Server::factory()->create(['status' => 'offline']),
            Server::factory()->create(['status' => 'online']),
        ]);

        $selected = $this->service->selectOptimalServer($servers, []);

        expect($selected->status)->toBe('online');
    });

    it('excludes servers without recent metrics', function () {
        $servers = collect([
            Server::factory()->create(['name' => 'stale-metrics']),
            Server::factory()->create(['name' => 'fresh-metrics']),
        ]);

        // Old metrics (>5 minutes)
        ServerResourceMetric::factory()->create([
            'server_id' => $servers[0]->id,
            'created_at' => now()->subMinutes(10),
        ]);

        // Fresh metrics
        ServerResourceMetric::factory()->create([
            'server_id' => $servers[1]->id,
            'created_at' => now(),
        ]);

        $selected = $this->service->selectOptimalServer($servers, []);

        expect($selected->name)->toBe('fresh-metrics');
    });
});

describe('Build Queue Optimization', function () {
    it('distributes builds across available servers', function () {
        $servers = Server::factory(3)->create([
            'organization_id' => $this->organization->id,
        ]);

        foreach ($servers as $server) {
            ServerResourceMetric::factory()->create([
                'server_id' => $server->id,
                'cpu_usage' => 30.0,
            ]);
        }

        $assignments = $this->service->optimizeBuildQueue($servers, 10);

        // Builds should be distributed
        expect($assignments)->toHaveCount(3);
        expect(array_sum($assignments))->toBe(10);
    });

    it('assigns more builds to higher-capacity servers', function () {
        $lowCapacity = Server::factory()->create();
        $highCapacity = Server::factory()->create();

        ServerResourceMetric::factory()->create([
            'server_id' => $lowCapacity->id,
            'cpu_usage' => 70.0,
        ]);

        ServerResourceMetric::factory()->create([
            'server_id' => $highCapacity->id,
            'cpu_usage' => 20.0,
        ]);

        $assignments = $this->service->optimizeBuildQueue(
            collect([$lowCapacity, $highCapacity]),
            10
        );

        expect($assignments[$highCapacity->id])->toBeGreaterThan($assignments[$lowCapacity->id]);
    });
});

describe('Resource Reservation', function () {
    it('reserves resources during deployment', function () {
        $server = Server::factory()->create();

        $this->service->reserveResources($server, [
            'cpu_cores' => 2,
            'memory_mb' => 2048,
        ]);

        // Verify reservation was stored
        $reservation = $server->resourceReservations()->latest()->first();

        expect($reservation)
            ->cpu_cores->toBe(2)
            ->memory_mb->toBe(2048);
    });

    it('releases resources after deployment completes', function () {
        $server = Server::factory()->create();

        $reservation = $this->service->reserveResources($server, [
            'cpu_cores' => 2,
            'memory_mb' => 2048,
        ]);

        $this->service->releaseResources($reservation);

        expect($server->resourceReservations()->active()->count())->toBe(0);
    });

    it('prevents over-allocation of resources', function () {
        $server = Server::factory()->create();

        // Reserve most of the server capacity
        $this->service->reserveResources($server, [
            'cpu_cores' => 6,
            'memory_mb' => 14336, // 14GB
        ]);

        $canAllocate = $this->service->canAllocateResources($server, [
            'cpu_cores' => 4,
            'memory_mb' => 4096,
        ]);

        expect($canAllocate)->toBeFalse();
    });
});

describe('Capacity Forecasting', function () {
    it('forecasts future capacity based on trends', function () {
        $server = Server::factory()->create();

        // Create increasing resource usage trend
        foreach (range(1, 10) as $i) {
            ServerResourceMetric::factory()->create([
                'server_id' => $server->id,
                'cpu_usage' => 50.0 + ($i * 2), // Increasing
                'created_at' => now()->subMinutes(10 - $i),
            ]);
        }

        $forecast = $this->service->forecastCapacity($server, hours: 24);

        expect($forecast['cpu_usage'])->toBeGreaterThan(70.0);
        expect($forecast['will_exceed_threshold'])->toBeTrue();
    });

    it('predicts capacity exhaustion time', function () {
        $server = Server::factory()->create();

        // Rapidly increasing usage
        foreach (range(1, 5) as $i) {
            ServerResourceMetric::factory()->create([
                'server_id' => $server->id,
                'cpu_usage' => 30.0 + ($i * 15),
                'created_at' => now()->subHours(5 - $i),
            ]);
        }

        $exhaustionTime = $this->service->predictExhaustion($server);

        expect($exhaustionTime)->toBeInstanceOf(\Carbon\Carbon::class);
        expect($exhaustionTime->isFuture())->toBeTrue();
    });
});

describe('Error Handling', function () {
    it('handles servers with no metrics gracefully', function () {
        $server = Server::factory()->create();

        $score = $this->service->calculateCapacityScore($server);

        expect($score)->toBe(0);
    });

    it('handles empty server collection', function () {
        $selected = $this->service->selectOptimalServer(collect([]), []);

        expect($selected)->toBeNull();
    });

    it('validates resource requirements', function () {
        expect(fn () => $this->service->selectOptimalServer(collect([]), [
            'cpu_cores' => -1, // Invalid
        ]))->toThrow(\InvalidArgumentException::class);
    });
});

describe('Performance', function () {
    it('selects from 1000 servers in under 1 second', function () {
        $servers = Server::factory(1000)->create([
            'organization_id' => $this->organization->id,
        ]);

        // Create metrics for all servers
        $servers->each(function ($server) {
            ServerResourceMetric::factory()->create([
                'server_id' => $server->id,
                'cpu_usage' => rand(10, 90),
            ]);
        });

        $start = microtime(true);
        $this->service->selectOptimalServer($servers, []);
        $duration = microtime(true) - $start;

        expect($duration)->toBeLessThan(1);
    });
});
```

### PaymentService Unit Tests

**File:** `tests/Unit/Services/Enterprise/PaymentServiceTest.php`

```php
<?php

use App\Services\Enterprise\PaymentService;
use App\Models\Organization;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use Tests\Traits\PaymentTestingTrait;
use Tests\Traits\OrganizationTestingTrait;

uses(PaymentTestingTrait::class, OrganizationTestingTrait::class);

beforeEach(function () {
    $this->service = app(PaymentService::class);
    $this->organization = $this->createOrganization();

    $this->mockStripeGateway();
    $this->mockPayPalGateway();
});

describe('Payment Processing', function () {
    it('processes credit card payment via Stripe', function () {
        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => 9900, // $99.00
            'currency' => 'USD',
            'description' => 'Monthly subscription',
        ]);

        expect($transaction)
            ->toBeInstanceOf(PaymentTransaction::class)
            ->status->toBe('completed')
            ->amount->toBe(9900)
            ->gateway->toBe('stripe');
    });

    it('processes PayPal payment successfully', function () {
        $paymentMethod = PaymentMethod::factory()->paypal()->create([
            'organization_id' => $this->organization->id,
        ]);

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => 14900,
            'currency' => 'USD',
        ]);

        expect($transaction->gateway)->toBe('paypal');
        expect($transaction->status)->toBe('completed');
    });

    it('handles payment failures gracefully', function () {
        $this->mockFailedStripePayment();

        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => 9900,
            'currency' => 'USD',
        ]);

        expect($transaction->status)->toBe('failed');
        expect($transaction->error_message)->toContain('insufficient funds');
    });

    it('retries failed payments automatically', function () {
        $attempts = 0;

        $this->mockStripeGatewayWithRetry(function () use (&$attempts) {
            $attempts++;
            return $attempts === 3; // Succeed on 3rd attempt
        });

        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => 9900,
            'currency' => 'USD',
        ]);

        expect($attempts)->toBe(3);
        expect($transaction->status)->toBe('completed');
    });

    it('validates payment amount', function () {
        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        expect(fn () => $this->service->processPayment($paymentMethod, [
            'amount' => -100, // Invalid negative amount
            'currency' => 'USD',
        ]))->toThrow(\InvalidArgumentException::class);
    });

    it('supports multiple currencies', function (string $currency, int $amount) {
        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => $amount,
            'currency' => $currency,
        ]);

        expect($transaction->currency)->toBe($currency);
        expect($transaction->amount)->toBe($amount);
    })->with([
        ['USD', 9900],
        ['EUR', 8900],
        ['GBP', 7900],
        ['JPY', 990000], // Yen has no decimals
    ]);
});

describe('Refund Processing', function () {
    it('processes full refund successfully', function () {
        $originalTransaction = PaymentTransaction::factory()->completed()->create([
            'organization_id' => $this->organization->id,
            'amount' => 9900,
            'gateway' => 'stripe',
        ]);

        $refund = $this->service->refundPayment($originalTransaction, 9900);

        expect($refund)
            ->status->toBe('refunded')
            ->refunded_amount->toBe(9900);
    });

    it('processes partial refund', function () {
        $originalTransaction = PaymentTransaction::factory()->completed()->create([
            'organization_id' => $this->organization->id,
            'amount' => 9900,
        ]);

        $refund = $this->service->refundPayment($originalTransaction, 5000);

        expect($refund->refunded_amount)->toBe(5000);
        expect($originalTransaction->refresh()->status)->toBe('partially_refunded');
    });

    it('prevents refund exceeding original amount', function () {
        $transaction = PaymentTransaction::factory()->completed()->create([
            'amount' => 9900,
        ]);

        expect(fn () => $this->service->refundPayment($transaction, 15000))
            ->toThrow(\Exception::class, 'Refund amount exceeds');
    });
});

describe('Subscription Management', function () {
    it('creates subscription successfully', function () {
        $paymentMethod = PaymentMethod::factory()->stripe()->create([
            'organization_id' => $this->organization->id,
        ]);

        $subscription = $this->service->createSubscription([
            'organization_id' => $this->organization->id,
            'payment_method_id' => $paymentMethod->id,
            'plan' => 'pro',
            'billing_cycle' => 'monthly',
        ]);

        expect($subscription)
            ->status->toBe('active')
            ->plan->toBe('pro')
            ->billing_cycle->toBe('monthly');
    });

    it('calculates next billing date correctly', function () {
        $paymentMethod = PaymentMethod::factory()->create([
            'organization_id' => $this->organization->id,
        ]);

        $subscription = $this->service->createSubscription([
            'organization_id' => $this->organization->id,
            'payment_method_id' => $paymentMethod->id,
            'plan' => 'pro',
            'billing_cycle' => 'monthly',
        ]);

        expect($subscription->next_billing_date->isNextMonth())->toBeTrue();
    });

    it('pauses subscription', function () {
        $subscription = OrganizationSubscription::factory()->active()->create([
            'organization_id' => $this->organization->id,
        ]);

        $this->service->pauseSubscription($subscription);

        expect($subscription->refresh()->status)->toBe('paused');
    });

    it('cancels subscription with end-of-period option', function () {
        $subscription = OrganizationSubscription::factory()->active()->create([
            'organization_id' => $this->organization->id,
            'next_billing_date' => now()->addMonth(),
        ]);

        $this->service->cancelSubscription($subscription, atPeriodEnd: true);

        expect($subscription->refresh())
            ->status->toBe('cancelling')
            ->cancels_at->not->toBeNull();
    });
});

describe('Webhook Processing', function () {
    it('processes Stripe webhook successfully', function () {
        $webhookPayload = $this->generateStripeWebhook('payment_intent.succeeded', [
            'id' => 'pi_test123',
            'amount' => 9900,
        ]);

        $result = $this->service->processWebhook('stripe', $webhookPayload);

        expect($result)->toBeTrue();
    });

    it('validates webhook signature', function () {
        $webhookPayload = $this->generateStripeWebhook('payment_intent.succeeded');
        $webhookPayload['signature'] = 'invalid_signature';

        expect(fn () => $this->service->processWebhook('stripe', $webhookPayload))
            ->toThrow(\Exception::class, 'Invalid webhook signature');
    });

    it('handles subscription renewal webhook', function () {
        $subscription = OrganizationSubscription::factory()->active()->create([
            'organization_id' => $this->organization->id,
            'gateway_subscription_id' => 'sub_test123',
        ]);

        $webhookPayload = $this->generateStripeWebhook('invoice.payment_succeeded', [
            'subscription' => 'sub_test123',
            'amount_paid' => 9900,
        ]);

        $this->service->processWebhook('stripe', $webhookPayload);

        $subscription->refresh();
        expect($subscription->next_billing_date->isFuture())->toBeTrue();
    });

    it('processes PayPal webhook', function () {
        $webhookPayload = $this->generatePayPalWebhook('PAYMENT.SALE.COMPLETED', [
            'id' => 'PAYID-TEST123',
            'amount' => ['total' => '99.00'],
        ]);

        $result = $this->service->processWebhook('paypal', $webhookPayload);

        expect($result)->toBeTrue();
    });
});

describe('Error Handling', function () {
    it('logs failed payments with context', function () {
        Log::shouldReceive('error')
            ->once()
            ->with('Payment processing failed', Mockery::type('array'));

        $this->mockFailedStripePayment();

        $paymentMethod = PaymentMethod::factory()->stripe()->create();

        $this->service->processPayment($paymentMethod, [
            'amount' => 9900,
            'currency' => 'USD',
        ]);
    });

    it('handles gateway timeout gracefully', function () {
        $this->mockStripeTimeout();

        $paymentMethod = PaymentMethod::factory()->stripe()->create();

        $transaction = $this->service->processPayment($paymentMethod, [
            'amount' => 9900,
            'currency' => 'USD',
        ]);

        expect($transaction->status)->toBe('pending');
    });

    it('handles concurrent payment processing', function () {
        $paymentMethod = PaymentMethod::factory()->stripe()->create();

        // Simulate 10 concurrent payments
        $transactions = [];

        for ($i = 0; $i < 10; $i++) {
            $transactions[] = $this->service->processPayment($paymentMethod, [
                'amount' => 9900,
                'currency' => 'USD',
            ]);
        }

        expect($transactions)->toHaveCount(10);
        expect(collect($transactions)->pluck('status')->unique())->toContain('completed');
    });
});

describe('Performance', function () {
    it('processes payment in under 3 seconds', function () {
        $paymentMethod = PaymentMethod::factory()->stripe()->create();

        $start = microtime(true);

        $this->service->processPayment($paymentMethod, [
            'amount' => 9900,
            'currency' => 'USD',
        ]);

        $duration = microtime(true) - $start;

        expect($duration)->toBeLessThan(3);
    });
});
```

## Implementation Approach

### Step 1: Set Up Testing Infrastructure
1. Configure PHPUnit with coverage reporting
2. Configure Pest with parallel execution
3. Create base test traits (Tasks 72-75)
4. Set up mock helpers for external services

### Step 2: Implement White-Label Service Tests
1. Create WhiteLabelServiceTest.php
2. Write CSS generation tests (40+ tests)
3. Write branding configuration tests
4. Write email variable tests
5. Write favicon management tests
6. Write cache invalidation tests
7. Write performance tests

### Step 3: Implement Infrastructure Service Tests
1. Create TerraformServiceTest.php (50+ tests)
2. Create TerraformStateManagerTest.php (35+ tests)
3. Create CloudProviderAdapterTest.php (20+ tests per provider)
4. Mock Terraform binary execution
5. Test all provisioning workflows
6. Test state encryption and backup

### Step 4: Implement Resource Management Tests
1. Create CapacityManagerTest.php (40+ tests)
2. Create SystemResourceMonitorTest.php (30+ tests)
3. Test server selection algorithms
4. Test resource reservation logic
5. Test capacity forecasting
6. Test concurrent operations

### Step 5: Implement Payment Service Tests
1. Create PaymentServiceTest.php (45+ tests)
2. Create SubscriptionManagerTest.php (35+ tests)
3. Mock Stripe and PayPal gateways
4. Test payment processing workflows
5. Test refund logic
6. Test webhook handling with signature validation

### Step 6: Implement Domain Service Tests
1. Create DomainRegistrarServiceTest.php (40+ tests)
2. Create DnsManagementServiceTest.php (30+ tests)
3. Mock domain registrar APIs
4. Test DNS record management
5. Test SSL certificate provisioning

### Step 7: Implement Deployment Service Tests
1. Create EnhancedDeploymentServiceTest.php (45+ tests)
2. Create DeploymentStrategyFactoryTest.php (20+ tests)
3. Test rolling update strategy
4. Test blue-green deployment
5. Test canary deployment
6. Test automatic rollback

### Step 8: Code Coverage Analysis
1. Generate coverage reports
2. Identify untested code paths
3. Write additional tests for gaps
4. Achieve >90% line coverage target

### Step 9: Performance Testing
1. Add performance assertions to critical tests
2. Test concurrent execution safety
3. Test memory usage for large datasets
4. Optimize slow tests

### Step 10: CI/CD Integration
1. Configure GitHub Actions workflow
2. Add coverage reporting to CI
3. Add PHPStan to CI pipeline
4. Set up quality gate thresholds

## Test Strategy

### Unit Test Categories

1. **Happy Path Tests** - Verify correct behavior under normal conditions
2. **Error Path Tests** - Verify graceful error handling
3. **Edge Case Tests** - Verify boundary conditions
4. **Performance Tests** - Verify execution time requirements
5. **Concurrency Tests** - Verify thread safety
6. **Mock Integration Tests** - Verify external service integration

### Test Data Management

**Factories:**
- Use Laravel factories for all models
- Create specialized states for common scenarios
- Use sequences for unique values

**Datasets:**
- Use Pest datasets for parameterized tests
- Define datasets at file level for reusability

**Mocking:**
- Mock external HTTP APIs (Stripe, PayPal, cloud providers)
- Mock Terraform binary execution
- Mock file system operations where appropriate

### Coverage Targets

- **Overall Line Coverage:** >90%
- **Critical Services:** 95%+ coverage
- **Error Handling:** 100% coverage of catch blocks
- **Public Methods:** 100% coverage

### Test Execution Performance

- **Total Suite Execution:** <60 seconds
- **Individual Test:** <500ms
- **Parallel Execution:** 8 workers
- **Database Refresh:** Use RefreshDatabase trait

## Definition of Done

- [ ] WhiteLabelServiceTest.php complete (40+ tests)
- [ ] BrandingCacheServiceTest.php complete (25+ tests)
- [ ] FaviconGeneratorServiceTest.php complete (30+ tests)
- [ ] TerraformServiceTest.php complete (50+ tests)
- [ ] TerraformStateManagerTest.php complete (35+ tests)
- [ ] CloudProviderAdapterTest.php complete (60+ tests total)
- [ ] CapacityManagerTest.php complete (40+ tests)
- [ ] SystemResourceMonitorTest.php complete (30+ tests)
- [ ] PaymentServiceTest.php complete (45+ tests)
- [ ] SubscriptionManagerTest.php complete (35+ tests)
- [ ] DomainRegistrarServiceTest.php complete (40+ tests)
- [ ] DnsManagementServiceTest.php complete (30+ tests)
- [ ] EnhancedDeploymentServiceTest.php complete (45+ tests)
- [ ] DeploymentStrategyFactoryTest.php complete (20+ tests)
- [ ] All tests use Pest PHP syntax
- [ ] All tests use appropriate testing traits
- [ ] All external dependencies mocked
- [ ] Code coverage >90% overall
- [ ] Critical services >95% coverage
- [ ] All edge cases tested
- [ ] All error paths tested
- [ ] Performance assertions passing
- [ ] Concurrency tests passing
- [ ] Tests execute in <60 seconds
- [ ] No database state leakage
- [ ] PHPStan level 5 passing on test files
- [ ] Laravel Pint formatting applied
- [ ] Coverage report generated
- [ ] CI/CD pipeline configured
- [ ] Documentation updated with testing guidelines
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 72 (OrganizationTestingTrait)
- **Depends on:** Task 73 (LicenseTestingTrait)
- **Depends on:** Task 74 (TerraformTestingTrait)
- **Depends on:** Task 75 (PaymentTestingTrait)
- **Tests:** Tasks 2-11 (White-label services)
- **Tests:** Tasks 12-21 (Terraform infrastructure)
- **Tests:** Tasks 22-31 (Resource monitoring)
- **Tests:** Tasks 32-41 (Enhanced deployment)
- **Tests:** Tasks 42-51 (Payment processing)
- **Tests:** Tasks 52-61 (Enhanced API)
- **Tests:** Tasks 62-71 (Domain management)
- **Used by:** Task 77 (Integration tests)
- **Used by:** Task 81 (CI/CD quality gates)
