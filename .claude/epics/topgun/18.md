---
name: Build TerraformDeploymentJob for async provisioning with progress tracking
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:38:37Z
github: https://github.com/johnproblems/topgun/issues/128
depends_on: [17]
parallel: false
conflicts_with: []
---

# Task: Build TerraformDeploymentJob for async provisioning with progress tracking

## Description

Implement a Laravel queued job that executes Terraform infrastructure provisioning asynchronously with real-time progress tracking and WebSocket broadcasting. This job is the execution engine for the Terraform integration system, transforming synchronous infrastructure provisioning (which can take 5-15 minutes) into a non-blocking background operation with comprehensive status updates.

**The Async Infrastructure Challenge:**

Provisioning cloud infrastructure involves multiple slow operations:
1. **Terraform init**: Download provider plugins (~30-60 seconds)
2. **Terraform plan**: Calculate infrastructure changes (~20-40 seconds)
3. **Terraform apply**: Create cloud resources (3-10 minutes for typical deployments)
4. **Resource polling**: Wait for instances to be running (1-3 minutes)
5. **Post-provisioning**: SSH key deployment, Docker verification (30-90 seconds)

Running these operations synchronously in an HTTP request is impossible—web servers timeout after 60-120 seconds. Even with extended timeouts, blocking a web worker for 10+ minutes is wasteful and creates a poor user experience. Users must stare at loading spinners without feedback about what's happening.

**The Solution Architecture:**

TerraformDeploymentJob implements asynchronous execution with rich progress tracking:

1. **Laravel Queue Integration**: Job dispatched to dedicated 'terraform' queue with high priority
2. **Progress Tracking**: Database updates at each Terraform stage (init → plan → apply → verify)
3. **WebSocket Broadcasting**: Real-time progress updates via Laravel Reverb to frontend UI
4. **Error Recovery**: Comprehensive error handling with automatic retry logic and rollback
5. **State Management**: Integration with TerraformStateManager (Task 17) for state file handling
6. **Output Parsing**: Extract IP addresses, instance IDs, and metadata from Terraform outputs
7. **Server Registration**: Automatic triggering of server auto-registration (Task 19) on success

**Real-Time Progress Flow:**

```
User clicks "Provision" → Job dispatched → Queue worker picks up job
  ↓
Job starts → Broadcast: {status: 'initializing', progress: 0%}
  ↓
Terraform init → Broadcast: {status: 'downloading_plugins', progress: 20%}
  ↓
Terraform plan → Broadcast: {status: 'planning', progress: 40%, changes: {add: 5, change: 0, destroy: 0}}
  ↓
Terraform apply → Broadcast: {status: 'provisioning', progress: 60%}
  ↓ (poll every 10s)
Resources creating → Broadcast: {status: 'creating_resources', progress: 80%, created: 3, remaining: 2}
  ↓
Success → Broadcast: {status: 'completed', progress: 100%, outputs: {...}}
  ↓
Server registration job dispatched
```

**Integration Architecture:**

**Depends On:**
- **Task 14 (TerraformService)**: Executes terraform commands via service layer
- **Task 17 (TerraformStateManager)**: Manages state file encryption, storage, backup
- **Task 12 (Database Schema)**: Reads cloud_provider_credentials, writes to terraform_deployments

**Triggers:**
- **Task 19 (Server Auto-Registration)**: Dispatched on successful provisioning
- **WebSocket Broadcasting**: Real-time UI updates via Laravel Reverb channels

**Why This Task is Critical:**

Infrastructure provisioning is inherently slow—there's no way to make AWS spin up an EC2 instance in under 60 seconds. But we can make it *feel* fast by:
1. **Non-blocking**: User can continue working while provisioning happens
2. **Transparent**: Clear progress updates show exactly what's happening
3. **Reliable**: Automatic retries and rollback prevent partial failures
4. **Observable**: Complete logs and status tracking for debugging

Without async execution, infrastructure provisioning would be unusable in production. This job transforms a 10-minute blocking operation into a background task with real-time feedback that users can monitor or ignore.

## Acceptance Criteria

- [ ] Job implements ShouldQueue interface for Laravel queue system
- [ ] Dispatches to dedicated 'terraform' queue with appropriate priority
- [ ] Executes Terraform workflow: init → plan → apply
- [ ] Updates terraform_deployments.status at each stage (initializing, planning, applying, completed, failed)
- [ ] Broadcasts progress via WebSocket to organization-specific channel
- [ ] Integrates with TerraformStateManager for state file operations
- [ ] Parses Terraform output to extract resource metadata (IP addresses, instance IDs)
- [ ] Stores structured outputs in terraform_deployments.output_data JSONB column
- [ ] Implements comprehensive error handling with descriptive error messages
- [ ] Supports automatic retry logic (3 attempts with exponential backoff)
- [ ] Executes rollback (terraform destroy) on fatal errors if requested
- [ ] Dispatches ServerRegistrationJob (Task 19) on successful completion
- [ ] Logs all Terraform command output to database and Laravel logs
- [ ] Implements timeout protection (30 minutes max execution time)
- [ ] Supports manual job cancellation with graceful cleanup
- [ ] Updates organization resource usage quotas after provisioning
- [ ] Horizon tags for filtering and monitoring

## Technical Details

### File Paths

**Job:**
- `/home/topgun/topgun/app/Jobs/Enterprise/TerraformDeploymentJob.php` (new)

**Events:**
- `/home/topgun/topgun/app/Events/Enterprise/TerraformProvisioningProgress.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/TerraformProvisioningCompleted.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/TerraformProvisioningFailed.php` (new)

**Artisan Command:**
- `/home/topgun/topgun/app/Console/Commands/TerraformProvision.php` (new - for manual/CLI provisioning)

**Configuration:**
- `/home/topgun/topgun/config/terraform.php` (enhance existing)

### Database Schema (Existing - Task 12)

The job updates the existing `terraform_deployments` table:

```php
// Fields written by TerraformDeploymentJob
'status' => 'initializing|planning|applying|completed|failed|cancelled'
'progress_percentage' => 0-100
'current_stage' => 'init|plan|apply|verify|cleanup'
'output_data' => JSONB // Parsed Terraform outputs
'error_message' => TEXT // Error details if failed
'execution_log' => TEXT // Full Terraform output
'started_at' => TIMESTAMP
'completed_at' => TIMESTAMP
'retry_count' => INTEGER
```

### TerraformDeploymentJob Implementation

**File:** `app/Jobs/Enterprise/TerraformDeploymentJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\TerraformServiceInterface;
use App\Contracts\TerraformStateManagerInterface;
use App\Events\Enterprise\TerraformProvisioningCompleted;
use App\Events\Enterprise\TerraformProvisioningFailed;
use App\Events\Enterprise\TerraformProvisioningProgress;
use App\Models\TerraformDeployment;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class TerraformDeploymentJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $timeout = 1800; // 30 minutes
    public int $backoff = 60; // Wait 60 seconds before retry

    /**
     * Create a new job instance
     *
     * @param int $deploymentId
     * @param bool $autoRollbackOnFailure
     */
    public function __construct(
        public int $deploymentId,
        public bool $autoRollbackOnFailure = false
    ) {
        $this->onQueue('terraform');
    }

    /**
     * Execute the job
     *
     * @param TerraformServiceInterface $terraformService
     * @param TerraformStateManagerInterface $stateManager
     * @return void
     * @throws \Exception
     */
    public function handle(
        TerraformServiceInterface $terraformService,
        TerraformStateManagerInterface $stateManager
    ): void {
        $deployment = TerraformDeployment::with(['organization', 'cloudProviderCredential'])
            ->findOrFail($this->deploymentId);

        Log::info('Starting Terraform deployment', [
            'deployment_id' => $deployment->id,
            'organization_id' => $deployment->organization_id,
            'provider' => $deployment->cloud_provider,
            'attempt' => $this->attempts(),
        ]);

        try {
            $this->updateStatus($deployment, 'initializing', 0, 'init');
            $this->broadcastProgress($deployment, 'Initializing Terraform workspace', 0);

            // Stage 1: Terraform init
            $this->executeInit($deployment, $terraformService);

            // Stage 2: Terraform plan
            $planResult = $this->executePlan($deployment, $terraformService);

            // Stage 3: Terraform apply
            $this->executeApply($deployment, $terraformService, $stateManager);

            // Stage 4: Parse and store outputs
            $this->parseOutputs($deployment, $terraformService);

            // Stage 5: Mark complete and trigger server registration
            $this->completeDeployment($deployment);

        } catch (Throwable $e) {
            $this->handleFailure($deployment, $e, $terraformService);
            throw $e; // Re-throw for retry logic
        }
    }

    /**
     * Execute terraform init
     *
     * @param TerraformDeployment $deployment
     * @param TerraformServiceInterface $terraformService
     * @return void
     * @throws \Exception
     */
    private function executeInit(
        TerraformDeployment $deployment,
        TerraformServiceInterface $terraformService
    ): void {
        $this->updateStatus($deployment, 'initializing', 10, 'init');
        $this->broadcastProgress($deployment, 'Downloading Terraform providers', 10);

        $initOutput = $terraformService->init($deployment);

        $this->appendLog($deployment, "=== TERRAFORM INIT ===\n{$initOutput}\n");

        Log::info('Terraform init completed', [
            'deployment_id' => $deployment->id,
        ]);

        $this->updateStatus($deployment, 'planning', 20, 'init');
    }

    /**
     * Execute terraform plan
     *
     * @param TerraformDeployment $deployment
     * @param TerraformServiceInterface $terraformService
     * @return array Plan summary
     * @throws \Exception
     */
    private function executePlan(
        TerraformDeployment $deployment,
        TerraformServiceInterface $terraformService
    ): array {
        $this->updateStatus($deployment, 'planning', 30, 'plan');
        $this->broadcastProgress($deployment, 'Planning infrastructure changes', 30);

        $planOutput = $terraformService->plan($deployment);

        $this->appendLog($deployment, "=== TERRAFORM PLAN ===\n{$planOutput}\n");

        // Parse plan output for resource counts
        $planSummary = $this->parsePlanOutput($planOutput);

        $this->broadcastProgress($deployment, sprintf(
            'Plan complete: +%d to add, ~%d to change, -%d to destroy',
            $planSummary['add'],
            $planSummary['change'],
            $planSummary['destroy']
        ), 40, $planSummary);

        Log::info('Terraform plan completed', [
            'deployment_id' => $deployment->id,
            'resources_to_add' => $planSummary['add'],
            'resources_to_change' => $planSummary['change'],
            'resources_to_destroy' => $planSummary['destroy'],
        ]);

        $this->updateStatus($deployment, 'applying', 50, 'plan');

        return $planSummary;
    }

    /**
     * Execute terraform apply
     *
     * @param TerraformDeployment $deployment
     * @param TerraformServiceInterface $terraformService
     * @param TerraformStateManagerInterface $stateManager
     * @return void
     * @throws \Exception
     */
    private function executeApply(
        TerraformDeployment $deployment,
        TerraformServiceInterface $terraformService,
        TerraformStateManagerInterface $stateManager
    ): void {
        $this->updateStatus($deployment, 'applying', 60, 'apply');
        $this->broadcastProgress($deployment, 'Provisioning cloud infrastructure', 60);

        $applyOutput = $terraformService->apply($deployment);

        $this->appendLog($deployment, "=== TERRAFORM APPLY ===\n{$applyOutput}\n");

        // Get state file from Terraform working directory and save it
        $stateFilePath = $terraformService->getStateFilePath($deployment);
        if (file_exists($stateFilePath)) {
            $stateContent = file_get_contents($stateFilePath);
            $stateManager->saveState($deployment, $stateContent, 'Applied infrastructure');

            Log::info('Terraform state saved', [
                'deployment_id' => $deployment->id,
                'state_version' => $deployment->state_version + 1,
            ]);
        }

        $this->updateStatus($deployment, 'verifying', 80, 'apply');
        $this->broadcastProgress($deployment, 'Verifying created resources', 80);

        Log::info('Terraform apply completed', [
            'deployment_id' => $deployment->id,
        ]);
    }

    /**
     * Parse and store Terraform outputs
     *
     * @param TerraformDeployment $deployment
     * @param TerraformServiceInterface $terraformService
     * @return void
     */
    private function parseOutputs(
        TerraformDeployment $deployment,
        TerraformServiceInterface $terraformService
    ): void {
        $this->updateStatus($deployment, 'verifying', 90, 'verify');
        $this->broadcastProgress($deployment, 'Extracting infrastructure metadata', 90);

        try {
            $outputs = $terraformService->getOutputs($deployment);

            $deployment->update([
                'output_data' => $outputs,
            ]);

            Log::info('Terraform outputs parsed', [
                'deployment_id' => $deployment->id,
                'output_keys' => array_keys($outputs),
            ]);
        } catch (\Exception $e) {
            Log::warning('Failed to parse Terraform outputs', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            // Non-fatal - continue with deployment
            $deployment->update([
                'output_data' => ['error' => 'Failed to parse outputs: ' . $e->getMessage()],
            ]);
        }
    }

    /**
     * Mark deployment as complete and trigger server registration
     *
     * @param TerraformDeployment $deployment
     * @return void
     */
    private function completeDeployment(TerraformDeployment $deployment): void
    {
        $deployment->update([
            'status' => 'completed',
            'progress_percentage' => 100,
            'current_stage' => 'completed',
            'completed_at' => now(),
        ]);

        $this->broadcastProgress($deployment, 'Infrastructure provisioning complete', 100);

        // Broadcast completion event
        broadcast(new TerraformProvisioningCompleted($deployment))->toOthers();

        Log::info('Terraform deployment completed successfully', [
            'deployment_id' => $deployment->id,
            'duration_seconds' => now()->diffInSeconds($deployment->started_at),
        ]);

        // Dispatch server auto-registration job (Task 19)
        if ($deployment->auto_register_server) {
            ServerRegistrationJob::dispatch($deployment->id)
                ->delay(now()->addSeconds(10)); // Small delay to ensure outputs are accessible
        }
    }

    /**
     * Handle deployment failure
     *
     * @param TerraformDeployment $deployment
     * @param Throwable $exception
     * @param TerraformServiceInterface $terraformService
     * @return void
     */
    private function handleFailure(
        TerraformDeployment $deployment,
        Throwable $exception,
        TerraformServiceInterface $terraformService
    ): void {
        $errorMessage = sprintf(
            "%s in %s:%d\n%s",
            $exception->getMessage(),
            $exception->getFile(),
            $exception->getLine(),
            $exception->getTraceAsString()
        );

        $deployment->update([
            'status' => 'failed',
            'current_stage' => 'failed',
            'error_message' => $errorMessage,
            'completed_at' => now(),
            'retry_count' => $this->attempts(),
        ]);

        $this->appendLog($deployment, "\n=== ERROR ===\n{$errorMessage}\n");

        // Broadcast failure event
        broadcast(new TerraformProvisioningFailed($deployment, $exception->getMessage()))
            ->toOthers();

        Log::error('Terraform deployment failed', [
            'deployment_id' => $deployment->id,
            'attempt' => $this->attempts(),
            'error' => $exception->getMessage(),
            'trace' => $exception->getTraceAsString(),
        ]);

        // Auto-rollback if configured and this is the final attempt
        if ($this->autoRollbackOnFailure && $this->attempts() >= $this->tries) {
            $this->executeRollback($deployment, $terraformService);
        }
    }

    /**
     * Execute terraform destroy to rollback failed deployment
     *
     * @param TerraformDeployment $deployment
     * @param TerraformServiceInterface $terraformService
     * @return void
     */
    private function executeRollback(
        TerraformDeployment $deployment,
        TerraformServiceInterface $terraformService
    ): void {
        Log::warning('Executing automatic rollback', [
            'deployment_id' => $deployment->id,
        ]);

        try {
            $deployment->update([
                'status' => 'rolling_back',
                'current_stage' => 'rollback',
            ]);

            $this->broadcastProgress($deployment, 'Rolling back failed deployment', 0);

            $destroyOutput = $terraformService->destroy($deployment);

            $this->appendLog($deployment, "\n=== TERRAFORM DESTROY (ROLLBACK) ===\n{$destroyOutput}\n");

            $deployment->update([
                'status' => 'rolled_back',
                'current_stage' => 'rolled_back',
            ]);

            Log::info('Rollback completed successfully', [
                'deployment_id' => $deployment->id,
            ]);
        } catch (\Exception $e) {
            Log::error('Rollback failed', [
                'deployment_id' => $deployment->id,
                'error' => $e->getMessage(),
            ]);

            $deployment->update([
                'error_message' => $deployment->error_message . "\n\nRollback also failed: " . $e->getMessage(),
            ]);
        }
    }

    /**
     * Parse terraform plan output for resource counts
     *
     * @param string $output
     * @return array
     */
    private function parsePlanOutput(string $output): array
    {
        $summary = [
            'add' => 0,
            'change' => 0,
            'destroy' => 0,
        ];

        // Parse "Plan: X to add, Y to change, Z to destroy" line
        if (preg_match('/Plan:\s*(\d+)\s*to\s*add,\s*(\d+)\s*to\s*change,\s*(\d+)\s*to\s*destroy/', $output, $matches)) {
            $summary['add'] = (int) $matches[1];
            $summary['change'] = (int) $matches[2];
            $summary['destroy'] = (int) $matches[3];
        }

        return $summary;
    }

    /**
     * Update deployment status and progress
     *
     * @param TerraformDeployment $deployment
     * @param string $status
     * @param int $progress
     * @param string $stage
     * @return void
     */
    private function updateStatus(
        TerraformDeployment $deployment,
        string $status,
        int $progress,
        string $stage
    ): void {
        $deployment->update([
            'status' => $status,
            'progress_percentage' => $progress,
            'current_stage' => $stage,
            'started_at' => $deployment->started_at ?? now(),
        ]);
    }

    /**
     * Broadcast progress update via WebSocket
     *
     * @param TerraformDeployment $deployment
     * @param string $message
     * @param int $progress
     * @param array $metadata
     * @return void
     */
    private function broadcastProgress(
        TerraformDeployment $deployment,
        string $message,
        int $progress,
        array $metadata = []
    ): void {
        broadcast(new TerraformProvisioningProgress(
            $deployment,
            $message,
            $progress,
            $metadata
        ))->toOthers();
    }

    /**
     * Append output to execution log
     *
     * @param TerraformDeployment $deployment
     * @param string $logContent
     * @return void
     */
    private function appendLog(TerraformDeployment $deployment, string $logContent): void
    {
        $currentLog = $deployment->execution_log ?? '';
        $deployment->update([
            'execution_log' => $currentLog . $logContent,
        ]);
    }

    /**
     * Handle job failure after all retries exhausted
     *
     * @param Throwable $exception
     * @return void
     */
    public function failed(Throwable $exception): void
    {
        $deployment = TerraformDeployment::find($this->deploymentId);

        if ($deployment) {
            $deployment->update([
                'status' => 'failed',
                'current_stage' => 'failed',
                'completed_at' => now(),
            ]);

            Log::error('Terraform deployment job failed permanently', [
                'deployment_id' => $deployment->id,
                'attempts' => $this->tries,
                'error' => $exception->getMessage(),
            ]);
        }
    }

    /**
     * Get Horizon tags for filtering
     *
     * @return array<int, string>
     */
    public function tags(): array
    {
        $deployment = TerraformDeployment::find($this->deploymentId);

        $tags = ['terraform', 'infrastructure'];

        if ($deployment) {
            $tags[] = "organization:{$deployment->organization_id}";
            $tags[] = "deployment:{$deployment->id}";
            $tags[] = "provider:{$deployment->cloud_provider}";
        }

        return $tags;
    }
}
```

### WebSocket Events

**File:** `app/Events/Enterprise/TerraformProvisioningProgress.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\TerraformDeployment;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class TerraformProvisioningProgress implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    /**
     * Create a new event instance
     *
     * @param TerraformDeployment $deployment
     * @param string $message
     * @param int $progress
     * @param array $metadata
     */
    public function __construct(
        public TerraformDeployment $deployment,
        public string $message,
        public int $progress,
        public array $metadata = []
    ) {}

    /**
     * Get the channels the event should broadcast on
     *
     * @return Channel
     */
    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->deployment->organization_id}.terraform");
    }

    /**
     * Get the data to broadcast
     *
     * @return array
     */
    public function broadcastWith(): array
    {
        return [
            'deployment_id' => $this->deployment->id,
            'status' => $this->deployment->status,
            'stage' => $this->deployment->current_stage,
            'progress' => $this->progress,
            'message' => $this->message,
            'metadata' => $this->metadata,
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

**File:** `app/Events/Enterprise/TerraformProvisioningCompleted.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\TerraformDeployment;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class TerraformProvisioningCompleted implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public TerraformDeployment $deployment
    ) {}

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->deployment->organization_id}.terraform");
    }

    public function broadcastWith(): array
    {
        return [
            'deployment_id' => $this->deployment->id,
            'status' => 'completed',
            'outputs' => $this->deployment->output_data,
            'duration_seconds' => now()->diffInSeconds($this->deployment->started_at),
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

**File:** `app/Events/Enterprise/TerraformProvisioningFailed.php`

```php
<?php

namespace App\Events\Enterprise;

use App\Models\TerraformDeployment;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class TerraformProvisioningFailed implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public function __construct(
        public TerraformDeployment $deployment,
        public string $errorMessage
    ) {}

    public function broadcastOn(): Channel
    {
        return new Channel("organization.{$this->deployment->organization_id}.terraform");
    }

    public function broadcastWith(): array
    {
        return [
            'deployment_id' => $this->deployment->id,
            'status' => 'failed',
            'error' => $this->errorMessage,
            'attempt' => $this->deployment->retry_count,
            'timestamp' => now()->toIso8601String(),
        ];
    }
}
```

### Artisan Command for Manual Provisioning

**File:** `app/Console/Commands/TerraformProvision.php`

```php
<?php

namespace App\Console\Commands;

use App\Jobs\Enterprise\TerraformDeploymentJob;
use App\Models\TerraformDeployment;
use Illuminate\Console\Command;

class TerraformProvision extends Command
{
    protected $signature = 'terraform:provision
                            {deployment : Deployment ID to provision}
                            {--sync : Run synchronously instead of queuing}
                            {--rollback : Auto-rollback on failure}';

    protected $description = 'Provision infrastructure via Terraform';

    public function handle(): int
    {
        $deploymentId = $this->argument('deployment');
        $sync = $this->option('sync');
        $rollback = $this->option('rollback');

        $deployment = TerraformDeployment::find($deploymentId);

        if (!$deployment) {
            $this->error("Deployment {$deploymentId} not found");
            return self::FAILURE;
        }

        $this->info("Provisioning infrastructure for deployment: {$deployment->id}");
        $this->info("Provider: {$deployment->cloud_provider}");
        $this->info("Organization: {$deployment->organization->name}");

        $job = new TerraformDeploymentJob($deployment->id, $rollback);

        if ($sync) {
            $this->warn('Running synchronously - this may take 10+ minutes...');

            try {
                $job->handle(
                    app(\App\Contracts\TerraformServiceInterface::class),
                    app(\App\Contracts\TerraformStateManagerInterface::class)
                );

                $this->info('✓ Provisioning completed successfully');
                return self::SUCCESS;
            } catch (\Exception $e) {
                $this->error("✗ Provisioning failed: {$e->getMessage()}");
                return self::FAILURE;
            }
        }

        // Queue the job
        dispatch($job);

        $this->info('✓ Provisioning job dispatched to queue');
        $this->info('Monitor progress in Horizon or via WebSocket updates');

        return self::SUCCESS;
    }
}
```

## Implementation Approach

### Step 1: Create Job Class
1. Create TerraformDeploymentJob implementing ShouldQueue
2. Configure queue name, retries, timeout, backoff
3. Add constructor with deployment ID parameter
4. Set up dependency injection for services

### Step 2: Implement Core Provisioning Flow
1. Create executeInit() method for terraform init
2. Create executePlan() method for terraform plan
3. Create executeApply() method for terraform apply
4. Create parseOutputs() method for output extraction
5. Chain methods in handle() with proper error handling

### Step 3: Add Progress Tracking
1. Create updateStatus() method for database updates
2. Implement progress percentage calculation
3. Create TerraformProvisioningProgress event
4. Broadcast progress at each stage
5. Store current_stage in database

### Step 4: Integrate State Management
1. Call TerraformStateManager after successful apply
2. Load state before destroy operations
3. Handle state locking errors gracefully
4. Store state file path in deployment record

### Step 5: Implement Error Handling
1. Create handleFailure() method
2. Store error messages and full logs
3. Create TerraformProvisioningFailed event
4. Implement automatic rollback logic
5. Configure retry behavior

### Step 6: Add Output Parsing
1. Parse Terraform JSON outputs
2. Extract IP addresses, instance IDs
3. Store structured data in output_data column
4. Handle parsing errors gracefully

### Step 7: Create WebSocket Events
1. TerraformProvisioningProgress for updates
2. TerraformProvisioningCompleted for success
3. TerraformProvisioningFailed for errors
4. Configure organization-specific channels

### Step 8: Build Artisan Command
1. Create terraform:provision command
2. Add --sync flag for immediate execution
3. Add --rollback flag for auto-rollback
4. Implement progress output for CLI

### Step 9: Integration Testing
1. Test full provisioning flow
2. Test error handling and retries
3. Test WebSocket broadcasting
4. Test state file integration
5. Test rollback functionality

### Step 10: Horizon Configuration
1. Configure 'terraform' queue with high priority
2. Set appropriate worker count
3. Add monitoring and alerting
4. Test job tagging and filtering

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Jobs/TerraformDeploymentJobTest.php`

```php
<?php

use App\Jobs\Enterprise\TerraformDeploymentJob;
use App\Models\TerraformDeployment;
use App\Services\Enterprise\TerraformService;
use App\Services\Enterprise\TerraformStateManager;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;

beforeEach(function () {
    $this->terraformService = Mockery::mock(TerraformServiceInterface::class);
    $this->stateManager = Mockery::mock(TerraformStateManagerInterface::class);
});

it('dispatches to terraform queue', function () {
    Queue::fake();

    $deployment = TerraformDeployment::factory()->create();

    TerraformDeploymentJob::dispatch($deployment->id);

    Queue::assertPushedOn('terraform', TerraformDeploymentJob::class);
});

it('executes terraform init, plan, and apply', function () {
    $deployment = TerraformDeployment::factory()->create();

    $this->terraformService->shouldReceive('init')
        ->once()
        ->with($deployment)
        ->andReturn('Terraform initialized');

    $this->terraformService->shouldReceive('plan')
        ->once()
        ->with($deployment)
        ->andReturn('Plan: 3 to add, 0 to change, 0 to destroy');

    $this->terraformService->shouldReceive('apply')
        ->once()
        ->with($deployment)
        ->andReturn('Apply complete! Resources: 3 added');

    $this->terraformService->shouldReceive('getStateFilePath')
        ->andReturn('/tmp/terraform.tfstate');

    $this->terraformService->shouldReceive('getOutputs')
        ->andReturn(['server_ip' => '1.2.3.4']);

    $this->stateManager->shouldReceive('saveState')
        ->once();

    $job = new TerraformDeploymentJob($deployment->id);
    $job->handle($this->terraformService, $this->stateManager);

    $deployment->refresh();
    expect($deployment->status)->toBe('completed');
    expect($deployment->progress_percentage)->toBe(100);
});

it('broadcasts progress events', function () {
    Event::fake([TerraformProvisioningProgress::class]);

    $deployment = TerraformDeployment::factory()->create();

    $this->terraformService->shouldReceive('init')->andReturn('');
    $this->terraformService->shouldReceive('plan')->andReturn('Plan: 1 to add');
    $this->terraformService->shouldReceive('apply')->andReturn('');
    $this->terraformService->shouldReceive('getStateFilePath')->andReturn('/tmp/state');
    $this->terraformService->shouldReceive('getOutputs')->andReturn([]);
    $this->stateManager->shouldReceive('saveState');

    $job = new TerraformDeploymentJob($deployment->id);
    $job->handle($this->terraformService, $this->stateManager);

    Event::assertDispatched(TerraformProvisioningProgress::class);
});

it('handles failures and broadcasts error events', function () {
    Event::fake([TerraformProvisioningFailed::class]);

    $deployment = TerraformDeployment::factory()->create();

    $this->terraformService->shouldReceive('init')
        ->andThrow(new \Exception('Terraform binary not found'));

    $job = new TerraformDeploymentJob($deployment->id);

    expect(fn() => $job->handle($this->terraformService, $this->stateManager))
        ->toThrow(\Exception::class);

    $deployment->refresh();
    expect($deployment->status)->toBe('failed');

    Event::assertDispatched(TerraformProvisioningFailed::class);
});

it('parses plan output correctly', function () {
    $deployment = TerraformDeployment::factory()->create();
    $job = new TerraformDeploymentJob($deployment->id);

    $planOutput = "Plan: 5 to add, 2 to change, 1 to destroy";
    $summary = invade($job)->parsePlanOutput($planOutput);

    expect($summary)->toBe([
        'add' => 5,
        'change' => 2,
        'destroy' => 1,
    ]);
});

it('saves state file after successful apply', function () {
    $deployment = TerraformDeployment::factory()->create();

    $this->terraformService->shouldReceive('init')->andReturn('');
    $this->terraformService->shouldReceive('plan')->andReturn('Plan: 1 to add');
    $this->terraformService->shouldReceive('apply')->andReturn('');

    $this->terraformService->shouldReceive('getStateFilePath')
        ->andReturn(__DIR__ . '/fixtures/terraform.tfstate');

    $this->terraformService->shouldReceive('getOutputs')->andReturn([]);

    $this->stateManager->shouldReceive('saveState')
        ->once()
        ->with($deployment, Mockery::type('string'), 'Applied infrastructure');

    $job = new TerraformDeploymentJob($deployment->id);
    $job->handle($this->terraformService, $this->stateManager);
});

it('has correct Horizon tags', function () {
    $deployment = TerraformDeployment::factory()->create([
        'cloud_provider' => 'aws',
    ]);

    $job = new TerraformDeploymentJob($deployment->id);
    $tags = $job->tags();

    expect($tags)->toContain('terraform');
    expect($tags)->toContain("organization:{$deployment->organization_id}");
    expect($tags)->toContain("deployment:{$deployment->id}");
    expect($tags)->toContain("provider:aws");
});
```

### Integration Tests

**File:** `tests/Feature/TerraformProvisioningTest.php`

```php
<?php

use App\Jobs\Enterprise\TerraformDeploymentJob;
use App\Models\CloudProviderCredential;
use App\Models\Organization;
use App\Models\TerraformDeployment;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;

it('provisions infrastructure end-to-end', function () {
    Queue::fake();
    Event::fake();

    $org = Organization::factory()->create();
    $credential = CloudProviderCredential::factory()->create([
        'organization_id' => $org->id,
        'provider' => 'aws',
    ]);

    $deployment = TerraformDeployment::factory()->create([
        'organization_id' => $org->id,
        'cloud_provider_credential_id' => $credential->id,
        'cloud_provider' => 'aws',
        'configuration' => [
            'instance_type' => 't3.micro',
            'region' => 'us-east-1',
        ],
    ]);

    TerraformDeploymentJob::dispatch($deployment->id);

    Queue::assertPushed(TerraformDeploymentJob::class, function ($job) use ($deployment) {
        return $job->deploymentId === $deployment->id;
    });
});

it('updates status through all stages', function () {
    // This test would run actual Terraform in a test environment
    // Or use mocks to verify state transitions
})->skip('Requires Terraform binary and test cloud credentials');
```

## Definition of Done

- [ ] TerraformDeploymentJob created implementing ShouldQueue
- [ ] Dispatches to 'terraform' queue with priority
- [ ] Executes terraform init, plan, apply in sequence
- [ ] Updates deployment status at each stage
- [ ] Broadcasts progress via WebSocket
- [ ] Integrates with TerraformStateManager
- [ ] Parses and stores Terraform outputs
- [ ] Implements comprehensive error handling
- [ ] Supports automatic retry (3 attempts, exponential backoff)
- [ ] Implements optional rollback on failure
- [ ] Dispatches ServerRegistrationJob on success
- [ ] Logs all output to database
- [ ] Implements 30-minute timeout
- [ ] TerraformProvisioningProgress event created
- [ ] TerraformProvisioningCompleted event created
- [ ] TerraformProvisioningFailed event created
- [ ] Events broadcast to organization-specific channels
- [ ] terraform:provision Artisan command created
- [ ] Command supports --sync and --rollback flags
- [ ] Horizon tags implemented
- [ ] Unit tests written (>90% coverage)
- [ ] Integration tests written
- [ ] WebSocket broadcasting tested
- [ ] Documentation added to methods
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Manual testing with real Terraform operations
- [ ] Code reviewed and approved
