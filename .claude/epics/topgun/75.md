---
name: Create PaymentTestingTrait with gateway simulation
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:26Z
github: https://github.com/johnproblems/topgun/issues/182
depends_on: [46]
parallel: true
conflicts_with: []
---

# Task: Create PaymentTestingTrait with gateway simulation

## Description

Create a comprehensive PHPUnit testing trait that provides mock payment gateway implementations, helper methods, and testing utilities for the enterprise payment processing system. This trait enables reliable, fast, and deterministic tests for all payment-related functionality without making real API calls to Stripe, PayPal, or other payment providers.

**The Testing Challenge:**

Payment processing tests are notoriously difficult to write and maintain:
1. **External API Dependencies**: Real payment gateways require API keys, network connectivity, and sandbox environments
2. **Non-Deterministic Behavior**: Webhook timing, async processing, network latency create flaky tests
3. **Complex State Management**: Subscriptions, payment methods, transactions have intricate lifecycle states
4. **Security Concerns**: Test data can leak sensitive information if not properly mocked
5. **Cost and Rate Limits**: Sandbox environments have transaction quotas and processing delays
6. **Webhook Validation**: HMAC signature validation requires complex mocking

**The Solution:**

`PaymentTestingTrait` provides a complete payment gateway simulation framework that replaces real payment providers with predictable, controllable mocks. This enables:
- **100% Coverage**: Test all code paths including rare failure scenarios
- **Zero External Dependencies**: No API keys, network, or sandbox environments required
- **Deterministic Results**: Consistent test outcomes regardless of external factors
- **Fast Execution**: No network latency, tests run in milliseconds
- **Security**: No real credentials or transaction data exposed
- **Comprehensive Scenarios**: Easily simulate success, failure, timeout, webhook scenarios

**Key Capabilities:**

1. **Gateway Factory Mocking**: Replace `PaymentGatewayInterface` implementations with test doubles
2. **Fake Payment Methods**: Create credit cards, bank accounts, PayPal accounts with predictable tokens
3. **Transaction Simulation**: Process charges, refunds, subscriptions with configurable outcomes
4. **Webhook Simulation**: Generate webhook payloads with valid HMAC signatures
5. **State Assertions**: Verify database state after payment operations
6. **Error Simulation**: Test timeout, decline, fraud detection, network failure scenarios
7. **Idempotency Testing**: Verify duplicate request handling
8. **Multi-Gateway Testing**: Test gateway switching and failover logic

**Integration Points:**

- **PaymentService (Task 46)**: Mock all payment gateway interactions
- **SubscriptionManager (Task 48)**: Test subscription lifecycle without real payments
- **WebhookController (Task 47)**: Simulate gateway webhooks with valid signatures
- **BillingDashboard (Task 50)**: Test billing display logic with fake transaction data
- **OrganizationTestingTrait (Task 72)**: Combine with organization context for multi-tenant tests
- **LicenseTestingTrait (Task 73)**: Test payment-triggered license activation

**Why This Task is Critical:**

Payment processing is the revenue engine of the enterprise platform. Bugs in payment code can result in lost revenue, compliance violations, and customer trust issues. However, testing payment code against real APIs is slow, expensive, and unreliable. This trait solves the testing dilemma by providing comprehensive mocking that's indistinguishable from real payment gateways during tests, enabling developers to write thorough test suites that catch bugs before they reach production.

Without this trait, developers would either:
1. Skip payment tests entirely (dangerous)
2. Write flaky tests against sandbox APIs (unreliable)
3. Implement ad-hoc mocking in every test (duplicated effort)

With this trait, payment testing becomes as simple and reliable as testing any other business logic, ensuring the payment system is rock-solid before deployment.

## Acceptance Criteria

- [ ] PaymentTestingTrait created in tests/Traits/
- [ ] Fake payment gateway implementations for Stripe and PayPal
- [ ] Mock PaymentGatewayFactory returns fake gateways
- [ ] Helper methods for creating test payment methods (cards, bank accounts)
- [ ] Helper methods for simulating successful payments
- [ ] Helper methods for simulating payment failures (declined, timeout, fraud)
- [ ] Helper methods for generating webhook payloads
- [ ] HMAC signature generation for webhook validation
- [ ] Transaction state assertion helpers
- [ ] Subscription state assertion helpers
- [ ] Idempotency key testing utilities
- [ ] Multi-gateway failover simulation
- [ ] Configurable response delays for async testing
- [ ] Database state verification methods
- [ ] Full integration with Pest testing framework
- [ ] Comprehensive PHPDoc documentation with usage examples

## Technical Details

### File Paths

**Trait:**
- `/home/topgun/topgun/tests/Traits/PaymentTestingTrait.php` (new)

**Fake Gateways:**
- `/home/topgun/topgun/tests/Fakes/FakeStripeGateway.php` (new)
- `/home/topgun/topgun/tests/Fakes/FakePayPalGateway.php` (new)
- `/home/topgun/topgun/tests/Fakes/FakePaymentGatewayFactory.php` (new)

**Example Usage in Tests:**
- `/home/topgun/topgun/tests/Feature/Enterprise/PaymentProcessingTest.php` (modify/enhance)
- `/home/topgun/topgun/tests/Feature/Enterprise/SubscriptionManagementTest.php` (modify/enhance)
- `/home/topgun/topgun/tests/Feature/Enterprise/WebhookHandlingTest.php` (modify/enhance)

### Trait Implementation

**File:** `tests/Traits/PaymentTestingTrait.php`

```php
<?php

namespace Tests\Traits;

use App\Contracts\PaymentGatewayInterface;
use App\Models\Organization;
use App\Models\PaymentMethod;
use App\Models\PaymentTransaction;
use App\Models\OrganizationSubscription;
use App\Services\Enterprise\PaymentService;
use Illuminate\Support\Facades\App;
use Tests\Fakes\FakeStripeGateway;
use Tests\Fakes\FakePayPalGateway;
use Tests\Fakes\FakePaymentGatewayFactory;

/**
 * Payment Testing Trait
 *
 * Provides comprehensive payment gateway mocking and testing utilities
 * for Coolify Enterprise payment processing tests.
 *
 * Usage:
 * ```php
 * use Tests\Traits\PaymentTestingTrait;
 *
 * it('processes payment successfully', function () {
 *     $this->setupPaymentMocks();
 *     $organization = Organization::factory()->create();
 *     $paymentMethod = $this->createTestPaymentMethod($organization, 'card');
 *
 *     $result = $this->processTestPayment($organization, 10000); // $100.00
 *
 *     $this->assertPaymentSucceeded($result);
 * })->uses(PaymentTestingTrait::class);
 * ```
 *
 * @package Tests\Traits
 */
trait PaymentTestingTrait
{
    /**
     * Fake gateway instances
     */
    protected FakeStripeGateway $fakeStripeGateway;
    protected FakePayPalGateway $fakePayPalGateway;
    protected FakePaymentGatewayFactory $fakeGatewayFactory;

    /**
     * Transaction history for assertions
     */
    protected array $processedTransactions = [];

    /**
     * Setup payment gateway mocks
     *
     * Call this in the beginning of each test to replace real payment
     * gateways with fake implementations.
     *
     * @param array $config Optional configuration for fake gateways
     * @return void
     */
    protected function setupPaymentMocks(array $config = []): void
    {
        $this->fakeStripeGateway = new FakeStripeGateway($config['stripe'] ?? []);
        $this->fakePayPalGateway = new FakePayPalGateway($config['paypal'] ?? []);

        $this->fakeGatewayFactory = new FakePaymentGatewayFactory(
            $this->fakeStripeGateway,
            $this->fakePayPalGateway
        );

        // Replace the real factory with fake
        App::instance('App\Contracts\PaymentGatewayFactoryInterface', $this->fakeGatewayFactory);

        // Clear transaction history
        $this->processedTransactions = [];
    }

    /**
     * Create a test payment method
     *
     * @param Organization $organization
     * @param string $type 'card', 'bank_account', 'paypal'
     * @param array $attributes Additional attributes
     * @return PaymentMethod
     */
    protected function createTestPaymentMethod(
        Organization $organization,
        string $type = 'card',
        array $attributes = []
    ): PaymentMethod {
        $defaults = match ($type) {
            'card' => [
                'type' => 'card',
                'gateway' => 'stripe',
                'gateway_payment_method_id' => 'pm_test_' . uniqid(),
                'last_four' => '4242',
                'brand' => 'visa',
                'exp_month' => 12,
                'exp_year' => date('Y') + 2,
                'is_default' => true,
            ],
            'bank_account' => [
                'type' => 'bank_account',
                'gateway' => 'stripe',
                'gateway_payment_method_id' => 'ba_test_' . uniqid(),
                'last_four' => '6789',
                'bank_name' => 'Test Bank',
                'is_default' => true,
            ],
            'paypal' => [
                'type' => 'paypal',
                'gateway' => 'paypal',
                'gateway_payment_method_id' => 'PAYPAL-' . uniqid(),
                'email' => 'customer@example.com',
                'is_default' => true,
            ],
            default => throw new \InvalidArgumentException("Unknown payment method type: {$type}"),
        };

        return PaymentMethod::create([
            'organization_id' => $organization->id,
            ...$defaults,
            ...$attributes,
        ]);
    }

    /**
     * Process a test payment
     *
     * @param Organization $organization
     * @param int $amount Amount in cents
     * @param array $options Additional payment options
     * @return PaymentTransaction
     */
    protected function processTestPayment(
        Organization $organization,
        int $amount,
        array $options = []
    ): PaymentTransaction {
        $paymentService = app(PaymentService::class);

        $paymentMethod = $options['payment_method'] ??
            $organization->paymentMethods()->where('is_default', true)->first();

        if (!$paymentMethod) {
            throw new \RuntimeException('No payment method available for test payment');
        }

        $transaction = $paymentService->processPayment(
            $organization,
            $paymentMethod,
            $amount,
            $options['metadata'] ?? []
        );

        $this->processedTransactions[] = $transaction;

        return $transaction;
    }

    /**
     * Simulate payment failure
     *
     * Configure the fake gateway to fail the next payment attempt.
     *
     * @param string $reason Failure reason: 'declined', 'insufficient_funds', 'timeout', 'fraud'
     * @param string $gateway Gateway to configure: 'stripe' or 'paypal'
     * @return void
     */
    protected function simulatePaymentFailure(string $reason, string $gateway = 'stripe'): void
    {
        $fakeGateway = $gateway === 'stripe' ? $this->fakeStripeGateway : $this->fakePayPalGateway;
        $fakeGateway->setNextPaymentFailure($reason);
    }

    /**
     * Simulate webhook delivery
     *
     * Generates a valid webhook payload with HMAC signature for testing
     * webhook handlers.
     *
     * @param string $event Event type (e.g., 'charge.succeeded', 'subscription.created')
     * @param array $data Event data
     * @param string $gateway Gateway sending webhook: 'stripe' or 'paypal'
     * @return array Webhook payload and headers
     */
    protected function simulateWebhook(string $event, array $data, string $gateway = 'stripe'): array
    {
        $fakeGateway = $gateway === 'stripe' ? $this->fakeStripeGateway : $this->fakePayPalGateway;

        return $fakeGateway->generateWebhook($event, $data);
    }

    /**
     * Create test subscription
     *
     * @param Organization $organization
     * @param string $planId Plan identifier
     * @param array $attributes Additional attributes
     * @return OrganizationSubscription
     */
    protected function createTestSubscription(
        Organization $organization,
        string $planId = 'pro-monthly',
        array $attributes = []
    ): OrganizationSubscription {
        $paymentService = app(PaymentService::class);

        $paymentMethod = $organization->paymentMethods()
            ->where('is_default', true)
            ->first();

        if (!$paymentMethod) {
            $paymentMethod = $this->createTestPaymentMethod($organization);
        }

        return $paymentService->createSubscription(
            $organization,
            $paymentMethod,
            $planId,
            $attributes
        );
    }

    /**
     * Assert payment succeeded
     *
     * @param PaymentTransaction $transaction
     * @return void
     */
    protected function assertPaymentSucceeded(PaymentTransaction $transaction): void
    {
        expect($transaction->status)->toBe('succeeded')
            ->and($transaction->gateway_transaction_id)->not->toBeNull()
            ->and($transaction->failed_at)->toBeNull()
            ->and($transaction->failure_reason)->toBeNull();

        $this->assertDatabaseHas('payment_transactions', [
            'id' => $transaction->id,
            'status' => 'succeeded',
        ]);
    }

    /**
     * Assert payment failed
     *
     * @param PaymentTransaction $transaction
     * @param string|null $expectedReason Expected failure reason
     * @return void
     */
    protected function assertPaymentFailed(PaymentTransaction $transaction, ?string $expectedReason = null): void
    {
        expect($transaction->status)->toBe('failed')
            ->and($transaction->failed_at)->not->toBeNull();

        if ($expectedReason) {
            expect($transaction->failure_reason)->toContain($expectedReason);
        }

        $this->assertDatabaseHas('payment_transactions', [
            'id' => $transaction->id,
            'status' => 'failed',
        ]);
    }

    /**
     * Assert subscription is active
     *
     * @param OrganizationSubscription $subscription
     * @return void
     */
    protected function assertSubscriptionActive(OrganizationSubscription $subscription): void
    {
        expect($subscription->status)->toBe('active')
            ->and($subscription->starts_at)->not->toBeNull()
            ->and($subscription->ends_at)->toBeNull()
            ->and($subscription->gateway_subscription_id)->not->toBeNull();

        $this->assertDatabaseHas('organization_subscriptions', [
            'id' => $subscription->id,
            'status' => 'active',
        ]);
    }

    /**
     * Assert subscription is cancelled
     *
     * @param OrganizationSubscription $subscription
     * @param bool $immediately Whether cancellation is immediate or at period end
     * @return void
     */
    protected function assertSubscriptionCancelled(
        OrganizationSubscription $subscription,
        bool $immediately = false
    ): void {
        expect($subscription->status)->toBe('cancelled');

        if ($immediately) {
            expect($subscription->ends_at)->not->toBeNull()
                ->and($subscription->ends_at->isPast())->toBeTrue();
        } else {
            expect($subscription->ends_at)->not->toBeNull()
                ->and($subscription->ends_at->isFuture())->toBeTrue();
        }

        $this->assertDatabaseHas('organization_subscriptions', [
            'id' => $subscription->id,
            'status' => 'cancelled',
        ]);
    }

    /**
     * Assert payment method is stored
     *
     * @param PaymentMethod $paymentMethod
     * @return void
     */
    protected function assertPaymentMethodStored(PaymentMethod $paymentMethod): void
    {
        expect($paymentMethod->exists)->toBeTrue()
            ->and($paymentMethod->gateway_payment_method_id)->not->toBeNull()
            ->and($paymentMethod->organization_id)->not->toBeNull();

        $this->assertDatabaseHas('payment_methods', [
            'id' => $paymentMethod->id,
            'organization_id' => $paymentMethod->organization_id,
        ]);
    }

    /**
     * Assert refund was processed
     *
     * @param PaymentTransaction $originalTransaction
     * @param int|null $refundAmount Expected refund amount in cents (null for full refund)
     * @return void
     */
    protected function assertRefundProcessed(PaymentTransaction $originalTransaction, ?int $refundAmount = null): void
    {
        $expectedAmount = $refundAmount ?? $originalTransaction->amount;

        $this->assertDatabaseHas('payment_transactions', [
            'parent_transaction_id' => $originalTransaction->id,
            'type' => 'refund',
            'amount' => $expectedAmount,
            'status' => 'succeeded',
        ]);
    }

    /**
     * Assert idempotency key prevents duplicate charges
     *
     * Tests that submitting the same idempotency key twice doesn't create duplicate charges.
     *
     * @param string $idempotencyKey
     * @return void
     */
    protected function assertIdempotencyKeyPreventsDoubleCharge(string $idempotencyKey): void
    {
        $transactionCount = PaymentTransaction::where('idempotency_key', $idempotencyKey)->count();

        expect($transactionCount)->toBe(1,
            "Expected exactly 1 transaction with idempotency key {$idempotencyKey}, found {$transactionCount}"
        );
    }

    /**
     * Get all processed transactions in this test
     *
     * @return array
     */
    protected function getProcessedTransactions(): array
    {
        return $this->processedTransactions;
    }

    /**
     * Configure gateway response delay
     *
     * Simulates network latency for async testing.
     *
     * @param int $milliseconds Delay in milliseconds
     * @param string $gateway Gateway to configure
     * @return void
     */
    protected function setGatewayDelay(int $milliseconds, string $gateway = 'stripe'): void
    {
        $fakeGateway = $gateway === 'stripe' ? $this->fakeStripeGateway : $this->fakePayPalGateway;
        $fakeGateway->setResponseDelay($milliseconds);
    }

    /**
     * Assert webhook signature is valid
     *
     * @param string $payload Webhook payload
     * @param string $signature HMAC signature
     * @param string $gateway Gateway type
     * @return void
     */
    protected function assertWebhookSignatureValid(string $payload, string $signature, string $gateway = 'stripe'): void
    {
        $fakeGateway = $gateway === 'stripe' ? $this->fakeStripeGateway : $this->fakePayPalGateway;
        $isValid = $fakeGateway->verifyWebhookSignature($payload, $signature);

        expect($isValid)->toBeTrue('Webhook signature verification failed');
    }

    /**
     * Create test card that will be declined
     *
     * Returns a payment method configuration that will trigger a decline.
     *
     * @param Organization $organization
     * @return PaymentMethod
     */
    protected function createDeclinedCard(Organization $organization): PaymentMethod
    {
        return $this->createTestPaymentMethod($organization, 'card', [
            'gateway_payment_method_id' => 'pm_card_declined',
            'last_four' => '0002',
        ]);
    }

    /**
     * Create test card with insufficient funds
     *
     * @param Organization $organization
     * @return PaymentMethod
     */
    protected function createInsufficientFundsCard(Organization $organization): PaymentMethod
    {
        return $this->createTestPaymentMethod($organization, 'card', [
            'gateway_payment_method_id' => 'pm_card_insufficient_funds',
            'last_four' => '9995',
        ]);
    }

    /**
     * Create test card that triggers fraud detection
     *
     * @param Organization $organization
     * @return PaymentMethod
     */
    protected function createFraudCard(Organization $organization): PaymentMethod
    {
        return $this->createTestPaymentMethod($organization, 'card', [
            'gateway_payment_method_id' => 'pm_card_fraud',
            'last_four' => '0019',
        ]);
    }

    /**
     * Simulate gateway timeout
     *
     * Configure the gateway to timeout on the next request.
     *
     * @param string $gateway Gateway to configure
     * @return void
     */
    protected function simulateGatewayTimeout(string $gateway = 'stripe'): void
    {
        $fakeGateway = $gateway === 'stripe' ? $this->fakeStripeGateway : $this->fakePayPalGateway;
        $fakeGateway->setNextRequestTimeout();
    }

    /**
     * Assert transaction has correct metadata
     *
     * @param PaymentTransaction $transaction
     * @param array $expectedMetadata
     * @return void
     */
    protected function assertTransactionMetadata(PaymentTransaction $transaction, array $expectedMetadata): void
    {
        $metadata = $transaction->metadata ?? [];

        foreach ($expectedMetadata as $key => $value) {
            expect($metadata)->toHaveKey($key)
                ->and($metadata[$key])->toBe($value, "Metadata key '{$key}' mismatch");
        }
    }

    /**
     * Simulate subscription renewal
     *
     * Triggers a subscription renewal event via webhook simulation.
     *
     * @param OrganizationSubscription $subscription
     * @return array Webhook payload and headers
     */
    protected function simulateSubscriptionRenewal(OrganizationSubscription $subscription): array
    {
        return $this->simulateWebhook('subscription.renewed', [
            'subscription_id' => $subscription->gateway_subscription_id,
            'organization_id' => $subscription->organization_id,
            'amount' => $subscription->amount,
            'period_start' => now()->toIso8601String(),
            'period_end' => now()->addMonth()->toIso8601String(),
        ], $subscription->gateway);
    }

    /**
     * Simulate payment method expiration
     *
     * Updates payment method to be expired.
     *
     * @param PaymentMethod $paymentMethod
     * @return void
     */
    protected function simulatePaymentMethodExpiration(PaymentMethod $paymentMethod): void
    {
        $paymentMethod->update([
            'exp_month' => now()->subMonth()->month,
            'exp_year' => now()->subMonth()->year,
        ]);
    }

    /**
     * Assert gateway failover occurred
     *
     * Verifies that payment failed on primary gateway and succeeded on fallback.
     *
     * @param string $primaryGateway Expected primary gateway
     * @param string $fallbackGateway Expected fallback gateway
     * @return void
     */
    protected function assertGatewayFailover(string $primaryGateway, string $fallbackGateway): void
    {
        $transactions = $this->getProcessedTransactions();

        expect(count($transactions))->toBeGreaterThanOrEqual(2, 'Expected at least 2 transactions for failover');

        $firstAttempt = $transactions[count($transactions) - 2];
        $secondAttempt = $transactions[count($transactions) - 1];

        expect($firstAttempt->gateway)->toBe($primaryGateway)
            ->and($firstAttempt->status)->toBe('failed')
            ->and($secondAttempt->gateway)->toBe($fallbackGateway)
            ->and($secondAttempt->status)->toBe('succeeded');
    }
}
```

### Fake Stripe Gateway

**File:** `tests/Fakes/FakeStripeGateway.php`

```php
<?php

namespace Tests\Fakes;

use App\Contracts\PaymentGatewayInterface;
use App\Models\Organization;
use App\Models\PaymentMethod;

class FakeStripeGateway implements PaymentGatewayInterface
{
    protected ?string $nextFailureReason = null;
    protected bool $nextRequestTimeout = false;
    protected int $responseDelay = 0;
    protected array $processedPayments = [];

    public function __construct(protected array $config = [])
    {
    }

    public function processPayment(
        Organization $organization,
        PaymentMethod $paymentMethod,
        int $amount,
        array $metadata = []
    ): array {
        $this->applyDelay();

        if ($this->nextRequestTimeout) {
            $this->nextRequestTimeout = false;
            throw new \Exception('Gateway timeout');
        }

        // Simulate special test cards
        if ($paymentMethod->gateway_payment_method_id === 'pm_card_declined') {
            $this->nextFailureReason = 'card_declined';
        } elseif ($paymentMethod->gateway_payment_method_id === 'pm_card_insufficient_funds') {
            $this->nextFailureReason = 'insufficient_funds';
        } elseif ($paymentMethod->gateway_payment_method_id === 'pm_card_fraud') {
            $this->nextFailureReason = 'fraud_detected';
        }

        if ($this->nextFailureReason) {
            $reason = $this->nextFailureReason;
            $this->nextFailureReason = null;

            return [
                'status' => 'failed',
                'gateway_transaction_id' => null,
                'failure_reason' => $reason,
                'gateway_response' => ['error' => $reason],
            ];
        }

        $transactionId = 'ch_test_' . uniqid();

        $this->processedPayments[] = [
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'organization_id' => $organization->id,
            'metadata' => $metadata,
        ];

        return [
            'status' => 'succeeded',
            'gateway_transaction_id' => $transactionId,
            'failure_reason' => null,
            'gateway_response' => [
                'id' => $transactionId,
                'amount' => $amount,
                'currency' => 'usd',
                'status' => 'succeeded',
            ],
        ];
    }

    public function createSubscription(
        Organization $organization,
        PaymentMethod $paymentMethod,
        string $planId,
        array $metadata = []
    ): array {
        $this->applyDelay();

        $subscriptionId = 'sub_test_' . uniqid();

        return [
            'status' => 'active',
            'gateway_subscription_id' => $subscriptionId,
            'gateway_response' => [
                'id' => $subscriptionId,
                'plan' => $planId,
                'status' => 'active',
                'current_period_start' => now()->timestamp,
                'current_period_end' => now()->addMonth()->timestamp,
            ],
        ];
    }

    public function cancelSubscription(string $gatewaySubscriptionId, bool $immediately = false): array
    {
        $this->applyDelay();

        return [
            'status' => 'cancelled',
            'ends_at' => $immediately ? now() : now()->addMonth(),
            'gateway_response' => [
                'id' => $gatewaySubscriptionId,
                'status' => 'canceled',
                'cancel_at_period_end' => !$immediately,
            ],
        ];
    }

    public function refundPayment(string $gatewayTransactionId, int $amount): array
    {
        $this->applyDelay();

        $refundId = 're_test_' . uniqid();

        return [
            'status' => 'succeeded',
            'gateway_refund_id' => $refundId,
            'amount' => $amount,
            'gateway_response' => [
                'id' => $refundId,
                'charge' => $gatewayTransactionId,
                'amount' => $amount,
                'status' => 'succeeded',
            ],
        ];
    }

    public function addPaymentMethod(Organization $organization, array $paymentMethodData): array
    {
        $paymentMethodId = 'pm_test_' . uniqid();

        return [
            'gateway_payment_method_id' => $paymentMethodId,
            'last_four' => $paymentMethodData['last_four'] ?? '4242',
            'brand' => $paymentMethodData['brand'] ?? 'visa',
            'exp_month' => $paymentMethodData['exp_month'] ?? 12,
            'exp_year' => $paymentMethodData['exp_year'] ?? date('Y') + 2,
        ];
    }

    public function removePaymentMethod(string $gatewayPaymentMethodId): bool
    {
        return true;
    }

    public function generateWebhook(string $event, array $data): array
    {
        $timestamp = time();
        $payload = json_encode([
            'id' => 'evt_test_' . uniqid(),
            'type' => $event,
            'data' => ['object' => $data],
            'created' => $timestamp,
        ]);

        $secret = config('payment.stripe.webhook_secret', 'whsec_test');
        $signature = $this->generateWebhookSignature($payload, $timestamp, $secret);

        return [
            'payload' => $payload,
            'headers' => [
                'Stripe-Signature' => "t={$timestamp},v1={$signature}",
            ],
        ];
    }

    public function verifyWebhookSignature(string $payload, string $signature): bool
    {
        // Extract timestamp and signature from header
        preg_match('/t=(\d+)/', $signature, $tMatches);
        preg_match('/v1=([a-f0-9]+)/', $signature, $sigMatches);

        if (!$tMatches || !$sigMatches) {
            return false;
        }

        $timestamp = $tMatches[1];
        $providedSignature = $sigMatches[1];

        $secret = config('payment.stripe.webhook_secret', 'whsec_test');
        $expectedSignature = $this->generateWebhookSignature($payload, $timestamp, $secret);

        return hash_equals($expectedSignature, $providedSignature);
    }

    protected function generateWebhookSignature(string $payload, int $timestamp, string $secret): string
    {
        $signedPayload = "{$timestamp}.{$payload}";
        return hash_hmac('sha256', $signedPayload, $secret);
    }

    public function setNextPaymentFailure(string $reason): void
    {
        $this->nextFailureReason = $reason;
    }

    public function setNextRequestTimeout(): void
    {
        $this->nextRequestTimeout = true;
    }

    public function setResponseDelay(int $milliseconds): void
    {
        $this->responseDelay = $milliseconds;
    }

    protected function applyDelay(): void
    {
        if ($this->responseDelay > 0) {
            usleep($this->responseDelay * 1000);
        }
    }

    public function getProcessedPayments(): array
    {
        return $this->processedPayments;
    }
}
```

### Fake PayPal Gateway

**File:** `tests/Fakes/FakePayPalGateway.php`

```php
<?php

namespace Tests\Fakes;

use App\Contracts\PaymentGatewayInterface;
use App\Models\Organization;
use App\Models\PaymentMethod;

class FakePayPalGateway implements PaymentGatewayInterface
{
    protected ?string $nextFailureReason = null;
    protected bool $nextRequestTimeout = false;
    protected int $responseDelay = 0;
    protected array $processedPayments = [];

    public function __construct(protected array $config = [])
    {
    }

    public function processPayment(
        Organization $organization,
        PaymentMethod $paymentMethod,
        int $amount,
        array $metadata = []
    ): array {
        $this->applyDelay();

        if ($this->nextRequestTimeout) {
            $this->nextRequestTimeout = false;
            throw new \Exception('PayPal API timeout');
        }

        if ($this->nextFailureReason) {
            $reason = $this->nextFailureReason;
            $this->nextFailureReason = null;

            return [
                'status' => 'failed',
                'gateway_transaction_id' => null,
                'failure_reason' => $reason,
                'gateway_response' => ['error' => $reason],
            ];
        }

        $transactionId = 'PAYPAL-' . strtoupper(uniqid());

        $this->processedPayments[] = [
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'organization_id' => $organization->id,
            'metadata' => $metadata,
        ];

        return [
            'status' => 'succeeded',
            'gateway_transaction_id' => $transactionId,
            'failure_reason' => null,
            'gateway_response' => [
                'id' => $transactionId,
                'status' => 'COMPLETED',
                'amount' => [
                    'value' => number_format($amount / 100, 2),
                    'currency_code' => 'USD',
                ],
            ],
        ];
    }

    public function createSubscription(
        Organization $organization,
        PaymentMethod $paymentMethod,
        string $planId,
        array $metadata = []
    ): array {
        $this->applyDelay();

        $subscriptionId = 'I-' . strtoupper(uniqid());

        return [
            'status' => 'active',
            'gateway_subscription_id' => $subscriptionId,
            'gateway_response' => [
                'id' => $subscriptionId,
                'plan_id' => $planId,
                'status' => 'ACTIVE',
            ],
        ];
    }

    public function cancelSubscription(string $gatewaySubscriptionId, bool $immediately = false): array
    {
        $this->applyDelay();

        return [
            'status' => 'cancelled',
            'ends_at' => $immediately ? now() : now()->addMonth(),
            'gateway_response' => [
                'id' => $gatewaySubscriptionId,
                'status' => 'CANCELLED',
            ],
        ];
    }

    public function refundPayment(string $gatewayTransactionId, int $amount): array
    {
        $this->applyDelay();

        $refundId = 'REF-' . strtoupper(uniqid());

        return [
            'status' => 'succeeded',
            'gateway_refund_id' => $refundId,
            'amount' => $amount,
            'gateway_response' => [
                'id' => $refundId,
                'status' => 'COMPLETED',
            ],
        ];
    }

    public function addPaymentMethod(Organization $organization, array $paymentMethodData): array
    {
        $paymentMethodId = 'PAYPAL-PM-' . strtoupper(uniqid());

        return [
            'gateway_payment_method_id' => $paymentMethodId,
            'email' => $paymentMethodData['email'] ?? 'test@example.com',
        ];
    }

    public function removePaymentMethod(string $gatewayPaymentMethodId): bool
    {
        return true;
    }

    public function generateWebhook(string $event, array $data): array
    {
        $payload = json_encode([
            'id' => 'WH-' . strtoupper(uniqid()),
            'event_type' => $event,
            'resource' => $data,
            'create_time' => now()->toIso8601String(),
        ]);

        $secret = config('payment.paypal.webhook_id', 'WH-TEST');
        $signature = base64_encode(hash_hmac('sha256', $payload, $secret, true));

        return [
            'payload' => $payload,
            'headers' => [
                'PayPal-Transmission-Id' => 'test-' . uniqid(),
                'PayPal-Transmission-Time' => now()->toIso8601String(),
                'PayPal-Transmission-Sig' => $signature,
            ],
        ];
    }

    public function verifyWebhookSignature(string $payload, string $signature): bool
    {
        $secret = config('payment.paypal.webhook_id', 'WH-TEST');
        $expectedSignature = base64_encode(hash_hmac('sha256', $payload, $secret, true));

        return hash_equals($expectedSignature, $signature);
    }

    public function setNextPaymentFailure(string $reason): void
    {
        $this->nextFailureReason = $reason;
    }

    public function setNextRequestTimeout(): void
    {
        $this->nextRequestTimeout = true;
    }

    public function setResponseDelay(int $milliseconds): void
    {
        $this->responseDelay = $milliseconds;
    }

    protected function applyDelay(): void
    {
        if ($this->responseDelay > 0) {
            usleep($this->responseDelay * 1000);
        }
    }

    public function getProcessedPayments(): array
    {
        return $this->processedPayments;
    }
}
```

### Fake Payment Gateway Factory

**File:** `tests/Fakes/FakePaymentGatewayFactory.php`

```php
<?php

namespace Tests\Fakes;

use App\Contracts\PaymentGatewayInterface;
use App\Contracts\PaymentGatewayFactoryInterface;

class FakePaymentGatewayFactory implements PaymentGatewayFactoryInterface
{
    public function __construct(
        protected FakeStripeGateway $stripeGateway,
        protected FakePayPalGateway $paypalGateway
    ) {
    }

    public function make(string $gateway): PaymentGatewayInterface
    {
        return match ($gateway) {
            'stripe' => $this->stripeGateway,
            'paypal' => $this->paypalGateway,
            default => throw new \InvalidArgumentException("Unknown payment gateway: {$gateway}"),
        };
    }

    public function getStripeGateway(): FakeStripeGateway
    {
        return $this->stripeGateway;
    }

    public function getPayPalGateway(): FakePayPalGateway
    {
        return $this->paypalGateway;
    }
}
```

## Implementation Approach

### Step 1: Create Trait Structure
1. Create `tests/Traits/PaymentTestingTrait.php`
2. Define trait with PHPDoc explaining usage
3. Add protected properties for fake gateways
4. Create `setupPaymentMocks()` method

### Step 2: Implement Fake Gateways
1. Create `FakeStripeGateway` implementing `PaymentGatewayInterface`
2. Create `FakePayPalGateway` implementing `PaymentGatewayInterface`
3. Implement all interface methods with realistic responses
4. Add configuration methods (setNextFailure, setTimeout, etc.)

### Step 3: Create Gateway Factory Mock
1. Create `FakePaymentGatewayFactory`
2. Implement `make()` method returning fake gateways
3. Add getter methods for direct gateway access
4. Integrate with Laravel service container

### Step 4: Add Helper Methods
1. Implement `createTestPaymentMethod()` with card/bank/PayPal variants
2. Implement `processTestPayment()` wrapper
3. Add `simulateWebhook()` with HMAC signature generation
4. Create special card helpers (declined, insufficient funds, fraud)

### Step 5: Add Assertion Helpers
1. Implement `assertPaymentSucceeded()`
2. Implement `assertPaymentFailed()`
3. Implement `assertSubscriptionActive()`
4. Implement `assertRefundProcessed()`
5. Add metadata and idempotency assertions

### Step 6: Webhook Simulation
1. Implement webhook payload generation for Stripe
2. Implement webhook payload generation for PayPal
3. Add HMAC signature generation matching real gateways
4. Create `verifyWebhookSignature()` method

### Step 7: Advanced Scenarios
1. Add timeout simulation
2. Add response delay configuration
3. Implement gateway failover testing
4. Add subscription renewal simulation

### Step 8: Integration and Testing
1. Update existing payment tests to use trait
2. Write tests for the trait itself
3. Verify all payment scenarios work with mocks
4. Document usage patterns in PHPDoc

## Test Strategy

### Unit Tests for Trait

**File:** `tests/Unit/Traits/PaymentTestingTraitTest.php`

```php
<?php

use Tests\Traits\PaymentTestingTrait;
use App\Models\Organization;
use App\Models\PaymentMethod;

uses(PaymentTestingTrait::class);

beforeEach(function () {
    $this->setupPaymentMocks();
});

it('creates test payment method with correct attributes', function () {
    $organization = Organization::factory()->create();

    $card = $this->createTestPaymentMethod($organization, 'card');

    expect($card->type)->toBe('card')
        ->and($card->gateway)->toBe('stripe')
        ->and($card->last_four)->toBe('4242')
        ->and($card->organization_id)->toBe($organization->id);
});

it('processes test payment successfully', function () {
    $organization = Organization::factory()->create();
    $this->createTestPaymentMethod($organization);

    $transaction = $this->processTestPayment($organization, 10000);

    $this->assertPaymentSucceeded($transaction);
    expect($transaction->amount)->toBe(10000);
});

it('simulates payment decline', function () {
    $organization = Organization::factory()->create();
    $card = $this->createDeclinedCard($organization);

    $this->simulatePaymentFailure('card_declined');

    expect(fn() => $this->processTestPayment($organization, 5000, ['payment_method' => $card]))
        ->not->toThrow(\Exception::class);

    $transaction = $this->getProcessedTransactions()[0];
    $this->assertPaymentFailed($transaction, 'declined');
});

it('generates valid webhook with HMAC signature', function () {
    $webhook = $this->simulateWebhook('charge.succeeded', [
        'id' => 'ch_test_123',
        'amount' => 10000,
    ], 'stripe');

    expect($webhook)->toHaveKeys(['payload', 'headers']);

    $this->assertWebhookSignatureValid(
        $webhook['payload'],
        $webhook['headers']['Stripe-Signature']
    );
});

it('creates active subscription', function () {
    $organization = Organization::factory()->create();
    $this->createTestPaymentMethod($organization);

    $subscription = $this->createTestSubscription($organization, 'pro-monthly');

    $this->assertSubscriptionActive($subscription);
});

it('simulates gateway timeout', function () {
    $organization = Organization::factory()->create();
    $this->createTestPaymentMethod($organization);

    $this->simulateGatewayTimeout();

    expect(fn() => $this->processTestPayment($organization, 10000))
        ->toThrow(\Exception::class, 'timeout');
});
```

### Integration Tests Using Trait

**File:** `tests/Feature/Enterprise/PaymentProcessingWithTraitTest.php`

```php
<?php

use Tests\Traits\PaymentTestingTrait;
use Tests\Traits\OrganizationTestingTrait;
use App\Models\Organization;
use App\Services\Enterprise\PaymentService;

uses(PaymentTestingTrait::class, OrganizationTestingTrait::class);

beforeEach(function () {
    $this->setupPaymentMocks();
    $this->setupOrganizationContext();
});

it('processes payment end-to-end', function () {
    $organization = $this->createTestOrganization();
    $paymentMethod = $this->createTestPaymentMethod($organization, 'card');

    $paymentService = app(PaymentService::class);
    $transaction = $paymentService->processPayment($organization, $paymentMethod, 15000);

    $this->assertPaymentSucceeded($transaction);
    expect($transaction->amount)->toBe(15000)
        ->and($transaction->organization_id)->toBe($organization->id);
});

it('handles webhook for subscription renewal', function () {
    $organization = $this->createTestOrganization();
    $subscription = $this->createTestSubscription($organization);

    $webhook = $this->simulateSubscriptionRenewal($subscription);

    // Post webhook to controller
    $response = $this->post('/webhooks/stripe',
        json_decode($webhook['payload'], true),
        $webhook['headers']
    );

    $response->assertOk();

    // Verify subscription was renewed
    $subscription->refresh();
    expect($subscription->current_period_end)->toBeGreaterThan(now());
});

it('enforces idempotency for duplicate payment requests', function () {
    $organization = $this->createTestOrganization();
    $paymentMethod = $this->createTestPaymentMethod($organization);
    $idempotencyKey = 'test-key-' . uniqid();

    $paymentService = app(PaymentService::class);

    // Process payment twice with same idempotency key
    $paymentService->processPayment($organization, $paymentMethod, 10000, [
        'idempotency_key' => $idempotencyKey,
    ]);

    $paymentService->processPayment($organization, $paymentMethod, 10000, [
        'idempotency_key' => $idempotencyKey,
    ]);

    // Verify only one transaction was created
    $this->assertIdempotencyKeyPreventsDoubleCharge($idempotencyKey);
});

it('fails over from Stripe to PayPal on decline', function () {
    $organization = $this->createTestOrganization();
    $stripeCard = $this->createDeclinedCard($organization);
    $paypalAccount = $this->createTestPaymentMethod($organization, 'paypal');

    $this->simulatePaymentFailure('card_declined', 'stripe');

    $paymentService = app(PaymentService::class);

    // Attempt payment with Stripe (will fail)
    try {
        $paymentService->processPayment($organization, $stripeCard, 10000);
    } catch (\Exception $e) {
        // Expected to fail, retry with PayPal
        $transaction = $paymentService->processPayment($organization, $paypalAccount, 10000);
        $this->assertPaymentSucceeded($transaction);
    }

    $this->assertGatewayFailover('stripe', 'paypal');
});
```

## Definition of Done

- [ ] PaymentTestingTrait created in `tests/Traits/`
- [ ] FakeStripeGateway implemented with all interface methods
- [ ] FakePayPalGateway implemented with all interface methods
- [ ] FakePaymentGatewayFactory created
- [ ] setupPaymentMocks() method replaces real gateways
- [ ] createTestPaymentMethod() supports card, bank_account, paypal types
- [ ] processTestPayment() wrapper implemented
- [ ] simulatePaymentFailure() supports declined, insufficient_funds, timeout, fraud
- [ ] simulateWebhook() generates valid HMAC signatures
- [ ] Webhook signature verification implemented for both gateways
- [ ] createTestSubscription() helper implemented
- [ ] assertPaymentSucceeded() assertion implemented
- [ ] assertPaymentFailed() assertion implemented
- [ ] assertSubscriptionActive() assertion implemented
- [ ] assertRefundProcessed() assertion implemented
- [ ] assertIdempotencyKeyPreventsDoubleCharge() implemented
- [ ] Special card helpers created (declined, insufficient funds, fraud)
- [ ] Gateway timeout simulation implemented
- [ ] Response delay configuration implemented
- [ ] assertGatewayFailover() implemented
- [ ] simulateSubscriptionRenewal() implemented
- [ ] Comprehensive PHPDoc with usage examples
- [ ] Unit tests for trait methods (10+ tests, >95% coverage)
- [ ] Integration tests using trait in realistic scenarios (8+ tests)
- [ ] Existing payment tests refactored to use trait
- [ ] No external API calls during tests verified
- [ ] All tests run in < 500ms total
- [ ] Code follows Pest testing conventions
- [ ] Laravel Pint formatting applied
- [ ] PHPStan level 5 passing
- [ ] Documentation added to testing guide
- [ ] Code reviewed and approved

## Related Tasks

- **Depends on:** Task 46 (PaymentService implementation)
- **Integrates with:** Task 47 (Webhook handling)
- **Integrates with:** Task 48 (Subscription management)
- **Integrates with:** Task 72 (OrganizationTestingTrait)
- **Used by:** Task 51 (Payment tests with gateway mocking)
- **Used by:** All payment-related feature tests
