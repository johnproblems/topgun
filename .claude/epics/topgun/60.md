---
name: Build ApiUsageMonitoring.vue for real-time API usage visualization
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:14Z
github: https://github.com/johnproblems/topgun/issues/168
depends_on: [54]
parallel: true
conflicts_with: []
---

# Task: Build ApiUsageMonitoring.vue for real-time API usage visualization

## Description

Build a comprehensive Vue.js dashboard component that provides real-time visualization of API usage, rate limiting metrics, and quota enforcement across the Coolify Enterprise platform. This component empowers organization administrators to monitor API consumption patterns, identify usage spikes, track rate limit violations, and optimize API integration strategies through interactive charts and detailed analytics.

**The Monitoring Challenge:**

Enterprise API platforms face constant visibility challenges:
1. **Usage Opacity**: Organizations cannot see which integrations consume the most API resources
2. **Rate Limit Surprises**: Developers hit rate limits without warning, causing production failures
3. **Quota Planning**: Lack of historical data makes capacity planning impossible
4. **Security Blindness**: Unusual API patterns (potential attacks) go undetected
5. **Cost Attribution**: Cannot attribute API costs to specific teams, projects, or applications

Without comprehensive monitoring, organizations operate their API integrations blindly—leading to unexpected outages, inefficient resource usage, and inability to enforce governance policies.

**The Solution:**

ApiUsageMonitoring.vue provides a real-time, multi-dimensional view of API consumption with:

1. **Real-Time Metrics Dashboard**
   - Current API requests per minute with ApexCharts line graphs
   - Active API tokens and their individual usage
   - Rate limit remaining across all tiers (percentage gauges)
   - Top endpoints by request volume (bar charts)

2. **Historical Analytics**
   - 24-hour, 7-day, 30-day usage trends
   - Peak usage time identification
   - Endpoint popularity over time
   - Rate limit violation frequency and patterns

3. **Token-Level Breakdown**
   - Usage per API token with color-coded status
   - Token-specific rate limit consumption
   - Last request timestamp and endpoint
   - Ability-based usage (which scopes are actually used)

4. **Rate Limit Insights**
   - Visual progress bars for rate limit consumption
   - Predictive alerts when approaching limits (80%, 90%, 95%)
   - Reset timer countdown
   - Tier upgrade recommendations based on usage

5. **Security Anomaly Detection**
   - Sudden traffic spikes highlighted
   - Unusual endpoint access patterns
   - Failed authentication attempts
   - IP-based request distribution

6. **Interactive Filters**
   - Filter by date range, endpoint, token, user
   - Export data to CSV/JSON for external analysis
   - Customizable dashboard widgets (drag-and-drop layout)

**Integration Architecture:**

**Data Sources:**
- **Redis Cache**: Real-time rate limit counters (key: `rate_limit:{org_id}:{token_id}:*`)
- **Database Tables**:
  - `api_request_logs` - Historical request data with indexing on timestamp, organization_id, token_id, endpoint
  - `personal_access_tokens` - Sanctum tokens with organization context
  - `api_usage_summary` - Pre-aggregated metrics for fast dashboard loading (updated every 5 minutes)

**WebSocket Integration:**
- Subscribe to Laravel Reverb channel: `organization.{id}.api-usage`
- Receive real-time events: `RequestProcessed`, `RateLimitApproaching`, `AnomalyDetected`
- Update charts without page refresh using Vue reactivity

**Backend API Endpoints:**
- `GET /api/v1/organizations/{org}/api-usage/summary` - Current metrics snapshot
- `GET /api/v1/organizations/{org}/api-usage/timeline?range=24h` - Historical timeline data
- `GET /api/v1/organizations/{org}/api-usage/tokens` - Per-token breakdown
- `GET /api/v1/organizations/{org}/api-usage/endpoints` - Endpoint popularity ranking
- `GET /api/v1/organizations/{org}/api-usage/export?format=csv` - Data export

**Dependencies:**
- **Task 54 (Rate Limiting Middleware)**: Provides the rate limit tracking infrastructure this component visualizes
- **Task 52 (Organization-Scoped Tokens)**: Tokens must include organization context for proper filtering
- **Task 29 (ResourceDashboard.vue)**: Reuse chart components and ApexCharts configuration patterns

**Why This Task is Critical:**

API observability is the difference between reactive firefighting and proactive optimization. Without visibility:
- Developers waste hours debugging why their integration suddenly stops working (rate limits)
- Organizations overpay for API capacity they don't need or underprovision and face outages
- Security incidents (API abuse, credential theft) go undetected until massive damage occurs
- Capacity planning becomes guesswork instead of data-driven decision making

This dashboard transforms API governance from "we hope everything works" to "we know exactly how our APIs are being used and can confidently optimize."

For enterprise customers, API usage monitoring is often a contractual requirement for compliance (SOC 2, ISO 27001) and cost control. Organizations expect this level of visibility in any modern API platform—its absence is a deal-breaker.

## Acceptance Criteria

- [ ] Vue.js 3 Composition API component with reactive data binding
- [ ] Real-time metrics dashboard with auto-refresh every 10 seconds
- [ ] ApexCharts integration for line graphs (timeline), bar charts (endpoints), and gauge charts (rate limits)
- [ ] WebSocket subscription to Laravel Reverb for live updates
- [ ] Historical data visualization with selectable date ranges (24h, 7d, 30d, custom)
- [ ] Per-token usage breakdown with color-coded status indicators
- [ ] Rate limit progress bars with percentage and time-to-reset display
- [ ] Top 10 endpoints by request volume (sortable, filterable)
- [ ] Anomaly detection alerts (visual indicators for spikes, unusual patterns)
- [ ] Export functionality to CSV and JSON formats
- [ ] Responsive design working on desktop, tablet, mobile
- [ ] Dark mode support matching Coolify theme
- [ ] Loading states and skeleton screens for async data
- [ ] Error handling for API failures and WebSocket disconnections
- [ ] Accessibility compliance (ARIA labels, keyboard navigation, screen reader support)
- [ ] Performance optimization: chart data pagination, lazy loading for historical data

## Technical Details

### File Paths

**Vue.js Component:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/ApiUsageMonitoring.vue` (new)

**Supporting Components:**
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/UsageMetricsCard.vue` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/RateLimitGauge.vue` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/TokenUsageTable.vue` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/EndpointRankingChart.vue` (new)
- `/home/topgun/topgun/resources/js/Components/Enterprise/API/UsageTimelineChart.vue` (new)

**Backend Controller:**
- `/home/topgun/topgun/app/Http/Controllers/Api/ApiUsageController.php` (new)

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/ApiUsageAnalyticsService.php` (new)
- `/home/topgun/topgun/app/Contracts/ApiUsageAnalyticsServiceInterface.php` (new)

**Database Schema:**
- `/home/topgun/topgun/database/migrations/2024_xx_xx_create_api_request_logs_table.php` (new)
- `/home/topgun/topgun/database/migrations/2024_xx_xx_create_api_usage_summary_table.php` (new)

**Routes:**
- `/home/topgun/topgun/routes/api.php` (modify - add usage endpoints)
- `/home/topgun/topgun/routes/web.php` (modify - add Inertia page route)

**WebSocket Events:**
- `/home/topgun/topgun/app/Events/Enterprise/ApiRequestProcessed.php` (new)
- `/home/topgun/topgun/app/Events/Enterprise/RateLimitApproaching.php` (new)

### Database Schema

**API Request Logs Table:**

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('api_request_logs', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->nullable()->constrained()->onDelete('set null');
            $table->foreignId('token_id')->nullable()->comment('personal_access_tokens.id');

            $table->string('endpoint', 500)->index(); // API endpoint URL
            $table->string('method', 10); // GET, POST, PUT, DELETE, etc.
            $table->integer('status_code'); // HTTP response status
            $table->integer('response_time_ms')->nullable(); // Response time in milliseconds

            $table->ipAddress('ip_address')->nullable()->index();
            $table->string('user_agent', 500)->nullable();

            $table->json('request_headers')->nullable(); // Store important headers
            $table->json('response_headers')->nullable();

            $table->boolean('rate_limited')->default(false)->index(); // Was this request rate limited?
            $table->string('rate_limit_tier', 50)->nullable(); // Which tier's limit was hit

            $table->timestamp('requested_at')->index(); // When the request occurred

            $table->index(['organization_id', 'requested_at']); // Composite index for queries
            $table->index(['token_id', 'requested_at']); // Token-specific queries
            $table->index(['endpoint', 'requested_at']); // Endpoint analytics
        });

        // Partition by month for better performance with large datasets
        DB::statement("ALTER TABLE api_request_logs PARTITION BY RANGE (YEAR(requested_at) * 100 + MONTH(requested_at)) (
            PARTITION p_2024_10 VALUES LESS THAN (202411),
            PARTITION p_2024_11 VALUES LESS THAN (202412),
            PARTITION p_2024_12 VALUES LESS THAN (202501),
            PARTITION p_future VALUES LESS THAN MAXVALUE
        )");
    }

    public function down(): void
    {
        Schema::dropIfExists('api_request_logs');
    }
};
```

**API Usage Summary Table (Pre-Aggregated Metrics):**

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('api_usage_summary', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->onDelete('cascade');
            $table->foreignId('token_id')->nullable(); // Null for org-wide aggregates

            $table->string('period_type', 20); // '5min', 'hour', 'day', 'month'
            $table->timestamp('period_start')->index();
            $table->timestamp('period_end')->index();

            $table->bigInteger('total_requests')->default(0);
            $table->bigInteger('successful_requests')->default(0); // 2xx responses
            $table->bigInteger('failed_requests')->default(0); // 4xx, 5xx responses
            $table->bigInteger('rate_limited_requests')->default(0);

            $table->integer('avg_response_time_ms')->nullable();
            $table->integer('p95_response_time_ms')->nullable();
            $table->integer('p99_response_time_ms')->nullable();

            $table->json('top_endpoints')->nullable(); // Top 10 endpoints with counts
            $table->json('status_code_distribution')->nullable(); // {"200": 1500, "404": 50, ...}

            $table->unique(['organization_id', 'token_id', 'period_type', 'period_start'], 'unique_summary');
            $table->index(['organization_id', 'period_type', 'period_start']); // Dashboard queries
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('api_usage_summary');
    }
};
```

### ApiUsageMonitoring.vue Component

**File:** `resources/js/Components/Enterprise/API/ApiUsageMonitoring.vue`

```vue
<script setup>
import { ref, onMounted, onUnmounted, computed, watch } from 'vue'
import { usePage } from '@inertiajs/vue3'
import axios from 'axios'
import Echo from 'laravel-echo'
import UsageMetricsCard from './UsageMetricsCard.vue'
import RateLimitGauge from './RateLimitGauge.vue'
import TokenUsageTable from './TokenUsageTable.vue'
import EndpointRankingChart from './EndpointRankingChart.vue'
import UsageTimelineChart from './UsageTimelineChart.vue'

const props = defineProps({
  organizationId: {
    type: Number,
    required: true,
  },
  refreshInterval: {
    type: Number,
    default: 10000, // 10 seconds
  },
})

// State
const currentMetrics = ref({
  requestsPerMinute: 0,
  totalRequestsToday: 0,
  activeTokens: 0,
  rateLimitRemaining: 100,
  rateLimitTotal: 1000,
  rateLimitResetAt: null,
})

const timelineData = ref([])
const tokenUsageData = ref([])
const endpointRankingData = ref([])
const anomalies = ref([])

const selectedDateRange = ref('24h')
const isLoading = ref(false)
const error = ref(null)
const lastUpdated = ref(null)

// WebSocket connection
let echoConnection = null
const isConnected = ref(false)

// Computed
const rateLimitPercentage = computed(() => {
  if (currentMetrics.value.rateLimitTotal === 0) return 0
  return (currentMetrics.value.rateLimitRemaining / currentMetrics.value.rateLimitTotal) * 100
})

const rateLimitStatus = computed(() => {
  const percentage = rateLimitPercentage.value
  if (percentage > 50) return 'healthy'
  if (percentage > 20) return 'warning'
  return 'critical'
})

const timeToReset = computed(() => {
  if (!currentMetrics.value.rateLimitResetAt) return null

  const resetTime = new Date(currentMetrics.value.rateLimitResetAt)
  const now = new Date()
  const diffMs = resetTime - now

  if (diffMs <= 0) return 'Resetting now...'

  const minutes = Math.floor(diffMs / 60000)
  const seconds = Math.floor((diffMs % 60000) / 1000)

  return `${minutes}m ${seconds}s`
})

// Methods
const fetchCurrentMetrics = async () => {
  try {
    const response = await axios.get(`/api/v1/organizations/${props.organizationId}/api-usage/summary`)
    currentMetrics.value = response.data.data
    lastUpdated.value = new Date()
  } catch (err) {
    console.error('Failed to fetch current metrics:', err)
    error.value = 'Failed to load current metrics'
  }
}

const fetchTimelineData = async (range = selectedDateRange.value) => {
  isLoading.value = true
  error.value = null

  try {
    const response = await axios.get(
      `/api/v1/organizations/${props.organizationId}/api-usage/timeline`,
      { params: { range } }
    )
    timelineData.value = response.data.data
  } catch (err) {
    console.error('Failed to fetch timeline data:', err)
    error.value = 'Failed to load timeline data'
  } finally {
    isLoading.value = false
  }
}

const fetchTokenUsage = async () => {
  try {
    const response = await axios.get(`/api/v1/organizations/${props.organizationId}/api-usage/tokens`)
    tokenUsageData.value = response.data.data
  } catch (err) {
    console.error('Failed to fetch token usage:', err)
  }
}

const fetchEndpointRanking = async () => {
  try {
    const response = await axios.get(`/api/v1/organizations/${props.organizationId}/api-usage/endpoints`)
    endpointRankingData.value = response.data.data
  } catch (err) {
    console.error('Failed to fetch endpoint ranking:', err)
  }
}

const exportData = async (format = 'csv') => {
  try {
    const response = await axios.get(
      `/api/v1/organizations/${props.organizationId}/api-usage/export`,
      {
        params: {
          format,
          range: selectedDateRange.value,
        },
        responseType: 'blob',
      }
    )

    // Create download link
    const url = window.URL.createObjectURL(new Blob([response.data]))
    const link = document.createElement('a')
    link.href = url
    link.setAttribute('download', `api-usage-${selectedDateRange.value}.${format}`)
    document.body.appendChild(link)
    link.click()
    link.remove()
  } catch (err) {
    console.error('Failed to export data:', err)
    error.value = 'Failed to export data'
  }
}

const connectWebSocket = () => {
  if (!window.Echo) {
    console.warn('Laravel Echo not configured')
    return
  }

  echoConnection = window.Echo.private(`organization.${props.organizationId}.api-usage`)
    .listen('.request-processed', (event) => {
      // Update current metrics with new request data
      currentMetrics.value.requestsPerMinute = event.requestsPerMinute
      currentMetrics.value.rateLimitRemaining = event.rateLimitRemaining

      // Update timeline with new data point
      if (timelineData.value.length > 0) {
        timelineData.value.push({
          timestamp: event.timestamp,
          requests: event.requestsPerMinute,
        })

        // Keep only last 100 data points for performance
        if (timelineData.value.length > 100) {
          timelineData.value.shift()
        }
      }
    })
    .listen('.rate-limit-approaching', (event) => {
      // Show warning when approaching rate limit
      anomalies.value.push({
        type: 'rate_limit_warning',
        message: `Rate limit ${event.percentage}% consumed`,
        timestamp: new Date(),
        severity: event.percentage > 90 ? 'critical' : 'warning',
      })
    })
    .listen('.anomaly-detected', (event) => {
      // Add security anomaly alert
      anomalies.value.push({
        type: 'security_anomaly',
        message: event.description,
        timestamp: new Date(),
        severity: 'warning',
      })
    })

  isConnected.value = true
}

const disconnectWebSocket = () => {
  if (echoConnection) {
    window.Echo.leave(`organization.${props.organizationId}.api-usage`)
    echoConnection = null
    isConnected.value = false
  }
}

const refreshAllData = async () => {
  await Promise.all([
    fetchCurrentMetrics(),
    fetchTimelineData(),
    fetchTokenUsage(),
    fetchEndpointRanking(),
  ])
}

// Lifecycle
onMounted(async () => {
  await refreshAllData()
  connectWebSocket()

  // Set up auto-refresh interval
  const refreshTimer = setInterval(fetchCurrentMetrics, props.refreshInterval)

  // Cleanup on unmount
  onUnmounted(() => {
    clearInterval(refreshTimer)
    disconnectWebSocket()
  })
})

// Watch date range changes
watch(selectedDateRange, (newRange) => {
  fetchTimelineData(newRange)
})
</script>

<template>
  <div class="api-usage-monitoring">
    <!-- Header -->
    <div class="header">
      <div class="header-content">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-gray-100">
          API Usage Monitoring
        </h2>

        <div class="header-actions">
          <!-- Date Range Selector -->
          <select
            v-model="selectedDateRange"
            class="form-select rounded-lg border-gray-300 dark:border-gray-700"
          >
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
            <option value="30d">Last 30 Days</option>
            <option value="custom">Custom Range</option>
          </select>

          <!-- Export Dropdown -->
          <div class="dropdown">
            <button class="btn btn-secondary">
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
              </svg>
              Export
            </button>
            <div class="dropdown-menu">
              <button @click="exportData('csv')" class="dropdown-item">Export as CSV</button>
              <button @click="exportData('json')" class="dropdown-item">Export as JSON</button>
            </div>
          </div>

          <!-- Refresh Button -->
          <button
            @click="refreshAllData"
            class="btn btn-primary"
            :disabled="isLoading"
          >
            <svg class="w-5 h-5 mr-2" :class="{ 'animate-spin': isLoading }"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            Refresh
          </button>
        </div>
      </div>

      <!-- Connection Status -->
      <div v-if="lastUpdated" class="text-sm text-gray-500 dark:text-gray-400 mt-2">
        Last updated: {{ new Date(lastUpdated).toLocaleTimeString() }}
        <span
          class="ml-4 inline-flex items-center"
          :class="isConnected ? 'text-green-600' : 'text-yellow-600'"
        >
          <span class="h-2 w-2 rounded-full mr-2"
                :class="isConnected ? 'bg-green-600 animate-pulse' : 'bg-yellow-600'" />
          {{ isConnected ? 'Live' : 'Disconnected' }}
        </span>
      </div>
    </div>

    <!-- Error Alert -->
    <div v-if="error" class="alert alert-error mb-6">
      <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
      </svg>
      {{ error }}
    </div>

    <!-- Metrics Overview Cards -->
    <div class="metrics-grid">
      <UsageMetricsCard
        title="Requests per Minute"
        :value="currentMetrics.requestsPerMinute"
        icon="chart-line"
        :trend="{ value: 12.5, direction: 'up' }"
      />

      <UsageMetricsCard
        title="Total Requests Today"
        :value="currentMetrics.totalRequestsToday.toLocaleString()"
        icon="database"
      />

      <UsageMetricsCard
        title="Active API Tokens"
        :value="currentMetrics.activeTokens"
        icon="key"
      />

      <RateLimitGauge
        :percentage="rateLimitPercentage"
        :remaining="currentMetrics.rateLimitRemaining"
        :total="currentMetrics.rateLimitTotal"
        :time-to-reset="timeToReset"
        :status="rateLimitStatus"
      />
    </div>

    <!-- Anomaly Alerts -->
    <div v-if="anomalies.length > 0" class="anomalies-section mb-6">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">
        Recent Alerts
      </h3>
      <div class="space-y-2">
        <div
          v-for="(anomaly, index) in anomalies.slice(0, 5)"
          :key="index"
          class="anomaly-card"
          :class="`anomaly-${anomaly.severity}`"
        >
          <svg class="w-5 h-5 mr-3" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
          </svg>
          <div class="flex-1">
            <p class="font-medium">{{ anomaly.message }}</p>
            <p class="text-sm text-gray-500">{{ new Date(anomaly.timestamp).toLocaleString() }}</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Dashboard Grid -->
    <div class="dashboard-grid">
      <!-- Usage Timeline Chart -->
      <div class="dashboard-card col-span-2">
        <h3 class="card-title">Request Timeline</h3>
        <UsageTimelineChart
          :data="timelineData"
          :loading="isLoading"
          :range="selectedDateRange"
        />
      </div>

      <!-- Endpoint Ranking -->
      <div class="dashboard-card">
        <h3 class="card-title">Top Endpoints</h3>
        <EndpointRankingChart
          :data="endpointRankingData"
          :loading="isLoading"
        />
      </div>

      <!-- Token Usage Table -->
      <div class="dashboard-card col-span-3">
        <h3 class="card-title">API Token Usage</h3>
        <TokenUsageTable
          :tokens="tokenUsageData"
          :loading="isLoading"
        />
      </div>
    </div>
  </div>
</template>

<style scoped>
.api-usage-monitoring {
  @apply p-6 space-y-6;
}

.header {
  @apply bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6;
}

.header-content {
  @apply flex justify-between items-center;
}

.header-actions {
  @apply flex gap-3;
}

.metrics-grid {
  @apply grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6;
}

.dashboard-grid {
  @apply grid grid-cols-1 lg:grid-cols-3 gap-6;
}

.dashboard-card {
  @apply bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6;
}

.card-title {
  @apply text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4;
}

.anomaly-card {
  @apply flex items-start p-4 rounded-lg border;
}

.anomaly-warning {
  @apply bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800 text-yellow-800 dark:text-yellow-200;
}

.anomaly-critical {
  @apply bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200;
}

.btn {
  @apply inline-flex items-center px-4 py-2 border border-transparent rounded-lg font-medium transition-colors;
}

.btn-primary {
  @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2;
}

.btn-secondary {
  @apply bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600;
}

.form-select {
  @apply px-3 py-2 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100;
}

.alert {
  @apply flex items-center p-4 rounded-lg;
}

.alert-error {
  @apply bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-800;
}
</style>
```

### Supporting Component: RateLimitGauge.vue

**File:** `resources/js/Components/Enterprise/API/RateLimitGauge.vue`

```vue
<script setup>
import { computed } from 'vue'

const props = defineProps({
  percentage: {
    type: Number,
    required: true,
  },
  remaining: {
    type: Number,
    required: true,
  },
  total: {
    type: Number,
    required: true,
  },
  timeToReset: {
    type: String,
    default: null,
  },
  status: {
    type: String,
    default: 'healthy', // 'healthy', 'warning', 'critical'
  },
})

const gaugeColor = computed(() => {
  switch (props.status) {
    case 'healthy': return '#10b981'
    case 'warning': return '#f59e0b'
    case 'critical': return '#ef4444'
    default: return '#6b7280'
  }
})

const strokeDasharray = computed(() => {
  const circumference = 2 * Math.PI * 45 // radius = 45
  const offset = circumference * (1 - props.percentage / 100)
  return `${circumference - offset} ${circumference}`
})
</script>

<template>
  <div class="rate-limit-gauge">
    <div class="gauge-container">
      <svg class="gauge-svg" viewBox="0 0 100 100">
        <!-- Background circle -->
        <circle
          cx="50"
          cy="50"
          r="45"
          fill="none"
          stroke="#e5e7eb"
          stroke-width="8"
        />

        <!-- Progress circle -->
        <circle
          cx="50"
          cy="50"
          r="45"
          fill="none"
          :stroke="gaugeColor"
          stroke-width="8"
          stroke-linecap="round"
          :stroke-dasharray="strokeDasharray"
          transform="rotate(-90 50 50)"
          class="progress-circle"
        />
      </svg>

      <!-- Center text -->
      <div class="gauge-text">
        <div class="text-3xl font-bold" :style="{ color: gaugeColor }">
          {{ Math.round(percentage) }}%
        </div>
        <div class="text-sm text-gray-500 dark:text-gray-400">
          {{ remaining.toLocaleString() }} / {{ total.toLocaleString() }}
        </div>
      </div>
    </div>

    <div class="mt-4 text-center">
      <div class="text-sm font-medium text-gray-900 dark:text-gray-100">
        Rate Limit Remaining
      </div>
      <div v-if="timeToReset" class="text-xs text-gray-500 dark:text-gray-400 mt-1">
        Resets in {{ timeToReset }}
      </div>
    </div>
  </div>
</template>

<style scoped>
.rate-limit-gauge {
  @apply bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6;
}

.gauge-container {
  @apply relative w-32 h-32 mx-auto;
}

.gauge-svg {
  @apply w-full h-full;
}

.progress-circle {
  transition: stroke-dasharray 0.3s ease;
}

.gauge-text {
  @apply absolute inset-0 flex flex-col items-center justify-center;
}
</style>
```

### Backend Service: ApiUsageAnalyticsService

**File:** `app/Services/Enterprise/ApiUsageAnalyticsService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\ApiUsageAnalyticsServiceInterface;
use App\Models\Organization;
use App\Models\ApiRequestLog;
use App\Models\ApiUsageSummary;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Redis;
use Carbon\Carbon;

class ApiUsageAnalyticsService implements ApiUsageAnalyticsServiceInterface
{
    /**
     * Get current usage metrics for organization
     *
     * @param Organization $organization
     * @return array
     */
    public function getCurrentMetrics(Organization $organization): array
    {
        $cacheKey = "api_usage_metrics:{$organization->id}:current";

        return Cache::remember($cacheKey, 60, function () use ($organization) {
            // Get rate limit info from Redis
            $rateLimitKey = "rate_limit:{$organization->id}:*";
            $rateLimitData = $this->getRateLimitFromRedis($organization);

            // Get requests in last minute
            $requestsPerMinute = ApiRequestLog::where('organization_id', $organization->id)
                ->where('requested_at', '>=', now()->subMinute())
                ->count();

            // Get total requests today
            $totalToday = ApiRequestLog::where('organization_id', $organization->id)
                ->whereDate('requested_at', today())
                ->count();

            // Get active tokens count
            $activeTokens = DB::table('personal_access_tokens')
                ->where('tokenable_type', 'App\Models\User')
                ->whereIn('tokenable_id', function ($query) use ($organization) {
                    $query->select('users.id')
                        ->from('users')
                        ->join('organization_users', 'users.id', '=', 'organization_users.user_id')
                        ->where('organization_users.organization_id', $organization->id);
                })
                ->where('expires_at', '>', now())
                ->orWhereNull('expires_at')
                ->count();

            return [
                'requestsPerMinute' => $requestsPerMinute,
                'totalRequestsToday' => $totalToday,
                'activeTokens' => $activeTokens,
                'rateLimitRemaining' => $rateLimitData['remaining'],
                'rateLimitTotal' => $rateLimitData['total'],
                'rateLimitResetAt' => $rateLimitData['reset_at'],
            ];
        });
    }

    /**
     * Get timeline data for specified range
     *
     * @param Organization $organization
     * @param string $range '24h', '7d', '30d'
     * @return array
     */
    public function getTimelineData(Organization $organization, string $range): array
    {
        $startDate = match ($range) {
            '24h' => now()->subHours(24),
            '7d' => now()->subDays(7),
            '30d' => now()->subDays(30),
            default => now()->subHours(24),
        };

        $groupBy = match ($range) {
            '24h' => '5 MINUTE',
            '7d' => '1 HOUR',
            '30d' => '1 DAY',
            default => '5 MINUTE',
        };

        $data = DB::table('api_request_logs')
            ->select(
                DB::raw("DATE_FORMAT(requested_at, '%Y-%m-%d %H:%i:00') as timestamp"),
                DB::raw('COUNT(*) as requests'),
                DB::raw('AVG(response_time_ms) as avg_response_time'),
                DB::raw('SUM(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 ELSE 0 END) as successful'),
                DB::raw('SUM(CASE WHEN rate_limited = 1 THEN 1 ELSE 0 END) as rate_limited')
            )
            ->where('organization_id', $organization->id)
            ->where('requested_at', '>=', $startDate)
            ->groupBy(DB::raw("DATE_FORMAT(requested_at, '%Y-%m-%d %H:%i:00')"))
            ->orderBy('timestamp')
            ->get();

        return $data->map(function ($row) {
            return [
                'timestamp' => $row->timestamp,
                'requests' => (int) $row->requests,
                'avgResponseTime' => round($row->avg_response_time, 2),
                'successful' => (int) $row->successful,
                'rateLimited' => (int) $row->rate_limited,
            ];
        })->toArray();
    }

    /**
     * Get per-token usage breakdown
     *
     * @param Organization $organization
     * @return array
     */
    public function getTokenUsage(Organization $organization): array
    {
        $tokens = DB::table('personal_access_tokens as tokens')
            ->select(
                'tokens.id',
                'tokens.name',
                'tokens.last_used_at',
                'tokens.expires_at',
                'users.name as user_name',
                'users.email as user_email'
            )
            ->join('users', 'tokens.tokenable_id', '=', 'users.id')
            ->join('organization_users', 'users.id', '=', 'organization_users.user_id')
            ->where('organization_users.organization_id', $organization->id)
            ->where('tokens.tokenable_type', 'App\Models\User')
            ->get();

        return $tokens->map(function ($token) {
            $requestsToday = ApiRequestLog::where('token_id', $token->id)
                ->whereDate('requested_at', today())
                ->count();

            $requestsThisMonth = ApiRequestLog::where('token_id', $token->id)
                ->whereMonth('requested_at', now()->month)
                ->count();

            $rateLimited = ApiRequestLog::where('token_id', $token->id)
                ->where('rate_limited', true)
                ->whereDate('requested_at', today())
                ->count();

            return [
                'id' => $token->id,
                'name' => $token->name,
                'userName' => $token->user_name,
                'userEmail' => $token->user_email,
                'requestsToday' => $requestsToday,
                'requestsThisMonth' => $requestsThisMonth,
                'rateLimitedRequests' => $rateLimited,
                'lastUsed' => $token->last_used_at,
                'expiresAt' => $token->expires_at,
                'status' => $this->getTokenStatus($token),
            ];
        })->toArray();
    }

    /**
     * Get endpoint popularity ranking
     *
     * @param Organization $organization
     * @param int $limit
     * @return array
     */
    public function getEndpointRanking(Organization $organization, int $limit = 10): array
    {
        return ApiRequestLog::select(
                'endpoint',
                DB::raw('COUNT(*) as total_requests'),
                DB::raw('AVG(response_time_ms) as avg_response_time'),
                DB::raw('SUM(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 ELSE 0 END) as successful'),
                DB::raw('SUM(CASE WHEN status_code >= 400 THEN 1 ELSE 0 END) as failed')
            )
            ->where('organization_id', $organization->id)
            ->whereDate('requested_at', '>=', now()->subDays(7))
            ->groupBy('endpoint')
            ->orderByDesc('total_requests')
            ->limit($limit)
            ->get()
            ->map(function ($row) {
                return [
                    'endpoint' => $row->endpoint,
                    'totalRequests' => (int) $row->total_requests,
                    'avgResponseTime' => round($row->avg_response_time, 2),
                    'successRate' => round(($row->successful / $row->total_requests) * 100, 1),
                    'failed' => (int) $row->failed,
                ];
            })
            ->toArray();
    }

    /**
     * Export usage data
     *
     * @param Organization $organization
     * @param string $format 'csv' or 'json'
     * @param string $range
     * @return string
     */
    public function exportData(Organization $organization, string $format, string $range): string
    {
        $startDate = match ($range) {
            '24h' => now()->subHours(24),
            '7d' => now()->subDays(7),
            '30d' => now()->subDays(30),
            default => now()->subHours(24),
        };

        $data = ApiRequestLog::where('organization_id', $organization->id)
            ->where('requested_at', '>=', $startDate)
            ->select('endpoint', 'method', 'status_code', 'response_time_ms', 'requested_at', 'ip_address')
            ->orderBy('requested_at', 'desc')
            ->get();

        if ($format === 'csv') {
            return $this->convertToCSV($data);
        }

        return $data->toJson(JSON_PRETTY_PRINT);
    }

    /**
     * Get rate limit data from Redis
     *
     * @param Organization $organization
     * @return array
     */
    private function getRateLimitFromRedis(Organization $organization): array
    {
        $license = $organization->enterpriseLicense;

        if (!$license) {
            return [
                'remaining' => 0,
                'total' => 0,
                'reset_at' => null,
            ];
        }

        $tier = $license->tier; // 'starter', 'professional', 'enterprise'
        $limit = config("enterprise.rate_limits.{$tier}.per_minute", 100);

        // Get current usage from Redis
        $key = "rate_limit:{$organization->id}:minute:" . now()->format('Y-m-d-H-i');
        $current = (int) Redis::get($key) ?? 0;

        return [
            'remaining' => max(0, $limit - $current),
            'total' => $limit,
            'reset_at' => now()->endOfMinute()->toISOString(),
        ];
    }

    /**
     * Get token status
     *
     * @param object $token
     * @return string
     */
    private function getTokenStatus(object $token): string
    {
        if ($token->expires_at && Carbon::parse($token->expires_at)->isPast()) {
            return 'expired';
        }

        if (!$token->last_used_at) {
            return 'unused';
        }

        $lastUsed = Carbon::parse($token->last_used_at);

        if ($lastUsed->isToday()) {
            return 'active';
        }

        if ($lastUsed->gt(now()->subDays(7))) {
            return 'recent';
        }

        return 'inactive';
    }

    /**
     * Convert data to CSV format
     *
     * @param \Illuminate\Support\Collection $data
     * @return string
     */
    private function convertToCSV($data): string
    {
        if ($data->isEmpty()) {
            return '';
        }

        $csv = '';

        // Headers
        $headers = array_keys($data->first()->toArray());
        $csv .= implode(',', $headers) . "\n";

        // Rows
        foreach ($data as $row) {
            $values = array_map(function ($value) {
                // Escape commas and quotes
                return '"' . str_replace('"', '""', $value) . '"';
            }, $row->toArray());

            $csv .= implode(',', $values) . "\n";
        }

        return $csv;
    }
}
```

### Backend Controller

**File:** `app/Http/Controllers/Api/ApiUsageController.php`

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Contracts\ApiUsageAnalyticsServiceInterface;
use App\Models\Organization;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Response;

class ApiUsageController extends Controller
{
    public function __construct(
        private ApiUsageAnalyticsServiceInterface $analyticsService
    ) {}

    /**
     * Get current usage metrics
     *
     * @param Organization $organization
     * @return JsonResponse
     */
    public function summary(Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $metrics = $this->analyticsService->getCurrentMetrics($organization);

        return response()->json([
            'data' => $metrics,
        ]);
    }

    /**
     * Get timeline data
     *
     * @param Request $request
     * @param Organization $organization
     * @return JsonResponse
     */
    public function timeline(Request $request, Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $validated = $request->validate([
            'range' => 'required|in:24h,7d,30d,custom',
        ]);

        $data = $this->analyticsService->getTimelineData($organization, $validated['range']);

        return response()->json([
            'data' => $data,
        ]);
    }

    /**
     * Get per-token usage
     *
     * @param Organization $organization
     * @return JsonResponse
     */
    public function tokens(Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $tokens = $this->analyticsService->getTokenUsage($organization);

        return response()->json([
            'data' => $tokens,
        ]);
    }

    /**
     * Get endpoint ranking
     *
     * @param Organization $organization
     * @return JsonResponse
     */
    public function endpoints(Organization $organization): JsonResponse
    {
        $this->authorize('view', $organization);

        $endpoints = $this->analyticsService->getEndpointRanking($organization);

        return response()->json([
            'data' => $endpoints,
        ]);
    }

    /**
     * Export usage data
     *
     * @param Request $request
     * @param Organization $organization
     * @return Response
     */
    public function export(Request $request, Organization $organization): Response
    {
        $this->authorize('view', $organization);

        $validated = $request->validate([
            'format' => 'required|in:csv,json',
            'range' => 'required|in:24h,7d,30d',
        ]);

        $data = $this->analyticsService->exportData(
            $organization,
            $validated['format'],
            $validated['range']
        );

        $contentType = $validated['format'] === 'csv'
            ? 'text/csv'
            : 'application/json';

        return response($data)
            ->header('Content-Type', $contentType)
            ->header('Content-Disposition', "attachment; filename=api-usage-{$validated['range']}.{$validated['format']}");
    }
}
```

### Routes

**File:** `routes/api.php` (add to existing routes)

```php
// API Usage Monitoring
Route::middleware(['auth:sanctum', 'organization'])->group(function () {
    Route::prefix('organizations/{organization}')->group(function () {
        Route::get('/api-usage/summary', [ApiUsageController::class, 'summary'])
            ->name('api.usage.summary');

        Route::get('/api-usage/timeline', [ApiUsageController::class, 'timeline'])
            ->name('api.usage.timeline');

        Route::get('/api-usage/tokens', [ApiUsageController::class, 'tokens'])
            ->name('api.usage.tokens');

        Route::get('/api-usage/endpoints', [ApiUsageController::class, 'endpoints'])
            ->name('api.usage.endpoints');

        Route::get('/api-usage/export', [ApiUsageController::class, 'export'])
            ->name('api.usage.export');
    });
});
```

## Implementation Approach

### Step 1: Database Setup
1. Create migrations for `api_request_logs` and `api_usage_summary` tables
2. Add indexes for performance optimization
3. Configure table partitioning for time-series data
4. Run migrations: `php artisan migrate`

### Step 2: Backend Service Layer
1. Create `ApiUsageAnalyticsServiceInterface` in `app/Contracts/`
2. Implement `ApiUsageAnalyticsService` in `app/Services/Enterprise/`
3. Register service in `EnterpriseServiceProvider`
4. Add rate limit tracking to Redis in existing rate limit middleware

### Step 3: API Endpoints
1. Create `ApiUsageController` with all CRUD endpoints
2. Register routes in `routes/api.php`
3. Test endpoints with Postman/Insomnia
4. Add authorization checks using policies

### Step 4: WebSocket Events
1. Create `ApiRequestProcessed` event
2. Create `RateLimitApproaching` event
3. Configure Laravel Reverb broadcasting
4. Test WebSocket connections

### Step 5: Main Vue Component
1. Create `ApiUsageMonitoring.vue` main dashboard
2. Implement data fetching with axios
3. Set up WebSocket connection with Laravel Echo
4. Add auto-refresh timer
5. Implement date range filtering

### Step 6: Supporting Components
1. Create `UsageMetricsCard.vue` for metric display
2. Create `RateLimitGauge.vue` with SVG gauge visualization
3. Create `TokenUsageTable.vue` with sortable columns
4. Create `EndpointRankingChart.vue` using ApexCharts
5. Create `UsageTimelineChart.vue` using ApexCharts

### Step 7: Chart Integration
1. Install ApexCharts: `npm install apexcharts vue3-apexcharts`
2. Configure chart themes for dark mode
3. Implement responsive chart sizing
4. Add chart export functionality

### Step 8: Export Functionality
1. Implement CSV export in `ApiUsageAnalyticsService`
2. Implement JSON export
3. Add download triggers in Vue component
4. Test export with large datasets

### Step 9: Testing
1. Write unit tests for `ApiUsageAnalyticsService`
2. Write integration tests for API endpoints
3. Write Vue component tests with Vitest
4. Test WebSocket functionality
5. Performance test with large data volumes

### Step 10: Documentation and Polish
1. Add PHPDoc blocks to all methods
2. Document Vue component props and events
3. Add README for API usage monitoring feature
4. Polish UI/UX based on feedback

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/ApiUsageAnalyticsServiceTest.php`

```php
<?php

use App\Services\Enterprise\ApiUsageAnalyticsService;
use App\Models\Organization;
use App\Models\ApiRequestLog;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Redis;

uses(RefreshDatabase::class);

beforeEach(function () {
    $this->service = app(ApiUsageAnalyticsService::class);
    Cache::flush();
    Redis::flushdb();
});

it('gets current metrics for organization', function () {
    $organization = Organization::factory()->create();

    // Create some request logs
    ApiRequestLog::factory()->count(50)->create([
        'organization_id' => $organization->id,
        'requested_at' => now()->subSeconds(30),
    ]);

    $metrics = $this->service->getCurrentMetrics($organization);

    expect($metrics)->toHaveKeys([
        'requestsPerMinute',
        'totalRequestsToday',
        'activeTokens',
        'rateLimitRemaining',
        'rateLimitTotal',
        'rateLimitResetAt',
    ]);

    expect($metrics['requestsPerMinute'])->toBeGreaterThan(0);
});

it('gets timeline data for 24h range', function () {
    $organization = Organization::factory()->create();

    // Create hourly request logs for last 24 hours
    for ($i = 0; $i < 24; $i++) {
        ApiRequestLog::factory()->count(10)->create([
            'organization_id' => $organization->id,
            'requested_at' => now()->subHours($i),
        ]);
    }

    $timeline = $this->service->getTimelineData($organization, '24h');

    expect($timeline)->toBeArray();
    expect(count($timeline))->toBeGreaterThan(0);
    expect($timeline[0])->toHaveKeys(['timestamp', 'requests', 'avgResponseTime']);
});

it('gets per-token usage breakdown', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    // Create personal access token
    $token = $user->createToken('Test Token', ['read', 'write']);

    // Create request logs for this token
    ApiRequestLog::factory()->count(20)->create([
        'organization_id' => $organization->id,
        'token_id' => $token->accessToken->id,
    ]);

    $tokenUsage = $this->service->getTokenUsage($organization);

    expect($tokenUsage)->toBeArray();
    expect($tokenUsage[0])->toHaveKeys([
        'id',
        'name',
        'requestsToday',
        'status',
    ]);
    expect($tokenUsage[0]['requestsToday'])->toBe(20);
});

it('gets endpoint ranking', function () {
    $organization = Organization::factory()->create();

    // Create requests to different endpoints
    ApiRequestLog::factory()->count(50)->create([
        'organization_id' => $organization->id,
        'endpoint' => '/api/servers',
    ]);

    ApiRequestLog::factory()->count(30)->create([
        'organization_id' => $organization->id,
        'endpoint' => '/api/applications',
    ]);

    $ranking = $this->service->getEndpointRanking($organization, 10);

    expect($ranking)->toBeArray();
    expect($ranking[0]['endpoint'])->toBe('/api/servers');
    expect($ranking[0]['totalRequests'])->toBe(50);
    expect($ranking[1]['endpoint'])->toBe('/api/applications');
});

it('exports data as CSV', function () {
    $organization = Organization::factory()->create();

    ApiRequestLog::factory()->count(10)->create([
        'organization_id' => $organization->id,
    ]);

    $csv = $this->service->exportData($organization, 'csv', '24h');

    expect($csv)->toBeString();
    expect($csv)->toContain('endpoint,method,status_code');
});

it('caches current metrics', function () {
    $organization = Organization::factory()->create();

    // First call - should query database
    $metrics1 = $this->service->getCurrentMetrics($organization);

    // Second call - should use cache
    $metrics2 = $this->service->getCurrentMetrics($organization);

    expect($metrics1)->toBe($metrics2);

    // Verify cache was used
    expect(Cache::has("api_usage_metrics:{$organization->id}:current"))->toBeTrue();
});
```

### Integration Tests

**File:** `tests/Feature/Api/ApiUsageMonitoringTest.php`

```php
<?php

use App\Models\Organization;
use App\Models\User;
use App\Models\ApiRequestLog;
use Illuminate\Support\Facades\Cache;

it('returns current usage metrics via API', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    ApiRequestLog::factory()->count(25)->create([
        'organization_id' => $organization->id,
        'requested_at' => now()->subSeconds(30),
    ]);

    $response = $this->actingAs($user)
        ->getJson("/api/v1/organizations/{$organization->id}/api-usage/summary");

    $response->assertOk()
        ->assertJsonStructure([
            'data' => [
                'requestsPerMinute',
                'totalRequestsToday',
                'activeTokens',
                'rateLimitRemaining',
                'rateLimitTotal',
            ],
        ]);
});

it('returns timeline data via API', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    ApiRequestLog::factory()->count(100)->create([
        'organization_id' => $organization->id,
    ]);

    $response = $this->actingAs($user)
        ->getJson("/api/v1/organizations/{$organization->id}/api-usage/timeline?range=24h");

    $response->assertOk()
        ->assertJsonStructure([
            'data' => [
                '*' => [
                    'timestamp',
                    'requests',
                    'avgResponseTime',
                ],
            ],
        ]);
});

it('exports usage data as CSV', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    ApiRequestLog::factory()->count(50)->create([
        'organization_id' => $organization->id,
    ]);

    $response = $this->actingAs($user)
        ->get("/api/v1/organizations/{$organization->id}/api-usage/export?format=csv&range=24h");

    $response->assertOk()
        ->assertHeader('Content-Type', 'text/csv')
        ->assertHeader('Content-Disposition', 'attachment; filename=api-usage-24h.csv');

    expect($response->getContent())->toContain('endpoint,method,status_code');
});

it('enforces organization authorization', function () {
    $organization1 = Organization::factory()->create();
    $organization2 = Organization::factory()->create();
    $user = User::factory()->create();
    $organization1->users()->attach($user, ['role' => 'admin']);

    // Try to access organization2's data (should fail)
    $response = $this->actingAs($user)
        ->getJson("/api/v1/organizations/{$organization2->id}/api-usage/summary");

    $response->assertForbidden();
});

it('validates timeline range parameter', function () {
    $organization = Organization::factory()->create();
    $user = User::factory()->create();
    $organization->users()->attach($user, ['role' => 'admin']);

    $response = $this->actingAs($user)
        ->getJson("/api/v1/organizations/{$organization->id}/api-usage/timeline?range=invalid");

    $response->assertUnprocessable()
        ->assertJsonValidationErrors('range');
});
```

### Vue Component Tests

**File:** `resources/js/Components/Enterprise/API/__tests__/ApiUsageMonitoring.spec.js`

```javascript
import { mount } from '@vue/test-utils'
import { describe, it, expect, beforeEach, vi } from 'vitest'
import ApiUsageMonitoring from '../ApiUsageMonitoring.vue'
import axios from 'axios'

vi.mock('axios')

describe('ApiUsageMonitoring.vue', () => {
  let wrapper

  beforeEach(() => {
    axios.get.mockResolvedValue({
      data: {
        data: {
          requestsPerMinute: 150,
          totalRequestsToday: 5000,
          activeTokens: 5,
          rateLimitRemaining: 800,
          rateLimitTotal: 1000,
        },
      },
    })

    wrapper = mount(ApiUsageMonitoring, {
      props: {
        organizationId: 1,
      },
    })
  })

  it('renders the dashboard header', () => {
    expect(wrapper.text()).toContain('API Usage Monitoring')
  })

  it('fetches current metrics on mount', async () => {
    await wrapper.vm.$nextTick()

    expect(axios.get).toHaveBeenCalledWith(
      '/api/v1/organizations/1/api-usage/summary'
    )
  })

  it('displays current metrics', async () => {
    await wrapper.vm.$nextTick()

    expect(wrapper.vm.currentMetrics.requestsPerMinute).toBe(150)
    expect(wrapper.vm.currentMetrics.totalRequestsToday).toBe(5000)
  })

  it('calculates rate limit percentage correctly', async () => {
    await wrapper.vm.$nextTick()

    expect(wrapper.vm.rateLimitPercentage).toBe(80)
  })

  it('fetches timeline data when date range changes', async () => {
    await wrapper.vm.$nextTick()

    axios.get.mockResolvedValue({
      data: {
        data: [
          { timestamp: '2024-01-01 10:00:00', requests: 50 },
        ],
      },
    })

    wrapper.vm.selectedDateRange = '7d'
    await wrapper.vm.$nextTick()

    expect(axios.get).toHaveBeenCalledWith(
      '/api/v1/organizations/1/api-usage/timeline',
      { params: { range: '7d' } }
    )
  })

  it('triggers export when export button clicked', async () => {
    axios.get.mockResolvedValue({
      data: new Blob(['test csv data']),
    })

    await wrapper.vm.exportData('csv')

    expect(axios.get).toHaveBeenCalledWith(
      '/api/v1/organizations/1/api-usage/export',
      expect.objectContaining({
        params: {
          format: 'csv',
          range: expect.any(String),
        },
      })
    )
  })

  it('shows error message on API failure', async () => {
    axios.get.mockRejectedValue(new Error('API Error'))

    await wrapper.vm.fetchCurrentMetrics()
    await wrapper.vm.$nextTick()

    expect(wrapper.vm.error).toBeTruthy()
  })
})
```

## Definition of Done

- [ ] Database migrations created for `api_request_logs` and `api_usage_summary` tables
- [ ] Migrations run successfully with indexes and partitioning
- [ ] `ApiUsageAnalyticsService` created implementing `ApiUsageAnalyticsServiceInterface`
- [ ] Service registered in `EnterpriseServiceProvider`
- [ ] `ApiUsageController` created with all CRUD endpoints
- [ ] API routes registered in `routes/api.php`
- [ ] Authorization policies implemented and tested
- [ ] `ApiRequestProcessed` and `RateLimitApproaching` WebSocket events created
- [ ] Laravel Reverb broadcasting configured for API usage channel
- [ ] `ApiUsageMonitoring.vue` main component created with Composition API
- [ ] WebSocket subscription implemented with Laravel Echo
- [ ] Auto-refresh timer working correctly (every 10 seconds)
- [ ] `UsageMetricsCard.vue` component created
- [ ] `RateLimitGauge.vue` component created with SVG gauge
- [ ] `TokenUsageTable.vue` component created with sorting
- [ ] `EndpointRankingChart.vue` component created with ApexCharts
- [ ] `UsageTimelineChart.vue` component created with ApexCharts
- [ ] ApexCharts installed and configured
- [ ] Dark mode support implemented for all charts
- [ ] Date range filtering working (24h, 7d, 30d, custom)
- [ ] CSV export functionality working
- [ ] JSON export functionality working
- [ ] Error handling for API failures
- [ ] Loading states and skeleton screens
- [ ] Responsive design tested on mobile, tablet, desktop
- [ ] Accessibility compliance (ARIA labels, keyboard navigation)
- [ ] Unit tests written for `ApiUsageAnalyticsService` (10+ tests, >90% coverage)
- [ ] Integration tests written for API endpoints (8+ tests)
- [ ] Vue component tests written with Vitest (6+ tests)
- [ ] WebSocket functionality tested
- [ ] Performance tested with large datasets (10k+ records)
- [ ] Documentation updated (PHPDoc blocks, component props)
- [ ] Code follows Laravel 12 and Vue.js 3 best practices
- [ ] PHPStan level 5 passing
- [ ] Laravel Pint formatting applied
- [ ] ESLint passing with zero warnings
- [ ] Code reviewed and approved
- [ ] Manual testing completed with real API usage data
- [ ] Performance benchmarks met (< 200ms API response, < 1s chart render)

## Related Tasks

- **Depends on:** Task 54 (Tiered rate limiting middleware) - Provides rate limit tracking infrastructure
- **Integrates with:** Task 52 (Organization-scoped Sanctum tokens) - Token data for per-token usage
- **Reuses patterns from:** Task 29 (ResourceDashboard.vue) - Chart components and ApexCharts config
- **Complements:** Task 59 (ApiKeyManager.vue) - Token management UI
- **Enhances:** Task 56 (API endpoints for enterprise features) - Adds monitoring to existing APIs
