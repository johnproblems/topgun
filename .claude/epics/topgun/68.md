---
name: Integrate Let's Encrypt for SSL certificate provisioning
status: open
created: 2025-10-06T15:23:47Z
updated: 2025-10-06T20:39:21Z
github: https://github.com/johnproblems/topgun/issues/176
depends_on: [67]
parallel: false
conflicts_with: []
---

# Task: Integrate Let's Encrypt for SSL certificate provisioning

## Description

Implement a comprehensive Let's Encrypt integration for automated SSL/TLS certificate provisioning, renewal, and management within the Coolify Enterprise platform. This service enables organizations to secure their applications and custom domains with free, automatically-renewed SSL certificates from Let's Encrypt's Certificate Authority, eliminating manual certificate management overhead and ensuring continuous HTTPS availability.

**The SSL Certificate Challenge:**

Modern web applications require HTTPS encryption for security, SEO rankings, browser compatibility, and user trust. However, manual SSL certificate management is complex, error-prone, and expensive:

1. **Certificate Acquisition**: Purchasing SSL certificates costs $50-$300+ annually per domain
2. **Manual Renewal**: Certificates expire after 1 year, requiring manual renewal processes
3. **Installation Complexity**: Generating CSRs, validating domains, installing certificates on servers
4. **Multi-Domain Management**: Managing certificates for hundreds of applications across dozens of domains
5. **Expiration Monitoring**: Tracking expiration dates to prevent service disruptions
6. **Security Risks**: Expired certificates cause browser warnings and broken user experiences

**The Let's Encrypt Solution:**

Let's Encrypt provides free, automated SSL certificates with 90-day lifespans, designed for automatic renewal. This integration brings enterprise-grade certificate automation to Coolify:

1. **Automated Provisioning**: Automatically obtain certificates when domains are added
2. **Challenge Validation**: Support HTTP-01 and DNS-01 ACME challenges for domain ownership verification
3. **Auto-Renewal**: Automatically renew certificates 30 days before expiration
4. **Wildcard Support**: Provision wildcard certificates (*.example.com) via DNS-01 challenge
5. **Multi-Domain Certificates**: Single certificate covering multiple SANs (Subject Alternative Names)
6. **Integration with Nginx/Traefik**: Automatically update proxy configurations with new certificates
7. **Certificate Revocation**: Revoke compromised certificates immediately

**Architecture Integration:**

This service integrates deeply with Coolify's infrastructure and domain management systems:

**Upstream Dependencies:**
- **Task 67 (DnsManagementService)**: Creates TXT records for DNS-01 challenge validation
- **Task 62 (Domain Schema)**: Uses `organization_domains` table for domain tracking
- **Existing Proxy System**: Coolify's Nginx/Traefik proxy configuration

**Downstream Consumers:**
- **Task 70 (DomainManager.vue)**: Displays certificate status and expiration dates
- **Application Deployment**: Automatically applies certificates to deployed applications
- **WhiteLabel System**: Enables HTTPS for custom white-label domains

**ACME Protocol Implementation:**

The service implements the ACME (Automated Certificate Management Environment) v2 protocol using the PHP `letsencrypt/letsencrypt` library:

1. **Account Registration**: Create Let's Encrypt account with organization email
2. **Order Creation**: Request certificate for one or more domains
3. **Authorization**: Prove ownership via HTTP-01 or DNS-01 challenges
4. **Certificate Issuance**: Download signed certificate chain
5. **Installation**: Deploy certificate to servers and update proxy configs
6. **Renewal Cycle**: Monitor expiration and auto-renew 30 days before expiry

**Challenge Methods Supported:**

1. **HTTP-01 Challenge** (Default, Simplest):
   - Let's Encrypt requests: `http://example.com/.well-known/acme-challenge/{token}`
   - Service creates temporary file with validation token
   - Works for single domains, not wildcards
   - Requires port 80 accessible

2. **DNS-01 Challenge** (Wildcard Support):
   - Let's Encrypt verifies TXT record: `_acme-challenge.example.com`
   - Service creates DNS record via DnsManagementService (Task 67)
   - Supports wildcard certificates (*.example.com)
   - Works behind firewalls

**Certificate Storage & Security:**

- **Database Storage**: `ssl_certificates` table stores certificate metadata and paths
- **File Storage**: Certificate files stored in encrypted filesystem at `storage/app/ssl/{organization_id}/{domain}/`
- **Private Keys**: Encrypted using Laravel's encryption service (AES-256)
- **Certificate Chain**: Includes full chain (certificate + intermediate certificates)
- **Backup**: Automatic backup to S3-compatible storage for disaster recovery

**Renewal Automation:**

A scheduled job (`SslCertificateRenewalJob`) runs daily to:
1. Query certificates expiring within 30 days
2. Request renewal from Let's Encrypt
3. Validate domain ownership (reuse existing DNS records if possible)
4. Download renewed certificate
5. Update server configurations (Nginx/Traefik reload)
6. Notify administrators on renewal failures

**Why This Task is Critical:**

SSL certificate automation is non-negotiable for enterprise platforms. Manual certificate management doesn't scale beyond 5-10 domains—enterprise organizations often manage hundreds or thousands of domains. Without automation:

- **Operations Overhead**: DevOps teams spend hours monthly on certificate renewals
- **Service Disruptions**: Expired certificates break user access and damage brand reputation
- **Security Risks**: Delayed renewals create windows of vulnerability
- **Cost**: Commercial certificates cost thousands annually at scale

Let's Encrypt automation eliminates these problems entirely. Once implemented, certificates provision and renew automatically, providing continuous HTTPS protection with zero manual intervention. This is a foundational capability that unlocks secure white-label deployments, custom domain support, and enterprise-grade infrastructure management.

## Acceptance Criteria

- [ ] LetsEncryptService implements ACME v2 protocol for certificate lifecycle
- [ ] Support for HTTP-01 challenge validation (automatic .well-known/acme-challenge file creation)
- [ ] Support for DNS-01 challenge validation (integration with DnsManagementService from Task 67)
- [ ] Wildcard certificate provisioning (*.example.com) via DNS-01 challenge
- [ ] Multi-domain SAN certificates (single cert for multiple domains)
- [ ] Automatic certificate renewal 30 days before expiration
- [ ] SslCertificateRenewalJob scheduled daily for renewal checks
- [ ] Certificate revocation capability for compromised certificates
- [ ] Integration with Nginx proxy configuration (auto-update SSL directives)
- [ ] Integration with Traefik proxy configuration (dynamic cert loading)
- [ ] Certificate chain storage (full chain including intermediates)
- [ ] Private key encryption using Laravel encryption service
- [ ] Certificate metadata stored in `ssl_certificates` table
- [ ] Backup certificates to S3-compatible storage
- [ ] Notification system for certificate expiration warnings (7 days, 3 days, 1 day)
- [ ] Admin notifications for renewal failures
- [ ] Rate limit compliance with Let's Encrypt (50 certificates per domain per week)
- [ ] Account registration with organization email
- [ ] Challenge validation status tracking (pending, valid, invalid)
- [ ] Certificate installation verification (HTTPS health check)

## Technical Details

### File Paths

**Service Layer:**
- `/home/topgun/topgun/app/Services/Enterprise/LetsEncryptService.php` (new)
- `/home/topgun/topgun/app/Contracts/LetsEncryptServiceInterface.php` (new)

**Jobs:**
- `/home/topgun/topgun/app/Jobs/Enterprise/SslCertificateProvisioningJob.php` (new)
- `/home/topgun/topgun/app/Jobs/Enterprise/SslCertificateRenewalJob.php` (new)

**Models:**
- `/home/topgun/topgun/app/Models/Enterprise/SslCertificate.php` (new)
- `/home/topgun/topgun/app/Models/Enterprise/AcmeChallenge.php` (new)

**Controllers:**
- `/home/topgun/topgun/app/Http/Controllers/Enterprise/SslCertificateController.php` (new)

**Artisan Commands:**
- `/home/topgun/topgun/app/Console/Commands/RenewSslCertificates.php` (new)
- `/home/topgun/topgun/app/Console/Commands/ProvisionSslCertificate.php` (new)

**ACME Challenge Files:**
- `public/.well-known/acme-challenge/{token}` (HTTP-01 challenges, temporary)

**Certificate Storage:**
- `storage/app/ssl/{organization_id}/{domain}/certificate.pem`
- `storage/app/ssl/{organization_id}/{domain}/private_key.pem` (encrypted)
- `storage/app/ssl/{organization_id}/{domain}/fullchain.pem`
- `storage/app/ssl/{organization_id}/{domain}/chain.pem`

**Configuration:**
- `/home/topgun/topgun/config/letsencrypt.php` (new)

### Database Schema

#### SSL Certificates Table

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('ssl_certificates', function (Blueprint $table) {
            $table->id();
            $table->foreignId('organization_id')->constrained()->onDelete('cascade');
            $table->foreignId('organization_domain_id')->nullable()->constrained()->onDelete('set null');

            // Domain information
            $table->string('domain'); // Primary domain (e.g., example.com)
            $table->json('san_domains')->nullable(); // Subject Alternative Names (additional domains)
            $table->boolean('is_wildcard')->default(false); // Wildcard certificate (*.example.com)

            // Certificate metadata
            $table->text('certificate_path'); // Path to certificate.pem
            $table->text('private_key_path'); // Path to encrypted private_key.pem
            $table->text('fullchain_path'); // Path to fullchain.pem (cert + intermediates)
            $table->text('chain_path')->nullable(); // Path to chain.pem (intermediates only)

            // Let's Encrypt account info
            $table->string('acme_account_url')->nullable(); // Let's Encrypt account URL
            $table->string('acme_order_url')->nullable(); // Certificate order URL

            // Certificate status
            $table->enum('status', ['pending', 'valid', 'renewing', 'expired', 'revoked', 'failed'])->default('pending');
            $table->timestamp('issued_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamp('last_renewed_at')->nullable();
            $table->integer('renewal_attempts')->default(0);
            $table->text('last_error')->nullable();

            // Challenge information
            $table->enum('challenge_type', ['http-01', 'dns-01'])->default('http-01');
            $table->json('challenge_data')->nullable(); // Challenge tokens and validation data

            // Auto-renewal settings
            $table->boolean('auto_renew')->default(true);
            $table->integer('renewal_days_before_expiry')->default(30);

            // Backup information
            $table->string('backup_path')->nullable(); // S3 backup location
            $table->timestamp('last_backup_at')->nullable();

            $table->timestamps();
            $table->softDeletes();

            // Indexes
            $table->index(['organization_id', 'domain']);
            $table->index(['status', 'expires_at']);
            $table->index(['auto_renew', 'expires_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('ssl_certificates');
    }
};
```

#### ACME Challenges Table

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('acme_challenges', function (Blueprint $table) {
            $table->id();
            $table->foreignId('ssl_certificate_id')->constrained()->onDelete('cascade');

            // Challenge details
            $table->string('domain'); // Domain being validated
            $table->enum('type', ['http-01', 'dns-01']); // Challenge type
            $table->string('token'); // Challenge token
            $table->text('authorization_url'); // Let's Encrypt authorization URL

            // Validation data
            $table->text('key_authorization'); // Token.AccountKey for HTTP-01
            $table->string('dns_record_name')->nullable(); // _acme-challenge.example.com for DNS-01
            $table->string('dns_record_value')->nullable(); // TXT record value for DNS-01
            $table->foreignId('dns_record_id')->nullable()->constrained()->onDelete('set null'); // Link to dns_records table

            // Challenge status
            $table->enum('status', ['pending', 'processing', 'valid', 'invalid', 'expired'])->default('pending');
            $table->timestamp('validated_at')->nullable();
            $table->text('error_message')->nullable();

            $table->timestamps();

            // Indexes
            $table->index(['ssl_certificate_id', 'type']);
            $table->index(['status', 'created_at']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('acme_challenges');
    }
};
```

### LetsEncryptService Implementation

**File:** `app/Services/Enterprise/LetsEncryptService.php`

```php
<?php

namespace App\Services\Enterprise;

use App\Contracts\LetsEncryptServiceInterface;
use App\Contracts\DnsManagementServiceInterface;
use App\Models\Organization;
use App\Models\Enterprise\SslCertificate;
use App\Models\Enterprise\AcmeChallenge;
use App\Models\Enterprise\OrganizationDomain;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Crypt;
use AcmePhp\Core\AcmeClient;
use AcmePhp\Core\Http\SecureHttpClient;
use AcmePhp\Ssl\CertificateRequest;
use AcmePhp\Ssl\DistinguishedName;
use AcmePhp\Ssl\Generator\KeyPairGenerator;
use AcmePhp\Ssl\Signer\CertificateRequestSigner;
use GuzzleHttp\Client as GuzzleClient;

class LetsEncryptService implements LetsEncryptServiceInterface
{
    private const ACME_DIRECTORY_URL_PRODUCTION = 'https://acme-v02.api.letsencrypt.org/directory';
    private const ACME_DIRECTORY_URL_STAGING = 'https://acme-staging-v02.api.letsencrypt.org/directory';

    public function __construct(
        private DnsManagementServiceInterface $dnsManagementService
    ) {}

    /**
     * Provision SSL certificate for domain(s)
     *
     * @param Organization $organization
     * @param string $primaryDomain
     * @param array $sanDomains Additional domains for multi-domain certificate
     * @param string $challengeType 'http-01' or 'dns-01'
     * @return SslCertificate
     * @throws \Exception
     */
    public function provisionCertificate(
        Organization $organization,
        string $primaryDomain,
        array $sanDomains = [],
        string $challengeType = 'http-01'
    ): SslCertificate {
        // Validate inputs
        $this->validateDomain($primaryDomain);

        foreach ($sanDomains as $domain) {
            $this->validateDomain($domain);
        }

        // Check for existing certificate
        $existingCert = SslCertificate::where('organization_id', $organization->id)
            ->where('domain', $primaryDomain)
            ->whereIn('status', ['valid', 'pending', 'renewing'])
            ->first();

        if ($existingCert) {
            throw new \Exception("Active certificate already exists for {$primaryDomain}");
        }

        // Create certificate record
        $isWildcard = str_starts_with($primaryDomain, '*.');

        if ($isWildcard && $challengeType !== 'dns-01') {
            throw new \Exception("Wildcard certificates require DNS-01 challenge");
        }

        $certificate = SslCertificate::create([
            'organization_id' => $organization->id,
            'domain' => $primaryDomain,
            'san_domains' => !empty($sanDomains) ? $sanDomains : null,
            'is_wildcard' => $isWildcard,
            'challenge_type' => $challengeType,
            'status' => 'pending',
        ]);

        try {
            // Initialize ACME client
            $acmeClient = $this->createAcmeClient($organization);

            // Create certificate request
            $domains = array_merge([$primaryDomain], $sanDomains);
            $certificateRequest = $this->createCertificateRequest($domains);

            // Request certificate order
            $order = $acmeClient->requestOrder($domains);
            $certificate->acme_order_url = $order->getUrl();
            $certificate->save();

            // Complete authorizations (challenges)
            foreach ($order->getAuthorizations() as $authorization) {
                $domain = $authorization->getDomain();

                if ($challengeType === 'http-01') {
                    $this->completeHttpChallenge($authorization, $certificate, $acmeClient);
                } else {
                    $this->completeDnsChallenge($authorization, $certificate, $acmeClient, $organization);
                }
            }

            // Finalize order and download certificate
            $certificateResponse = $acmeClient->finalizeOrder($order, $certificateRequest);

            // Save certificate files
            $this->saveCertificateFiles($certificate, $certificateResponse);

            // Update certificate status
            $certificate->update([
                'status' => 'valid',
                'issued_at' => now(),
                'expires_at' => now()->addDays(90), // Let's Encrypt certs valid 90 days
            ]);

            // Install certificate on proxies
            $this->installCertificate($certificate);

            // Backup to S3
            $this->backupCertificate($certificate);

            Log::info("SSL certificate provisioned successfully", [
                'organization_id' => $organization->id,
                'domain' => $primaryDomain,
                'certificate_id' => $certificate->id,
            ]);

            return $certificate->fresh();

        } catch (\Exception $e) {
            $certificate->update([
                'status' => 'failed',
                'last_error' => $e->getMessage(),
            ]);

            Log::error("SSL certificate provisioning failed", [
                'organization_id' => $organization->id,
                'domain' => $primaryDomain,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Renew SSL certificate
     *
     * @param SslCertificate $certificate
     * @return SslCertificate
     * @throws \Exception
     */
    public function renewCertificate(SslCertificate $certificate): SslCertificate
    {
        $certificate->update([
            'status' => 'renewing',
            'renewal_attempts' => $certificate->renewal_attempts + 1,
        ]);

        try {
            $organization = $certificate->organization;

            // Prepare domains for renewal
            $domains = array_merge(
                [$certificate->domain],
                $certificate->san_domains ?? []
            );

            // Initialize ACME client
            $acmeClient = $this->createAcmeClient($organization);

            // Create new certificate request
            $certificateRequest = $this->createCertificateRequest($domains);

            // Request new order
            $order = $acmeClient->requestOrder($domains);
            $certificate->acme_order_url = $order->getUrl();
            $certificate->save();

            // Complete authorizations (reuse challenge type)
            foreach ($order->getAuthorizations() as $authorization) {
                if ($certificate->challenge_type === 'http-01') {
                    $this->completeHttpChallenge($authorization, $certificate, $acmeClient);
                } else {
                    $this->completeDnsChallenge($authorization, $certificate, $acmeClient, $organization);
                }
            }

            // Finalize order and download renewed certificate
            $certificateResponse = $acmeClient->finalizeOrder($order, $certificateRequest);

            // Save renewed certificate files
            $this->saveCertificateFiles($certificate, $certificateResponse);

            // Update certificate status
            $certificate->update([
                'status' => 'valid',
                'last_renewed_at' => now(),
                'expires_at' => now()->addDays(90),
                'renewal_attempts' => 0,
                'last_error' => null,
            ]);

            // Reinstall certificate on proxies
            $this->installCertificate($certificate);

            // Backup renewed certificate
            $this->backupCertificate($certificate);

            Log::info("SSL certificate renewed successfully", [
                'certificate_id' => $certificate->id,
                'domain' => $certificate->domain,
            ]);

            return $certificate->fresh();

        } catch (\Exception $e) {
            $certificate->update([
                'status' => 'failed',
                'last_error' => $e->getMessage(),
            ]);

            Log::error("SSL certificate renewal failed", [
                'certificate_id' => $certificate->id,
                'domain' => $certificate->domain,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Revoke SSL certificate
     *
     * @param SslCertificate $certificate
     * @param string $reason Revocation reason (e.g., 'keyCompromise', 'cessationOfOperation')
     * @return bool
     */
    public function revokeCertificate(SslCertificate $certificate, string $reason = 'unspecified'): bool
    {
        try {
            $organization = $certificate->organization;
            $acmeClient = $this->createAcmeClient($organization);

            // Load certificate from file
            $certificateContent = Storage::disk('local')->get($certificate->certificate_path);

            // Revoke via ACME
            $acmeClient->revokeCertificate($certificateContent, $reason);

            // Update status
            $certificate->update([
                'status' => 'revoked',
            ]);

            // Remove from proxies
            $this->uninstallCertificate($certificate);

            Log::info("SSL certificate revoked", [
                'certificate_id' => $certificate->id,
                'domain' => $certificate->domain,
                'reason' => $reason,
            ]);

            return true;

        } catch (\Exception $e) {
            Log::error("SSL certificate revocation failed", [
                'certificate_id' => $certificate->id,
                'error' => $e->getMessage(),
            ]);

            return false;
        }
    }

    /**
     * Create ACME client instance
     *
     * @param Organization $organization
     * @return AcmeClient
     */
    private function createAcmeClient(Organization $organization): AcmeClient
    {
        $directoryUrl = config('letsencrypt.use_staging', false)
            ? self::ACME_DIRECTORY_URL_STAGING
            : self::ACME_DIRECTORY_URL_PRODUCTION;

        $httpClient = new SecureHttpClient(
            $this->getAccountKeyPair($organization),
            new GuzzleClient()
        );

        $acmeClient = new AcmeClient($httpClient, $directoryUrl);

        // Register account if not exists
        $accountEmail = $organization->billing_email ?? $organization->email;
        $acmeClient->registerAccount($accountEmail);

        return $acmeClient;
    }

    /**
     * Get or create account key pair for organization
     *
     * @param Organization $organization
     * @return \AcmePhp\Ssl\KeyPair
     */
    private function getAccountKeyPair(Organization $organization): \AcmePhp\Ssl\KeyPair
    {
        $keyPath = "ssl/{$organization->id}/account/private_key.pem";
        $publicKeyPath = "ssl/{$organization->id}/account/public_key.pem";

        if (Storage::disk('local')->exists($keyPath)) {
            // Load existing key pair
            $privateKey = Crypt::decryptString(Storage::disk('local')->get($keyPath));
            $publicKey = Storage::disk('local')->get($publicKeyPath);

            return new \AcmePhp\Ssl\KeyPair($publicKey, $privateKey);
        }

        // Generate new key pair
        $generator = new KeyPairGenerator();
        $keyPair = $generator->generateKeyPair(4096);

        // Save encrypted private key and public key
        Storage::disk('local')->put(
            $keyPath,
            Crypt::encryptString($keyPair->getPrivateKey())
        );

        Storage::disk('local')->put(
            $publicKeyPath,
            $keyPair->getPublicKey()
        );

        return $keyPair;
    }

    /**
     * Create certificate request for domains
     *
     * @param array $domains
     * @return CertificateRequest
     */
    private function createCertificateRequest(array $domains): CertificateRequest
    {
        $generator = new KeyPairGenerator();
        $keyPair = $generator->generateKeyPair(4096);

        $distinguishedName = new DistinguishedName(
            $domains[0], // Common Name (primary domain)
            'US',
            null, // State
            null, // Locality
            null, // Organization Name
            null, // Organizational Unit
            null, // Email
            $domains  // Subject Alternative Names
        );

        return new CertificateRequest($distinguishedName, $keyPair);
    }

    /**
     * Complete HTTP-01 challenge
     *
     * @param \AcmePhp\Core\Protocol\Authorization $authorization
     * @param SslCertificate $certificate
     * @param AcmeClient $acmeClient
     * @return void
     */
    private function completeHttpChallenge(
        \AcmePhp\Core\Protocol\Authorization $authorization,
        SslCertificate $certificate,
        AcmeClient $acmeClient
    ): void {
        $domain = $authorization->getDomain();
        $challenge = $authorization->getHttpChallenge();

        if (!$challenge) {
            throw new \Exception("HTTP-01 challenge not available for {$domain}");
        }

        // Create ACME challenge record
        $acmeChallenge = AcmeChallenge::create([
            'ssl_certificate_id' => $certificate->id,
            'domain' => $domain,
            'type' => 'http-01',
            'token' => $challenge->getToken(),
            'authorization_url' => $authorization->getUrl(),
            'key_authorization' => $challenge->getPayload(),
            'status' => 'pending',
        ]);

        // Create .well-known/acme-challenge file
        $challengePath = ".well-known/acme-challenge/{$challenge->getToken()}";
        Storage::disk('public')->put($challengePath, $challenge->getPayload());

        // Request validation
        $acmeClient->challengeAuthorization($challenge);

        // Wait for validation (max 60 seconds)
        $maxAttempts = 12;
        $attempt = 0;

        while ($attempt < $maxAttempts) {
            sleep(5);

            $status = $acmeClient->checkAuthorization($authorization);

            if ($status->isValid()) {
                $acmeChallenge->update([
                    'status' => 'valid',
                    'validated_at' => now(),
                ]);

                // Clean up challenge file
                Storage::disk('public')->delete($challengePath);

                return;
            }

            if ($status->isInvalid()) {
                $acmeChallenge->update([
                    'status' => 'invalid',
                    'error_message' => 'Challenge validation failed',
                ]);

                throw new \Exception("HTTP-01 challenge validation failed for {$domain}");
            }

            $attempt++;
        }

        throw new \Exception("HTTP-01 challenge validation timeout for {$domain}");
    }

    /**
     * Complete DNS-01 challenge
     *
     * @param \AcmePhp\Core\Protocol\Authorization $authorization
     * @param SslCertificate $certificate
     * @param AcmeClient $acmeClient
     * @param Organization $organization
     * @return void
     */
    private function completeDnsChallenge(
        \AcmePhp\Core\Protocol\Authorization $authorization,
        SslCertificate $certificate,
        AcmeClient $acmeClient,
        Organization $organization
    ): void {
        $domain = $authorization->getDomain();
        $challenge = $authorization->getDnsChallenge();

        if (!$challenge) {
            throw new \Exception("DNS-01 challenge not available for {$domain}");
        }

        // Strip wildcard prefix if present
        $baseDomain = ltrim($domain, '*.');

        // Calculate DNS record values
        $recordName = "_acme-challenge.{$baseDomain}";
        $recordValue = $challenge->getPayload();

        // Create ACME challenge record
        $acmeChallenge = AcmeChallenge::create([
            'ssl_certificate_id' => $certificate->id,
            'domain' => $domain,
            'type' => 'dns-01',
            'token' => $challenge->getToken(),
            'authorization_url' => $authorization->getUrl(),
            'key_authorization' => $challenge->getPayload(),
            'dns_record_name' => $recordName,
            'dns_record_value' => $recordValue,
            'status' => 'pending',
        ]);

        // Create DNS TXT record via DnsManagementService (Task 67)
        $dnsRecord = $this->dnsManagementService->createRecord(
            $organization,
            $baseDomain,
            'TXT',
            $recordName,
            $recordValue,
            300 // TTL: 5 minutes
        );

        $acmeChallenge->update(['dns_record_id' => $dnsRecord->id]);

        // Wait for DNS propagation (60 seconds)
        Log::info("Waiting for DNS propagation", [
            'domain' => $domain,
            'record_name' => $recordName,
        ]);

        sleep(60);

        // Request validation
        $acmeClient->challengeAuthorization($challenge);

        // Wait for validation (max 120 seconds for DNS)
        $maxAttempts = 24;
        $attempt = 0;

        while ($attempt < $maxAttempts) {
            sleep(5);

            $status = $acmeClient->checkAuthorization($authorization);

            if ($status->isValid()) {
                $acmeChallenge->update([
                    'status' => 'valid',
                    'validated_at' => now(),
                ]);

                // Clean up DNS record
                $this->dnsManagementService->deleteRecord($organization, $dnsRecord->id);

                return;
            }

            if ($status->isInvalid()) {
                $acmeChallenge->update([
                    'status' => 'invalid',
                    'error_message' => 'DNS challenge validation failed',
                ]);

                throw new \Exception("DNS-01 challenge validation failed for {$domain}");
            }

            $attempt++;
        }

        throw new \Exception("DNS-01 challenge validation timeout for {$domain}");
    }

    /**
     * Save certificate files to storage
     *
     * @param SslCertificate $certificate
     * @param \AcmePhp\Ssl\Certificate $certificateResponse
     * @return void
     */
    private function saveCertificateFiles(
        SslCertificate $certificate,
        \AcmePhp\Ssl\Certificate $certificateResponse
    ): void {
        $basePath = "ssl/{$certificate->organization_id}/{$certificate->domain}";

        // Save certificate
        $certPath = "{$basePath}/certificate.pem";
        Storage::disk('local')->put($certPath, $certificateResponse->getPEM());

        // Save private key (encrypted)
        $privateKeyPath = "{$basePath}/private_key.pem";
        Storage::disk('local')->put(
            $privateKeyPath,
            Crypt::encryptString($certificateResponse->getPrivateKey()->getPEM())
        );

        // Save full chain
        $fullchainPath = "{$basePath}/fullchain.pem";
        Storage::disk('local')->put(
            $fullchainPath,
            $certificateResponse->getFullChainPEM()
        );

        // Save intermediate chain
        $chainPath = "{$basePath}/chain.pem";
        Storage::disk('local')->put($chainPath, $certificateResponse->getIssuerChainPEM());

        // Update certificate paths
        $certificate->update([
            'certificate_path' => $certPath,
            'private_key_path' => $privateKeyPath,
            'fullchain_path' => $fullchainPath,
            'chain_path' => $chainPath,
        ]);
    }

    /**
     * Install certificate on Nginx/Traefik proxies
     *
     * @param SslCertificate $certificate
     * @return void
     */
    private function installCertificate(SslCertificate $certificate): void
    {
        // Get decrypted private key
        $privateKey = Crypt::decryptString(
            Storage::disk('local')->get($certificate->private_key_path)
        );

        $fullchain = Storage::disk('local')->get($certificate->fullchain_path);

        // TODO: Integrate with Coolify's proxy configuration system
        // This depends on existing Coolify proxy architecture

        // For Nginx: Update nginx config with ssl_certificate and ssl_certificate_key directives
        // For Traefik: Add certificate to dynamic configuration or file provider

        Log::info("Certificate installed on proxies", [
            'certificate_id' => $certificate->id,
            'domain' => $certificate->domain,
        ]);
    }

    /**
     * Remove certificate from proxies
     *
     * @param SslCertificate $certificate
     * @return void
     */
    private function uninstallCertificate(SslCertificate $certificate): void
    {
        // TODO: Remove from Nginx/Traefik configurations

        Log::info("Certificate removed from proxies", [
            'certificate_id' => $certificate->id,
            'domain' => $certificate->domain,
        ]);
    }

    /**
     * Backup certificate to S3-compatible storage
     *
     * @param SslCertificate $certificate
     * @return void
     */
    private function backupCertificate(SslCertificate $certificate): void
    {
        if (!config('letsencrypt.backup_enabled', false)) {
            return;
        }

        $backupDisk = config('letsencrypt.backup_disk', 's3');
        $backupPath = "ssl-backups/{$certificate->organization_id}/{$certificate->domain}";

        // Backup all certificate files
        Storage::disk($backupDisk)->put(
            "{$backupPath}/certificate.pem",
            Storage::disk('local')->get($certificate->certificate_path)
        );

        Storage::disk($backupDisk)->put(
            "{$backupPath}/private_key.pem",
            Storage::disk('local')->get($certificate->private_key_path)
        );

        Storage::disk($backupDisk)->put(
            "{$backupPath}/fullchain.pem",
            Storage::disk('local')->get($certificate->fullchain_path)
        );

        $certificate->update([
            'backup_path' => $backupPath,
            'last_backup_at' => now(),
        ]);

        Log::info("Certificate backed up to S3", [
            'certificate_id' => $certificate->id,
            'backup_path' => $backupPath,
        ]);
    }

    /**
     * Validate domain format
     *
     * @param string $domain
     * @return void
     * @throws \Exception
     */
    private function validateDomain(string $domain): void
    {
        // Allow wildcards
        $pattern = '/^(\*\.)?([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/';

        if (!preg_match($pattern, $domain)) {
            throw new \Exception("Invalid domain format: {$domain}");
        }
    }

    /**
     * Get certificates expiring soon
     *
     * @param int $daysBeforeExpiry
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function getCertificatesExpiringWithin(int $daysBeforeExpiry): \Illuminate\Database\Eloquent\Collection
    {
        return SslCertificate::where('status', 'valid')
            ->where('auto_renew', true)
            ->where('expires_at', '<=', now()->addDays($daysBeforeExpiry))
            ->where('expires_at', '>', now())
            ->get();
    }
}
```

### Service Interface

**File:** `app/Contracts/LetsEncryptServiceInterface.php`

```php
<?php

namespace App\Contracts;

use App\Models\Organization;
use App\Models\Enterprise\SslCertificate;

interface LetsEncryptServiceInterface
{
    /**
     * Provision SSL certificate for domain(s)
     *
     * @param Organization $organization
     * @param string $primaryDomain
     * @param array $sanDomains
     * @param string $challengeType
     * @return SslCertificate
     */
    public function provisionCertificate(
        Organization $organization,
        string $primaryDomain,
        array $sanDomains = [],
        string $challengeType = 'http-01'
    ): SslCertificate;

    /**
     * Renew SSL certificate
     *
     * @param SslCertificate $certificate
     * @return SslCertificate
     */
    public function renewCertificate(SslCertificate $certificate): SslCertificate;

    /**
     * Revoke SSL certificate
     *
     * @param SslCertificate $certificate
     * @param string $reason
     * @return bool
     */
    public function revokeCertificate(SslCertificate $certificate, string $reason = 'unspecified'): bool;

    /**
     * Get certificates expiring soon
     *
     * @param int $daysBeforeExpiry
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public function getCertificatesExpiringWithin(int $daysBeforeExpiry): \Illuminate\Database\Eloquent\Collection;
}
```

### Background Jobs

**File:** `app/Jobs/Enterprise/SslCertificateProvisioningJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\LetsEncryptServiceInterface;
use App\Models\Organization;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class SslCertificateProvisioningJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $timeout = 600; // 10 minutes
    public int $backoff = 60;

    public function __construct(
        public int $organizationId,
        public string $primaryDomain,
        public array $sanDomains = [],
        public string $challengeType = 'http-01'
    ) {
        $this->onQueue('ssl-provisioning');
    }

    public function handle(LetsEncryptServiceInterface $letsEncryptService): void
    {
        $organization = Organization::find($this->organizationId);

        if (!$organization) {
            Log::error("Organization not found for SSL provisioning", [
                'organization_id' => $this->organizationId,
            ]);
            return;
        }

        try {
            $certificate = $letsEncryptService->provisionCertificate(
                $organization,
                $this->primaryDomain,
                $this->sanDomains,
                $this->challengeType
            );

            Log::info("SSL certificate provisioned via job", [
                'organization_id' => $organization->id,
                'certificate_id' => $certificate->id,
                'domain' => $this->primaryDomain,
            ]);
        } catch (\Exception $e) {
            Log::error("SSL certificate provisioning job failed", [
                'organization_id' => $organization->id,
                'domain' => $this->primaryDomain,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    public function failed(\Throwable $exception): void
    {
        Log::error("SSL certificate provisioning job failed permanently", [
            'organization_id' => $this->organizationId,
            'domain' => $this->primaryDomain,
            'error' => $exception->getMessage(),
        ]);
    }

    public function tags(): array
    {
        return [
            'ssl',
            'provisioning',
            "organization:{$this->organizationId}",
            "domain:{$this->primaryDomain}",
        ];
    }
}
```

**File:** `app/Jobs/Enterprise/SslCertificateRenewalJob.php`

```php
<?php

namespace App\Jobs\Enterprise;

use App\Contracts\LetsEncryptServiceInterface;
use App\Models\Enterprise\SslCertificate;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Notification;
use App\Notifications\SslCertificateRenewalFailed;

class SslCertificateRenewalJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $timeout = 600; // 10 minutes
    public int $backoff = 300; // 5 minutes

    public function __construct()
    {
        $this->onQueue('ssl-renewal');
    }

    public function handle(LetsEncryptServiceInterface $letsEncryptService): void
    {
        // Get certificates expiring within 30 days
        $expiringCertificates = $letsEncryptService->getCertificatesExpiringWithin(30);

        Log::info("SSL certificate renewal check", [
            'expiring_count' => $expiringCertificates->count(),
        ]);

        foreach ($expiringCertificates as $certificate) {
            try {
                $renewed = $letsEncryptService->renewCertificate($certificate);

                Log::info("SSL certificate renewed", [
                    'certificate_id' => $renewed->id,
                    'domain' => $renewed->domain,
                    'expires_at' => $renewed->expires_at,
                ]);
            } catch (\Exception $e) {
                Log::error("SSL certificate renewal failed", [
                    'certificate_id' => $certificate->id,
                    'domain' => $certificate->domain,
                    'error' => $e->getMessage(),
                ]);

                // Notify organization admins on renewal failure
                $admins = $certificate->organization->users()->where('role', 'admin')->get();

                Notification::send($admins, new SslCertificateRenewalFailed($certificate));
            }
        }
    }

    public function tags(): array
    {
        return ['ssl', 'renewal', 'scheduled'];
    }
}
```

### Artisan Commands

**File:** `app/Console/Commands/RenewSslCertificates.php`

```php
<?php

namespace App\Console\Commands;

use App\Jobs\Enterprise\SslCertificateRenewalJob;
use Illuminate\Console\Command;

class RenewSslCertificates extends Command
{
    protected $signature = 'ssl:renew-certificates
                            {--sync : Run synchronously instead of queuing}';

    protected $description = 'Check and renew expiring SSL certificates';

    public function handle(): int
    {
        $this->info('Checking for expiring SSL certificates...');

        if ($this->option('sync')) {
            // Run synchronously
            $job = new SslCertificateRenewalJob();
            $job->handle(app(\App\Contracts\LetsEncryptServiceInterface::class));

            $this->info('✓ Certificate renewal check completed');
        } else {
            // Dispatch to queue
            SslCertificateRenewalJob::dispatch();

            $this->info('✓ Certificate renewal job dispatched to queue');
        }

        return self::SUCCESS;
    }
}
```

**File:** `app/Console/Commands/ProvisionSslCertificate.php`

```php
<?php

namespace App\Console\Commands;

use App\Contracts\LetsEncryptServiceInterface;
use App\Models\Organization;
use Illuminate\Console\Command;

class ProvisionSslCertificate extends Command
{
    protected $signature = 'ssl:provision
                            {organization : Organization ID or slug}
                            {domain : Primary domain for certificate}
                            {--san=* : Additional SAN domains}
                            {--challenge=http-01 : Challenge type (http-01 or dns-01)}
                            {--wildcard : Provision wildcard certificate (sets challenge to dns-01)}';

    protected $description = 'Provision SSL certificate for domain';

    public function handle(LetsEncryptServiceInterface $letsEncryptService): int
    {
        $orgIdOrSlug = $this->argument('organization');
        $primaryDomain = $this->argument('domain');
        $sanDomains = $this->option('san') ?? [];
        $challengeType = $this->option('challenge');

        // Handle wildcard flag
        if ($this->option('wildcard')) {
            if (!str_starts_with($primaryDomain, '*.')) {
                $primaryDomain = "*.{$primaryDomain}";
            }
            $challengeType = 'dns-01';
        }

        // Find organization
        $organization = Organization::where('id', $orgIdOrSlug)
            ->orWhere('slug', $orgIdOrSlug)
            ->first();

        if (!$organization) {
            $this->error("Organization not found: {$orgIdOrSlug}");
            return self::FAILURE;
        }

        $this->info("Provisioning SSL certificate...");
        $this->info("Organization: {$organization->name}");
        $this->info("Primary Domain: {$primaryDomain}");

        if (!empty($sanDomains)) {
            $this->info("SAN Domains: " . implode(', ', $sanDomains));
        }

        $this->info("Challenge Type: {$challengeType}");

        try {
            $certificate = $letsEncryptService->provisionCertificate(
                $organization,
                $primaryDomain,
                $sanDomains,
                $challengeType
            );

            $this->newLine();
            $this->info('✓ SSL certificate provisioned successfully!');
            $this->table(
                ['Field', 'Value'],
                [
                    ['Certificate ID', $certificate->id],
                    ['Domain', $certificate->domain],
                    ['Status', $certificate->status],
                    ['Issued At', $certificate->issued_at],
                    ['Expires At', $certificate->expires_at],
                    ['Challenge Type', $certificate->challenge_type],
                ]
            );

            return self::SUCCESS;
        } catch (\Exception $e) {
            $this->error("SSL certificate provisioning failed: {$e->getMessage()}");
            return self::FAILURE;
        }
    }
}
```

### Configuration File

**File:** `config/letsencrypt.php`

```php
<?php

return [
    /**
     * Use Let's Encrypt staging environment for testing
     */
    'use_staging' => env('LETSENCRYPT_STAGING', false),

    /**
     * Backup certificates to S3-compatible storage
     */
    'backup_enabled' => env('LETSENCRYPT_BACKUP_ENABLED', true),

    /**
     * Disk for certificate backups
     */
    'backup_disk' => env('LETSENCRYPT_BACKUP_DISK', 's3'),

    /**
     * Days before expiration to trigger renewal
     */
    'renewal_days_before_expiry' => env('LETSENCRYPT_RENEWAL_DAYS', 30),

    /**
     * DNS propagation wait time (seconds)
     */
    'dns_propagation_wait' => env('LETSENCRYPT_DNS_WAIT', 60),

    /**
     * Challenge validation timeout (seconds)
     */
    'challenge_timeout' => env('LETSENCRYPT_CHALLENGE_TIMEOUT', 300),
];
```

### Scheduler Configuration

**File:** `app/Console/Kernel.php` (add to schedule method)

```php
protected function schedule(Schedule $schedule): void
{
    // ... existing scheduled tasks ...

    // Renew SSL certificates daily at 3 AM
    $schedule->job(new SslCertificateRenewalJob())
        ->dailyAt('03:00')
        ->name('ssl-certificate-renewal')
        ->withoutOverlapping()
        ->onOneServer();
}
```

## Implementation Approach

### Step 1: Install ACME PHP Library
```bash
composer require acmephp/core acmephp/ssl
```

### Step 2: Create Database Migrations
1. Create `ssl_certificates` table migration
2. Create `acme_challenges` table migration
3. Run migrations: `php artisan migrate`

### Step 3: Create Models
1. Create `SslCertificate` model with relationships and accessors
2. Create `AcmeChallenge` model with relationships
3. Define Eloquent relationships

### Step 4: Implement LetsEncryptService
1. Create `LetsEncryptServiceInterface` in `app/Contracts/`
2. Implement `LetsEncryptService` in `app/Services/Enterprise/`
3. Add ACME client initialization
4. Implement `provisionCertificate()` method
5. Implement HTTP-01 challenge handling
6. Implement DNS-01 challenge handling (integrate with DnsManagementService)
7. Implement `renewCertificate()` method
8. Implement `revokeCertificate()` method
9. Add certificate file storage and encryption

### Step 5: Create Background Jobs
1. Create `SslCertificateProvisioningJob` for async provisioning
2. Create `SslCertificateRenewalJob` for scheduled renewals
3. Configure job queues and retry logic
4. Add Horizon tags for monitoring

### Step 6: Integrate with Proxy Configuration
1. Research Coolify's existing Nginx/Traefik configuration system
2. Implement `installCertificate()` method to update proxy configs
3. Implement `uninstallCertificate()` method
4. Add proxy reload/restart logic

### Step 7: Create Artisan Commands
1. Create `ProvisionSslCertificate` command for manual provisioning
2. Create `RenewSslCertificates` command for manual renewal
3. Add command options and validation
4. Test commands with various scenarios

### Step 8: Add Scheduler Configuration
1. Schedule `SslCertificateRenewalJob` to run daily
2. Configure `withoutOverlapping()` and `onOneServer()`
3. Test scheduled execution

### Step 9: Implement S3 Backup
1. Configure S3-compatible storage disk
2. Implement `backupCertificate()` method
3. Test backup and restore procedures

### Step 10: Create Notifications
1. Create `SslCertificateRenewalFailed` notification
2. Create `SslCertificateExpiringSoon` notification
3. Send to organization admins

### Step 11: Testing
1. Write unit tests for LetsEncryptService methods
2. Write integration tests for certificate lifecycle
3. Test HTTP-01 and DNS-01 challenges
4. Test renewal automation
5. Test revocation
6. Test error handling and retries

## Test Strategy

### Unit Tests

**File:** `tests/Unit/Services/LetsEncryptServiceTest.php`

```php
<?php

use App\Services\Enterprise\LetsEncryptService;
use App\Models\Organization;
use App\Models\Enterprise\SslCertificate;
use Illuminate\Support\Facades\Storage;
use Mockery;

beforeEach(function () {
    Storage::fake('local');
    Storage::fake('s3');
});

it('validates domain format correctly', function () {
    $service = app(LetsEncryptService::class);

    expect(fn() => invade($service)->validateDomain('example.com'))
        ->not->toThrow(\Exception::class);

    expect(fn() => invade($service)->validateDomain('*.example.com'))
        ->not->toThrow(\Exception::class);

    expect(fn() => invade($service)->validateDomain('invalid domain'))
        ->toThrow(\Exception::class);
});

it('creates account key pair for organization', function () {
    $organization = Organization::factory()->create();
    $service = app(LetsEncryptService::class);

    $keyPair = invade($service)->getAccountKeyPair($organization);

    expect($keyPair)->toBeInstanceOf(\AcmePhp\Ssl\KeyPair::class);

    // Verify keys are stored
    Storage::disk('local')->assertExists("ssl/{$organization->id}/account/private_key.pem");
    Storage::disk('local')->assertExists("ssl/{$organization->id}/account/public_key.pem");
});

it('saves certificate files correctly', function () {
    $organization = Organization::factory()->create();
    $certificate = SslCertificate::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
    ]);

    // Mock certificate response
    $mockCertResponse = Mockery::mock(\AcmePhp\Ssl\Certificate::class);
    $mockCertResponse->shouldReceive('getPEM')->andReturn('cert-content');
    $mockCertResponse->shouldReceive('getPrivateKey->getPEM')->andReturn('private-key');
    $mockCertResponse->shouldReceive('getFullChainPEM')->andReturn('fullchain');
    $mockCertResponse->shouldReceive('getIssuerChainPEM')->andReturn('chain');

    $service = app(LetsEncryptService::class);
    invade($service)->saveCertificateFiles($certificate, $mockCertResponse);

    // Verify files stored
    Storage::disk('local')->assertExists("ssl/{$organization->id}/example.com/certificate.pem");
    Storage::disk('local')->assertExists("ssl/{$organization->id}/example.com/private_key.pem");
    Storage::disk('local')->assertExists("ssl/{$organization->id}/example.com/fullchain.pem");

    // Verify certificate updated
    $certificate->refresh();
    expect($certificate->certificate_path)->not->toBeNull();
    expect($certificate->private_key_path)->not->toBeNull();
});

it('gets certificates expiring within specified days', function () {
    $org = Organization::factory()->create();

    // Certificate expiring in 20 days (should be included)
    SslCertificate::factory()->create([
        'organization_id' => $org->id,
        'status' => 'valid',
        'auto_renew' => true,
        'expires_at' => now()->addDays(20),
    ]);

    // Certificate expiring in 40 days (should NOT be included)
    SslCertificate::factory()->create([
        'organization_id' => $org->id,
        'status' => 'valid',
        'auto_renew' => true,
        'expires_at' => now()->addDays(40),
    ]);

    // Certificate already expired (should NOT be included)
    SslCertificate::factory()->create([
        'organization_id' => $org->id,
        'status' => 'valid',
        'auto_renew' => true,
        'expires_at' => now()->subDays(5),
    ]);

    $service = app(LetsEncryptService::class);
    $expiring = $service->getCertificatesExpiringWithin(30);

    expect($expiring)->toHaveCount(1);
    expect($expiring->first()->expires_at)->toEqual(now()->addDays(20)->format('Y-m-d H:i:s'));
});
```

### Integration Tests

**File:** `tests/Feature/Enterprise/SslCertificateProvisioningTest.php`

```php
<?php

use App\Services\Enterprise\LetsEncryptService;
use App\Models\Organization;
use App\Models\Enterprise\SslCertificate;
use App\Models\Enterprise\AcmeChallenge;
use Illuminate\Support\Facades\Storage;
use Mockery;

it('provisions SSL certificate with HTTP-01 challenge', function () {
    Storage::fake('local');
    Storage::fake('public');

    $organization = Organization::factory()->create();

    // Mock ACME client
    // In real test, use Let's Encrypt staging environment or mock AcmeClient

    $service = app(LetsEncryptService::class);

    // This test would require integration with Let's Encrypt staging
    // For unit testing, mock the AcmeClient and test the flow

    expect(true)->toBeTrue(); // Placeholder
})->skip('Requires Let\'s Encrypt staging environment');

it('renews expiring certificate successfully', function () {
    Storage::fake('local');

    $organization = Organization::factory()->create();
    $certificate = SslCertificate::factory()->create([
        'organization_id' => $organization->id,
        'domain' => 'example.com',
        'status' => 'valid',
        'expires_at' => now()->addDays(20),
        'auto_renew' => true,
    ]);

    // Mock renewal process
    // In production, this would call Let's Encrypt

    expect($certificate->status)->toBe('valid');
})->skip('Requires Let\'s Encrypt staging environment');

it('handles provisioning failure gracefully', function () {
    $organization = Organization::factory()->create();

    $service = app(LetsEncryptService::class);

    expect(fn() => $service->provisionCertificate(
        $organization,
        'invalid..domain',
        [],
        'http-01'
    ))->toThrow(\Exception::class);
});
```

### Job Tests

**File:** `tests/Feature/Jobs/SslCertificateRenewalJobTest.php`

```php
<?php

use App\Jobs\Enterprise\SslCertificateRenewalJob;
use App\Models\Organization;
use App\Models\Enterprise\SslCertificate;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\Notification;

it('renews certificates expiring within 30 days', function () {
    Queue::fake();
    Notification::fake();

    $org = Organization::factory()->create();

    $expiringCert = SslCertificate::factory()->create([
        'organization_id' => $org->id,
        'status' => 'valid',
        'auto_renew' => true,
        'expires_at' => now()->addDays(20),
    ]);

    // Dispatch job
    SslCertificateRenewalJob::dispatch();

    Queue::assertPushedOn('ssl-renewal', SslCertificateRenewalJob::class);
});

it('sends notification on renewal failure', function () {
    Notification::fake();

    // This would test notification sending on renewal failure
    // Mock the LetsEncryptService to throw an exception

    expect(true)->toBeTrue(); // Placeholder
})->skip('Requires service mocking');
```

### Artisan Command Tests

**File:** `tests/Feature/Commands/ProvisionSslCertificateCommandTest.php`

```php
<?php

use App\Models\Organization;

it('provisions certificate via artisan command', function () {
    $organization = Organization::factory()->create(['slug' => 'test-org']);

    $this->artisan('ssl:provision', [
        'organization' => 'test-org',
        'domain' => 'example.com',
        '--challenge' => 'http-01',
    ])->assertSuccessful();
})->skip('Requires Let\'s Encrypt staging environment');

it('handles wildcard flag correctly', function () {
    $organization = Organization::factory()->create(['slug' => 'test-org']);

    $this->artisan('ssl:provision', [
        'organization' => 'test-org',
        'domain' => 'example.com',
        '--wildcard' => true,
    ])->assertSuccessful();

    // Verify domain was prefixed with *. and challenge set to dns-01
})->skip('Requires Let\'s Encrypt staging environment');

it('fails gracefully for non-existent organization', function () {
    $this->artisan('ssl:provision', [
        'organization' => 'non-existent',
        'domain' => 'example.com',
    ])->assertFailed()
        ->expectsOutput('Organization not found: non-existent');
});
```

## Definition of Done

- [ ] `acmephp/core` and `acmephp/ssl` libraries installed via Composer
- [ ] `ssl_certificates` table migration created and executed
- [ ] `acme_challenges` table migration created and executed
- [ ] `SslCertificate` model created with relationships and accessors
- [ ] `AcmeChallenge` model created with relationships
- [ ] `LetsEncryptServiceInterface` created in `app/Contracts/`
- [ ] `LetsEncryptService` implemented in `app/Services/Enterprise/`
- [ ] Service registered in `EnterpriseServiceProvider`
- [ ] ACME client initialization implemented
- [ ] `provisionCertificate()` method implemented
- [ ] HTTP-01 challenge validation implemented
- [ ] DNS-01 challenge validation implemented (integrated with DnsManagementService)
- [ ] `renewCertificate()` method implemented
- [ ] `revokeCertificate()` method implemented
- [ ] Certificate file storage and encryption implemented
- [ ] Account key pair generation and storage implemented
- [ ] `SslCertificateProvisioningJob` created and configured
- [ ] `SslCertificateRenewalJob` created and configured
- [ ] Job queues configured ('ssl-provisioning', 'ssl-renewal')
- [ ] Horizon tags implemented for job monitoring
- [ ] Integration with Nginx/Traefik proxy configuration completed
- [ ] `installCertificate()` method implemented
- [ ] `uninstallCertificate()` method implemented
- [ ] `ProvisionSslCertificate` Artisan command created
- [ ] `RenewSslCertificates` Artisan command created
- [ ] Scheduler configured for daily renewal checks (3:00 AM)
- [ ] S3 certificate backup implemented
- [ ] Certificate backup tested and verified
- [ ] `SslCertificateRenewalFailed` notification created
- [ ] `SslCertificateExpiringSoon` notification created
- [ ] Notification system tested
- [ ] Unit tests written for LetsEncryptService (10+ tests, >90% coverage)
- [ ] Integration tests written for certificate lifecycle (5+ tests)
- [ ] Job tests written (3+ tests)
- [ ] Artisan command tests written (3+ tests)
- [ ] Manual testing with Let's Encrypt staging environment
- [ ] Wildcard certificate provisioning tested
- [ ] Multi-domain SAN certificate tested
- [ ] Renewal automation tested (simulate expiring certificates)
- [ ] Revocation tested
- [ ] Error handling and retry logic tested
- [ ] Rate limit compliance verified (Let's Encrypt limits)
- [ ] Configuration file created (`config/letsencrypt.php`)
- [ ] Environment variables documented
- [ ] Code follows Laravel 12 and Coolify coding standards
- [ ] Laravel Pint formatting applied (`./vendor/bin/pint`)
- [ ] PHPStan level 5 passing with zero errors
- [ ] Documentation updated with usage examples
- [ ] Integration guide written for existing Coolify proxy system
- [ ] Code reviewed and approved
- [ ] Deployed to staging environment
- [ ] Production deployment plan created
- [ ] Monitoring and alerting configured for certificate renewals

## Related Tasks

- **Depends on:** Task 67 (DnsManagementService) - DNS-01 challenge requires DNS record creation
- **Depends on:** Task 62 (Domain Schema) - Uses `organization_domains` table
- **Integrates with:** Task 70 (DomainManager.vue) - UI displays certificate status
- **Integrates with:** Coolify Proxy System - Nginx/Traefik configuration updates
- **Used by:** Application deployment - HTTPS for deployed applications
- **Used by:** White-label system - HTTPS for custom domains
